<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>xv6 第九章</title>
      <link href="/2022/08/31/xv6-Chapter-9/"/>
      <url>/2022/08/31/xv6-Chapter-9/</url>
      
        <content type="html"><![CDATA[<h2 id="第九章：并发"><a href="#第九章：并发" class="headerlink" title="第九章：并发"></a>第九章：并发</h2><p>要同时获得良好的的性能、并发的正确性和易于理解的代码是内核设计的一大挑战。直接使用锁是保证正确性的最佳途径，但不总是可行的。本章重点介绍了xv6不得不使用锁的例子，以及使用类似锁（但不是锁）的例子。</p><h3 id="9-1-Locking-patterns"><a href="#9-1-Locking-patterns" class="headerlink" title="9.1 Locking patterns"></a>9.1 Locking patterns</h3><p>缓存项通常是锁的一个挑战。例如，文件系统的块缓存(kernel/bio.c:26)存储了<strong>NBUF</strong>个磁盘块的副本。一个给定的磁盘块在缓存中最多只有一个副本，这一点非常重要；否则，不同的进程对同一磁盘块的不同副本进行修改时可能会发生冲突。每一个缓存的磁盘块都被存储在一个<strong>buf</strong>结构中(kernel/buf.h:1)。<strong>buf</strong>结构有一个锁字段，它确保每次只有一个进程使用一个给定的磁盘块。然而，这个锁是不够的：如果一个块根本不存在于缓存中，而两个进程想同时使用它怎么办？没有 <strong>buf</strong> (因为该块还没有被缓存)，因此没有能加锁的东西。Xv6对所有块的标识符关联一个额外的锁来处理这种情况。判断块是否被缓存的代码（e.g.  bget(kernel/bio.c:59)），或改变缓存块集合的代码，必须持有<strong>bcache.lock</strong>。当代码找到它所需要的块和<strong>buf</strong>结构后，它就可以释放<strong>bcache.lock，</strong>然后锁定特定的块，这是一种通用模式：一组一把锁，外加每个项一把锁。</p><p>通常情况下，获取锁的函数会释放那把锁。但更准确的说法是，当一个序列需要保证原子性时，会在该序列开始时获取锁，而在序列结束时释放锁。如果序列的开始和结束在不同的函数中，或者不同的线程中，或者在不同的CPU上，那么锁的获取和释放也必须是一样的。锁的功能是强制其他的使用者等待，而不是将一段数据绑定给特定的代理。一个例子是yield中的<strong>acquire</strong>(kernel/proc.c:515)，它是在调度线程中释放的，而不是在获取锁的进程中释放的。另一个例子是<strong>ilock</strong>(kernel/fs.c:289)中的<strong>acquiresleep</strong>；这段代码经常在读取磁盘时睡眠；它可能在不同的CPU上被唤醒，这意味着锁可能在不同的CPU上获取和释放。</p><p>释放一个被锁保护的且锁内嵌在其中的对象是一件很棘手的事情，因为拥有锁并不足以保证释放对象的正确性。当有其他线程在<strong>acquire</strong>中等待时，问题就会出现；释放这个对象就意味着释放内嵌的锁，而释放这个锁会导致等待线程出错。一种方式是追踪该对象有多少个引用，只有在最后一个引用消失时才会释放对象。<strong>pipeclose (kernel/pipe.c:59)</strong>就是这样的例子。<strong>pi-&gt;readopen</strong>和<strong>pi-&gt;writeopen</strong>跟踪是否有文件描述符引用该管道。</p><h3 id="9-2-Lock-like-patterns"><a href="#9-2-Lock-like-patterns" class="headerlink" title="9.2 Lock-like patterns"></a>9.2 Lock-like patterns</h3><p>在许多地方，xv6使用引用计数或标志位作为一种软锁（soft lock），以表明一个对象已被分配，不应该被释放或重用。进程的<strong>p-&gt;state</strong>依此工作，<strong>file</strong>、<strong>inode</strong>和<strong>buf</strong>结构中的引用计数也是如此。虽然在每种情况下，锁都会保护标志位或引用计数，但正是标志位或引用计数防止了对象被过早释放。  </p><p>文件系统使用结构体<strong>inode</strong>的引用计数作为一种共享锁，可以由多个进程持有，以避免代码使用普通锁时出现的死锁。例如，<strong>namex</strong>(kernel/fs.c:626)中的循环依次锁定路径上的每个目录。然而，<strong>namex</strong>必须在循环末尾释放每一个锁，因为如果它持有多个锁，那么如果路径名中包含.(即当前目录，例如，a/./b)，它可能会与自己发生死锁。它也可能因为涉及目录和..的并发查找而死锁。正如第8章所解释的那样，解决方案是让循环将目录的inode带入下一次迭代，并增加其引用计数，但不锁定。</p><p>有些数据项在不同的时候会受到不同机制的保护。它有时可能会被xv6代码的结构隐式保护，而不是通过显式的锁来防止并发访问。例如，当一个物理页是空闲的时候，它被<strong>kmem.lock（kernel/kalloc.c:24）</strong>保护。如果页面被分配作为管道(kernel/pipe.c:23)，它将被一个不同的锁(内嵌的<strong>pi-&gt;lock</strong>)保护。如果该页被重新分配给一个新进程的用户内存，它就不会受到锁的保护。相反，分配器不会将该页交给任何其他进程（直到它被释放）的事实保护了它不被并发访问。一个新进程的内存的所有权是很复杂的：首先父进程在<strong>fork</strong>中分配和操作它，然后子进程使用它，（在子进程退出后）父进程再次拥有内存，并将其传递给<strong>kfree</strong>。这里有两个需要注意的地方：第一，一个数据对象在其生命周期中的不同时刻可以用不同的方式来保护它不被并发访问；第二，保护的形式可能是隐式结构而不是显式锁。</p><p>最后一个类似于锁的例子是在调用<strong>mycpu()</strong>(kernel/proc.c:68)时需要禁用中断。禁用中断会导致调用代码对定时器中断是原子性的，而定时器中断可能会强制上下文切换，从而将进程移到不同的CPU上。</p><h3 id="9-3-No-locks-at-all"><a href="#9-3-No-locks-at-all" class="headerlink" title="9.3 No locks at all"></a>9.3 No locks at all</h3><p>xv6有几个地方是在完全没有锁的情况下共享可变数据的。一个是在<strong>spinlocks</strong>的实现中，尽管你可以把RISC-V原子指令看作是依靠硬件实现的锁。另一个是<strong>main.c</strong> (kernel/main.c:7)中的<strong>started</strong>变量，用来防止其他CPU运行，直到CPU 0完成xv6的初始化；<strong>volatile</strong>确保编译器真正生成加载和存储指令。第三个例子是proc.c(kernel.proc.c:398)(kernel/proc.c:306)中的p-&gt;parent。它的一些用法会导致死锁，但是明显不会有其他进程能够同时修改p-&gt;parent。第四个例子是p-&gt;killed。它在持有p-&gt;lock时被设置，但在检查时却并不需要锁。</p><p>Xv6包含这样的情况：一个CPU或线程写一些数据，另一个CPU或线程读数据，但没有专门的锁来保护这些数据。例如，在<strong>fork</strong>中，父进程写入子进程的用户内存页，子进程(可能在不同的CPU上)读取这些页。这些页没有锁来显式地保护。严格来说，这不是锁的问题，因为子进程在父进程写完后才开始执行。这是一个潜在的内存操作的顺序问题（见第6章），因为没有内存屏障，没有理由期望一个CPU看到另一个CPU的写入。然而，由于父进程CPU释放锁，而子进程CPU在启动时获取锁，所以在<strong>acquire</strong>和<strong>release</strong>中的内存屏障保证了子进程CPU能看到父进程CPU的写入。</p><h3 id="9-4-Parallelism"><a href="#9-4-Parallelism" class="headerlink" title="9.4 Parallelism"></a>9.4 Parallelism</h3><p>锁主要是为了正确性而抑制并行性。但是性能也很重要，所以内核设计者经常要考虑如何使用锁，来同时保证正确性和良好的并行性。虽然xv6并未对高性能进行系统地设计，但仍然值得考虑哪些xv6操作可以并行执行，哪些操作可能在锁上发生冲突。</p><p>xv6中的管道是一个并行性相当好的例子。每个管道都有自己的锁，因此不同的进程可以在不同的CPU上并行读写不同的管道。然而，对于一个给定的管道，writer和reader必须等待对方释放锁，他们不能同时读/写同一个管道。还有一种情况是，从一个空管道读（或向一个满管道写）必须阻塞，但这不是锁的方案导致的问题。</p><p>上下文切换是一个更复杂的例子。两个在各自CPU上执行的内核线程，可以同时调用<strong>yield</strong>、<strong>sched</strong>和<strong>swtch</strong>，并且这些调用能并行执行。这两个线程各自持有一个锁，但是不同的锁，所以它们不必等待对方。一旦进入<strong>scheduler</strong>，两个CPU在遍历进程表寻找一个RUNNABLE的进程的时候，却可能会发生锁冲突。也就是说，xv6在上下文切换的过程中，很可能会从多个CPU中获得性能上的好处，但可能没有那么多。</p><p>另一个例子是在不同的CPU上从不同的进程并发调用<strong>fork</strong>。这些调用可能需要互相等待<strong>pid_lock</strong>和<strong>kmem.lock</strong>，以及在进程表中搜索一个<strong>UNUSED</strong>进程所需的进程锁。另一方面，两个正在fork的进程可以完全并行地复制用户内存页和格式化页表页。</p><p>上述每个例子中的锁方案在某些情况下都牺牲了并行性能。在每一种情况下，都有可能通过更复杂的设计获得更多的并行性。这是否值得取决于细节：相关操作被调用的频率、代码在锁竞争的情况下所花费的时间、有多少CPU可能同时运行冲突的操作、是否代码的其他部分才是性能瓶颈。很难猜测一个给定的锁方案是否会导致性能问题，或者一个新的设计是否有明显的改进，所以往往需要在现实的工作负载上进行测量。</p><h3 id="9-5-Exercises"><a href="#9-5-Exercises" class="headerlink" title="9.5 Exercises"></a>9.5 Exercises</h3><ol><li><p>修改xv6管道的实现，允许对同一管道的读和写在不同内核上并行进行。</p></li><li><p>修改xv6 <strong>scheduler()</strong>，以减少不同内核同时寻找可运行进程时的锁竞争。</p></li><li><p>消除<strong>fork</strong>中一些串行执行的代码。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第八章</title>
      <link href="/2022/08/31/xv6-Chapter-8/"/>
      <url>/2022/08/31/xv6-Chapter-8/</url>
      
        <content type="html"><![CDATA[<h2 id="第八章：文件系统"><a href="#第八章：文件系统" class="headerlink" title="第八章：文件系统"></a>第八章：文件系统</h2><p>文件系统的目的是组织和存储数据。文件系统通常支持用户和应用程序之间的数据共享，以及支持持久性，以便数据在重启后仍然可用。</p><p>xv6文件系统提供了类Unix的文件、目录和路径名（见第1章），并将其数据存储在virtio磁盘上以实现持久化（见第4章）。该文件系统解决了几个挑战：</p><ul><li><p>文件系统需要磁盘上的数据结构来表示命名目录和文件的树，记录保存每个文件内容的块的身份，并记录磁盘上哪些区域是空闲的。</p></li><li><p>文件系统必须支持崩溃恢复。也就是说，如果发生崩溃（如电源故障），文件系统必须在重新启动后仍能正常工作。风险在于，崩溃可能会中断更新序列，并在磁盘上留下不一致的数据结构（例如，一个块既在文件中使用，又被标记为空闲）。</p></li><li><p>不同的进程可能并发在文件系统上运行，所以文件系统代码必须协调维护每一个临界区。</p></li><li><p>访问磁盘的速度比访问内存的速度要慢几个数量级，所以文件系统必须在内存维护一个缓冲区，用于缓存常用块。</p></li></ul><p>本章剩下的部分将解释xv6如何解决这些问题。</p><h3 id="8-1-Overview"><a href="#8-1-Overview" class="headerlink" title="8.1 Overview"></a>8.1 Overview</h3><p><img src="/img/Figure-8.1.png" alt="Figure-8.1"></p><p>xv6文件系统的实现分为七层，如图8.1所示。disk层在virtio磁盘上读写块。Buffer cache缓存磁盘块，并同步访问它们，确保一个块只能同时被内核中的一个进程访问。日志层允许上层通过事务更新多个磁盘块，并确保在崩溃时，磁盘块是原子更新的（即全部更新或不更新）。inode层将一个文件都表示为一个<strong>inode</strong>，每个文件包含一个唯一的i-number和一些存放文件数据的块。目录层将实现了一种特殊的<strong>inode</strong>，被称为目录，其包含一个目录项序列，每个目录项由文件名称和i-number组成。路径名层提供了层次化的路径名，如/<strong>usr/rtm/xv6/fs.c</strong>，可以用递归查找解析他们。文件描述符层用文件系统接口抽象了许多Unix资源（如管道、设备、文件等），使程序员的生产力得到大大的提高。</p><p><img src="/img/Figure-8.2.png" alt="Figure-8.2"></p><p> 文件系统必须安排好磁盘存储inode和内容块的位置。为此，xv6将磁盘分为几个部分，如图8.2所示。文件系统不使用块0（它存放boot sector）。第1块称为<strong><em>superblock</em></strong>，它包含了文件系统的元数据（以块为单位的文件系统大小、数据块的数量、inode的数量和日志中的块数）。从块2开始存放着日志。日志之后是inodes，每个块会包含多个inode。在这些块之后是<strong><em>位图块(bitmap)</em></strong>，记录哪些数据块在使用。其余的块是数据块，每个数据块要么在bitmap块中标记为空闲，要么持有文件或目录的内容。超级块由一个单独的程序<strong>mkfs</strong>写入，它建立了一个初始文件系统。</p><p>本章的其余部分将讨论每一层，从buffer缓存开始。从讨论中我们将看到如何选择合适的低层抽象，来方便更高层的设计。 </p><h3 id="8-2-Buffer-cache-layer"><a href="#8-2-Buffer-cache-layer" class="headerlink" title="8.2 Buffer cache layer"></a>8.2 Buffer cache layer</h3><p>buffer缓存有两项工作。(1)同步访问磁盘块，以确保磁盘块在内存中只有一个buffer缓存，并且一次只有一个内核线程能使用该buffer缓存；(2)缓存使用较多的块，这样它们就不需要从慢速磁盘中重新读取。代码见<strong>bio.c</strong>。</p><p>buffer缓存的主要接口包括<strong>bread</strong>和<strong>bwrite</strong>，bread返回一个在内存中可以读取和修改的块副本<strong>buf</strong>，<strong>bwrite</strong>将修改后的buffer写到磁盘上相应的块。内核线程在使用完一个buffer后，必须通过调用<strong>brelse</strong>释放它。buffer缓存为每个buffer的都设有sleep-lock，以确保每次只有一个线程使用buffer（从而使用相应的磁盘块）；<strong>bread</strong> 返回的buffer会被锁定，而<strong>brelse</strong>释放锁。</p><p>我们再来看看buffer缓存。buffer缓存有固定数量的buffer来存放磁盘块，这意味着如果文件系统需要一个尚未被缓存的块，buffer缓存必须回收一个当前存放其他块的buffer。buffer缓存为新块寻找最近使用最少的buffer（lru机制）。因为最近使用最少的buffer是最不可能被再次使用的buffer。</p><h3 id="8-3-Code-Buffer-cache"><a href="#8-3-Code-Buffer-cache" class="headerlink" title="8.3 Code: Buffer cache"></a>8.3 Code: Buffer cache</h3><p>buffer缓存是一个由buffer组成的双端链表。由函数<strong>binit</strong>用静态数组<strong>buf</strong>初始化这个链表， <strong>binit</strong>在启动时由<strong>main</strong>(kernel/main.c:27)调用。访问buffer缓存是通过链表，而不是<strong>buf</strong>数组。</p><p>buffer有两个与之相关的状态字段。字段<strong>valid</strong>表示是否包含该块的副本（是否从磁盘读取了数据）。字段<strong>disk</strong>表示缓冲区的内容已经被修改需要被重新写入磁盘。</p><p><strong>bget</strong> (kernel/bio.c:59)扫描buffer链表，寻找给定设备号和扇区号来查找缓冲区(kernel/bio.c:65-73)。如果存在，<strong>bget</strong>就会获取该buffer的sleep-lock。然后<strong>bget</strong>返回被锁定的buffer。</p><p>如果给定的扇区没有缓存的buffer，<strong>bget</strong>必须生成一个，可能会使用一个存放不同扇区的buffer，它再次扫描buffer链表，寻找没有被使用的buffer(<strong>b-&gt;refcnt = 0</strong>)；任何这样的buffer都可以使用。任何这样的buffer都可以使用。bget修改buffer元数据，记录新的设备号和扇区号，并获得其sleep-lock。请注意，<strong>b-&gt;valid = 0</strong>可以确保bread从磁盘读取块数据，而不是错误地使用buffer之前的内容。</p><p>请注意，每个磁盘扇区最多只能有一个buffer，以确保写操作对读取者可见，也因为文件系统需要使用buffer上的锁来进行同步。<strong>Bget</strong>通过从第一次循环检查块是否被缓存，第二次循环来生成一个相应的buffer（通过设置<strong>dev</strong>、<strong>blockno</strong>和<strong>refcnt</strong>），在进行这两步操作时，需要一直持有<strong>bache.lock</strong> 。持有<strong>bache.lock</strong>会保证上面两个循环在整体上是原子的。</p><p><strong>bget</strong>在<strong>bcache.lock</strong>保护的临界区之外获取buffer的sleep-lock是安全的，因为非零的<strong>b-&gt;refcnt</strong>可以防止缓冲区被重新用于不同的磁盘块。sleep-lock保护的是块的缓冲内容的读写，而bcache.lock保护被缓存块的信息。</p><p>如果所有buffer都在使用，那么太多的进程同时在执行文件相关的系统调用，bget就会<strong>panic</strong>。一个更好的处理方式可能是睡眠，直到有buffer空闲，尽管这时有可能出现死锁。</p><p>一旦<strong>bread</strong>读取了磁盘内容（如果需要的话）并将缓冲区返回给它的调用者，调用者就独占该buffer，可以读取或写入数据。如果调用者修改了buffer，它必须在释放buffer之前调用<strong>bwrite</strong>将修改后的数据写入磁盘。<strong>bwrite</strong> (kernel/bio.c:107)调用<strong>virtio_disk_rw</strong>与磁盘硬件交互。</p><p>当调用者处理完一个buffer后，必须调用<strong>brelse</strong>来释放它。(<strong>brelse</strong>这个名字是<strong>b-release</strong>的缩写，虽然很神秘，但值得学习，它起源于Unix，在BSD、Linux和Solaris中也有使用。) <strong>brelse</strong> (kernel/bio.c:117)释放sleep-lock，并将该buffer移动到链表的头部(kernel/bio.c:128-133)。移动buffer会使链表按照buffer最近使用的时间（最近释放）排序，链表中的第一个buffer是最近使用的，最后一个是最早使用的。<strong>bget</strong>中的两个循环利用了这一点，在最坏的情况下，获取已缓存buffer的扫描必须处理整个链表，由于数据局部性，先检查最近使用的缓冲区（从<strong>bcache.head</strong>开始，通过<strong>next</strong>指针）将减少扫描时间。扫描选取可使用buffer的方法是通过从后向前扫描（通过<strong>prev</strong>指针）选取最近使用最少的缓冲区。</p><h3 id="8-4-Logging-layer"><a href="#8-4-Logging-layer" class="headerlink" title="8.4 Logging layer"></a>8.4 Logging layer</h3><p>文件系统设计中最有趣的问题之一是崩溃恢复。这个问题的出现是因为许多文件系统操作涉及到对磁盘的多次写入，如果只执行了部分写操作，然后发生崩溃可能会使磁盘上的文件系统处于不一致的状态。例如，假设在文件截断（将文件的长度设置为零并释放其内容块）时发生崩溃。根据磁盘写入的顺序，可能会留下一个引用空闲内容块的inode，也可能会留下一个已分配但没有被引用的内容块。</p><p>后面的这种情况相对来说好一点，但是如果一个inode指向被释放的块，很可能在重启后造成严重的问题。重启后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向了同一个块。如果xv6支持多用户，这种情况可能是一个安全问题，因为旧文件的所有者能够读写新文件，即使该文件被另一个用户所拥有。</p><p>Xv6通过简单的日志系统来解决文件系统操作过程中崩溃带来的问题。xv6的系统调用不直接写磁盘上的文件系统数据结构。相反，它将写入的数据记录在磁盘上的日志中。一旦系统调用记录了全部的写入数据，它就会在磁盘上写一个特殊的提交记录，表明该日志包含了一个完整的操作。这时，系统调用就会将日志中的写入数据写到磁盘上相应的位置。在执行完成后，系统调用将磁盘上的日志清除。</p><p>如果系统崩溃并重启，文件系统会在启动过程中恢复自己。如果日志被标记为包含一个完整的操作，那么恢复代码就会将写入的内容复制到它们在磁盘文件系统中的相应位置。如果日志未被标记为包含完整的操作，则恢复代码将忽略并清除该日志。</p><p>为什么xv6的日志系统可以解决文件系统操作过程中的崩溃问题？如果崩溃发生在操作提交之前，那么磁盘上的日志将不会被标记为完成，恢复代码将忽略它，磁盘的状态就像操作根本没有开始一样。如果崩溃发生在操作提交之后，那么恢复代码会重新执行写操作，可能会重复执行之前的写操作。不管是哪种情况，日志都会使写与崩溃为原子的，即恢复后，所有操作的写入内容，要么都在磁盘上，要么都不在。</p><h3 id="8-5-Log-design"><a href="#8-5-Log-design" class="headerlink" title="8.5 Log design"></a>8.5 Log design</h3><p>日志贮存在一个固定位置，由<strong><em>superblock</em></strong>指定。它由一个header块组成，后面是一连串的更新块副本（日志块）。header块包含一个扇区号数组，其中的每个扇区号都对应一个日志块<a href="#ftn1">[1]</a>，header还包含日志块的数量。磁盘上header块中的数量要么为零，表示日志中没有事务，要么为非零，表示日志中包含一个完整的提交事务，并有指定数量的日志块。Xv6在事务提交时会修改 header块，将日志块复制到文件系统后，会将数量设为零。因此，一个事务中途的崩溃将导致日志header块中的计数为零；提交后的崩溃的计数为非零。</p><p>为了应对崩溃，每个系统调用都包含一个原子写序列。为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写操作累积到一个事务中。因此，一次提交可能涉及多个完整系统调用的写入。为了避免一个系统调用被分裂到不同的事务中，只有在没有文件系统相关的系统调用正在进行时，日志系统才会提交。</p><p>将几个事务一起提交的方法被称为组提交（group commit）。组提交可以减少磁盘操作的次数，因为它将提交的固定成本分摊在了多个操作上。组提交可以让文件系统同时执行更多的并发写，也可以让磁盘在一次磁盘轮转中把它们全部写入。Xv6的virtio驱动不支持这种批处理，但xv6的文件系统实现了这种方式。</p><p>Xv6在磁盘上划出固定的空间来存放日志。在一个事务中，系统调用所写的块总数必须适应这个空间的大小。这将导致两个后果：</p><p>1、系统调用写入的日志大小必须小于日志空间的大小。这对大多数系统调用来说都不是问题，但有两个系统调用可能会写很多块，<strong>write</strong>和<strong>unlink</strong>。大文件的write可能会写很多数据块和bitmap块，以及一个inode块；取消链接一个大文件可能会写很多bitmap块和一个inode。Xv6的<strong>write</strong>系统调用将大的写操作分解成多个小的写操作，以适应在日志空间的大小，而<strong>unlink</strong>不会引起问题，因为xv6文件系统只使用一个位图块。</p><p>2、日志空间有限的另一个后果是，日志系统只会在确定了系统调用的写操作可以适应剩余日志空间之后，才会开始执行该系统调用。</p><h3 id="8-6-Code-logging"><a href="#8-6-Code-logging" class="headerlink" title="8.6 Code: logging"></a>8.6 Code: logging</h3><p>系统调用中一般用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure><p><strong>begin_op</strong>(kernel/log.c:126)会一直等到日志系统没有commiting，并且有足够的日志空间来容纳这次调用的写。<strong>log.outstanding</strong>统计当前系统调用的数量，可以通过<strong>log.outstanding</strong>乘以<strong>MAXOPBLOCKS</strong>来计算已使用的日志空间。自增<strong>log.outstanding</strong>既能预留空间，又能防止该系统调用期间进行提交。该代码假设每次系统调用最多写入<strong>MAXOPBLOCKS</strong>个块。</p><p>​    <strong>log_write</strong> (kernel/log.c:214) 是<strong>bwrite</strong>的代理。它将扇区号记录在内存中，在磁盘上的日志中使用一个槽，并自增<strong>buffer.refcnt</strong>防止该<strong>buffer</strong>被重用。在提交之前，块必须留在缓存中，即该缓存的副本是修改的唯一记录；在提交之后才能将其写入磁盘上的位置；该次修改必须对其他读可见。 注意，当一个块在一个事务中被多次写入时，他们在日志中的槽是相同的。这种优化通常被称为<strong><em>absorption</em></strong>(吸收)。例如，在一个事务中，包含多个文件的多个inode的磁盘块被写多次，这是常见的情况。通过将几次磁盘写<strong><em>吸收</em></strong>为一次，文件系统可以节省日志空间，并且可以获得更好的性能，因为只有一份磁盘块的副本必须写入磁盘。</p><p><strong>end_op</strong> (kernel/log.c:146)首先递减<strong>log.outstanding</strong>。如果计数为零，则通过调用<strong>commit()</strong>来提交当前事务。</p><p><strong>Commit</strong>分为四个阶段：</p><p>1、<strong>write_log</strong>()(kernel/log.c:178)将事务中修改的每个块从buffer缓存中复制到磁盘上的日志槽中。</p><p>2、 <strong>write_head</strong>()(kernel/log.c:102)将header块写到磁盘上，就表明已提交，为提交点，写完日志后的崩溃，会导致在重启后重新执行日志。</p><p>3、<strong>install_trans</strong>(kernel/log.c:69)从日志中读取每个块，并将其写到文件系统中对应的位置。</p><p>4、最后修改日志块计数为0，并写入日志空间的header部分。这必须在下一个事务开始之前修改，这样崩溃就不会导致重启后的恢复使用这次的header和下次的日志块。</p><p><strong>recover_from_log</strong> (kernel/log.c:116) 是在 <strong>initlog</strong> (kernel/log.c:55) 中调用的，而 <strong>initlog</strong> 是在第一个用户进程运行 (kernel/proc.c:539) 之前, 由 <strong>fsinit</strong>(kernel/fs.c:42) 调用的。它读取日志头，如果日志头显示日志中包含一个已提交的事务，则会像<strong>end_op</strong>那样执行日志。</p><p>一个使用了日志的例子是filewrite (kernel/file.c:135)。这个事务看起来像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">ilock(f-&gt;ip);</span><br><span class="line">r = writei(f-&gt;ip, ...);</span><br><span class="line">iunlock(f-&gt;ip);</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure><p>这段代码被包裹在一个循环中，它将大的写分解成每次只有几个扇区的单独事务，以避免溢出日志空间。调用 <strong>writei</strong> 写入许多块作为这个事务的一部分：文件的 inode，一个或多个bitmap块，以及一些数据块。</p><h3 id="8-7-Code-Block-allocator"><a href="#8-7-Code-Block-allocator" class="headerlink" title="8.7 Code: Block allocator"></a>8.7 Code: Block allocator</h3><p>文件和目录存储在磁盘块中，必须从空闲池中分配，xv6的块分配器在磁盘上维护一个bitmap，每个块对应一个位。0表示对应的块是空闲的，1表示正在使用中。程序mkfs设置引导扇区、超级块、日志块、inode块和位图块对应的位。</p><p>块分配器提供了两个函数：<strong>balloc</strong>申请一个新的磁盘块，<strong>bfree</strong>释放一个块。<strong>balloc</strong> (kernel/fs.c:71)会有一个循环遍历每一个块，从块 0 开始，直到 <strong>sb.size</strong>，即文件系统中的块数。它寻找一个位为0的空闲块。如果 <strong>balloc</strong> 找到了这样一个块，它就会更新bitmap并返回该块。为了提高效率，这个循环被分成两部分。外循环读取bitmap的一个块，内循环检查块中的所有BPB位。如果两个进程同时试图分配一个块，可能会发生竞争，但buffer缓存只允许块同时被一个进程访问，这就避免了这种情况的发生。</p><p><strong>Bfree</strong> (kernel/fs.c:90) 找到相应的bitmap块并清除相应的位。<strong>bread</strong>和<strong>brelse</strong>暗含的独占性避免了显式锁定。</p><p>与本章其余部分描述的大部分代码一样，<strong>balloc</strong>和<strong>bfree</strong>必须在事务中被调用。</p><h3 id="8-8-Inode-layer"><a href="#8-8-Inode-layer" class="headerlink" title="8.8 Inode layer"></a>8.8 Inode layer</h3><p>术语inode有两种相关的含义。1、指的是磁盘上的数据结构，其中包含了文件的大小和数据块号的列表；2、指的是内存中的inode，它包含了磁盘上inode的副本以及内核中需要的其他信息。</p><p>磁盘上的inode被放置磁盘的一个连续区域。每一个inode的大小都是一样的，所以，给定一个数字n，很容易找到磁盘上的第n个inode。事实上，这个数字n，被称为inode号或i-number，在实现中就是通过这个识别inode的。</p><p>结构体<strong>dinode</strong>(kernel/fs.h:32)定义了磁盘上的inode。<strong>type</strong>字段区分了文件、目录和特殊文件（设备）。type为0表示该inode是空闲的。<strong>nlink</strong>字段统计引用这个inode的目录项的数量，当引用数为0时就释放磁盘上的inode及其数据块。<strong>size</strong>字段记录了文件中内容的字节数。<strong>addrs</strong>数组记录了持有文件内容的磁盘块的块号。</p><p>内核将在使用的inode保存在内存中；结构体<strong>inode</strong> (kernel/file.h:17)是磁盘<strong>dinode</strong>的拷贝。内核只在有指针指向inode才会储存。<strong>ref</strong>字段为指向inode的指针的数量，如果引用数量减少到零，内核就会从内存中丢弃这个inode。<strong>iget</strong>和<strong>iput</strong>函数引用和释放inode，并修改引用计数。指向inode的指针可以来自文件描述符，当前工作目录，以及短暂的内核代码，如<strong>exec</strong>。</p><p>在xv6的inode代码中，有四种锁或类似锁的机制。<strong>icache.lock</strong>保证了一个inode在缓存只有一个副本，以及缓存inode的<strong>ref</strong>字段计数正确。每个内存中的inode都有一个包含sleep-lock的锁字段，它保证了可以独占访问inode的其他字段（如文件长度）以及inode的文件或目录内容块的。一个inode的<strong>ref</strong>如果大于0，则会使系统将该inode保留在缓存中，而不会重用该inode。最后，每个inode都包含一个<strong>nlink</strong>字段(在磁盘上，缓存时会复制到内存中)，该字段统计链接该inode的目录项的数量；如果一个inode的链接数大于零，xv6不会释放它。</p><p>在xv6的inode代码中，有四种锁或类似锁的机制。<strong>icache.lock</strong>保证了一个inode在缓存只有一个副本，以及缓存inode的<strong>ref</strong>字段计数正确。每个内存中的inode都有一个包含sleep-lock的锁字段，它保证了可以独占访问inode的其他字段（如文件长度）以及inode的文件或目录内容块的。一个inode的<strong>ref</strong>如果大于0，则会使系统将该inode保留在缓存中，而不会重用该缓存buffer。最后，每个inode都包含一个<strong>nlink</strong>字段(在磁盘上，如果是缓存，则复制在内存中)，该字段统计引用文件的目录项的数量；只有当inode的链接数为零时，xv6才会释放它。</p><p><strong>iget()</strong>返回的<strong>inode</strong>指针在调用iput()之前都是有效的；inode不会被删除，指针所引用的内存也不会被另一个inode重新使用。<strong>iget()</strong>提供了对inode的非独占性访问，因此可以有许多指针指向同一个inode。文件系统代码中的许多部分都依赖于<strong>iget()</strong>的这种行为，既是为了保持对inode的长期引用(如打开的文件和当前目录)，也是为了防止竞争，同时避免在操作多个inode的代码中出现死锁(如路径名查找)。</p><p>inode缓存只缓存被指针指向的inode。它的主要工作其实是同步多个进程的访问，缓存是次要的。如果一个inode被频繁使用，如果不被inode缓存保存，buffer缓存可能会把它保存在内存中。inode缓存是<strong><em>write-through</em></strong>的，这意味着缓存的inode被修改，就必须立即用<strong>iupdate</strong>把它写入磁盘。</p><h3 id="8-9-Code-Inodes"><a href="#8-9-Code-Inodes" class="headerlink" title="8.9 Code: Inodes"></a>8.9 Code: Inodes</h3><p>要创建一个新的inode(例如，当创建一个文件时)，xv6会调用<strong>ialloc</strong>(kernel/fs.c:196)。<strong>ialloc</strong> 类似于 <strong>balloc</strong>：它遍历磁盘上的 inode ，寻找一个被标记为空闲的inode。当它找到后，它会修改该inode的<strong>type</strong>字段来使用它，最后调用 <strong>iget</strong> (kernel/fs.c:210) 来从 inode 缓存中返回一个条目。由于一次只能有一个进程持有对<strong>bp:ialloc</strong>的引用，所以可以确保其他进程不会同时看到inode是可用的并使用它。</p><p><strong>Iget</strong> (kernel/fs.c:243) 在 inode 缓存中寻找一个带有所需设备号和 inode 号码的active条目 (ip-&gt;ref &gt; 0)。如果它找到了，它就返回一个新的对该inode的引用(kernel/fs.c:252-256)。当 <strong>iget</strong> 扫描时，它会记录第一个空槽的位置 (kernel/fs.c:257- 258)，当它需要分配一个缓存条目时，它会使用这个空槽。</p><p>在读写inode的元数据或内容之前，代码必须使用<strong>ilock</strong>锁定它。<strong>Ilock</strong>(kernel/fs.c:289)使用sleep-lock来锁定。一旦<strong>ilock</strong>锁定了inode，它就会根据自己的需要从磁盘（更有可能是buffer缓存）读取inode。函数<strong>iunlock</strong> (kernel/fs.c:317)释放睡眠锁，这会唤醒正在等待该睡眠锁的进程。</p><p><strong>Iput</strong> (kernel/fs.c:333) 通过递减引用次数 (kernel/fs.c:356) 释放指向inode的指针。如果递减后的引用数为0，inode 缓存中的 就会释放掉该inode 在inode缓存中的槽位，该槽位就可以被其他inode使用。</p><p>如果<strong>iput</strong>发现没有指针指向该inode，并且没有任何目录项链接该inode（不在任何目录中出现），那么该inode和它的数据块必须被释放。<strong>Iput</strong>调用<strong>itrunc</strong>将文件截断为零字节，释放数据块；将inode类型设置为0（未分配）；并将inode写入磁盘（kernel/fs.c:338）。</p><p><strong>iput</strong>在释放inode的锁定协议是值得我们仔细研究。一个危险是，一个并发线程可能会在<strong>ilock</strong>中等待使用这个inode(例如，读取一个文件或列出一个目录)，但它没有意识到该inode可能被释放掉了。这种情况是不会发生，因为该inode的没有被目录项链接且<strong>ip-&gt;ref</strong>为1，那么系统调用是没有这个指针的（如果有，<strong>ip-&gt;ref</strong>应该为2）。这一个引用是调用 iput 的线程所拥有的。的确，<strong>iput</strong>会在其<strong>icache.lock</strong>锁定的临界区之外检查引用数是否为1，但此时已知链接数为0，所以没有线程会尝试获取新的引用。另一个主要的危险是，并发调用<strong>ialloc</strong>可能会使<strong>iput</strong>返回一个正在被释放的inode。这种情况发生在<strong>iupdate</strong>写磁盘时<strong>ip-&gt;type=0</strong>。这种竞争是正常的，分配inode的线程会等待获取inode的睡眠锁，然后再读取或写入inode，但此时<strong>iput</strong>就结束了。</p><p><strong>iput()</strong>会写磁盘。这意味着任何使用文件系统的系统调用都会写磁盘，因为系统调用可能是最后一个对文件有引用的调用。甚至像read()这样看似只读的调用，最终也可能会调用iput()。这又意味着，即使是只读的系统调用，如果使用了文件系统，也必须用事务来包装。</p><p>崩溃发生在<strong>iput()</strong>中是相当棘手的。当文件的链接数降到零时，<strong>iput()</strong>不会立即截断一个文件，因为一些进程可能仍然在内存中持有对inode的引用：一个进程可能仍然在对文件进行读写，因为它成功地打开了inode。但是，如果崩溃发生在该文件的最后一个文件描述符释放时，那么该文件将被标记为已在磁盘上分配，但没有目录项指向它。</p><p>文件系统处理这种情况的方法有两种。简单的解决方法是，是在重启后的恢复时，文件系统会扫描整个文件系统，寻找那些被标记为已分配的文件，但没有指向它们的目录项。如果有这样的文件存在，那么就可以释放这些文件。</p><p>第二种解决方案不需要扫描文件系统。在这个解决方案中，文件系统在磁盘上（例如，在<strong><em>superblock</em></strong>中）记录链接数为0但引用数不为0的文件的inode的inumber。如果文件系统在其引用计数达到0时删除该文件 。当文件的引用数为0时，文件系统会删除该文件，同时它更新磁盘上的列表，从列表中删除该inode。恢复时，文件系统会释放列表中的任何文件。</p><p>Xv6没有实现这两种解决方案，这意味着inode可能会在磁盘上被标记分配，即使它们不再使用。这意味着随着时间的推移，xv6可能会面临磁盘空间耗尽的风险。</p><h3 id="8-10-Code-Inode-content"><a href="#8-10-Code-Inode-content" class="headerlink" title="8.10 Code: Inode content"></a>8.10 Code: Inode content</h3><p> <img src="/img/Figure-8.3.png" alt="Figure-8.3"></p><p>磁盘上的<strong>inode</strong>，即<strong>dinode</strong>结构体，包含一个size和一个块号数组（见图8.3）。<strong>inode</strong>数据可以在<strong>dinode</strong>的<strong>addrs</strong>数组中找到。开始的<strong>NDIRECT</strong>个数据块列在数组中的前<strong>NDIRECT</strong>个条目中，这些块被称为<strong><em>直接块</em></strong>。接下来的<strong>NINDIRECT</strong>个数据块并没有列在<strong>inode</strong>中，而是列在叫做<strong><em>间接块</em></strong>的数据块中。<strong>addrs</strong>数组中的最后一个条目给出了放置间接块的地址。因此，一个文件的前<strong>12</strong> <strong>kB</strong> ( <strong>NDIRECT x BSIZE</strong>)字节可以从<strong>inode</strong>中列出的块中加载，而接下来的<strong>256</strong> <strong>kB</strong> ( <strong>NINDIRECT x BSIZE</strong>)字节只能在查阅间接块后才能取出。对于磁盘这是一种不错的表示方式，但对客户机就有点复杂了。函数<strong>bmap</strong>包装了这种表示方式使得高层次的函数，如<strong>readi</strong>和<strong>writei</strong>可以更好的使用。<strong>Bmap</strong>返回inode <strong>ip</strong>的第 <strong>bn</strong>个数据块的磁盘块号。如果<strong>ip</strong>没有第<strong>bn</strong>个的数据块，<strong>bmap</strong>就会分配一个。</p><p>函数<strong>bmap</strong>(kernel/fs.c:378)从简单的情况开始：最前面的<strong>NDIRECT</strong>个块储存在inode(kernel/fs.c:383-387)中，接下来的<strong>NINDIRECT</strong>个块放置在<strong>ip-&gt;addrs[NDIRECT]</strong>指向的的<strong><em>间接块</em></strong>中。<strong>Bmap</strong>读取间接块(kernel/fs.c:394)，然后从块内的正确的位置读取一个块号(kernel/fs.c:395)。如果块号超过了<strong>NDIRECT+NINDIRECT</strong>，<strong>bmap</strong>就会<strong>panic</strong>；<strong>writei</strong>会检查并防止这种情况(kernel/fs.c:490)。</p><p><strong>Bmap</strong>根据需要分配块。<strong>ip-&gt;addrs[bn]</strong>或间接条目为0 时表示没有块。当<strong>bmap</strong>遇到0时，它会用新的块号来代替0(kernel/fs.c:384-385) (kernel/fs.c:392-393)。</p><p><strong>itrunc</strong> 释放文件的块，将inode的大小重置为零。<strong>Itrunc</strong> (kernel/fs.c:410) 首先释放<strong><em>直接块</em></strong>(kernel/fs.c:416-421)，然后释放<strong><em>间接块</em></strong>中指向的块(kernel/fs.c:426- 429)，最后释放<strong><em>间接块</em></strong>本身(kernel/fs.c:431-432)。</p><p>Bmap 使得 readi 和 writei 可以很容易地获取一个 inode 的数据。Readi (kernel/fs.c:456)首先要确定偏移量和计数没有超过文件末端。从文件超出末尾开始的读会返回一个错误(kernel/fs.c:461-462)，而从文件末尾开始或读取过程中超出末尾的读会不会返回错误，只是返回的字节数会少于请求的字节数(kernel/fs.c:463-464)。</p><p>主循环会把文件中的每一个块的数据复制到<strong>dst</strong>中(kernel/fs.c:466-474)。<strong>writei</strong> (kernel/fs.c:483)与<strong>readi</strong>相同，但有三个不同：（1）、从文件末尾开始或越过文件末尾的写入会使文件增长，但不会超过文件的最大长度(kernel/fs.c:490-491)；（2）、循环将数据复制到缓冲区而不是<strong>out</strong>(kernel/fs.c:36)；（3）、如果写使文件增长了，<strong>writi</strong>必须更新它的大小(kernel/fs.c:504-511)。</p><p><strong>readi</strong>和<strong>writei</strong>开始都会检查<strong>ip-&gt;type == T_DEV</strong>。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层中再讨论这种情况。</p><p>函数 <strong>stati</strong> (kernel/fs.c:442) 将 inode 元数据复制到 <strong>stat</strong> 结构体中，通过 <strong>stat</strong> 系统调用暴露给用户程序。</p><h3 id="8-11-Code-directory-layer"><a href="#8-11-Code-directory-layer" class="headerlink" title="8.11 Code: directory layer"></a>8.11 Code: directory layer</h3><p>目录的实现机制和文件很类似。它的<strong>inode</strong>类型是<strong>T_DIR</strong>，它的数据是一个目录项的序列。每个条目是一个结构体<strong>dirent</strong>(kernel/fs.h:56)，它包含一个名称和一个inode号。名称最多包含<strong>DIRSIZ</strong>(14)个字符，较短的名称以<strong>NULL</strong>(0)结束。inode号为0的目录项是空闲的。</p><p>函数<strong>dirlookup</strong> (kernel/fs.c:527)在一个目录中搜索一个带有给定名称的条目。如果找到了，它返回一个指向相应未上锁的inode的指针，并将<strong>*poff</strong>设置为目录中条目的字节偏移量，以便调用者想要编辑它。如果dirlookup找到一个对应名称的条目，则更新<em>poff，并返回一个通过iget获得的未被锁定的inode。Dirlookup是iget返回未锁定的inode的原因。调用者已经锁定了dp，所以如果查找的是 <strong>“.”</strong> ，当前目录的别名，在返回之前试图锁定inode，就会试图重新锁定dp而死锁。(还有更复杂的死锁情况，涉及到多个进程和”<strong>..”</strong>，父目录的别名；”<em>*.”</em></em>不是唯一的问题。) 调用者可以先解锁dp，然后再锁定ip，保证一次只持有一个锁。</p><p>函数<strong>dirlink</strong> (kernel/fs.c:554)会在当前目录dp中创建一个新的目录项，通过给定的名称和inode号。如果名称已经存在，dirlink 将返回一个错误(kernel/fs.c:560- 564)。主循环读取目录项，寻找一个未使用的条目。当它找到一个时，它会提前跳出循环 (kernel/fs.c:538-539)，并将 <strong>off</strong> 设置为该可用条目的偏移量。否则，循环结束时，将<strong>off</strong>设置为<strong>dp-&gt;size</strong>。不管是哪种方式，<strong>dirlink</strong>都会在偏移量<strong>off</strong>的位置添加一个新的条目到目录中(kernel/fs.c:574-577)。</p><h3 id="8-12-Code-Path-names"><a href="#8-12-Code-Path-names" class="headerlink" title="8.12 Code: Path names"></a>8.12 Code: Path names</h3><p>查找路径名会对每一个节点调用一次<strong>dirlookup</strong>。Namei (kernel/fs.c:661) 解析路径并返回相应的inode。函数<strong>nameiparent</strong>是<strong>namei</strong>的一个变种：它返回相应inode的父目录inode，并将最后一个元素复制到<strong>name</strong>中。这两个函数都通过调用<strong>namex</strong>来实现。</p><p><strong>Namex</strong> (kernel/fs.c:626)首先确定路径解析从哪里开始。如果路径以斜线开头，则从根目录开始解析；否则，从当前目录开始解析(kernel/fs.c:630-633)。然后它使用 <strong>skipelem</strong> 来遍历路径中的每个元素(kernel/fs.c:635)。循环的每次迭代都必须在当前inode <strong>ip</strong>中查找<strong>name</strong>。迭代的开始是锁定<strong>ip</strong>并检查它是否是一个目录。如果不是，查找就会失败(kernel/fs.c:636-640)。(锁定<strong>ip</strong>是必要的，不是因为<strong>ip-&gt;type</strong>可能会改变，而是因为在<strong>ilock</strong>运行之前，不能保证ip-&gt;type已经从磁盘载入)。如果调用的是<strong>nameiparent</strong>，而且这是最后一个路径元素，按照之前<strong>nameiparent</strong>的定义，循环应该提前停止，最后一个路径元素已经被复制到name中，所以<strong>namex</strong>只需要返回解锁的ip(kernel/fs.c:641-645)。最后，循环使用<strong>dirlookup</strong>查找路径元素，并通过设置<strong>ip</strong> = <strong>next</strong>为下一次迭代做准备(kernel/fs.c:646-651)。当循环遍历完路径元素时，它返回<strong>ip</strong>。</p><p><strong>namex</strong>可能需要很长的时间来完成：它可能会涉及几个磁盘操作，通过遍历路径名得到的目录的inode和目录块（如果它们不在buffer缓存中）。Xv6经过精心设计，如果一个内核线程对<strong>namex</strong>的调用阻塞在磁盘I/O上，另一个内核线程查找不同的路径名可以同时进行。<strong>Namex</strong>分别锁定路径中的每个目录，这样不同目录的查找就可以并行进行。</p><p>这种并发性带来了一些挑战。例如，当一个内核线程在查找一个路径名时，另一个内核线程可能正在取消链接一个目录，这会改变目录数。一个潜在的风险是，可能一个查找线程正在搜索的目录可能已经被另一个内核线程删除了，而它的块已经被另一个目录或文件重用了。</p><p>Xv6避免了这种竞争。例如，在<strong>namex</strong>中执行<strong>dirlookup</strong>时，查找线程会持有目录的锁，<strong>dirlookup</strong>返回一个使用<strong>iget</strong>获得的inode。<strong>iget</strong>会增加inode的引用次数。只有从<strong>dirlookup</strong>收到inode后，<strong>namex</strong>才会释放目录上的锁。现在另一个线程可能会从目录中取消链接inode，但xv6还不会删除inode，因为inode的引用数仍然大于零。</p><p>另一个风险是死锁。例如，当查找<strong>“. “</strong>时，next指向的inode与<strong>ip</strong>相同。在释放对<strong>ip</strong>的锁之前锁定next会导致死锁。为了避免这种死锁，<strong>namex</strong>在获得对next的锁之前就会解锁目录。这里我们再次看到为什么<strong>iget</strong>和<strong>ilock</strong>之间的分离是很重要的。</p><h3 id="8-13-File-descriptor-layer"><a href="#8-13-File-descriptor-layer" class="headerlink" title="8.13 File descriptor layer"></a>8.13 File descriptor layer</h3><p>Unix接口很酷的一点是：Unix中的大部分资源都是以文件的形式来表示的。包括控制台、管道等设备，当然还有真实的文件。文件描述符层就是实现这种统一性的一层。</p><p>Xv6给每个进程提供了自己的打开文件表，或者说文件描述符表，就像我们在第一章中看到的那样。每个打开的文件由一个结构体<strong>file</strong>(kernel/file.h:1)表示，它包装inode或管道，也包含一个I/O偏移量。每次调用<strong>open</strong>都会创建一个新的打开文件（一个新的结构体file），如果多个进程独立打开同一个文件，那么不同的<strong>file</strong>实例会有不同的I/O偏移量。另一方面，一个打开的文件（同一个结构文件）可以在一个进程的文件表中出现多次，也可以在多个进程的文件表中出现。如果一个进程使用<strong>open</strong>打开文件，然后使用<strong>dup</strong>创建别名，或者使用<strong>fork</strong>与子进程共享文件，就会出现这种情况。引用计数可以跟踪特定打开文件的引用数量。一个文件的打开方式可以为读，写，或者读写。通过<strong>readable</strong>和<strong>writable</strong>来指明。</p><p>系统中所有打开的文件都保存在一个全局文件表中，即<strong>ftable</strong>。文件表的功能有: 分配文件(<strong>filealloc</strong>)、创建重复引用(<strong>fileup</strong>)、释放引用(<strong>fileclose</strong>)、读写数据(<strong>fileeread</strong>和<strong>filewrite</strong>)。</p><p>前三个函数应该比较熟悉了,就不过多的讨论。<strong>Filealloc</strong> (kernel/file.c:30) 扫描文件表，寻找一个未引用的文件 (f-&gt;ref == 0)，并返回一个新的引用；<strong>fileup</strong> (kernel/file.c:48) 增加引用计数；<strong>fileclose</strong> (kernel/file.c:60) 减少引用计数。当一个文件的引用数达到0时，<strong>fileclose</strong>会根据类型释放底层的管道或inode。</p><p>函数<strong>filestat</strong>、<strong>fileread</strong>和<strong>filewrite</strong>实现了对文件的统计、读和写操作。Filestat(kernel/file.c:88)只允许对inodes进行操作，并调用<strong>stati</strong>。<strong>Fileread</strong>和<strong>filewrite</strong>首先检查打开模式是否允许该操作，然后再调用管道或inode的相关实现。如果文件代表一个inode，<strong>fileread</strong>和<strong>filewrite</strong>使用I/O偏移量作为本次操作的偏移量，然后前移偏移量（kernel/file.c:122- 123）（kernel/file.c:153-154）。Pipes没有偏移量的概念。回想一下inode的函数需要调用者处理锁的相关操作（kernel/file.c:94-96）（kernel/file.c:121-124）（kernel/file.c:163-166）。inode加锁附带了一个不错的作用，那就是读写偏移量是原子式更新的，这样多个进程写一个文件时，自己写的数据就不会被其他进程所覆盖，尽管他们的写入可能最终会交错进行。</p><h3 id="8-14-Code-System-calls"><a href="#8-14-Code-System-calls" class="headerlink" title="8.14 Code: System calls"></a>8.14 Code: System calls</h3><p>有了更低层提供的函数，大多数系统调用的实现都是比较简单的（见(kernel/sysfile.c)）。有几个调用值得仔细研究一下。</p><p>函数 <strong>sys_link</strong> 和 <strong>sys_unlink</strong> 可以编辑目录，创建或删除对 inodes 的引用。它们是使用事务的另一个很好的例子。<strong>Sys_link</strong> (kernel/sysfile.c:120) 首先获取它的参数，两个字符串 <strong>old</strong> 和 <strong>new</strong> (kernel/sysfile.c:125) 。假设 <strong>old</strong> 存在并且不是一个目录 (kernel/sysfile.c:129-132)，<strong>sys_link</strong> 会递增它的 <strong>ip-&gt;nlink</strong> 计数。然后 <strong>sys_link</strong> 调用 <strong>nameiparent</strong> 找到 new (kernel/sysfile.c:145) 的父目录和最终路径元素，并创建一个指向 <strong>old</strong>的 inode 的新目录项 (kernel/sysfile.c:148)。新的父目录必须存在，并且和现有的inode在同一个设备上，inode号只在同一个磁盘上有意义。如果出现这样的错误，<strong>sys_link</strong>必须返回并减少<strong>ip-&gt;nlink</strong>。</p><p>事务简化了这个函数的实现，因为它需要更新多个磁盘块，但我们不必担心做这些事情的顺序。它们要么全部成功，要么都不成功。例如，如果没有事务，在创建链接之前更新<strong>ip-&gt;nlink</strong>，会使文件系统暂时处于不安全的状态，中间的崩溃可能会造成破坏。有了事务，我们就不用担心这个问题了。</p><p><strong>Sys_link</strong>为一个现有的inode创建一个新的名字。而函数<strong>create</strong> (kernel/sysfile.c:242)为一个新的inode创建一个新的名字。它是三个文件创建相关的系统调用的综合：使用O_CREATE标志的open创建一个新的普通文件，<strong>mkdir</strong>创建一个新的目录，以及mkdev创建一个新的设备文件。和<strong>sys_link</strong>一样，<strong>create</strong>也是通过调用<strong>nameiparent</strong>来获取父目录的inode。然后调用 <strong>dirlookup</strong> 来检查名称是否已经存在 (kernel/sysfile.c:252)。如果名称存在，create的行为取决于它被用于哪个系统调用：<strong>open</strong>，<strong>mkdir</strong>，<strong>mkdev</strong>的语义不同。如果<strong>create</strong>是由<strong>open</strong>使用的 (<strong>type == T_FILE</strong>)，如果能根据该名字存在且为普通文件，那么打开就会成功，所以<strong>create</strong>也会成功 (kernel/sysfile.c:256)。否则，就会报错（kernel/sysfile.c:257-258）。如果这个名字不存在，<strong>create</strong>就会用<strong>ialloc</strong>分配一个新的inode(kernel/sysfile.c:261)。如果新的inode是一个目录，<strong>create</strong>会在该目录添加条目“.”和“..”。最后，现在数据已经被正确地初始化了，<strong>create</strong>可以把它链接到父目录中(kernel/sysfile.c:274)。和<strong>sys_link</strong>一样，create同时拥有两个inode锁：<strong>ip</strong>和<strong>dp</strong>。没有死锁的可能性，因为inode <strong>ip</strong>是新分配的：系统中没有其他进程会持有<strong>ip</strong>的锁并尝试锁住dp。。</p><p>使用<strong>create</strong>，很容易实现<strong>sys_open</strong>、<strong>sys_mkdir</strong>和<strong>sys_mknod</strong>。<strong>Sys_open</strong> (kernel/sysfile.c:287)是其中最复杂的，因为创建一个新文件只是它做的一小部分。如果<strong>open</strong>的打开模式包含为<strong>O_CREATE</strong>，它就会调用<strong>create</strong> (kernel/sysfile.c:301)。否则，它会调用 <strong>namei</strong> (kernel/sysfile.c:307)。<strong>Create</strong>会返回一个锁定的inode，但<strong>namei</strong>不会，所以<strong>sys_open</strong>必须锁定inode。这比较有一个方便的地方是目录只会以读打开，而不是写。假设inode是通过某种方式获得的，sys_open会分配一个文件和一个文件描述符(kernel/sysfile.c:325)，然后设置file相关的字段(kernel/sysfile.c:337- 94 342)。注意，没有其他进程可以访问这个部分初始化的文件，因为它只在当前进程的表中。</p><p>第7章在我们还没有文件系统之前就研究了管道的实现。函数<strong>sys_pipe</strong>通过提供创建管道对的方法将管道实现与文件系统连接起来。它的参数是一个指针，该指针指向一个长度为2的int类型数组，它将在这里记录两个新的文件描述符。然后它分配管道并装入文件描述符。</p><h3 id="8-15-Real-world"><a href="#8-15-Real-world" class="headerlink" title="8.15 Real world"></a>8.15 Real world</h3><p>实际操作系统中的buffer缓存要比xv6的复杂得多，但它有同样的两个目的：缓存和同步访问磁盘。xv6的buffer缓存和V6是一样的，使用简单的最近最少使用（LRU）抛弃策略；可以实现许多更复杂的策略，每种策略都对某些情况有好处，而对其它情况没有好处。更高效的LRU缓存不使用链表，而使用哈希表进行查找，使用堆进行LRU抛弃。现代的buffer缓存通常与虚拟内存系统集成在一起，以支持内存映射的文件。</p><p>Xv6的日志系统效率低下。提交不能与文件系统系统调用同时发生。系统会记录整个块，即使一个块中只有几个字节被改变。它执行同步的日志写入，一次写一个块，每一个块都可能需要整个磁盘旋转时间。真正的日志系统可以解决所有这些问题。</p><p>日志不是提供崩溃恢复的唯一方法。早期的文件系统在重启期间使用scavenger（例如UNIX fsck程序）来检查每个文件和目录以及块和inode空闲列表，寻找并解决不一致的地方。对于大型文件系统来说，清扫可能需要几个小时的时间，而且在某些情况下，这种方式要想获得的数据一致性，其系统调用必须是一致性的。从日志中恢复要快得多，而且在崩溃时，系统调用是原子的。</p><p>Xv6使用了与早期UNIX相同的inodes和目录的基本磁盘布局；这个方案多年来仍在使用。BSD的UFS/FFS和Linux的ext2/ext3使用基本相同的数据结构。文件系统布局中最低效的部分是目录，在每次查找过程中需要对所有磁盘块进行线性扫描。当目录只有几个磁盘块时，这是合理的，但对于有许多文件的目录来说是昂贵的。微软Windows的NTFS，Mac OS X的HFS，以及Solaris的ZFS，将目录实现为磁盘上块的平衡树。这很复杂，但可以保证目录查找的时间复杂度是对数级的。</p><p>Xv6对磁盘故障的处理很朴素：如果磁盘操作失败，xv6就会<strong>panic</strong>。这是否合理取决于硬件：如果一个操作系统位于特殊的硬件之上，这种硬件会使用冗余来掩盖故障，也许操作系统看到故障的频率很低，以至于直接<strong>panic</strong>是可以的。另一方面，使用普通磁盘的操作系统应该使用更加优雅的方式来处理异常，这样一个文件中一个块的丢失就不会影响文件系统其他部分的使用。</p><p>Xv6要求文件系统固定在单一磁盘设备上，而且大小不能改变。随着大型数据库和多媒体文件对存储要求越来越高，操作系统正在开发消除每个文件系统一个磁盘瓶颈的方法。基本的方法是将许多磁盘组合成一个逻辑磁盘。硬件解决方案（如RAID）仍然是最流行的，但目前的趋势是尽可能地在软件中实现这种逻辑。这些软件实现通常允许丰富的功能，如在运行时通过快速添加或删除磁盘来增长或缩小逻辑设备。当然，一个能够快速增长或收缩的存储层需要一个能够做到同样的文件系统：xv6使用的固定大小的inode块阵列在这样的环境中不能很好地工作。将磁盘管理与文件系统分离可能是最简洁的设计，但由于两者之间复杂的接口，使得有些系统，如Sun公司的ZFS，将两者直接结合起来。</p><p>Xv6的文件系统缺乏现代文件系统的许多其他功能，例如，它缺乏对快照和增量备份的支持。</p><p>现代Unix系统允许用与磁盘存储相同的系统调用来访问许多种类的资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如/proc。与xv6在fileread和filewrite中的if语句，这些系统通常给每个打开的文件一个函数指针表，每个代表一个操作，调用函数指针来调用该inode的实现调用。网络文件系统和用户级文件系统提供了将这些调用变成网络RPC的函数，并在返回前等待响应。</p><h3 id="8-16-Exercises"><a href="#8-16-Exercises" class="headerlink" title="8.16 Exercises"></a>8.16 Exercises</h3><ol><li><p>为什么<strong>balloc</strong>需要<strong>panic</strong>？xv6能恢复吗？</p></li><li><p>为什么<strong>ialloc</strong>需要<strong>panic</strong>？xv6能恢复吗？</p></li><li><p>为什么<strong>filealloc</strong>用完文件后不<strong>panic</strong>？为什么这种情况比较常见，而值得处理？</p></li><li><p>假设在执行<strong>sys_lin</strong>k时，另一个进程在<strong>iunlock(ip)</strong>和<strong>dirlink</strong>之间解除链接该<strong>ip</strong>对应的文件。链接会被正确创建吗？为什么？</p></li><li><p><strong>create</strong>调用了四次函数（一个<strong>ialloc</strong>，三次<strong>dirlink</strong>），它需要这些函数成功返回。如果任何一个不成功，<strong>create</strong>调用就会<strong>panic</strong>。为什么这可以接受？为什么这四个调用不能有一个失败呢？</p></li><li><p><strong>sys_chdir</strong>在<strong>iput(cp-&gt;cwd)</strong>之前调用<strong>iunlock(ip)</strong>，这可能会尝试锁定<strong>cp-&gt;cwd</strong>，但将<strong>iunlock(ip)</strong>推迟到<strong>iput</strong>之后不会造成死锁。为什么不会呢？</p></li><li><p>实现<strong>lseek</strong>系统调用。<strong>lseek</strong>还需要你修改<strong>filewrite</strong>，如果<strong>lseek</strong>设置超过<strong>f-&gt;ip-&gt;size</strong>，则在文件中用零来填补空缺。</p></li><li><p>给<strong>open</strong>增加O_TRUNC和O_APPEND，使&gt;和&gt;&gt;操作符在shell中可以使用。</p></li><li><p>修改文件系统使其支持符号链接。</p></li><li><p>修改文件系统使其支持命名管道。</p></li><li><p>修改文件系统和VM使其支持memory-map文件（内存映射文件）。</p></li></ol><hr><ol><li><a name="ftn1"></a>扇区号表明该日志块，应该写入的位置。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第七章</title>
      <link href="/2022/08/31/xv6-Chapter-7/"/>
      <url>/2022/08/31/xv6-Chapter-7/</url>
      
        <content type="html"><![CDATA[<h2 id="第七章：调度"><a href="#第七章：调度" class="headerlink" title="第七章：调度"></a>第七章：调度</h2><p>任何操作系统运行的进程数量都可能超过计算机的CPU数量，因此需要制定一个方案，在各进程之间分时共享CPU。理想情况下，这种共享对用户进程是透明的。一种常见的方法是通过将进程复用到硬件CPU上，给每个进程提供它有自己的虚拟CPU的假象。本章解释xv6如何实现这种复用。</p><h3 id="7-1-Multiplexing"><a href="#7-1-Multiplexing" class="headerlink" title="7.1 Multiplexing"></a>7.1 Multiplexing</h3><p>xv6通过在两种情况下将CPU从一个进程切换到另一个进程来实现复用。首先，xv6的<strong>sleep</strong>和<strong>wakeup</strong>机制会进行切换，这会发生在进程等待设备或管道I/O，或等待子进程退出，或在<strong>sleep</strong>系统调用中等待。其次，xv6周期性地强制切换，以应对长时间不进行sleep操作的计算进程。这种复用造成了每个进程都有自己的CPU的假象，就像xv6使用内存分配器和硬件页表造成每个进程都有自己的内存的假象一样。</p><p>实现复用会有一些挑战。首先，如何从一个进程切换到另一个进程？虽然上下文切换的想法很简单，但在XV6的实现中上下文切换却是最不透明的代码之一。第二，如何以对用户进程透明的方式进行强制切换？xv6采用标准通用的方式，用定时器中断来驱动上下文切换。第三，许多CPU可能会在进程间并发切换，需要设计一个锁来避免竞争。第四，当进程退出时，必须释放进程的内存和其他资源，但进程本身不能完全释放掉所有的资源，比如它不能在使用内核栈的同时释放自己的内核栈。第五，多核机器的每个内核必须记住它正在执行的进程，这样系统调用才能修改相应进程的内核状态。最后，<strong>sleep</strong>和<strong>wakeup</strong>允许一个进程放弃CPU，并睡眠等待某一事件，并允许另一个进程将睡眠的进程唤醒。需要注意一些竞争可能会使唤醒丢失。Xv6试图尽可能简单地解决这些问题，尽管如此，实际代码还是很棘手。</p><h3 id="7-2-Code-Context-switching"><a href="#7-2-Code-Context-switching" class="headerlink" title="7.2 Code: Context switching"></a>7.2 Code: Context switching</h3><p><img src="/img/Figure-7.1.png" alt="Figure-7.1"></p><p>图7.1概述了从一个用户进程切换到另一个用户进程所涉及的步骤：用户-内核的切换（通过系统调用或中断）到旧进程的内核线程，上下文（context）切换到当前CPU的调度器线程，上下文（context）切换到新进程的内核线程，以及trap返回到用户级进程。xv6调度器在每个CPU上有一个专门的线程(保存了寄存器和栈)，因为调度器在旧进程的内核栈上执行是不安全的：因为其他核心可能会唤醒该进程并运行它，而在两个不同的核心上使用相同的栈将是一场灾难。在本节中，我们将研究在内核线程和调度线程之间切换的机制。</p><p>从一个线程切换到另一个线程，需要保存旧线程的CPU寄存器，并恢复新线程之前保存的寄存器；栈指针和pc被保存和恢复，意味着CPU将切换栈和正在执行的代码。</p><p>函数<strong>swtch</strong>执行内核线程切换的保存和恢复。<strong>swtch</strong>并不直接知道线程，它只是保存和恢复寄存器组，称为<strong><em>上下文(context)</em></strong>。当一个进程要放弃CPU的时候，进程的内核线程会调用<strong>swtch</strong>保存自己的上下文并返回到调度器上下文。每个上下文都包含在一个结构体 <strong>context(kernel/proc.h:2)</strong>中，它本身包含在进程的结构体<strong>proc</strong>或CPU的结构体<strong>cpu</strong>中。<strong>Swtch</strong>有两个参数：<strong>struct context old</strong>和<strong>struct context new</strong>。它将当前的寄存器保存在old中，从new中加载寄存器，然后返回。</p><p>让我们跟随一个进程通过<strong>swtch</strong>进入<strong>scheduler</strong>。我们在第4章看到，在中断结束时，有一种情况是<strong>usertrap</strong>调用<strong>yield</strong>。<strong>yield</strong>又调用<strong>sched</strong>，<strong>sched</strong>调用<strong>swtch</strong>将当前上下文保存在<strong>p-&gt;context</strong>中，并切换到之前保存在<strong>cpu-&gt;scheduler</strong>中的调度器上下文（kernel/proc.c:509）。</p><p><strong>Swtch(kernel/swtch.S:3)</strong>只保存callee-saved寄存器，caller-saved寄存器由调用的C代码保存在堆栈上(如果需要)。<strong>Swtch</strong>知道<strong>struct context</strong>中每个寄存器字段的偏移量。它不保存pc。相反，<strong>swtch</strong>保存了ra寄存器<a href="#ftn1">[1]</a>，它保存了<strong>swtch</strong>应该返回的地址。现在，<strong>swtch</strong>从新的上下文中恢复寄存器，新的上下文中保存着前一次<strong>swtch</strong>所保存的寄存器值。当<strong>swtch</strong>返回时，它返回到被恢复的ra寄存器所指向的指令，也就是新线程之前调用<strong>swtch</strong>的指令。此外，它还会返回新线程的堆栈。</p><p>在我们的例子中，<strong>sched</strong>调用<strong>swtch</strong>切换到<strong>cpu-&gt;scheduler</strong>，即CPU调度器的上下文。这个上下文已经被<strong>scheduler</strong>对<strong>swtch</strong>的调用所保存(kernel/proc.c:475)。当我们跟踪的<strong>swtch</strong>返回时，它不是返回到<strong>sched</strong>而是返回到<strong>scheduler</strong>，它的栈指针指向当前CPU的调度器栈。</p><p>补充说明（不在翻译内容中）：</p><p>根据XV6的源代码，xv6中只有两处调用switch：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;scheduler);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swtch(&amp;c-&gt;scheduler, &amp;p-&gt;context);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以看出这里没有两个用户进程之间的直接切换，只有用户进程和调度器线程之间的切换</strong>：xv6中要主动让出cpu的进程都是通过调用exit/sleep/yield，间接调用sched，从而实现切换到调度器线程，再由调度器线程选出并切换到一个runnable。</p><h3 id="7-3-Code-Scheduling"><a href="#7-3-Code-Scheduling" class="headerlink" title="7.3 Code: Scheduling"></a>7.3 Code: Scheduling</h3><p>上一节研究了<strong>swtch</strong>的底层细节，现在我们把<strong>swtch</strong>作为一个给定的条件，研究从一个进程的内核线程通过调度器切换到另一个进程。调度器以CPU特殊线程（每个CPU各一个）的形式存在，线程运行<strong>scheduler</strong>函数。这个函数负责选择下一步运行哪个进程。一个想要放弃CPU的进程，必须获取自己的进程锁<strong>p-&gt;lock</strong>，释放它所持有的其他锁，更新自己的状态（<strong>p-&gt;state</strong>），然后调用<strong>sched</strong>。<strong>Yield</strong> (kernel/proc.c:515) 遵循这个规则，我们稍后要研究的<strong>sleep</strong>和<strong>exit</strong>也同样遵循这个规则。<strong>Sched</strong>对这些条件进行仔细检查(kernel/proc.c:499-504)，然后再检查这些条件的含义：既然锁被持有，就应该禁用中断。最后，<strong>sched</strong>调用<strong>swtch</strong>将当前上下文保存在p-&gt;context中，并切换到cpu-&gt;scheduler中<strong>scheduler</strong>的上下文。Swtch在<strong>scheduler</strong>堆栈上返回，<strong>scheduler</strong>继续for循环，找到一个要运行的进程，切换到它，然后循环重复。</p><p>我们刚刚看到xv6在调用<strong>swtch</strong>的过程中持有<strong>p-&gt;lock</strong>：<strong>swtch</strong>的调用者必须已经持有锁，并把锁的控制权移交给切换到的代码。这种约定对于锁来说是不寻常的；一般来说获得锁的线程也要负责释放锁，这样才容易保证正确性。对于上下文切换来说，有必要打破这个约定，因为<strong>p-&gt;lock</strong>保护了进程的状态和<strong>context</strong>字段上的<strong><em>不变量（invariant）</em></strong>，而这些不变量在<strong>swtch</strong>执行时是不正确的。如果<strong>p-&gt;lock</strong>在<strong>swtch</strong>过程中不被持有，可能会出现问题的一个情况：在<strong>yield</strong>将其状态设置为<strong>RUNNABLE</strong>之后，但在<strong>swtch</strong>切换到新的栈之前，其他CPU可能会运行这个进程。结果就是两个CPU运行在同一个栈上，这显然是错误的。</p><p>一个内核线程在<strong>sched</strong>中放弃它的CPU，并且切换到<strong>scheduler</strong>的同一个位置，而<strong>scheduler</strong>（几乎）总是切换到之前调用<strong>sched</strong>的某个内核线程。因此，如果把xv6切换线程的行号打印出来，就会观察到下面的结果：(kernel/proc.c:475)，(kernel/proc.c:509)，(kernel/proc.c:475)，(kernel/proc.c:509)，等等。在两个线程之间发生这种样式化切换的程序有时被称为<strong><em>协程（coroutine）</em></strong>；在这个例子中，<strong>sched</strong>和<strong>scheduler</strong>是彼此的<strong><em>coroutines</em></strong>。</p><p>有一种情况是调度器对<strong>swtch</strong>的调用没有以<strong>sched</strong>结束。当一个新进程第一次被调度时，它从<strong>forkret</strong>开始（kernel/proc.c:527）。<strong>forkret</strong>的存在是为了释放<strong>p-&gt;lock</strong>；否则，新进程需要从<strong>usertrapret</strong>开始。</p><p><strong>scheduler(kernel/proc.c:457)</strong>运行了一个简单的循环：找到一个可以运行进程，运行它，直到它让出CPU，一直重复。调度器在进程表上循环寻找一个可运行的进程，即p-&gt;state == RUNNABLE的进程。一旦找到这样的进程，它就会设置CPU当前进程变量c-&gt;proc指向该进程，将该进程标记为RUNNING，然后调用<strong>swtch</strong>开始运行它(kernel/proc.c:470- 475)。</p><p>你可以这样理解调度代码结构，它执行一组关于进程的不变量，并且每当这些不变量不正确时，就持有<strong>p-&gt;lock</strong>。一个不变量是，如果一个进程正在运行，那么定时中断导致的yield必须能够安全的让他让出cpu；这意味着CPU寄存器必须持有该进程的寄存器值（即<strong>swtch</strong>没有将它们移到上下文中），并且<strong>c-&gt;proc</strong>必须指向该进程。另一个不变量是，如果一个进程是<strong>RUNNABLE</strong>的，那么对于一个空闲的CPU调度器来说，运行它必须是安全的；这意味着 （1）<strong>p-&gt;context</strong>必须拥有进程的寄存器（即它们实际上并不在真实的寄存器中），（2）没有CPU在进程的内核栈上执行，（3）也没有CPU的c-&gt;proc指向该进程。请注意，当p-&gt;lock被持有时，这些属性往往不正确。</p><p>维护上述不变量是xv6经常在一个线程中获取<strong>p-&gt;lock</strong>，然后在另一个线程中释放它的原因（例如在<strong>yield</strong>中获取，在<strong>schedululer</strong>中释放）。一旦<strong>yield</strong>开始修改一个正在运行的进程的状态，使其成为<strong>RUNNABLE</strong>，锁必须一直保持，直到不变量被恢复：最早正确的释放点是在调度器（运行在自己的堆栈上）清除<strong>c-&gt;proc</strong>之后。同样，一旦调度器开始将一个<strong>RUNNABLE</strong>进程转换为<strong>RUNNING</strong>，锁就不能被释放，直到内核线程完成运行（在<strong>swtch</strong>之后，例如在<strong>yield</strong>中）。</p><p><strong>p-&gt;lock</strong>也保护其他的东西：<strong>exit</strong>和<strong>wait</strong>之间的相互作用，避免丢失唤醒的机制（见第7.5节），以及避免避免退出进程和读写其状态的其他进程之间的竞争（例如，<strong>exit</strong>系统调用查看<strong>p-&gt;pid</strong>并设置<strong>p-&gt;killed (kernel/proc.c:611)</strong>。值得思考的是，是否可以将<strong>p-&gt;lock</strong>的不同功能拆分开来，这样既清晰，也可能提高性能。</p><h3 id="7-4-Code-mycpu-and-myproc"><a href="#7-4-Code-mycpu-and-myproc" class="headerlink" title="7.4 Code: mycpu and myproc"></a>7.4 Code: mycpu and myproc</h3><p>​    Xv6经常需要一个指向当前进程<strong>proc</strong>的指针。在单核处理器上，可以用一个全局变量指向当前的<strong>proc</strong>。这在多核机器上是行不通的，因为每个核都执行不同的进程。解决这个问题的方法是利用每个核都有自己的一组寄存器的事实；我们可以使用其中的一个寄存器来帮助查找每个核的信息。</p><p>Xv6为每个CPU维护了一个<strong>cpu</strong>结构体(kernel/proc.h:22)，它记录了当前在该CPU上运行的进程(如果有的话)，为CPU的调度线程保存的寄存器，以及管理中断禁用所需的嵌套自旋锁的计数。函数<strong>mycpu</strong>(kernel/proc.c:60)返回一个指向当前CPU结构体<strong>cpu</strong>的指针。RISC-V对CPU进行编号，给每个CPU一个<strong>hartid</strong>。Xv6确保每个CPU的<strong>hartid</strong>在内核中被存储在该CPU的<strong>tp</strong>寄存器中。这使得<strong>mycpu</strong>可以使用<strong>tp</strong>对<strong>cpu</strong>结构体的数组进行索引，从而找到正确的cpu。</p><p>确保一个CPU的<strong>tp</strong>始终保持CPU的hartid是有一点复杂的。<strong>mstart</strong>在CPU启动的早期设置<strong>tp</strong>寄存器，此时CPU处于机器模式(kernel/start.c:46)。<strong>Usertrapret</strong>将<strong>tp</strong>寄存器保存在trampoline页中，因为用户进程可能会修改tp寄存器。最后，当从用户空间进入内核时，<strong>use</strong>rvec会恢复保存的tp（trapframe中的tp加载到tp寄存器）(kernel/trampoline.S:70)。编译器保证永远不使用tp寄存器。如果RISC-V允许xv6直接读取当前的hartid会更方便，但这只允许在机器模式下读取，而不允许在管理模式下读取。</p><p>cpuid和mycpu的返回值很容易错：如果定时器中断，导致线程让出CPU，然后转移到不同的CPU上，之前返回的值将不再正确。为了避免这个问题，xv6要求调用者禁用中断，只有在使用完返回的cpu结构后才启用中断。(即为了避免这个问题，调用cpuid和mycpu时，需要禁用中断)</p><p><strong>myproc</strong>(kernel/proc.c:68)函数返回当前CPU上运行的进程的<strong>proc</strong>指针。<strong>myproc</strong>禁用中断，调用<strong>mycpu</strong>，从<strong>struct</strong> <strong>cpu</strong>中获取当前进程指针(<strong>c-&gt;proc</strong>)，然后启用中断。即使启用了中断，<strong>myproc</strong>的返回值也可以安全使用：如果定时器中断将调用进程移到了另一个的CPU上，它的<strong>proc</strong>结构指针将保持不变。</p><h3 id="7-5-Sleep-and-wakeup"><a href="#7-5-Sleep-and-wakeup" class="headerlink" title="7.5 Sleep and wakeup"></a>7.5 Sleep and wakeup</h3><p>调度和锁有助于让一个进程对另一个进程的不可见，但到目前为止，我们还没有帮助进程进行交互的抽象。人们发明了许多机制来解决这个问题。Xv6使用了一种叫做睡眠和唤醒的机制，它允许一个进程睡眠并等待事件，另一个进程在该事件发生后将其唤醒。睡眠和唤醒通常被称为<strong><em>序列协调（sequence coordination）</em></strong> 或<strong><em>条件同步（conditional synchronization）</em></strong> 机制。</p><p>为了说明这一点，让我们考虑一个叫做<strong><em>信号量（semaphore）</em></strong>[4]的同步机制，它协调生产者和消费者。信号量维护一个计数并提供两个操作。V操作（针对生产者）增加计数。P操作（针对消费者）等待，直到计数非零，然后将其递减并返回。如果只有一个生产者线程和一个消费者线程，而且它们在不同的CPU上执行，编译器也没有太过激进的优化，那么这个实现是正确的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count += <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现是代价很大。如果生产者很少生产，消费者将把大部分时间花在while循环中，希望得到一个非零的计数。消费者的CPU可以通过反复<strong><em>轮询(polling)</em></strong> <strong>s-&gt;count</strong>可以找到比<strong><em>忙碌等待(busy waiting)</em></strong>更有效的工作。避免<strong><em>忙碌等待</em></strong>需要一种方法，让消费者让出CPU，只有在<strong>V</strong>增加计数后才恢复。</p><p>这里是朝着这个方向迈出的一步，虽然他不能完全解决这个问题。让我们想象一对调用，<strong>sleep</strong>和<strong>wakeup</strong>，其工作原理如下。<strong>Sleep(chan)</strong>睡眠<strong>chan</strong>上，<strong>chan</strong>可以为任意值，称为<strong><em>等待通道(wait channel)</em></strong>。<strong>Sleep</strong>使调用进程进入睡眠状态，释放CPU进行其他工作。<strong>Wakeup(chan)</strong>唤醒所有在<strong>chan</strong>上<strong>sleep</strong>的进程（如果有的话），使它们的<strong>sleep</strong>调用返回。如果没有进程在<strong>chan</strong>上等待，则<strong>wakeup</strong>不做任何事情。我们修改信号量实现，以使用<strong>sleep</strong>和<strong>wakeup</strong>（修改处用注释标注）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count += <span class="number">1</span>;</span><br><span class="line">  wakeup(s);<span class="comment">// 修改</span></span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    sleep(s);<span class="comment">// 修改</span></span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P现在放弃CPU而不是自旋，这是一个不错的改进。然而，事实证明，像这样设计<strong>sleep</strong>和<strong>wakeup</strong>并不是一件容易的事，因为它会遇到所谓的丢失唤醒问题。假设执行P 的<strong>s-&gt;count == 0</strong>这一行时。当P在<strong>sleep</strong>之前，V在另一个CPU上运行：它将<strong>s-&gt;count</strong>改为非零，并调用<strong>wakeup</strong>，<strong>wakeup</strong>发现没有进程在睡眠，因此什么也不做。现在P继续执行：它调用<strong>sleep</strong>并进入睡眠状态。这就造成了一个问题：P正在<strong>sleep</strong>，等待一个已经发生的V调用。除非我们运气好，生产者再次调用V，否则消费者将永远等待，即使计数是非零。</p><p>这个问题的根源在于，在错误的时刻运行的V违反了P只在<code>s-&gt;count==0</code>时休眠的不变量。保护这个不变量的一个不正确的方法是将锁获取（修改用注释标注）移动到P中，这样它对计数的检查和对sleep的调用是原子的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;s-&gt;lock);</span><br><span class="line">s-&gt;count += <span class="number">1</span>;</span><br><span class="line">wakeup(s);</span><br><span class="line">release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;s-&gt;lock);<span class="comment">// 修改</span></span><br><span class="line"><span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">sleep(s);</span><br><span class="line">s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人们可能希望这个版本的P能够避免丢失的唤醒，因为锁会阻止V在<strong>s-&gt;count == 0</strong>和sleep之间执行。它做到了这一点，但它也会死锁。P在<strong>sleep</strong>时保持着锁，所以V将永远阻塞在等待锁的过程中。</p><p>我们将通过改变<strong>sleep</strong>的接口来修正前面的方案：调用者必须将<strong><em>条件锁(condition lock)</em></strong>传递给<strong>sleep</strong>，这样在调用进程被标记为<strong><em>SLEEPING</em></strong>并在chan上等待后，它就可以释放锁。锁将强制并发的V等待直到P将自己置于<strong><em>SLEEPING</em></strong>状态，这样<strong>wakeup</strong>就会发现<strong><em>SLEEPING</em></strong>的消费者并将其唤醒。一旦消费者再次被唤醒，<strong>sleep</strong>就会重新获得锁，然后再返回。我们新的正确的睡眠/唤醒方案是可用的，如下所示（修改用注释标注）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;s-&gt;lock);</span><br><span class="line"><span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">sleep(s, &amp;s-&gt;lock);<span class="comment">// 修改</span></span><br><span class="line">s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P持有<strong>s-&gt;lock</strong>会阻止了V在P检查<strong>c-&gt;count</strong>和调用<strong>sleep</strong>之间试图唤醒它。但是，请注意，我们需要<strong>sleep</strong>来原子地释放<strong>s-&gt;lock</strong>并使消费者进程进入<strong><em>SLEEPING</em></strong>状态。</p><h3 id="7-6-Code-Sleep-and-wakeup"><a href="#7-6-Code-Sleep-and-wakeup" class="headerlink" title="7.6 Code: Sleep and wakeup"></a>7.6 Code: Sleep and wakeup</h3><p>让我们看看<strong>sleep (kernel/proc.c:548)</strong> 和 <strong>wakeup (kernel/proc.c:582)</strong> 的实现。其基本思想是让<strong>sleep</strong>将当前进程标记为<strong>SLEEPING</strong>，然后调用<strong>sched</strong>让出<strong>CPU</strong>；<strong>wakeup</strong>则寻找给定的<strong><em>等待通道</em></strong>上睡眠的进程，并将其标记为<strong>RUNNABLE</strong>。<strong>sleep</strong>和<strong>wakeup</strong>的调用者可以使用任何方便的数字作为<strong>channel</strong>。Xv6经常使用参与等待的内核数据结构的地址。</p><p><strong>Sleep</strong>首先获取<strong>p-&gt;lock (kernel/proc.c:559)</strong>。现在进入睡眠状态的进程同时持有<strong>p-&gt;lock</strong>和<strong>lk</strong>。在调用者(在本例中为P)中，持有<strong>lk</strong>是必要的：它保证了没有其他进程(在本例中，运行V的进程)可以调用<strong>wakeup(chan)</strong>。现在<strong>sleep</strong>持有<strong>p-&gt;lock</strong>，释放<strong>lk</strong>是安全的：其他进程可能会调用<strong>wakeup(chan)</strong>，但<strong>wakeup</strong>会等待获得<strong>p-&gt;lock</strong>，因此会等到<strong>sleep</strong>将进程状态设置为<strong>SLEEPING</strong>，使<strong>wakeup</strong>不会错过<strong>sleep</strong>的进程。</p><p>有一个复杂情况：如果<strong>lk</strong>和<strong>p-&gt;lock</strong>是同一个锁，如果<strong>sleep</strong>仍试图获取<strong>p-&gt;lock</strong>，就会和自己死锁。但是如果调用<strong>sleep</strong>的进程已经持有<strong>p-&gt;lock</strong>，那么它就不需要再做任何事情来避免错过一个并发的<strong>wakeup</strong>。这样的情况发生在，<strong>wait (kernel/proc.c:582)</strong>调用<strong>sleep</strong>并持有<strong>p-&gt;lock</strong>时。</p><p>现在<strong>sleep</strong>持有<strong>p-&gt;lock</strong>，而没有其他的锁，它可以通过记录它睡眠的<strong>channel</strong>，将进程状态设置<strong>SLEEPING</strong>，并调用<strong>sched</strong>(kernel/proc.c:564-567)来使进程进入睡眠状态。稍后我们就会明白为什么在进程被标记为<strong>SLEEPING</strong>之前，<strong>p-&gt;lock</strong>不会被释放（由调度器）。</p><p>在某些时候，一个进程将获取条件锁，设置睡眠等待的条件，并调用<strong>wakeup(chan)</strong>。重要的是，<strong>wakeup</strong>是在持有条件锁<a href="#ftn2">[2]</a>的情况下被调用的。<strong>Wakeup</strong>循环浏览进程表<strong>（kernel/proc.c:582）</strong>。它获取每个被检查的进程的<strong>p-&gt;lock</strong>，因为它可能会修改该进程的状态，也因为<strong>p-&gt;sleep</strong>确保<strong>sleep</strong>和<strong>wakeup</strong>不会相互错过。当<strong>wakeup</strong>发现一个进程处于状态为<strong>SLEEPING</strong>并有一个匹配的<strong>chan</strong>时，它就会将该进程的状态改为<strong>RUNNABLE</strong>。下一次调度器运行时，就会看到这个进程已经准备好运行了。</p><p>为什么<strong>sleep</strong>和<strong>wakeup</strong>的锁规则能保证睡眠的进程不会错过<strong>wakeup</strong>？<strong>sleep</strong>进程从检查条件之前到标记为<strong>SLEEPING</strong>之后的这段时间里，持有条件锁或它自己的<strong>p-&gt;lock</strong>或两者都持有。调用<strong>wakeup</strong>的进程在<strong>wakeup</strong>的循环中持有这两个锁。因此，唤醒者要么在消费者检查条件之前使条件为真；要么唤醒者的<strong>wakeup</strong>在消费者被标记为<strong>SLEEPING</strong>之后检查它。 无论怎样，<strong>wakeup</strong>就会看到这个睡眠的进程，并将其唤醒（除非有其他事情先将其唤醒）。</p><p>有时会出现多个进程在同一个<strong>channel</strong>上睡眠的情况；例如，有多个进程从管道中读取数据。调用一次<strong>wakeup</strong>就会把它们全部唤醒。其中一个进程将首先运行，并获得<strong>sleep</strong>参数传递的锁，（就管道而言）读取数据都会在管道中等待。其他进程会发现，尽管被唤醒了，但没有数据可读。从他们的角度来看，唤醒是“虚假的“，他们必须再次睡眠。出于这个原因，<strong>sleep</strong>总是在一个检查条件的循环中被调用。</p><p>如果两次使用<strong>sleep/wakeup</strong>不小心选择了同一个通道，也不会有害：它们会看到虚假的唤醒，上面提到的循环允许发生这种情况。<strong>sleep</strong>/<strong>wakeup</strong>的魅力很大程度上在于它既是轻量级的（不需要创建特殊的数据结构来充当睡眠通道），又提供了一层间接性（调用者不需要知道他们正在与哪个具体的进程交互）。</p><h3 id="7-7-Code-Pipes"><a href="#7-7-Code-Pipes" class="headerlink" title="7.7 Code: Pipes"></a>7.7 Code: Pipes</h3><p>一个使用<strong>sleep</strong>和<strong>wakeup</strong>来同步生产者和消费者的更复杂的例子是xv6的管道实现。我们在第1章看到了管道的接口：写入管道一端的字节被复制到内核缓冲区，然后可以从管道的另一端读取。未来的章节将研究管道如何支持文件描述符，但我们现在来看一下<strong>pipewrite</strong>和<strong>piperead</strong>的实现吧。</p><p>每个管道由一个结构体 <strong>pipe</strong>表示，它包含一个锁和一个数据缓冲区。<strong>nread</strong>和<strong>nwrite</strong>两个字段统计从缓冲区读取和写入的字节总数。缓冲区呈环形：<strong>buf[PIPESIZE-1]</strong>之后写入的下一个字节是<strong>buf[0]</strong>。计数不呈环形。这个约定使得实现可以区分满缓冲区(<strong>nwrite == nread+PIPESIZE</strong>)和空缓冲区(<strong>nwrite == nread</strong>)，但这意味着对缓冲区的索引必须使用<strong>buf[nread % PIPESIZE]</strong>，而不是使用<strong>buf[nread]</strong>(<strong>nwrite</strong>也是如此)。</p><p>假设对<strong>piperead</strong>和<strong>pipewrite</strong>的调用同时发生在两个不同的CPU上。<strong>Pipewrite</strong> <strong>(kernel/pipe.c:77)</strong>首先获取管道的锁，它保护了计数、数据和相关的不变式。然后，<strong>Piperead</strong> <strong>(kernel/pipe.c:103)</strong>也试图获取这个锁，但是不会获取成功。它在<strong>acquire(kernel/spinlock.c:22)</strong>中循环，等待锁的到来。当<strong>piperead</strong>等待时，<strong>pipewrite</strong>会循环写，依次将每个字节添加到管道中(kernel/pipe.c:95)。在这个循环中，可能会发生缓冲区被填满的情况(kernel/pipe.c:85)。在这种情况下，<strong>pipewrite</strong>调用<strong>wakeup</strong>来提醒所有睡眠中的reader有数据在缓冲区中等待，然后在<strong>&amp;pi-&gt;nwrite</strong>上<strong>sleep</strong>，等待reader从缓冲区中取出一些字节。<strong>Sleep</strong>函数内会释放<strong>pi-&gt;lock</strong>，然后<strong>pipwrite</strong>进程睡眠。</p><p>现在<strong>pi-&gt;lock</strong>可用了，<strong>piperead</strong>设法获取它并进入它的临界区：它发现<strong>pi-&gt;nread != pi-&gt;nwrite (kernel/pipe.c:110)</strong> (<strong>pipewrite</strong>进入睡眠状态是由于<strong>pi-&gt;nwrite == pi-&gt;nread+PIPESIZE (kernel/pipe.c:85)</strong>)，所以它进入for循环，将数据从管道中复制出来<strong>(kernel/pipe.c:117)</strong>，并按复制的字节数增加<strong>nread</strong>。现在又可写了，所以 <strong>piperead</strong> 在返回之前调用 <strong>wakeup (kernel/pipe.c:124)</strong> 来唤醒在睡眠的writer。<strong>Wakeup</strong>找到一个在<strong>&amp;pi-&gt;nwrite</strong>上睡眠的进程，这个进程正在运行<strong>pipewrite</strong>，但在缓冲区填满时停止了。它将该进程标记为<strong>RUNNABLE</strong>。</p><p>管道代码对reader和writer分别使用不同的睡眠<strong>channel</strong>（<strong>pi-&gt;nread</strong>和<strong>pi-&gt;nwrite</strong>）；这可能会使系统在有多个reader和writer等待同一个管道的情况下更有效率。管道代码在循环内sleep，检查sleep条件；如果有多个reader 和 writer，除了第一个被唤醒的进程外，其他进程都会看到条件仍然是假的，然后再次睡眠。</p><h3 id="7-8-Code-Wait-exit-and-kill"><a href="#7-8-Code-Wait-exit-and-kill" class="headerlink" title="7.8 Code: Wait, exit, and kill"></a>7.8 Code: Wait, exit, and kill</h3><p><strong>sleep</strong>和<strong>wakeup</strong>可以用于许多种需要等待的情况。在第1章中介绍的一个有趣的例子是，一个子进程的<strong>exit</strong>和其父进程的<strong>wait</strong>之间的交互。在子进程退出的时候，父进程可能已经在<strong>wait</strong>中睡眠了，也可能在做别的事情；在后一种情况下，后续的<strong>wait</strong>调用必须观察子进程的退出，也许是在它调用<strong>exit</strong>之后很久。xv6在<strong>wait</strong>观察到子进程退出之前，记录子进程退出的方式是让<strong>exit</strong>将调用进程设置为<strong>ZOMBIE</strong>状态，在那里停留，直到父进程的<strong>wait</strong>注意到它，将子进程的状态改为<strong>UNUSED</strong>，然后复制子进程的退出状态，并将子进程的进程ID返回给父进程。如果父进程比子进程先退出，父进程就把子进程交给<strong>init</strong>进程，而<strong>init</strong>进程则循环的调用<strong>wait</strong>；这样每个子进程都有一个“父进程”来清理。主要的实现挑战是父进程和子进程的<strong>wait</strong>和<strong>exit</strong>，以及<strong>exit</strong>和<strong>exit</strong>之间可能出现竞争和死锁的情况。</p><p><strong>Wait</strong>使用<em>调用进程</em> 的<strong>p-&gt;lock</strong>作为条件锁，以避免唤醒丢失，它在开始时获取该锁<strong>（kernel/proc.c:398）</strong>。然后它扫描进程表。如果它发现一个处于<strong>ZOMBIE</strong>状态的子进程，它释放这个子进程的资源和它的<strong>proc</strong>结构，将子进程的退出状态复制到提供给<strong>wait</strong>的地址(如果它不是0)，并返回子进程的ID。如果<strong>wait</strong>找到了子进程但没有一个退出，它调用<strong>sleep</strong>等待其中一个子进程退出<strong>(kernel/proc.c:445)</strong>，然后再次扫描。这里，在<strong>sleep</strong>中释放的条件锁是等待进程的<strong>p-&gt;lock</strong>，也就是上面提到的特殊情况。请注意，<strong>wait</strong>经常持有两个锁；它在试图获取任何子锁之前，会先获取自己的锁；因此xv6的所有锁都必须遵守相同的锁顺序（父进程的锁，然后是子进程的锁），以避免死锁。</p><p><strong>Wait</strong>会查看每个进程的<strong>np-&gt;parent</strong>来寻找它的子进程。它使用 <strong>np-&gt;parent</strong> 而不持有 <strong>np-&gt;lock</strong>，这违反了共享变量必须受锁保护的通常规则。但是<strong>np</strong>有可能是当前进程的祖先，在这种情况下，获取<strong>np-&gt;lock</strong>可能会导致死锁，因为这违反了上面提到的顺序。在这种情况下，在没有锁的情况下检查<strong>np-&gt;parent</strong>似乎是安全的；一个进程的父进程字段只有“父亲“改变，所以如果<strong>np-&gt;parent==p</strong>为真，除非当前进程改变它，否则该值就不会改变。</p><p><strong>Exit (kernel/proc.c:333)</strong>记录退出状态，释放一些资源，将所有子进程交给<strong>init</strong>进程，在父进程处于等待状态时唤醒它，将<em>调用进程</em>标记为<strong>zombie</strong>，并永久放弃CPU。最后的序列有点棘手。退出的进程必须持有父进程的锁，同时将自己状态设置为<strong>ZOMBIE</strong>并唤醒父进程，因为父进程的锁是条件锁，可以防止在等待中丢失<strong>wakeup</strong>。子进程也必须持有自己的<strong>p-&gt;lock</strong>，否则父进程可能会看到它的状态为<strong>ZOMBIE</strong>，并在它还在运行时释放它。锁的获取顺序对避免死锁很重要：因为<strong>wait</strong>在子锁之前获取父锁，所以<strong>exit</strong>必须使用相同的顺序。</p><p><strong>Exit</strong> 调用了一个专门的唤醒函数 <strong>wakeup1</strong>，它只唤醒父函数，而且只有父进程在<strong>wait</strong>中睡眠的情况下才会去唤醒它<strong>(kernel/proc.c:598)</strong>。在将自己的状态设置为<strong>ZOMBIE</strong>之前，唤醒父进程可能看起来并不正确，但这是安全的：尽管<strong>wakeup1</strong>可能会导致父进程运行，但<strong>wait</strong>中的循环不能检查子进程，直到子进程的<strong>p-&gt;lock</strong>被调度器释放为止，所以<strong>wait</strong>不能查看退出的进程，直到<strong>exit</strong>将其状态设置为<strong>ZOMBIE</strong>之后<strong>(kernel/proc.c:386)</strong>。</p><p><strong>exit</strong>允许一个进程自行终止，而<strong>kill（kernel/proc.c:611）</strong>则允许一个进程请求另一个进程终止。如果让<strong>kill</strong>直接摧毁进程，那就太复杂了，因为相应进程可能在另一个CPU上执行，也许正处于更新内核数据结构的敏感序列中。因此，kill的作用很小：它只是设置进程的<strong>p-&gt;killed</strong>，如果它在<strong>sleep</strong>，则<strong>wakeup</strong>它。最终，进程会进入或离开内核，这时如果<strong>p-&gt;killed</strong>被设置，<strong>usertrap</strong>中的代码会调用<strong>exit</strong>。如果进程在用户空间运行，它将很快通过进行系统调用或因为定时器（或其他设备）中断而进入内核。</p><p>如果进程处于睡眠状态，<strong>kill</strong>调用<strong>wakeup</strong>会使进程从睡眠中返回。这是潜在的危险，因为正在等待的条件可能不为真。然而，xv6对<strong>sleep</strong>的调用总是被包裹在一个<strong>while</strong>循环中，在<strong>sleep</strong>返回后重新检测条件。一些对<strong>sleep</strong>的调用也会在循环中检测<strong>p-&gt;killed</strong>，如果设置了<strong>p-&gt;killed</strong>，则离开当前活动。只有当这种离开是正确的时候才会这样做。例如，管道读写代码如果设置了<strong>killed</strong>标志就会返回；最终代码会返回到<strong>trap</strong>，<strong>trap</strong>会再次检查标志并退出。</p><p>一些xv6 <strong>sleep</strong>循环没有检查<strong>p-&gt;killed</strong>，因为代码处于多步骤系统调用的中间，而这个调用应该是原子的。virtio驱动<strong>(kernel/virtio_disk.c:242)</strong>就是一个例子：它没有检查<strong>p-&gt;killed</strong>，因为磁盘操作可能是一系列写操作中的一个，而这些写操作都是为了让文件系统处于一个正确的状态而需要的。一个在等待磁盘I/O时被杀死的进程不会退出，直到它完成当前的系统调用和<strong>usertrap</strong>看到<strong>killed</strong>的标志。</p><h3 id="7-9-Real-world"><a href="#7-9-Real-world" class="headerlink" title="7.9 Real world"></a>7.9 Real world</h3><p>xv6 调度器实现了一个简单的调度策略，它依次运行每个进程。这种策略被称为<strong><em>轮询调度(round robin)</em></strong>。真正的操作系统实现了更复杂的策略，例如，允许进程有优先级。这个策略是，一个可运行的高优先级进程将被调度器优先于一个可运行的低优先级进程。这些策略可能会很快变得复杂，因为经常有相互竞争的目标：例如，操作者可能还想保证公平性和高吞吐量。此外，复杂的策略可能会导致不尽人意的交互，如<strong><em>优先级倒置(priority inversion)</em></strong>和<strong><em>护航现象(convoys</em></strong>)。当低优先级和高优先级进程共享一个锁时，就会发生优先级倒置，当低优先级进程获得锁时，就会阻止高优先级进程的进展。当许多高优先级进程都在等待一个获得共享锁的低优先级进程时，就会形成一个长长的等待进程的车队；一旦护航现象形成，就会持续很长时间。为了避免这类问题，在复杂的调度器中需要额外的机制。</p><p><strong>sleep</strong>和<strong>wakeup</strong>是一种简单有效的同步方法，但还有很多其他的方法。在所有这些方法中，第一个挑战是避免我们在本章开头看到的丢失唤醒问题。最初的Unix内核的<strong>sleep</strong>只是禁用了中断，这已经足够了，因为Unix运行在单CPU系统上。因为xv6运行在多处理器上，所以它增加了一个显式的<strong>sleep</strong>锁。FreeBSD 的 <strong>msleep</strong> 采用了同样的方法。Plan 9的<strong>sleep</strong>使用了一个回调函数，它在进入睡眠前保持调度锁的情况下运行；这个函数的作用是在最后一刻检查<strong>sleep</strong>情况，以避免<strong>wakeup</strong>丢失。Linux内核的<strong>sleep</strong>使用一个显式的进程队列，称为等待队列，而不是等待通道；队列有自己的内部锁。</p><p>在<strong>wakeup</strong>过程中扫描整个进程链表，寻找相匹配的<strong>chan</strong>的进程，效率很低。一个更好的解决方案是用一个数据结构代替<strong>sleep</strong>和<strong>wakeup</strong>中的<strong>chan</strong>，该结构上存放着<strong>sleep</strong>的进程列表，比如Linux的等待队列。Plan 9的<strong>sleep</strong>和<strong>wakeup</strong>将该结构称为rendezvous point或Rendez。许多线程库将同一个结构称为条件变量；在这种情况下，sleep和wakeup的操作被称为<strong>wait</strong>和<strong>signal</strong>。所有这些机制都有相同的机制：睡眠条件被睡眠过程中原子地释放的锁保护。</p><p><strong>wakeup</strong>唤醒了所有在某个特定<strong>channel</strong>上等待的进程，可能很多进程都在等待这个特定<strong>channel</strong>。操作系统会调度所有这些进程，它们会争相检查睡眠条件。以这种方式行事的进程有时被称为<strong><em>惊群效应（thundering herd）</em></strong>，最好避免这种情况。大多数条件变量都有两个唤醒的基元：信号（signal），唤醒一个进程；广播（broadcast），唤醒所有等待的进程。</p><p>信号量通常用于同步。count通常对应于类似于管道缓冲区中可用的字节数或一个进程拥有的僵尸子进程的数量。使用显式计数作为抽象的一部分，可以避免丢失<strong>wakeup</strong>的问题：有一个显式的计数，说明已经发生的唤醒次数。该计数还避免了“虚假的”唤醒和<strong><em>惊群效应</em></strong>问题。</p><p>终止进程和清理进程在xv6中引入了很多复杂性。在大多数操作系统中，它甚至更加复杂，因为，假设被杀进程可能<strong>trap</strong>在内核中睡眠，而解除它的堆栈需要很多仔细的编程。许多操作系统使用显式的异常处理机制来解除堆栈，比如<strong>longjmp</strong><a href="#ftn3">[3]</a>。此外，还有其他一些事件可以导致一个睡眠进程被唤醒，即使它正在等待的事件还没有发生。例如，当一个Unix进程处于睡眠状态时，另一个进程可能会向它发送一个<strong>signal</strong>。在这种情况下，该进程将从中断的系统调用中返回，返回值为-1，错误代码设置为<strong>EINTR</strong>。应用程序可以检查这些值并决定做什么。Xv6不支持信号，也就不会出现这种复杂性。</p><p>Xv6对<strong>kill</strong>的支持并不完全令人满意：有些<strong>sleep</strong>循环可能应该检查<strong>p-&gt;killed</strong>。一个相关的问题是，即使是检查<strong>p-&gt;killed</strong>的<strong>sleep</strong>循环，在<strong>sleep</strong>和<strong>kill</strong>之间也会有一个竞争；<strong>kill</strong>可能会设置<strong>p-&gt;killed</strong>，并试图唤醒被杀进程，唤醒时刻发生在循环检查<strong>p-&gt;killed</strong>之后， 但在它调用<strong>sleep</strong>之前，就会发生。如果这个问题发生了，被杀进程不会注意到<strong>p-&gt;killed</strong>，直到它所等待的条件发生。这可能会晚很多（例如，当virtio驱动返回一个被杀进程正在等待的磁盘块时），也可能永远不会发生（例如，如果被杀进程正在等待来自控制台的输入，但用户没有键入任何输入）。</p><p>真正的操作系统会在常数时间内用显式的空闲列表来寻找空闲的进程，而不是在allocproc中进行线性时间的搜索；xv6为了简单起见，使用了线性扫描的方式。</p><h3 id="7-10-Exercises"><a href="#7-10-Exercises" class="headerlink" title="7.10 Exercises"></a>7.10 Exercises</h3><ol><li>Sleep必须检查lk != &amp; p-&gt;lock以避免死锁<strong>(kernel/proc.c:558-561)</strong>。假设一种特殊情况通过将</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">     acquire(&amp;p-&gt;lock);</span><br><span class="line">     release(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">release(lk);</span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br></pre></td></tr></table></figure><p>这样会破坏sleep吗，怎样破坏。</p><ol><li><p>大部分进程退出时，资源清理可以通过<strong>exit</strong>或<strong>wait</strong>来完成。事实证明，关闭打开的文件一定要在<strong>exit</strong>中进行。为什么？答案和管道有关。</p></li><li><p>在xv6中实现信号量而不使用<strong>sleep</strong>和<strong>wakeup</strong>(但可以使用<strong>spin</strong> <strong>locks</strong>)。在xv6中用信号量替换<strong>sleep</strong>和<strong>wakeup</strong>的使用。判断结果。</p></li><li><p>修正上面提到的<strong>kill</strong>和<strong>sleep</strong>之间的竞争，使得发生在被杀进程睡眠循环检查p-&gt;killed之后，在它调用sleep之前的kill会使得被杀进程放弃当前系统调用。</p></li><li><p>设计一个方案，让每一个睡眠循环都检查<strong>p-&gt;killed</strong>，这样，在<strong>virtio</strong>驱动中的进程如果被其他进程杀死，就可以从<strong>while</strong>循环中快速返回。</p></li><li><p>修改xv6，当从一个进程的内核线程切换到另一个进程时，只使用一次上下文切换，而不是先切换到调度线程，再切换到另一个进程。使用一次上下文切换，产生的线程需要自己选择下一个线程，并调用<strong>swtch</strong>。面临的挑战将是如何防止多个内核意外执行同一个线程；如何正确地进行锁定；以及如何避免死锁。</p></li><li><p>修改xv6的调度器，当没有进程可运行时，使用RISC-V <strong>WFI</strong>（等待中断）指令。尽量保证只要有可运行的进程等待运行，就不会有核心通过WFI进行暂停。</p></li><li><p>锁<strong>p-&gt;lock</strong>保护了很多不变式，当看到某段被<strong>p-&gt;lock</strong>保护的xv6代码时，可能很难弄清楚保护了那个不变式。通过将<strong>p-&gt;lock</strong>拆分成几个锁，设计一个更简洁的方案。</p></li></ol><hr><ol><li><p><a name="ftn1"></a>ra寄存器: 函数return地址。</p></li><li><p><a name="ftn2"></a>严格地说，只是在<strong>acquire</strong>之后<strong>wakeup</strong>就足够了(也就是说，可以在<strong>release</strong>之后调用<strong>wakeup</strong>)。</p></li><li><p><a name="ftn3"></a>一种异常处理方式，可以去google下。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第六章</title>
      <link href="/2022/08/31/xv6-Chapter-6/"/>
      <url>/2022/08/31/xv6-Chapter-6/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章：锁"><a href="#第六章：锁" class="headerlink" title="第六章：锁"></a>第六章：锁</h2><p>大多数内核，包括xv6，都会交错执行多个任务。一种实现交错执行任务的方式是多处理器架构：硬件系统具有多个CPU独立执行，如xv6的RISC-V。这些CPU共享物理RAM，xv6利用共享来维护所有CPU读写的数据结构。这种共享带来了一种可能性，即一个CPU读取一个数据结构，而另一个CPU正在中途更新它，甚至多个CPU同时更新同一个数据。如果不仔细设计，这种并行访问很可能产生不正确的结果或破坏数据结构。即使在单处理器上，内核也可能在多个线程之间切换CPU，导致它们的执行交错。最后，如果中断发生的时间不对，一个设备中断处理程序可能会修改与一些可中断代码相同的数据，从而破坏数据。并发一词指的是由于多处理器并行、线程切换或中断而导致多个指令流交错的情况。</p><p>内核中充满了并发访问的数据。例如，两个CPU可以同时调用<code>kalloc</code>，从而并发地从空闲内存链表的头部push。内核设计者喜欢允许大量的并发，因为它可以通过并行来提高性能，提高响应速度。然而，结果是内核设计者花了很多精力来让自己确认这些存在的并发是正确的。有很多方法可以写出正确的代码，有些方法比其他方法更简单。以并发下的正确性为目标的策略，以及支持这些策略的抽象，被称为并发控制技术。</p><p>根据不同的情况，xv6使用了很多并发控制技术，且还有更多的可能尚未被实现。本章重点介绍一种广泛使用的技术:锁（lock）。锁提供了互斥的功能，确保一次只有一个CPU可以持有一个特定的锁。如果程序员为每个共享数据项关联一个锁，并且代码在使用某项时总是持有关联的锁，那么该项每次只能由一个CPU使用。在这种情况下，我们说锁保护了数据项。虽然锁是一种简单易懂的并发控制机制，但其也带来了性能降低的缺点，因为锁将并发操作串行化了。</p><p>本章的其余部分解释了为什么xv6需要锁、xv6如何实现它们以及如何使用它们。</p><h3 id="6-1-竞争条件"><a href="#6-1-竞争条件" class="headerlink" title="6.1 竞争条件"></a>6.1 竞争条件</h3><p><img src="/img/Figure-6.1.png" alt="Figure-6.1"></p><p>作为我们为什么需要锁的一个例子，考虑两个进程在两个不同的CPU上调用<code>wait</code>，<code>wait</code>释放子进程的内存。因此，在每个CPU上，内核都会调用<code>kfree</code>来释放子进程的内存页。内核分配器维护了一个链表:<code>kalloc()</code>(kernel/kalloc.c:69)从空闲页链表中pop一页内存，<code>kfree()</code>(kernel/kalloc.c:47)将一页push空闲链表中。为了达到最好的性能，我们可能希望两个父进程的<code>kfree</code>能够并行执行，而不需要任何一个进程等待另一个进程，但是考虑到xv6的<code>kfree</code>实现，这是不正确的。</p><p>图6.1更详细地说明了这种设置：链表在两个CPU共享的内存中，CPU使用加载和存储指令操作链表。(在现实中，处理器有缓存，但在概念上，多处理器系统的行为就像有一个单一的共享内存一样)。如果没有并发请求，你可能会实现如下的链表push操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/Figure-6.2.png" alt="Figure-6.2"></p><p>如果单独执行，这个实现是正确的。但是，如果多个副本同时执行，代码就不正确。如果两个CPU同时执行<code>push</code>，那么两个CPU可能都会执行图6.1所示的第15行，然后其中一个才执行第16行，这就会产生一个不正确的结果，如图6.2所示。这样就会出现两个list元素，将next设为list的前值。当对list的两次赋值发生在第16行时，第二次赋值将覆盖第一次赋值;第一次赋值中涉及的元素将丢失。</p><p>第16行的丢失更新是竞争条件(race condition)的一个例子。竞争条件是指同时访问一个内存位置，并且至少有一次访问是写的情况。竞争通常是一个错误的标志，要么是丢失更新(如果访问是写)，要么是读取一个不完全更新的数据结构。竞争的结果取决于所涉及的两个CPU的确切时间，以及它们的内存操作如何被内存系统排序，这可能会使竞争引起的错误难以重现和调试。例如，在调试<code>push</code>时加入<code>print</code>语句可能会改变执行的时机，足以使竞争消失。</p><p>避免竞争的通常方法是使用锁。锁确保了相互排斥，因此一次只能有一个CPU执行<code>push</code>的哪一行;这就使得上面的情况不可能发生。上面代码的正确<code>lock</code>版本只增加了几行代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span>=</span><span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locklist</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span> <span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">    release(&amp;listlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code>和<code>release</code>之间的指令序列通常被称为临界区。这里的锁保护<code>list</code>。</p><p>当我们说锁保护数据时，我们真正的意思是<strong>锁保护了一些适用于数据的不变量(invariant)的集合</strong>。不变量是数据结构的属性，这些属性在不同的操作中得到维护。通常情况下，一个操作的正确行为取决于操作开始时的不变量是否为真。操作可能会暂时违反不变量，但在结束前必须重新建立不变量。例如，在链表中，不变性是：“list指向列表中的第一个元素，并且每个元素的下一个字段指向下一个元素”。push的实现暂时违反了这一不变性：在第17行，l指向下一个链表元素list，但list还没有指向l（在第18行重新建立）。我们上面所研究的竞争条件之所以会发生，是因为第二个CPU执行了依赖于列表不变式的代码，而它们被（暂时）违反了。正确使用锁可以确保每次只有一个CPU可以对关键部分的数据结构进行操作，因此当数据结构的不变式不成立时，没有CPU会执行数据结构操作。</p><p>你可以把锁看成是把并发的关键部分序列化，使它们一次只运行一个，从而保存不变性（假设关键部分孤立地正确）。你也可以认为由同一个锁保护的关键部分是相互原子的(atomic)，因此每个关键部分只看到来自更早的关键部分的完整变化，而永远不会看到部分完成的更新。</p><p>虽然正确使用锁可以使不正确的代码变得正确，但锁限制了性能。例如，如果两个进程同时调用kfree，锁会将两个调用序列化，我们在不同的CPU上运行它们不会获得任何好处。我们说，如果多个进程同时想要同一个锁，就会发生冲突，或者说锁经历了争夺。内核设计的一个主要挑战是避免锁的争夺。Xv6在这方面做得很少，但是复杂的内核会专门组织数据结构和算法来避免锁争用。在列表的例子中，一个内核可能会维护每个CPU的空闲列表，只有当CPU的列表是空的，并且它必须从另一个CPU偷取内存时，才会接触另一个CPU的空闲列表。其他用例可能需要更复杂的设计。</p><p>锁的位置对性能也很重要。例如，在<code>push</code>中把<code>acquisition</code>移动到较早的位置也是正确的：将<code>acquisition</code>的调用移动到第13行之前是可以的。然而，这可能会降低性能，因为这样的话，对<code>malloc</code>的调用也会被序列化。下面的“使用锁”一节提供了一些关于在哪里插入<code>acquisition</code>和<code>release</code>调用的指南。</p><h3 id="6-2-代码：锁"><a href="#6-2-代码：锁" class="headerlink" title="6.2 代码：锁"></a>6.2 代码：锁</h3><p>Xv6有两种类型的锁:自旋锁(spinlock)和睡眠锁(sleeplock)。我们先说说自旋锁。Xv6将自旋锁表示为一个结构体<code>spinlock</code>(kernel/spinlock.h:2)。该结构中重要的字段是<code>locked</code>，当锁可获得时，<code>locked</code>为零，当锁被持有时，<code>locked</code>为非零。从逻辑上讲，xv6获取锁的的代码类似于:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span><span class="comment">//doesnotwork!</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>)&#123;</span><br><span class="line">lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这种实现并不能保证多处理器上的相互排斥。可能会出现这样的情况:两个CPU同时到达if语句，看到<code>lk-&gt;locked</code>为零，然后都通过设置<code>lk-&gt;locked=1</code>来抢夺锁。此时，两个不同的CPU持有锁，这就违反了互斥属性。我们需要的是让第25行和第26行作为一个原子(即不可分割)步骤来执行。</p><p>由于锁被广泛使用，多核处理器通常提供了一些原子版的指令。在RISC-V上，这条指令是<code>amoswapr,a</code>。<code>amoswap</code>读取内存地址<code>a</code>处的值，将寄存器<code>r</code>的内容写入该地址，并将其读取的值放入<code>r</code>中，也就是说，它将寄存器的内容和内存地址进行了交换。它原子地执行这个序列，使用特殊的硬件来防止任何其他CPU使用读和写之间的内存地址。</p><p>Xv6的<code>acquire</code>(kernel/spinlock.c:22使用了可移植的C库调用<code>__sync_lock_test_and_set</code>，它本质上为<code>amoswap</code>指令;返回值是<code>lk-&gt;locked</code>的旧(被交换出来的)内容。<code>acquire</code>函数循环交换，重试(旋转)直到获取了锁。每一次迭代都会将1交换到<code>lk-&gt;locked</code>中，并检查之前的值;如果之前的值为0，那么我们已经获得了锁，并且交换将<code>lk-&gt;locked</code>设置为1。如果之前的值是1，那么其他CPU持有该锁，而我们原子地将1换成<code>lk-&gt;locked</code>并没有改变它的值。</p><p>一旦锁被获取，<code>acquire</code>就会记录获取该锁的CPU，这方便调试。<code>lk-&gt;cpu</code>字段受到锁的保护，只有在持有锁的时候才能改变。</p><p>函数<code>release</code>(kernel/spinlock.c:47)与<code>acquire</code>相反:它清除<code>lk-&gt;cpu</code>字段，然后释放锁。从概念上讲，释放只需要给<code>lk-&gt;locked</code>赋值为0。C标准允许编译器用多条存储指令来实现赋值，所以C赋值对于并发代码来说可能是非原子性的。相反，<code>release</code>使用C库函数<code>__sync_lock_release</code>执行原子赋值。这个函数也是使用了RISC-V的<code>amoswap</code>指令。</p><h3 id="6-3-代码：使用锁"><a href="#6-3-代码：使用锁" class="headerlink" title="6.3 代码：使用锁"></a>6.3 代码：使用锁</h3><p>Xv6在很多地方使用锁来避免竞赛条件。如上所述，<code>kalloc</code>(kernel/kalloc.c:69)和<code>kfree</code>(kernel/kalloc.c:47)就是一个很好的例子。试着练习1和2看看如果这些函数省略了锁会发生什么事情。你可能会发现，很难触发不正确的行为，这说明很难可靠地测试代码是否没有锁定错误和竞争。xv6有一些竞争也不是不可能的。</p><p>使用锁的一个难点是决定使用多少个锁，以及每个锁应该保护哪些数据和不变量。有几个基本原则。首先，任何时候，当一个CPU可以在另一个CPU读或写变量的同时写入变量时，都应该使用锁来防止这两个操作重叠。第二，记住锁保护不变量：如果一个不变量涉及多个内存位置，通常需要用一个锁保护所有的位置，以确保不变式得到维护。</p><p>上面的规则说了什么时候需要锁，但没有说什么时候不需要锁，为了效率，不要锁太多，因为锁会降低并行性。如果并行性不重要，那么可以安排只有一个进程，而不用担心锁的问题。一个简单的内核可以在多处理器上做到这一点，它有一个单一的锁，这个锁必须在进入内核时获得，并在退出内核时释放（尽管系统调用，如管道读取或等待会带来一个问题）。许多单处理器操作系统已经被改造成使用这种方法在多处理器上运行，有时被称为”大内核锁”，但这种方法牺牲了并行性：内核中一次只能执行一个CPU。如果内核做任何繁重的计算，那么使用一组更大的更细粒度的锁，这样内核可以同时在多个CPU上执行，效率会更高。</p><p>作为粗粒度锁的一个例子，xv6的kalloc.c分配器有一个单一的空闲列表，由一个单一的锁构成。如果不同CPU上的多个进程试图同时分配页面，那么每个进程都必须通过在<code>acquire</code>中旋转来等待轮到自己。旋转会降低性能，因为这不是有用的工作。如果争夺锁浪费了相当一部分CPU时间，也许可以通过改变分配器的设计来提高性能，使其拥有多个空闲列表，每个列表都有自己的锁，从而实现真正的并行分配。（该分配器在lockinglab中会被重写——译者注）</p><p>作为细粒度锁的一个例子，xv6为每个文件都有一个单独的锁，这样操作不同文件的进程往往可以不用等待对方的锁就可以进行。如果想让进程模拟写入同一文件的不同区域，文件锁方案可以做得更细。最终，锁的粒度决定需要由性能测量以及复杂性考虑来驱动。<br>在后续的章节解释xv6的每个部分时，会提到xv6使用锁来处理并发性的例子。作为预览，图6.3列出了xv6中所有的锁。</p><p><img src="/img/Figure-6.3.png" alt="Figure-6.3"></p><h3 id="6-4-死锁和锁的顺序"><a href="#6-4-死锁和锁的顺序" class="headerlink" title="6.4 死锁和锁的顺序"></a>6.4 死锁和锁的顺序</h3><p>如果一个穿过内核的代码路径必须同时持有多个锁，那么所有的代码路径以相同的顺序获取这些锁是很重要的。如果他们不这样做，就会有死锁的风险。假设线程T1执行代码path1并获取锁A，线程T2执行代码path2并获取锁B，接下来T1会尝试获取锁B，T2会尝试获取锁A，这两次获取都会无限期地阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回。为了避免这样的死锁，所有的代码路径必须以相同的顺序获取锁。对全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分:调用者调用函数的方式必须使锁按照约定的顺序被获取。</p><p>由于sleep的工作方式(见第7章)，xv6有许多长度为2的锁序链，涉及到进程锁(<code>structproc</code>中的锁)。例如，<code>consoleintr</code>(kernel/console.c:138)是处理格式化字符的中断流程。当一个新数据到达时，任何正在等待控制台（终端，即cmd）输入的进程都应该被唤醒。为此，<code>consoleintr</code>在调用<code>wakeup</code>时持有<code>cons.lock</code>，以获取进程锁来唤醒它。因此，全局避免死锁的锁顺序包括了<code>cons.lock</code>必须在任何进程锁之前获取的规则。文件系统代码包含xv6最长的锁链。例如，创建一个文件需要同时持有目录的锁、新文件的inode的锁、磁盘块缓冲区的锁、磁盘驱动器的<code>vdisk_lock</code>和调用进程的<code>p-&gt;lock</code>。为了避免死锁，文件系统代码总是按照上一句提到的顺序获取锁。</p><p>遵守全局避免死锁的顺序可能会非常困难。有时锁的顺序与逻辑程序结构相冲突，例如，也许代码模块M1调用模块M2，但锁的顺序要求M2中的锁在M1中的锁之前被获取。有时锁的身份并不是事先知道的，也许是因为必须持有一个锁才能发现接下来要获取的锁的身份。这种情况出现在文件系统中，因为它在路径名中查找连续的组件，也出现在<code>wait</code>和<code>exit</code>的代码中，因为它们搜索进程表寻找子进程。最后，死锁的危险往往制约着人们对锁方案的细化程度，因为更多的锁往往意味着更多的死锁机会。避免死锁是内核实现的重要需求。</p><h3 id="6-5-锁与中断处理"><a href="#6-5-锁与中断处理" class="headerlink" title="6.5 锁与中断处理"></a>6.5 锁与中断处理</h3><p>一些xv6自旋锁保护的数据会被线程和中断处理程序两者使用。例如，<code>clockintr</code>定时器中断处理程序可能会在内核线程读取<code>sys_sleep</code>(kernel/sysproc.c:64)中的<code>ticks</code>的同时，递增<code>ticks</code>(kernel/trap.c:163)。锁<code>tickslock</code>将保护两次临界区。</p><p>自旋锁和中断的相互作用带来了一个潜在的危险。假设<code>sys_sleep</code>持有<code>tickslock</code>，而它的CPU接收到一个时钟中断。<code>clockintr</code>会尝试获取<code>tickslock</code>，看到它被持有，并等待它被释放。在这种情况下，<code>tickslock</code>永远不会被释放：只有<code>sys_sleep</code>可以释放它，但<code>sys_sleep</code>不会继续运行，直到<code>clockintr</code>返回。所以CPU会死锁，任何需要其他锁的代码也会冻结。</p><p>为了避免这种情况，如果一个中断处理程序使用了自旋锁，CPU决不能在启用中断的情况下持有该锁。Xv6则采用了更加保守的策略：当一个CPU获取任何锁时，xv6总是禁用该CPU上的中断。中断仍然可能发生在其他CPU上，所以一个中断程序获取锁会等待一个线程释放自旋锁，但它们不在同一个CPU上。</p><p>xv6在CPU没有持有自旋锁时重新启用中断;它必须做一点记录来应对嵌套的临界区。<code>acquire</code>调用<code>push_off</code>(kernel/spinlock.c:89)和<code>release</code>调用<code>pop_off</code>(kernel/spinlock.c:100)来跟踪当前CPU上锁的嵌套级别。当该计数达到零时，<code>pop_off</code>会恢复最外层临界区开始时的中断启用状态。<code>intr_off</code>和<code>intr_on</code>函数分别执行RISC-V指令来禁用和启用中断。</p><p>在设置<code>lk-&gt;locked</code>之前，严格调用<code>push_off</code>是很重要的(kernel/spinlock.c:28)。如果两者反过来，那么在启用中断的情况下，锁会有一个窗口(未锁到的位置)，在未禁止中断时持有锁。在这种情况下，一个时机恰到好处的时钟中断会使系统死锁。同样，释放锁后才调用<code>pop_off</code>也很重要(kernel/spinlock.c:66)。</p><h3 id="6-6-指令与存储的顺序"><a href="#6-6-指令与存储的顺序" class="headerlink" title="6.6 指令与存储的顺序"></a>6.6 指令与存储的顺序</h3><p>人们很自然地认为程序是按照源代码语句出现的顺序来执行的。然而，许多编译器和CPU为了获得更高的性能，会不按顺序执行代码。如果一条指令需要很多周期才能完成，CPU可能会提前发出该指令，以便与其他指令重叠，避免CPU停顿。例如，CPU可能会注意到在一个串行序列中，指令A和B互不依赖。CPU可能先启动指令B，这是因为它的输入在A的输入之前已经准备好了，或者是为了使A和B的执行重叠。编译器可以执行类似的重新排序，在一条语句的指令之前发出另一条语句的指令，由于它们原来的顺序。</p><p>编译器和CPU在对指令重新排序时遵循相应规则，以确保它们不会改变正确编写的串行代码的结果。然而，这些规则确实允许重排，从而改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的指令排序规则规则称为内存模型(memory model)。</p><p>例如，在这段<code>push</code>的代码中，如果编译器或CPU将第4行对应的存储移到第6行释放后的某个点，那将是一场灾难。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release(&amp;listlock);</span><br></pre></td></tr></table></figure><p>如果发生这样的重排，就会有一个指令执行的窗口。在这个窗口中，另一个CPU可以获取锁并观察更新的链表，但看到的是一个未初始化的<code>list-&gt;next</code>。</p><p>为了告诉硬件和编译器不要执行这样的re-ordering，xv6在<code>acquire</code>(kernel/spinlock.c:22)和<code>release</code>(kernel/spinlock.c:47)中都使用了<code>__sync_synchronize()</code>。<code>__sync_synchronize</code>()是一个内存屏障(memory barrier):它告诉编译器和CPU不要在越过屏障重新排列任何的内存读写操作。<code>acquire</code>和<code>release</code>中的屏障几乎在所有重要的情况下都会强制锁定顺序，因为xv6在访问共享数据的周围使用锁。第9章讨论了一些例外情况。</p><h3 id="6-7-睡眠锁"><a href="#6-7-睡眠锁" class="headerlink" title="6.7 睡眠锁"></a>6.7 睡眠锁</h3><p>有时xv6需要长时间保持一个锁。例如，文件系统（第8章）在磁盘上读写文件内容时，会保持一个文件的锁定，这些磁盘操作可能需要几十毫秒。如果另一个进程想获取一个自旋锁，那么保持那么长的时间会导致浪费，因为第二个进程在等待锁的同时会浪费CPU很长时间。自旋锁的另一个缺点是，一个进程在保留自旋锁的同时不能释放CPU并将自身转变为就绪态；我们希望做到这一点，以便在拥有自旋锁的进程等待磁盘时，其他进程可以使用CPU。在持有自旋锁时释放CPU是非法的，因为如果第二个线程再试图获取自旋锁，可能会导致死锁；由于<code>acquire</code>并不能释放CPU，第二个进程的等待可能会阻止第一个进程运行和释放锁。在持有锁的同时释放CPU也会违反在持有自旋锁时中断必须关闭的要求。因此，我们希望有一种锁，在等待获取的同时让CPU可以进行别的工作，并在锁被持有时允许释放CPU，同时开放中断。</p><p>Xv6以睡眠锁(sleeplock)的形式提供了这样的锁。<code>acquiresleep</code>(kernel/sleeplock.c:22)在等待时产生CPU，使用的技术将在第7章解释。在高层次上，睡眠锁有一个由<code>spinlock</code>保护的锁定字段，<code>acquiresleep</code>调用<code>sleep</code>原子性地让渡CPU并释放<code>spinlock</code>。结果就是，在<code>acquireleep</code>等待的时候，其他线程可以执行。</p><p>因为睡眠锁使中断处于启用状态，所以它们不能用于中断处理程序中。由于<code>acquiresleep</code>可能会释放CPU，所以睡眠锁不能在自旋锁的核心代码中使用（尽管自旋锁可以在睡眠锁的核心代码中使用）。</p><p>自旋锁最适合于短的关键部分，因为等待它们会浪费CPU时间；睡眠锁对长的操作很有效。</p><h3 id="6-8-现实世界"><a href="#6-8-现实世界" class="headerlink" title="6.8 现实世界"></a>6.8 现实世界</h3><p>尽管对并发基元和并行进行了多年的研究，但使用锁进行编程仍然具有挑战性。通常最好是将锁隐藏在更高级别的构造中，比如同步队列，尽管xv6没有这样做。如果您使用锁编程，明智的做法是使用一个试图识别竞争条件的工具，因为很容易错过一个需要锁的不变式。</p><p>大多数操作系统都支持POSIX线程（Pthreads），它允许一个用户进程在不同的CPU上有多个线程同时运行。Pthreads对用户级锁、屏障等都有支持。支持Pthreads需要操作系统的支持。例如，应该是如果一个pthread在系统调用中阻塞，同一进程的另一个pthread应该可以在该CPU上运行。又比如，如果一个pthread改变了它的进程的地址空间（比如映射或取消映射内存），内核必须安排运行同一进程线程的其他CPU更新它们的硬件页表以反映地址空间的变化。</p><p>可以在没有原子指令的情况下实现锁，但成本很高，大多数操作系统都使用原子指令。</p><p>如果许多CPU试图同时获取同一个锁，那么锁的成本会很高。如果一个CPU的本地缓存中有一个锁，而另一个CPU必须获取该锁，那么更新持有该锁的缓存行的原子指令必须将该行从一个CPU的缓存中移到另一个CPU的缓存中，并且可能使缓存行的任何其他副本无效。从另一个CPU的缓存中获取缓存单元的代价可能比从本地缓存中获取行的代价高出一个数量级。</p><p>为了避免与锁相关的代价，许多操作系统使用无锁数据结构和算法。例如，可以实现像本章开头那样的链接列表，在列表搜索过程中不需要锁，只需要一条原子指令就可以在列表中插入一个项目。不过，无锁编程比有锁编程更复杂，例如，必须担心指令和内存的重新排序问题。用锁编程已经很难了，所以xv6避免了无锁编程的额外复杂性。</p><h3 id="6-9-习题"><a href="#6-9-习题" class="headerlink" title="6.9 习题"></a>6.9 习题</h3><ol><li>删去<code>kalloc</code>(kernel/kalloc.c:69)中对acquire和release的调用。这似乎会给调用kalloc的内核代码带来问题。你觉得会发生什么？当你运行xv6时，和你想的一样吗？运行<code>usertests</code>的时候呢？如果你没有看到问题，为什么没有呢？看看你是否可以通过在kalloc的关键部分插入dummy loops来引发问题。</li><li>假设你在<code>kfree</code>中注释了锁(在恢复<code>kalloc</code>的锁之后)。现在可能出了什么问题？<code>kfree</code>中缺少锁是否比kalloc中缺少锁的危害小？</li><li>如果两个CPU同时调用<code>kalloc</code>，其中一个就要等待另一个，这对性能不利。修改<code>kalloc.c</code>，使其具有更多的并行性，这样不同CPU对<code>kalloc</code>的同时调用就可以进行，而不需要等待对方。</li><li>使用大多数操作系统都支持的POSIX线程(Pthreads)编写一个并行程序。例如，实现一个并行哈希表，并测量put/get操作的数量是否随着核心数的增加而增加。</li><li>在xv6中实现Pthreads的一个子集。即实现用户级线程库，使一个用户进程可以有1个以上的线程，并安排这些线程可以在不同的CPU上并行运行。提出一个设计，正确处理线程进行阻塞系统调用和改变其共享地址空间的问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第五章</title>
      <link href="/2022/08/31/xv6-Chapter-5/"/>
      <url>/2022/08/31/xv6-Chapter-5/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章：中断和设备驱动"><a href="#第五章：中断和设备驱动" class="headerlink" title="第五章：中断和设备驱动"></a>第五章：中断和设备驱动</h2><p><strong><em>驱动</em></strong>是操作系统中管理特定设备的代码，它有如下功能：1、配置设备相关的硬件，2、告诉设备需要怎样执行，3、处理设备产生的中断，4、与等待设备I/O的进程进行交互。驱动程序的代码写起来可能很棘手，因为驱动程序与它所管理的设备会并发。此外，驱动必须了解设备的硬件接口，但硬件接口可能是很复杂的，而且文档不够完善。</p><p>需要操作系统关注的设备通常可以被配置为产生中断，这是trap的一种类型。内核trap处理代码可以知道设备何时引发了中断，并调用驱动的中断处理程序；在xv6中，这个处理发生在<strong>devintr</strong>(kernel/trap.c:177)中。</p><p>许多设备驱动程序在两个context中执行代码：上半部分（<strong><em>top half</em></strong>）在进程的内核线程中运行，下半部分（<strong><em>bottom half</em></strong>）在中断时执行。上半部分是通过系统调用，如希望执行I/O的 read和write。这段代码可能会要求硬件开始一个操作（比如要求磁盘读取一个块）；然后代码等待操作完成。最终设备完成操作并引发一个中断。驱动程序的中断处理程序，作为<strong>下半部分</strong>，找出什么操作已经完成，如果合适的话，唤醒一个等待该操作的进程，并告诉硬件执行下一个操作。</p><h3 id="5-1-Code-Console-input"><a href="#5-1-Code-Console-input" class="headerlink" title="5.1 Code: Console input"></a>5.1 Code: Console input</h3><p>​    控制台驱动(console.c)是驱动结构的一个简单说明。控制台驱动通过连接到RISC-V上的UART串行端口硬件，接受输入的字符。控制台驱动程序每次累计一行输入，处理特殊的输入字符，如退格键和control-u。用户进程，如shell，使用<strong>read</strong>系统调用从控制台获取输入行。当你在QEMU中向xv6输入时，你的按键会通过QEMU的模拟UART硬件传递给xv6。</p><p>与驱动交互的UART硬件是由QEMU仿真的16550芯片[11]。在真实的计算机上，16550将管理一个连接到终端或其他计算机的RS232串行链接。当运行QEMU时，它连接到你的键盘和显示器上。</p><p>UART硬件在软件看来是一组<strong>内存映射</strong>的控制寄存器。也就是说，有一些RISC-V硬件的物理内存地址会关联到UART设备，因此加载和存储与设备硬件而不是RAM交互。UART的内存映射地址从0x10000000开始，即<strong>UART0</strong>（kernel/memlayout.h:21）。这里有一些UART控制寄存器，每个寄存器的宽度是一个字节。它们与UART0的偏移量定义在(kernel/uart.c:22)。例如，<strong>LSR</strong>寄存器中一些位表示是否有输入字符在等待软件读取。这些字符（如果有的话）可以从<strong>RHR</strong>寄存器中读取。每次读取一个字符，UART硬件就会将其从内部等待字符的FIFO中删除，并在FIFO为空时清除<strong>LSR</strong>中的就绪位。UART传输硬件在很大程度上是独立于接收硬件的，如果软件向<strong>THR</strong>写入一个字节，UART就会发送该字节。</p><p>Xv6的<strong>main</strong>调用<strong>consoleinit</strong>（kernel/console.c:184）来初始化UART硬件。这段代码配置了UART，当UART接收到一个字节的输入时，就产生一个接收中断，当UART每次完成发送一个字节的输出时，产生一个<strong><em>传输完成(transmit complete)</em></strong>中断(kernel/uart.c:53)。</p><p>xv6 shell通过<strong>init.c</strong>(user/init.c:19)打开的文件描述符从控制台读取。对<strong>read</strong>的系统调用通过内核到达<strong>consoleread</strong>（kernel/console.c:82） 。<strong>consoleread</strong>等待输入的到来(通过中断)，输入会被缓冲在<strong>cons.buf</strong>，然后将输入复制到用户空间，再然后(在一整行到达后)返回到用户进程。如果用户还没有输入完整的行，任何调用了<strong>read</strong>进程将在<strong>sleep</strong>中等待(kernel/console.c:98)(第7章解释了sleep的细节)。</p><p>当用户键入一个字符时，UART硬件向RISC-V抛出一个中断，从而激活xv6的<strong>trap</strong>处理程序。trap处理程序调用devintr(kernel/trap.c:177)，它查看RISC-V的<strong>scause</strong>寄存器，发现中断来自一个外部设备。然后它向一个叫做PLIC[1]的硬件单元询问哪个设备中断了(kernel/trap.c:186)。如果是UART，<strong>devintr</strong>调用<strong>uartintr</strong>。</p><p><strong>uartintr</strong> (kernel/uart.c:180) 从<strong>UART</strong>硬件中读取在等待的输入字符，并将它们交给<strong>consoleintr</strong> (kernel/console.c:138)；它不会等待输入字符，因为以后的输入会引发一个新的中断。<strong>consoleintr</strong>的工作是将中输入字符积累<strong>cons.buf</strong>中，直到有一行字符。 <strong>consoleintr</strong>会特别处理退格键和其他一些字符。当一个新行到达时，<strong>consoleintr</strong>会唤醒一个等待的<strong>consoleread</strong>（如果有的话）。</p><p>一旦被唤醒，<strong>consoleread</strong>将会注意到<strong>cons.buf</strong>中的完整行，并将其将其复制到用户空间，并返回（通过系统调用机制）到用户空间。</p><h3 id="5-2-Code-Console-output"><a href="#5-2-Code-Console-output" class="headerlink" title="5.2 Code: Console output"></a>5.2 Code: Console output</h3><p>​    向控制台写数据的<strong>write</strong>系统调用最终会到达<strong>uartputc</strong>(kernel/uart.c:87)。设备驱动维护了一个输出缓冲区(<strong>uart_tx_buf</strong>)，这样写进程就不需要等待UART完成发送；相反，<strong>uartputc</strong>将每个字符追加到缓冲区，调用<strong>uartstart</strong>来启动设备发送(如果还没有的话)，然后返回。<strong>Uartputc</strong>只有在缓冲区满的时候才会等待。</p><p>​    每次UART发送完成一个字节，它都会产生一个中断。<strong>uartintr</strong>调用<strong>uartstart</strong>，<strong>uartintr</strong>检查设备是否真的发送完毕，并将下一个缓冲输出字符交给设备，每当UART发送完一个字节，就会产生一个中断。因此，如果一个进程向控制台写入多个字节，通常第一个字节将由uartputc s调用uartstart发送，其余的缓冲字节将由uartintr调用uartstart发送，因为发送完成中断到来。</p><p><strong>uartintr</strong>调用<strong>uartstart</strong>，<strong>uartintr</strong>查看设备是否真的发送完成，并将下一个缓冲输出字符交给设备，每当UART发送完一个字节，就会产生一个中断。因此，如果一个进程向控制台写入多个字节，通常第一个字节将由<strong>uartputc</strong>对<strong>uartstart</strong>的调用发送，其余的缓冲字节将随着发送完成中断的到来由<strong>uartintr</strong>的<strong>uartstart</strong>调用发送。</p><p>有一个通用模式需要注意，设备活动和进程活动需要解耦，这将通过缓冲和中断来实现。控制台驱动程序可以处理输入，即使没有进程等待读取它；随后的读取将看到输入。同样，进程可以发送输出字节，而不必等待设备。这种解耦可以通过允许进程与设备I/O并发执行来提高性能，当设备速度很慢（如UART）或需要立即关注（如回显键入的字节）时，这种解耦尤为重要。这个idea有时被称为<strong><em>I/O并发</em></strong>。</p><h3 id="5-3-Concurrency-in-drivers"><a href="#5-3-Concurrency-in-drivers" class="headerlink" title="5.3 Concurrency in drivers"></a>5.3 Concurrency in drivers</h3><p>你可能已经注意到在<strong>consoleread</strong>和<strong>consoleintr</strong>中会调用<strong>acquire</strong>。<strong>acquire</strong>调用会获取一个锁，保护控制台驱动的数据结构不被并发访问。这里有三个并发风险：不同CPU上的两个进程可能会同时调用<strong>consoleread</strong>；硬件可能会在一个CPU正在执行consoleread时，向该CPU抛出一个控制台（实际上是UART）中断；硬件可能会在consoleread执行时向另一个CPU抛出一个控制台中断。第6章探讨锁如何在这些情况下提供帮助。</p><p>需要关注驱动并发安全的另一个原因是，一个进程可能正在等待来自设备的输入，但是当表明输入到来的中断发生时该进程已经没有在运行（被切换）。因此，中断处理程序不允许知道被中断的进程或代码。例如，一个中断处理程序不能安全地用当前进程的页表调用<strong>copyout</strong>。中断处理程序通常只做相对较少的工作（例如，只是将输入数据复制到缓冲区），并唤醒<strong><em>上半部分</em></strong>代码来做剩下的工作。</p><h3 id="5-4-Timer-interrupts"><a href="#5-4-Timer-interrupts" class="headerlink" title="5.4 Timer interrupts"></a>5.4 Timer interrupts</h3><p>Xv6使用定时器中断来维护它的时钟，并使它能够切换计算密集型进程；<strong>usertrap</strong>和<strong>kerneltrap</strong>中的<strong>yield</strong>调用会导致这种切换。每个RISC-V CPU的时钟硬件都会抛出时钟中断。Xv6对这个时钟硬件进行编程，使其定期周期性地中断相应的CPU。</p><p>RISC-V要求在机器模式下处理定时器中断，而不是监督者模式。RISCV机器模式执行时没有分页，并且有一套单独的控制寄存器，因此在机器模式下运行普通的xv6内核代码是不实用的。因此，xv6对定时器中断的处理与上面谈到的trap机制完全分离了。</p><p>在main执行之前的<strong>start.c</strong>，是在机器模式下执行的。它设置了接收定时器中断(kernel/start.c:57)。一部分工作是对<strong>CLINT</strong>硬件（<strong>core-local interruptor</strong>）进行编程，使其每隔一定时间产生一次中断。另一部分是设置一个类似于<strong>trapframe</strong>的暂存区，帮助定时器中断处理程序保存寄存器和<strong>CLINT</strong>寄存器的地址。最后，<strong>start</strong>将<strong>mtvec</strong>设置为<strong>timervec</strong>，启用定时器中断。</p><p>定时器中断可能发生在用户或内核代码执行的任何时候；内核没有办法在关键操作中禁用定时器中断。因此，定时器中断处理程序必须以保证不干扰被中断的内核代码的方式进行工作。基本策略是处理程序要求RISC-V引发一个软件中断并立即返回。RISC-V用普通的trap机制将软件中断传递给内核，并允许内核禁用它们。处理定时器中断产生的软件中断的代码可以在<strong>devintr</strong>（kernel/trap.c:204）中看到。</p><p>机器模式的定时器中断向量是<strong>timervec</strong>(kernel/kernelvec.S:93)。它在<strong>start</strong>准备的暂存区保存一些寄存器，告诉<strong>CLINT</strong>何时产生下一个定时器中断，使RISC-V产生一个软件中断，恢复寄存器，然后返回。在定时器中断处理程序中没有C代码。</p><h3 id="5-5-Real-world"><a href="#5-5-Real-world" class="headerlink" title="5.5 Real world"></a>5.5 Real world</h3><p>Xv6允许在内核和用户程序执行时使用设备和定时器中断。定时器中断可以强制从定时器中断处理程序进行线程切换（调用<strong>yield</strong>），即使是在内核中执行。如果内核线程有时会花费大量的时间进行计算，而不返回用户空间，那么在内核线程之间公平地对CPU进行时间划分的能力是很有用的。然而，内核代码需要注意它可能会被暂停（由于定时器中断），然后在不同的CPU上恢复，这是xv6中一些复杂的根源。如果设备和定时器中断只发生在执行用户代码时，内核可以变得更简单一些。</p><p>在一台典型的计算机上支持所有设备的全貌是一件很辛苦的事情，因为设备很多，设备有很多功能，设备和驱动程序之间的协议可能很复杂，而且文档也不完善。在许多操作系统中，驱动程序所占的代码比核心内核还多。</p><p>UART驱动器通过读取UART控制寄存器，一次读取一个字节的数据；这种模式被称为编程I/O，因为软件在控制数据移动。程序化I/O简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用<strong><em>直接内存访问(direct memory access, DMA)</em></strong>。DMA设备硬件直接将传入数据写入RAM，并从RAM中读取传出数据。现代磁盘和网络设备都使用DMA。DMA设备的驱动程序会在RAM中准备数据，然后使用对控制寄存器的一次写入来告诉设备处理准备好的数据。</p><p>当设备在不可预知的时间需要关注,且不那么频繁时，中断是很有用的。但中断对CPU的开销很大。因此，高速设备，如网络和磁盘控制器，使用了减少对中断需求的技巧。其中一个技巧是对整批传入或传出的请求提出一个单一的中断。另一个技巧是让驱动程序完全禁用中断，并定期检查设备是否需要关注。这种技术称为<strong><em>轮询（polling）</em></strong>。如果设备执行操作的速度非常快，轮询是有意义的，但如果设备大部分时间处于空闲状态，则会浪费CPU时间。一些驱动程序会根据当前设备的负载情况，在轮询和中断之间动态切换。</p><p>UART驱动首先将输入的数据复制到内核的缓冲区，然后再复制到用户空间。这在低数据速率下是有意义的，但对于那些快速生成或消耗数据的设备来说，这样的双重拷贝会大大降低性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用DMA。</p><h3 id="5-6-Exercises"><a href="#5-6-Exercises" class="headerlink" title="5.6 Exercises"></a>5.6 Exercises</h3><ol><li><p>修改uart.c，使其完全不使用中断。你可能还需要修改 console.c。</p></li><li><p>添加一个网卡驱动。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第四章</title>
      <link href="/2022/08/31/xv6-Chapter-4/"/>
      <url>/2022/08/31/xv6-Chapter-4/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章：陷阱和系统调用"><a href="#第四章：陷阱和系统调用" class="headerlink" title="第四章：陷阱和系统调用"></a>第四章：陷阱和系统调用</h2><p>有三种事件会导致CPU搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码。一种情况是<strong><em>系统调用</em></strong>，当用户程序执行<strong>ecall</strong>指令要求内核为其做某事时。另一种情况是<strong><em>异常</em></strong>：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址。第三种情况是设备<strong><em>中断</em></strong>，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。</p><p>本书使用<strong><em>trap</em></strong>作为这些情况的通用术语。通常，代码在执行时发生trap，之后都会被恢复，而且不需要意识到发生了什么特殊的事情。也就是说，我们通常希望trap是透明的；这一点对于中断来说尤其重要，被中断的代码通常不会意识到会发生trap。通常的顺序是：trap迫使控制权转移到内核；内核保存寄存器和其他状态，以便恢复执行；内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复保存的状态，并从trap中返回；代码从原来的地方恢复执行。</p><p>xv6内核会处理所有的trap。这对于系统调用来说是很自然的。这对中断来说也是合理的，因为隔离要求用户进程不能直接使用设备，而且只有内核才有设备处理所需的状态。这对异常处理来说也是合理的，因为xv6响应所有来自用户空间的异常，并杀死该违规程序。</p><p>Xv6 trap 处理分为四个阶段：RISC-V CPU采取的硬件行为，为内核C代码准备的汇编入口，处理trap的C 处理程序，以及系统调用或设备驱动服务。虽然三种trap类型之间的共性表明，内核可以用单一的代码入口处理所有的trap，但事实证明，为三种不同的情况，即来自用户空间的trap、来自内核空间的trap和定时器中断，设置单独的汇编入口和C trap处理程序会更方便的。</p><h3 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h3><p>每个RISC-V CPU都有一组控制寄存器，内核写入这些寄存器来告诉CPU如何处理trap，内核可以通过读取这些寄存器来发现已经发生的trap。RISC-V文档包含了完整的叙述[1]。riscv.h（kernel/riscv.h:1）包含了xv6使用的定义。这里是最重要的寄存器的概述。</p><ul><li><p><code>stvec</code>：内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。</p></li><li><p><code>sepc</code>：当trap发生时，RISC-V会将程序计数器保存在这里（因为<code>PC</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从trap中返回）指令将<code>sepc</code>复制到<code>pc</code>中。内核可以写<code>sepc</code>来控制<code>sret</code>的返回到哪里。</p></li><li><p><code>scause</code>：RISC -V在这里放了一个数字，描述了trap的原因。</p></li><li><p><code>sscratch</code>：内核在这里放置了一个值，在trap处理程序开始时可以方便地使用。</p></li><li><p><code>sstatus</code>：<code>sstatus</code>中的<strong>SIE</strong>位控制设备中断是否被启用，如果内核清除<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核设置<strong>SIE</strong>。<strong>SPP</strong>位表示trap是来自用户模式还是supervisor模式，并控制<code>sret</code>返回到什么模式。</p><p>上述寄存器与在特权态模式下处理的trap有关，在用户模式下不能读或写。对于机器模式下处理的trap，有一组等效的控制寄存器；xv6只在定时器中断的特殊情况下使用它们。</p></li></ul><p>多核芯片上的每个CPU都有自己的一组这些寄存器，而且在任何时候都可能有多个CPU在处理一个trap。</p><p>当需要执行trap时，RISC-V硬件对所有的trap类型（除定时器中断外）进行以下操作：</p><ol><li>如果该trap是设备中断，且<code>sstatus</code> <strong>SIE</strong>位为0，则不执行以下任何操作。</li><li>通过清除SIE来禁用中断。</li><li>复制<code>pc</code>到<code>sepc</code>。</li><li>将当前模式（用户态或特权态）保存在<code>sstatus</code>的<strong>SPP</strong>位。</li><li>在<code>scause</code>设置该次trap的原因。</li><li>将模式转换为特权态。</li><li>将<code>stvec</code>复制到<code>pc</code>。</li><li>从新的<code>pc</code>开始执行。</li></ol><p>注意，CPU不会切换到内核页表，不会切换到内核中的栈，也不会保存pc以外的任何寄存器。内核软件必须执行这些任务。CPU在trap期间做很少的工作的一个原因是为了给软件提供灵活性，例如，一些操作系统在某些情况下不需要页表切换，这可以提高性能。</p><p>你可能会想CPU的trap处理流程是否可以进一步简化。例如，假设CPU没有切换程序计数器（pc）。那么trap可以切换到监督者模式时，还在运行用户指令。这些用户指令可以打破用户空间/内核空间的隔离，例如通过修改<code>satp</code>寄存器指向一个允许访问所有物理内存的页表。因此，CPU必须切换到内核指定的指令地址，即<code>stvec</code>。</p><h3 id="4-2-Traps-from-user-space"><a href="#4-2-Traps-from-user-space" class="headerlink" title="4.2 Traps from user space"></a>4.2 Traps from user space</h3><p>在用户空间执行时，如果用户程序进行了系统调用（<code>ecall</code>指令），或者做了一些非法的事情，或者设备中断，都可能发生trap。来自用户空间的trap的处理路径是<code>uservec</code>（kernel/trampoline.S:16），然后是<code>usertrap</code>（kernel/trap.c:37）；返回时是<code>usertrapret</code>（kernel/trap.c:90），然后是<code>userret</code>（kernel/trampoline.S:16）。</p><p>来自用户代码的trap比来自内核的trap更具挑战性，因为<code>satp</code>指向的用户页表并不映射内核，而且栈指针可能包含一个无效甚至恶意的值。</p><p>因为RISC-V硬件在trap过程中不切换页表，所以用户页表必须包含<code>uservec</code>的映射，即<code>stvec</code>指向的trap处理程序地址。<code>uservec</code>必须切换<code>satp</code>，使其指向内核页表；为了在切换后继续执行指令，<code>uservec</code>必须被映射到内核页表与用户页表相同的地址。</p><p>Xv6用一个包含<code>uservec</code>的trampoline页来满足这些条件。Xv6在内核页表和每个用户页表中的同一个虚拟地址上映射了trampoline页。这个虚拟地址就是<code>TRAMPOLINE</code>（如我们在图2.3和图3.3中看到的）。<code>trampoline.S</code>中包含trampoline的内容，（执行用户代码时）<code>stvec</code>设置为<code>uservec</code>（kernel/trampoline.S:16）。</p><p>当<code>uservec</code>启动时，所有32个寄存器都包含被中断的代码所拥有的值。但是<code>uservec</code>需要能够修改一些寄存器，以便设置<code>satp</code>和生成保存寄存器的地址。RISC-V通过<code>sscratch</code>寄存器提供了帮助。<code>uservec</code>开始时的<code>csrrw</code>指令将<code>a0</code>和<code>sscratch</code>的内容互换。现在用户代码的<code>a0</code>被保存了；<code>uservec</code>有一个寄存器（<code>a0</code>）可以使用；<code>a0</code>包含了内核之前放在<code>sscratch</code>中的值。</p><p><code>uservec</code>的下一个任务是保存用户寄存器。在进入用户空间之前，内核先设置<code>sscratch</code>指向该进程的<code>trapframe</code>，这个<code>trapframe</code>可以保存所有用户寄存器（kernel/proc.h:44）。因为<code>satp</code>仍然是指用户页表，所以<code>uservec</code>需要将<code>trapframe</code>映射到用户地址空间中。当创建每个进程时，xv6为进程的<code>trapframe</code>分配一页内存，并将它映射在用户虚拟地址<code>TRAPFRAME</code>，也就是<code>TRAMPOLINE</code>的下面。进程的<code>p-&gt;trapframe</code>也指向<code>trapframe</code>，不过是指向它的物理地址<a href="#_ftn1">[1]</a>，这样内核可以通过内核页表来使用它。</p><p>因此，在交换<code>a0</code>和<code>sscratch</code>后，<code>a0</code>将指向当前进程的<code>trapframe</code>。<code>uservec</code>将在<code>trapframe</code>保存全部的寄存器，包括从<code>sscratch</code>读取的<code>a0</code>。</p><p><code>trapframe</code>包含指向当前进程的内核栈、当前CPU的hartid、<code>usertrap</code>的地址和内核页表的地址的指针，<code>uservec</code>将这些值设置到相应的寄存器中，并将<code>satp</code>切换到内核页表和刷新TLB，然后调用<code>usertrap</code>。</p><p><code>usertrap</code>的作用是确定trap的原因，处理它，然后返回（kernel/ trap.c:37）。如上所述，它首先改变<code>stvec</code>，这样在内核中发生的trap将由<code>kernelvec</code>处理。它保存了<code>sepc</code>（用户PC），这也是因为<code>usertrap</code>中可能会有一个进程切换，导致<code>sepc</code>被覆盖。如果trap是系统调用，<code>syscall</code>会处理它；如果是设备中断，<code>devintr</code>会处理；否则就是异常，内核会杀死故障进程。<code>usertrap</code>会把用户<code>pc</code>加4，因为RISC-V在执行系统调用时，会留下指向<code>ecall</code>指令的程序指针<a href="#ftn2">[2]</a>。在退出时，<code>usertrap</code>检查进程是否已经被杀死或应该让出CPU（如果这个trap是一个定时器中断）。</p><p>回到用户空间的第一步是调用<code>usertrapret</code>（kernel/trap.c:90）。这个函数设置RISC-V控制寄存器，为以后用户空间trap做准备。这包括改变<code>stvec</code>来引用<code>uservec</code>，准备<code>uservec</code>所依赖的<code>trapframe</code>字段，并将<code>sepc</code>设置为先前保存的用户程序计数器。最后，<code>usertrapret</code>在用户页表和内核页表中映射的trampoline页上调用<code>userret</code>，因为<code>userret</code>中的汇编代码会切换页表。</p><p><code>usertrapret</code>对<code>userret</code>的调用传递了参数<code>a0</code>，<code>a1</code>， <code>a0</code>指向<code>TRAPFRAME</code>，<code>a1</code>指向用户进程页表（kernel/trampoline.S:88），<code>userret</code>将<code>satp</code>切换到进程的用户页表。回想一下，用户页表同时映射了trampoline页和<code>TRAPFRAME</code>，但没有映射内核的其他内容。同样，事实上，在用户页表和内核页表中，trampoline页被映射在相同的虚拟地址上，这也是允许<code>uservec</code>在改变<code>satp</code>后继续执行的原因。<code>userret</code>将<code>trapframe</code>中保存的用户<code>a0</code>复制到<code>sscratch</code>中，为以后与<code>TRAPFRAME</code>交换做准备。从这时开始，<code>userret</code>能使用的数据只有寄存器内容和<code>trapframe</code>的内容。接下来<code>userret</code>从trapframe中恢复保存的用户寄存器，对<code>a0</code>和<code>sscratch</code>做最后的交换，恢复用户<code>a0</code>并保存<code>TRAPFRAME</code>，为下一次trap做准备，并使用<code>sret</code>返回用户空间。</p><h3 id="4-3-Code-Calling-system-calls"><a href="#4-3-Code-Calling-system-calls" class="headerlink" title="4.3 Code: Calling system calls"></a>4.3 Code: Calling system calls</h3><p>第2章以<code>initcode.S</code>调用<code>exec</code>系统调用结束（user/initcode.S:11）。让我们来看看用户调用是如何在内核中实现<code>exec</code>系统调用的。</p><p>用户代码将<code>exec</code>的参数放在寄存器<code>a0</code>和<code>a1</code>中，并将系统调用号放在<code>a7</code>中。系统调用号与函数指针表<code>syscalls</code>数组（kernel/syscall.c:108）中的项匹配。<code>ecall</code>指令进入内核，执行<code>uservec</code>、<code>usertrap</code>，然后执行<code>syscall</code>，就像我们上面看到的那样。</p><p><code>syscall</code>（kernel/syscall.c:133）从trapframe中的<code>a7</code>中得到系统调用号，并其作为索引在<code>syscalls</code>查找相应函数。对于第一个系统调用<code>exec</code>，<code>a7</code>将为<code>SYS_exec</code>（kernel/syscall.h:8），这会让<code>syscall</code>调用<code>exec</code>的实现函数<code>sys_exec</code>。</p><p>当系统调用函数返回时，<code>syscall</code>将其返回值记录在<code>p-&gt;trapframe-&gt;a0</code>中。用户空间的<code>exec()</code>将会返回该值，因为RISC-V上的C调用通常将返回值放在<code>a0</code>中。系统调用返回负数表示错误，0或正数表示成功。如果系统调用号无效，<code>syscall</code>会打印错误并返回-1。</p><h3 id="4-4-Code-System-call-arguments"><a href="#4-4-Code-System-call-arguments" class="headerlink" title="4.4 Code: System call arguments"></a>4.4 Code: System call arguments</h3><p>内核的系统调用实现需要找到用户代码传递的参数。因为用户代码调用系统调用的包装函数，参数首先会存放在寄存器中，这是C语言存放参数的惯例位置。内核trap代码将用户寄存器保存到当前进程的trap frame中，内核代码可以在那里找到它们。函数<code>argint</code>、<code>argaddr</code>和<code>argfd</code>从trap frame中以整数、指针或文件描述符的形式检索第n个系统调用参数。它们都调用<code>argraw</code>来获取保存的用户寄存器（kernel/syscall.c:35）。</p><p>一些系统调用传递指针作为参数，而内核必须使用这些指针来读取或写入用户内存。例如，<code>exec</code>系统调用会向内核传递一个指向用户空间中的字符串的指针数组。这些指针带来了两个挑战。首先，用户程序可能是错误的或恶意的，可能会传递给内核一个无效的指针或一个旨在欺骗内核访问内核内存而不是用户内存的指针。第二，xv6内核页表映射与用户页表映射不一样，所以内核不能使用普通指令从用户提供的地址加载或存储。</p><p>内核实现了安全地将数据复制到用户提供的地址或从用户提供的地址复制数据的函数。例如<code>fetchstr</code>（kernel/syscall.c:25）。文件系统调用，如<code>exec</code>，使用<code>fetchstr</code>从用户空间中检索字符串文件名参数。<code>fetchstr</code>调用<code>copyinstr</code>来做这些困难的工作。</p><p><code>copyinstr</code>（kernel/vm.c:406）将用户页表<code>pagetable</code>中的虚拟地址<code>srcva</code>复制到<code>dst</code>，需指定最大复制字节数。它使用<code>walkaddr</code>（调用<code>walk</code>函数）在软件中模拟分页硬件的操作，以确定<code>srcva</code>的物理地址<code>pa0</code>。<code>walkaddr</code>（kernel/vm.c:95）检查用户提供的虚拟地址是否是进程用户地址空间的一部分，所以程序不能欺骗内核读取其他内存。类似的函数<code>copyout</code>，可以将数据从内核复制到用户提供的地址。</p><h3 id="4-5-Traps-from-kernel-space"><a href="#4-5-Traps-from-kernel-space" class="headerlink" title="4.5 Traps from kernel space"></a>4.5 Traps from kernel space</h3><p>Xv6根据用户还是内核代码正在执行，对CPU陷阱寄存器的配置略有不同行为。当内核在CPU上执行时，内核将<code>stvec</code>指向<code>kernelvec</code>上的汇编代码（kernel/kernelvec.S:10）。由于xv6已经在内核中，<code>kernelvec</code>可以使用<code>satp</code>，将其设置为内核页表，以及引用有效内核的堆栈指针。<code>kernelvec</code>保存所有寄存器，以便中断的代码最后可以在没有中断的情况下恢复。</p><p><code>kernelvec</code>将寄存器保存在中断内核线程的堆栈上，因为寄存器值属于该线程，这是合理的。如果trap导致切换到另一个线程—在这种情况下，trap将实际返回到新线程的栈上，将中断线程保存的寄存器安全地保留在其堆栈上。</p><p><code>kernelvec</code>在保存寄存器后跳转到<code>kerneltrap</code>（kernel/trap.c:134）。<code>kerneltrap</code>是为两种类型的陷阱准备的：设备中断和异常。它调用<code>devintr</code>（kernel/trap.c:177）来检查和处理前者。如果trap不是设备中断，那么它必须是异常，如果它发生在xv6内核中，则一定是一个致命错误；内核调用<code>panic</code>并停止执行。</p><p>如果由于计时器中断而调用了<code>kerneltrap</code>，并且进程的内核线程正在运行（而不是调度程序线程），<code>kerneltrap</code>调用<code>yield</code>让出CPU，允许其他线程运行。在某个时刻，其中一个线程将退出，并让我们的线程及其<code>kerneltrap</code>恢复。第7章解释了线程让出CPU控制权。</p><p>当<code>kerneltrap</code>的工作完成时，它需要返回到被中断的代码。因为<code>yield</code>可能破坏保存的<code>sepc</code>和在<code>sstatus</code>中保存的之前的模式。<code>kerneltrap</code>在启动时保存它们。它现在恢复那些控制寄存器并返回到<code>kernelvec</code>（kernel/kernelvec.S:48）。<code>kernelvec</code>从堆栈恢复保存的寄存器并执行<code>sret</code>，<code>sret</code>将<code>sepc</code>复制到<code>pc</code>并恢复中断的内核代码。</p><p>可以思考一下，如果因为时间中断，<code>kerneltrap</code>调用了<code>yield</code>，trap return是如何发生的。</p><p>当CPU从用户空间进入内核时，Xv6将CPU的<code>stvec</code>设置为<code>kernelvec</code>；可以在<code>usertrap</code>（kernel/trap.c:29）中看到这一点。内核运行但<code>stvec</code>被设置为<code>uservec</code>时，这期间有一个时间窗口，在这个窗口期，禁用设备中断是至关重要的。幸运的是，RISC-V总是在开始使用trap时禁用中断，xv6在设置<code>stvec</code>之前不会再次启用它们。</p><h3 id="4-6-Page-fault-exceptions"><a href="#4-6-Page-fault-exceptions" class="headerlink" title="4.6 Page-fault exceptions"></a>4.6 Page-fault exceptions</h3><p>Xv6对异常的响应是相当固定：如果一个异常发生在用户空间，内核就会杀死故障进程。如果一个异常发生在内核中，内核就会<strong>panic</strong>。真正的操作系统通常会以更有趣的方式进行响应。</p><p>举个例子，许多内核使用页面故障来实现<strong><em>写时复制（copy-on-write，cow）</em>fork</strong>。要解释写时复制fork，可以想一想xv6的<code>fork</code>，在第3章中介绍过。<code>fork</code>通过调用<code>uvmcopy</code>（kernel/vm.c:309）为子进程分配物理内存，并将父进程的内存复制到子程序中，使子进程拥有与父进程相同的内存内容。如果子进程和父进程能够共享父进程的物理内存，效率会更高。然而，直接实现这种方法是行不通的，因为父进程和子进程对共享栈和堆的写入会中断彼此的执行。</p><p>通过使用写时复制fork，可以让父进程和子进程安全地共享物理内存，通过页面故障来实现。当CPU不能将虚拟地址翻译成物理地址时，CPU会产生一个页面故障异常（page-fault exception）。 RISC-V有三种不同的页故障：load页故障（当加载指令不能翻译其虚拟地址时）、stote页故障（当存储指令不能翻译其虚拟地址时）和指令页故障（当指令的地址不能翻译时）。<code>scause</code>寄存器中的值表示页面故障的类型，<code>stval</code>寄存器中包含无法翻译的地址。</p><p><strong><em>COW</em></strong>  fork中的基本设计是父进程和子进程最初共享所有的物理页面，但将它们映射设置为只读。因此，当子进程或父进程执行store指令时，RISC-V CPU会引发一个页面故障异常。作为对这个异常的响应，内核会拷贝一份包含故障地址的页。然后将一个副本的读/写映射在子进程地址空间，另一个副本的读/写映射在父进程地址空间。更新页表后，内核在引起故障的指令处恢复故障处理。因为内核已经更新了相关的PTE，允许写入，所以现在故障指令将正常执行。</p><p>这个COW设计对<code>fork</code>很有效，因为往往子程序在fork后立即调用exec，用新的地址空间替换其地址空间。在这种常见的情况下，子程序只会遇到一些页面故障，而内核可以避免进行完整的复制。此外，COW fork是透明的：不需要对应用程序进行修改，应用程序就能受益。</p><p>页表和页故障的结合，将会有更多种有趣的可能性的应用。另一个被广泛使用的特性叫做<strong><em>懒分配 (lazy allocation)</em></strong>，它有两个部分。首先，当一个应用程序调用<code>sbrk</code>时，内核会增长地址空间，但在页表中把新的地址标记为无效。第二，当这些新地址中的一个出现页面故障时，内核分配物理内存并将其映射到页表中。由于应用程序经常要求获得比他们需要的更多的内存，所以懒分配是一个胜利：内核只在应用程序实际使用时才分配内存。像COW fork一样，内核可以对应用程序透明地实现这个功能。</p><p>另一个被广泛使用的利用页面故障的功能是从<strong><em>磁盘上分页(paging from disk)</em></strong>。如果应用程序需要的内存超过了可用的物理RAM，内核可以交换出一些页：将它们写入一个存储设备，比如磁盘，并将其PTE标记为无效。如果一个应用程序读取或写入一个被换出到磁盘的页，CPU将遇到一个页面故障。内核就可以检查故障地址。如果该地址属于磁盘上的页面，内核就会分配一个物理内存的页面，从磁盘上读取页面到该内存，更新PTE为有效并引用该内存，然后恢复应用程序。为了给该页腾出空间，内核可能要交换另一个页。这个特性不需要对应用程序进行任何修改，如果应用程序具有引用的位置性（即它们在任何时候都只使用其内存的一个子集），这个特性就能很好地发挥作用。</p><p>其他结合分页和分页错误异常的功能包括自动扩展堆栈和内存映射文件。</p><h3 id="4-7-Real-world"><a href="#4-7-Real-world" class="headerlink" title="4.7 Real world"></a>4.7 Real world</h3><p>如果将内核内存映射到每个进程的用户页表中（使用适当的PTE权限标志），就不需要特殊的trampoline页了。这也将消除从用户空间trap进入内核时对页表切换的需求。这也可以让内核中的系统调用实现利用当前进程的用户内存被映射的优势，让内核代码直接去间接引用（对地址取值）用户指针。许多操作系统已经使用这些想法来提高效率。Xv6没有实现这些想法，以减少由于无意使用用户指针而导致内核出现安全漏洞的机会，并减少一些复杂性，以确保用户和内核虚拟地址不重叠。</p><h3 id="4-8-Exercises"><a href="#4-8-Exercises" class="headerlink" title="4.8 Exercises"></a>4.8 Exercises</h3><ol><li>函数<code>copyin</code>和<code>copyinstr</code>在软件中walk用户页表。设置内核页表，使内核拥有用户程序的内存映射，<code>copyin</code>和<code>copyinstr</code>可以使用<code>memcpy</code>将系统调用参数复制到内核空间，依靠硬件来完成页表的walk。</li><li>实现内存的懒分配。</li><li>实现写时复制 fork。</li></ol><hr><ol><li><p><a name="ftn1"></a>内核中物理地址和虚拟地址时直接映射的，所以可以在启用分页时，通过物理地址访问。</p></li><li><p><a name="ftn2"></a>执行系统调用时，进程的pc会指向ecall指令，这里需要加4清除，因为进程栈的地址空间是从高到低。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第三章</title>
      <link href="/2022/08/31/xv6-Chapter-3/"/>
      <url>/2022/08/31/xv6-Chapter-3/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章：页表"><a href="#第三章：页表" class="headerlink" title="第三章：页表"></a>第三章：页表</h2><p>页表是操作系统为每个进程提供自己私有地址空间和内存的机制。页表决定了内存地址的含义，以及物理内存的哪些部分可以被访问。它们允许 xv6 隔离不同进程的地址空间，并将它们映射到物理内存上。页表还提供了一个间接层次，允许 xv6 实现一些技巧：在几个地址空间中映射同一内存（trampoline 页），以及用一个未映射页来保护内核栈和用户栈。本章其余部分将解释 RISC-V 硬件提供的页表以及 xv6 如何使用它们。</p><h3 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1  Paging hardware"></a>3.1  Paging hardware</h3><p>提醒一下，RISC-V 指令（包括用户和内核）操作的是虚拟地址。机器的 RAM，或者说物理内存，是用物理地址来做索引的，RISC-V 的页表通过将每个虚拟地址映射到一个物理地址将这两种地址联系起来，</p><p>xv6运行在Sv39 RISC-V上，这意味着只会使用64位虚拟地址的低39位，高25位没有被使用。在这种Sv39配置中，一个RISC-V页表在逻辑上是一个由2²⁷（134,217,728）个<b>页表项（Page Table Entry, PTE）</b>组成的数组。每个<strong>PTE</strong>包含一个44位的<b>物理页号（Physical Page Number, PPN）</b>和一些标志位。分页硬件通过利用39位中的高27位索引到页表中找到一个<strong>PTE</strong>来转换一个虚拟地址，并计算出一个56位的物理地址，它的前44位来自于<strong>PTE</strong>中的<strong>PPN</strong>，而它的后12位则是从原来的虚拟地址复制过来的。图3.1显示了这个过程，在逻辑上可以把页表看成是一个简单的<strong>PTE</strong>数组（更完整的描述见图3.2）。页表让操作系统控制虚拟地址到物理地址的转换，其粒度为4096（2¹²）字节的对齐块。这样的分块称为页。</p><p>在Sv39 RISC-V中，虚拟地址的前25位不用于地址转换；将来，RISC-V可能会使用这些位来定义更多的转换层。物理地址也有增长的空间：在<strong>PTE</strong>格式中，物理页号还有 10 位的增长空间。</p><p><img src="/img/Figure-3.1.jpg" alt="img"> </p><p>如图 3.2 所示，实际上转换过程分三步进行。一个页表以三层树的形式存储在物理内存中。树的根部是一个 4096 字节的页表页，它包含 512 个 PTE，这些 PTE 包含树的下一级页表页的物理地址。每一页都包含 512 个 PTE，用于指向下一个页表或物理地址。分页硬件用 27 位中的高 9 位选择根页表页中的 PTE，用中间 9 位选择树中下一级页表页中的 PTE，用低 9 位选择最后的 PTE。</p><p>如果转换一个地址所需的三个 PTE 中的任何一个不存在，分页硬件就会引发一个<strong>缺页异常（page-fault exception）</strong>，让内核来处理这个异常（见第 4 章）。这种三层结构允许页表在处理大范围的虚拟地址没有被映射这种常见情况时，能够忽略整个页表。</p><p>每个 PTE 都包含标志位，用于告诉分页硬件相关的虚拟地址被允许怎样使用。<code>PTE_V</code> 表示 PTE 是否存在：如果没有设置，对该页的引用会引起异常（即不允许）。<code>PTE_R</code> 控制是否允许指令读取该页。<code>PTE_W</code> 控制是否允许指令向该页写入。<code>PTE_X</code> 控制 CPU 是否可以将页面的内容解释为指令并执行。<code>PTE_U</code> 控制是否允许用户态下的指令访问页面；如果不设置 <code>PTE_U</code>， 对应 PTE 只能在内核态下使用。图 3.2 显示了这一切的工作原理。标志位和与分页硬件相关的数据结构定义在（<code>kernel/riscv.h</code>）中。</p><p><img src="/img/Figure-3.2.jpg" alt="img"></p><p>要告诉硬件使用一个页表，内核必须将对应根页表页的物理地址写入 <code>satp</code> 寄存器中。每个 CPU 都有自己的 <code>satp</code> 寄存器。一个 CPU 将使用自己的 <code>satp</code> 所指向的页表来翻译后续指令产生的所有地址。每个 CPU 都有自己的 <code>satp</code>，这样不同的 CPU 可以运行不同的进程，每个进程都有自己的页表所描述的私有地址空间。</p><p>关于术语的一些说明：物理内存指的是 <strong>DRAM</strong> 中的存储单元。物理存储器的一个字节有一个地址，称为物理地址。当指令操作虚拟地址时，分页硬件会将其翻译成物理地址，然后发送给 DRAM 硬件，以读取或写入存储。不像物理内存和虚拟地址，虚拟内存不是一个物理对象，而是指内核提供的管理物理内存和虚拟地址的抽象和机制的集合。</p><h3 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2  Kernel address space"></a>3.2  Kernel address space</h3><p>Xv6 为每个进程维护一个用于描述进程的用户地址空间的页表，外加一个单独的描述内核地址空间的页表。内核配置其地址空间的布局，使其能够通过可预测的虚拟地址访问物理内存和各种硬件资源。图 3.3 显示了这个设计是如何将内核虚拟地址映射到物理地址的。文件（<code>kernel/memlayout.h</code>）声明了 xv6 内核内存布局的常量。</p><p> <img src="/img/Figure-3.3.jpg" alt="img"> </p><p>QEMU 模拟的计算机包含 RAM（ 物理内存），从物理地址 <code>0x80000000</code> 开始， 至少到 <code>0x86400000</code>，xv6 称之为 <code>PHYSTOP</code>。QEMU 模拟还包括 I/O 设备，如磁盘接口。QEMU 将设备接口作为<b>内存映射（memory-mapped）</b>的控制寄存器暴露给软件，这些寄存器位于物理地址空间的 <code>0x80000000</code> 以下。内核可以通过读取/写入这些特殊的物理地址与设备进行交互；这种读取和写入与设备硬件而不是与 RAM 进行通信。第 4 章解释了 xv6 如何与设备交互。</p><p>内核对RAM和内存映射的设备寄存器使用“直接映射”，也就是将这些资源映射到和它们物理地址相同的虚拟地址上。例如，内核本身在虚拟地址空间和物理内存中的位置都是<code>KERNBASE=0x80000000</code>。直接映射简化了读/写物理内存的内核代码。例如，当 <code>fork</code> 为子进程分配用户内存时，分配器返回该内存的物理地址；<code>fork</code> 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。</p><p>有几个内核虚拟地址不是直接映射：</p><ul><li><p>trampoline 页。它被映射在虚拟地址空间的顶端；用户页表也有这个映射。第 4 章讨论了 trampoline 页的作用，但我们在这里看到了页表的一个有趣的用例；一个物理页（存放 trampoline 代码）在内核的虚拟地址空间中被映射了两次：一次是在虚拟地址空间的顶部，一次是直接映射。</p></li><li><p>内核栈页。每个进程都有自己的内核栈，内核栈被映射到高地址处，所以 xv6 可以在它后面留下一个未映射的守护页。守护页的 PTE 是无效的（不设置 <code>PTE_V</code> 位），这样如果内核栈溢出，很可能会引起异常，内核会报错。如果没有防护页，栈溢出时会覆盖其他内核内存，导致不正确的操作。报错还是比较好的。</p></li></ul><p>内核通过高地址映射使用它的栈空间，栈空间也可以通过直接映射的地址被内核访问。另一种的设计是只使用直接映射，并在直接映射的地址上使用 stack。但是在这种安排中，提供保护页将涉及到取消映射虚拟地址，否则这些地址将指向物理内存，这将很难使用。</p><p>内核将 trampoline 和 text（可执行程序的代码段）映射为有 <code>PTE_R</code> 和 <code>PTE_X</code> 权限的页。内核从这些页读取和执行指令。内核映射的其他页会有 <code>PTE_R</code> 和 <code>PTE_W</code> 权限，以便内核读写这些页面的内存。守护页的映射是无效的（不设置 <code>PTE_V</code>）。 </p><h3 id="3-3-Code-creating-an-address-space"><a href="#3-3-Code-creating-an-address-space" class="headerlink" title="3.3  Code: creating an address space"></a>3.3  Code: creating an address space</h3><p>大部分用于操作地址空间和页表的 xv6 代码都在<code>vm.c</code>（<code>kernel/vm.c:1</code>）中。核心数据结构是 <code>pagetable_t</code>，它实际上是一个指向 RISC-V 根页表页的指针；<code>pagetable_t</code>可以是内核页表，也可以是进程的页表。核心函数是 <code>walk</code> 和 <code>mappages</code>，前者通过虚拟地址得到 PTE，后者将虚拟地址映射到物理地址。以 <code>kvm</code> 开头的函数操作内核页表；以 <code>uvm</code> 开头的函数操作用户页表；其他函数同时用于这两种页表。<code>copyout</code>和<code>copyin</code>将数据复制到或复制出被作为系统调用参数的用户虚拟地址；它们在 <code>vm.c</code> 中，因为它们需要显式转换用户空间的地址，以便找到相应的物理内存。</p><p>在机器启动时，在启动序列的靠前部分，<code>main</code> 调用 <code>kvminit</code>（<code>kernel/vm.c:22</code>）来创建内核页表。这个调用发生在 xv6 在 RISC-V 启用分页之前，所以地址直接指向物理内存。<code>kvminit</code> 首先分配一页物理内存来存放根页表页。然后调用 <code>kvmmap</code> 将内核所需要的硬件资源映射到物理地址。这些资源包括内核的指令和数据，<code>KERNBASE</code> 到 <code>PHYSTOP</code>的物理内存，以及实际上是设备的内存范围。</p><p><code>kvmmap</code>（<code>kernel/vm.c:118</code>）调用 <code>mappages</code>（<code>kernel/vm.c:149</code>），它将指定范围的虚拟地址映射到一段物理地址。它将范围内地址分割成多页（忽略余数），每次映射一页的起始地址。对于每个要映射的虚拟地址（页的起始地址），<code>mapages</code> 调用 <code>walk</code> 找到该地址的最后一级 PTE 的地址。然后，它配置 PTE，使其持有相关的物理页号、所需的权限（<code>PTE_W</code>、<code>PTE_X</code>和/或<code>PTE_R</code>），以及<code>PTE_V</code>来标记 PTE 为有效（<code>kernel/vm.c:161</code>）。</p><p><code>walk</code>（<code>kernel/vm.c:72</code>）模仿 RISC-V 分页硬件查找虚拟地址的 PTE（见图 3.2）。<code>walk</code> 每次降低 9 位来查找三级页表。它使用每一级的 9 位虚拟地址来查找下一级页表或最后一级（<code>kernel/vm.c:78</code>）的 PTE。如果 PTE 无效，那么所需的物理页还没有被分配；如果 <code>alloc</code> 参数被设置，<code>walk</code> 会分配一个新的页表页，并把它的物理地址放在 PTE 中。它返回 树中最低层PTE的地址（<code>kernel/vm.c:88</code>）。</p><p><code>main</code> 调用 <code>kvminithart</code>（<code>kernel/vm.c:53</code>）来映射内核页表。它将根页表页的物理地址写入寄存器 <code>satp</code> 中。在这之后，CPU 将使用内核页表翻译地址。由于内核使用唯一映射，所以指令的虚拟地址将映射到正确的物理内存地址。</p><p><code>procinit</code>（<code>kernel/proc.c:26</code>），它由 <code>main</code> 调用，为每个进程分配一个内核栈。它将每个栈映射在 <code>KSTACK</code> 生成的虚拟地址上，这就为栈守护页留下了空间。<code>kvmmap</code> 将对应的PTE加入到内核页表中，然后调用 <code>kvminithart</code> 将内核页表重新加载到 <code>satp</code> 中，这样硬件就知道新的 PTE 了。</p><p>每个 RISC-V CPU 都会在 <strong>Translation Look-aside Buffer(TLB)</strong>中缓存页表项，当 xv6 改变页表时，必须告诉 CPU 使相应的缓存 TLB 项无效。如果它不这样做，那么在以后的某个时刻，TLB 可能会使用一个旧的缓存映射，指向一个物理页，而这个物理页在此期间已经分配给了另一个进程，这样的话，一个进程可能会在其他进程的内存上“乱写乱画“。RISC-V 有一条指令 <code>sfence.vma</code>，可以刷新当前 CPU 的 TLB。xv6 在<code>kvminithart</code>中，重新加载 <code>satp</code> 寄存器后， 执行 <code>sfence.vma</code>，也会在从内核空间返回用户空间前，切换到用户页表的trampoline 代码中执行 <code>sfence.vma</code>（<code>kernel/trampoline.S:79</code>）。</p><h3 id="3-4-Physical-memory-allocation"><a href="#3-4-Physical-memory-allocation" class="headerlink" title="3.4  Physical memory allocation"></a>3.4  Physical memory allocation</h3><p> 内核必须在运行时为页表、用户内存、内核堆栈和管道缓冲区分配和释放物理内存。xv6 使用内核地址结束到 <code>PHYSTOP</code> 之间的物理内存来进行运行时分配。它每次分配和释放整个4096 字节的页面。它通过保存空闲页链表，来记录哪些页是空闲的。分配包括从链表中删除一页；释放包括将释放的页面添加到空闲页链表中。</p><h3 id="3-5-Code-Physical-memory-allocator"><a href="#3-5-Code-Physical-memory-allocator" class="headerlink" title="3.5  Code: Physical memory allocator"></a>3.5  Code: Physical memory allocator</h3><p>分配器在 <code>kalloc.c</code>（<code>kernel/kalloc.c:1</code>）中。分配器的数据结构是一个可供分配的物理内存页的<strong>空闲链表</strong>，每个空闲页的链表元素是一个结构体 <code>struct run</code>（<code>kernel/kalloc.c:17</code>）。分配器从哪里获得内存来存放这个结构体呢？它把每个空闲页的 <code>run</code> 结构体存储在空闲页自身里面，因为那里没有其他东西存储。空闲链表由一个<strong>自旋锁</strong>保护（<code>kernel/kalloc.c:21-24</code>）。链表和锁被包裹在一个结构体中，以明确锁保护的是结构体中的字段。现在，请忽略锁以及 <code>acquire</code> 和<code>release</code> 的调用；第 6 章将详细研究锁。</p><p><code>main</code> 调用 <code>kinit</code> 来初始化分配器（<code>kernel/kalloc.c:27</code>）。<code>kinit</code> 初始化空闲页链表，以保存内核地址结束到 <code>PHYSTOP</code> 之间的每一页。xv6 应该通过解析硬件提供的配置信息来确定有多少物理内存可用。但是它没有这么做，而是假设机器有 128M 字节的 RAM。<code>kinit</code> 通过调用<code>freerange</code> 来添加内存到空闲页链表，<code>freerange</code> 则对每一页都调用 <code>kfree</code>。PTE 只能指向按4096 字节对齐的物理地址（4096 的倍数），因此 <code>freerange</code> 使用 <code>PGROUNDUP</code> 来确保它只添加对齐的物理地址到空闲链表中。分配器开始时没有内存；这些对 <code>kfree</code> 的调用给了它一些内存管理。</p><p>分配器有时把地址当作整数来处理，以便对其进行运算（如 <code>freerange</code> 遍历所有页）， 有时把地址当作指针来读写内存（如操作存储在每页中的 <code>run</code> 结构体）；这种对地址的双重使用是分配器代码中充满 C 类型转换的主要原因。另一个原因是，释放和分配本质上改变了内存的类型。</p><p><code>kfree</code>（<code>kernel/kalloc.c:47</code>）将被释放的内存中的每个字节设置为1。这将使得释放内存后使用内存的代码（使用悬空引用）将会读取垃圾而不是旧的有效内容；希望这将导致这类代码更快地崩溃。然后 <code>kfree</code> 将页面预存入释放列表：它将 <code>pa</code>（物理地址）转为指向结构体 <code>run</code> 的指针，在 <code>r-&gt;next</code> 中记录空闲链表之前的节点，并将释放列表设为 <code>r</code>。<code>kalloc</code>移除并返回空闲链表中的第一个元素。</p><h3 id="3-6-Process-address-space"><a href="#3-6-Process-address-space" class="headerlink" title="3.6  Process address space"></a>3.6  Process address space</h3><p>每个进程都有一个单独的页表，当 xv6 在进程间切换时，也会改变页表。如图 2.3 所示，一个进程的用户内存从虚拟地址 0 开始，可以增长到 <code>MAXVA</code>（<code>kernel/riscv.h:348</code>），原则上允许一个进程寻址 256GB 的内存。</p><p>当一个进程要求 xv6 提供更多的用户内存时，xv6 首先使用 <code>kalloc</code> 来分配物理页，然后将指向新物理页的 PTE 添加到进程的页表中。Xv6 设置这些 PTE 的 <code>PTE_W</code>、<code>PTE_X</code>、<code>PTE_R</code>、<code>PTE_U</code> 和 <code>PTE_V</code> 标志。大多数进程不使用整个用户地址空间；xv6 将不使用的 PTE 的 <code>PTE_V</code> 位保持为清除状态。</p><p>我们在这里看到了几个有趣例子，是关于使用页表的。首先，不同的进程页表将用户地址转化为物理内存的不同页，这样每个进程都有私有的用户内存。第二，每个进程都认为自己的内存具有从零开始的连续的虚拟地址，而进程的物理内存可以是不连续的。第三，内核会映射带有 <code>trampoline</code> 代码的页到用户地址空间顶端，因此，有一物理内存页在所有地址空间中都会出。</p><p><img src="/img/Figure-3.4.jpg" alt="img"></p><p>图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。栈只有一页，图中显示的是由<code>exec</code> 创建的初始内容。位于栈顶部的字符串中包含了命令行中输入的参数和指向他们的指针数组。在下方是允许程序在 <code>main</code> 启动的值，就像函数 <code>main(argc, argv)</code> 是刚刚被调用一样<a href="#ftn1">[1]</a>。</p><p>为了检测用户栈溢出分配的栈内存，xv6 会在 stack 的下方放置一个无效的保护页。如果用户栈溢出，而进程试图使用栈下面的地址，硬件会因为该映射无效而产生一个缺页异常。一个现实世界中的操作系统可能会在用户栈溢出时自动为其分配更多的内存。</p><h3 id="3-7-Code-sbrk"><a href="#3-7-Code-sbrk" class="headerlink" title="3.7  Code: sbrk"></a>3.7  Code: sbrk</h3><p> <code>sbrk</code> 是 一 个 进 程 收 缩 或 增 长 内 存 的 系 统 调 用 。 该 系 统 调 用 由 函 数<code>growproc</code>（<code>kernel/proc.c:239</code>）实现，<code>growproc</code> 调用 <code>uvmalloc</code> 或 <code>uvmdealloc</code>，取决于 <code>n</code> 是正数还是负数。<code>uvmalloc</code>（<code>kernel/vm.c:229</code>）通过 <code>kalloc</code> 分配物理内存，并使用 <code>mappages</code> 将 PTE 添加到用户页表中。 <code>uvmdealloc</code> 调用 <code>uvmunmap</code>（<code>kernel/vm.c:174</code>），它使用 <code>walk</code> 来查找 PTE 并使用 <code>kfree</code> 来释放它们所引用的物理内存。</p><p>xv6 使用进程的页表不仅是为了告诉硬件如何映射用户虚拟地址，也是将其作为分配给该进程的物理地址的唯一记录。这就是为什么释放用户内存（<code>uvmunmap</code> 中）需要检查用户页表的原因。</p><h3 id="3-8-Code-exec"><a href="#3-8-Code-exec" class="headerlink" title="3.8  Code: exec"></a>3.8  Code: exec</h3><p><code>exec</code> 是创建一个地址空间的用户部分的系统调用。它读取储存在文件系统上的文件用来初始化一个地址空间的用户部分。<code>exec</code>（<code>kernel/exec.c:13</code>）使用 <code>namei</code>（<code>kernel/exec.c:26</code>）打开二进制文件路径，这在第 8 章中有解释。然后，它读取 ELF 头。xv6 应用程序用 ELF 格式来描述可执行文件，它定义在（<code>kernel/elf.h</code>）。一个 ELF 二进制文件包括一个 ELF 头，<code>struct elfhdr</code>（<code>kernel/elf.h:6</code>）。之后是一串程序段头（program section header），<code>struct proghdr</code>（<code>kernel/elf.h:25</code>）。每一个<code>proghdr</code>描述了应用的一个必须加载到内存中的程序段；xv6 程序只有一个程序段头，但其他系统可能有分开的指令段和数据段需要加载到内存。</p><p>第一步是快速检查文件是否是ELF格式。一个 ELF 二进制文件以四个字节的“魔法数字” <code>0x7F</code>、<code>E</code>、<code>L</code>、<code>F</code>或 <code>ELF_MAGIC</code>（<code>kernel/elf.h:3</code>）开始。如果 ELF 头有正确的”魔法数字“，<code>exec</code>就会认为该二进制文件是正确的类型。</p><p><code>exec</code>使用<code>proc_pagetable</code>（<code>kernel/exec.c:38</code>）分配一个没有使用的页表，使用 <code>uvmalloc</code>（<code>kernel/exec.c:52</code>）为每一个 ELF 段分配内存，使用 <code>loadseg</code>（<code>kernel/exec.c:10</code>）加载每一个段到内存中。<code>loadseg</code>使用<code>walkaddr</code>找到分配内存的物理地址，在该地址写入 ELF 段的每一页，页的内容通过 <code>readi</code> 从文件中读取。</p><p>用 <code>exec</code> 创建的第一个用户程序<code>/init</code> 的程序段头是这样的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># objdump -p _init</span></span><br><span class="line">user/_init: file format elf64-littleriscv</span><br><span class="line">Program Header:</span><br><span class="line">LOAD off 0x00000000000000b0 vaddr 0x0000000000000000</span><br><span class="line">       paddr 0x0000000000000000 align 2**3</span><br><span class="line">     filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx</span><br><span class="line">   STACK off 0x0000000000000000 vaddr 0x0000000000000000</span><br><span class="line">        paddr 0x0000000000000000 align 2**4</span><br><span class="line">     filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-</span><br></pre></td></tr></table></figure><p>程序段头的 <code>filesz</code> 可能小于 <code>memsz</code>，说明它们之间的空隙应该用 0来填充（对于 C 语言中的全局变量），而不是从文件中读取。对于<code>/init</code>来说，<code>filesz</code>是 2112 字节，<code>memsz</code>是 2136字节，因此 <code>uvmalloc</code> 分配了足够的物理内存来容纳 2136 字节，但只从文件<code>/init</code> 中读取 2112字节。</p><p><code>exec</code> 在栈页的下方放置了一个不可访问页，这样程序如果试图使用多个页面，就会出现故障。这个不可访问的页还能允许<code>exec</code> 处理过大的参数；在这种情况下，<code>exec</code>用来复制参数到栈的 <code>copyout</code>（<code>kernel/vm.c:355</code>）函数会注意到目标页不可访问，并返回-1。</p><p>在准备新的内存映像的过程中，如果 <code>exec</code> 检测到一个错误，比如一个无效的程序段， 它就会跳转到标签 <code>bad</code>，释放新的映像，并返回-1。<code>exec</code> 必须延迟释放旧映像，直到它确定<code>exec</code>系统调用会成功：如果旧映像消失了，系统调用就不能返回-1。<code>exec</code>中唯一的错误情况发生在创建映像的过程中。一旦镜像完成，<code>exec</code>就可以提交到新的页表（<code>kernel/exec.c:113</code>）并释放旧的页表（<code>kernel/exec.c:117</code>）。</p><p><code>exec</code> 将 ELF 文件中的字节按 ELF 文件指定的地址加载到内存中。用户或进程可以将任何他们想要的地址放入 ELF 文件中。因此，<code>exec</code>是有风险的，因为 ELF 文件中的地址可能会意外地或故意地指向内核。对于一个不小心的内核来说，后果可能从崩溃到恶意颠覆内核的隔离机制(即安全漏洞)。xv6 执行了一些检查来避免这些风险。例如 <code>if (ph.vaddr + ph.memsz &lt; ph.vaddr)</code>检查总和是否溢出一个 64 位整数。危险的是，用户可以用指向用户选择的地址的 <code>ph.vaddr</code> 和足够大的 <code>ph.memsz</code> 来构造一个 ELF 二进制，使总和溢出到 <strong>0x1000</strong>，这看起来像是一个有效值。在旧版本的 xv6 中，用户地址空间也包含内核（但在用户模式下不可读/写），用户可以选择一个对应内核内存的地址，从而将 ELF 二进制中的数据复制到内核中。在 RISC-V 版本的 xv6 中，这是不可能的，因为内核有自己独立的页表；<code>loadseg</code>加载数据到进程的页表中，而不是内核的页表中。</p><p>内核开发人员很容易忽略一个关键的检查，现实中的内核有很长一段缺少检查的空档期， 用户程序可以利用缺少这些检查来获得内核特权。xv6 在验证需要提供给内核的用户程序数据的时候，并没有完全验证其是否是恶意的，恶意用户程序可能利用这些数据来绕过 xv6 的隔离。</p><h3 id="3-9-Real-world"><a href="#3-9-Real-world" class="headerlink" title="3.9  Real world"></a>3.9  Real world</h3><p>像大多数操作系统一样，xv6 使用分页硬件进行内存保护和映射。大多数操作系统对分页的使用要比 xv6 复杂得多，它将分页和缺页异常结合起来，我们将在第 4 章中讨论。</p><p>Xv6 的内核使用虚拟地址和物理地址之间的直接映射，这样会更简单，并假设在地址0x8000000 处有物理 RAM，即内核期望加载的地方。这在 QEMU 中是可行的，但是在真实的硬件上，它被证明是一个糟糕的想法；真实的硬件将 RAM 和设备放置在不可预测的物理地址上，例如在 0x8000000 处可能没有 RAM，而 xv6 期望能够在那里存储内核。更好的内核设计利用页表将任意的硬件物理内存布局变成可预测的内核虚拟地址布局。</p><p>RISC-V 支持物理地址级别的保护，但 xv6 没有使用该功能。</p><p>在有大量内存的机器上，使用 RISC-V 对超级页(4MB 的页)的支持可能是有意义的。当物理内存很小的时候，小页是有意义的，可以对磁盘进行精细地分配和分页。例如，如果一个程序只使用 8 千字节的内存，那么给它整整 4 兆字节的超级物理内存页是浪费的。更大的页在有大量内存的机器上是有意义的，可以减少页表操作的开销。</p><p>xv6 内核缺乏一个类 malloc 的分配器为小程序提供内存，这使得内核没有使用需要动态分配的复杂数据结构，从而简化了设计。</p><p>内存分配是一个常年的热门话题，基本问题是有效利用有限的内存和为未来未知的请求做准备<a href="#ftn2">[2]</a>。如今人们更关心的是速度而不是空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是（在 xv6 中）只分配 4096 字节的块；一个真正的内核分配器需要处理小块分配以及大块分配。</p><h3 id="3-10-Exercises"><a href="#3-10-Exercises" class="headerlink" title="3.10  Exercises"></a>3.10  Exercises</h3><p>1、分析 RISC-V 的设备树（device tree），找出计算机有多少物理内存。</p><p>2、编写一个用户程序，通过调用<code>sbrk(1)</code>使其地址空间增加一个字节。运行该程序，研究调用 <code>sbrk</code> 之前和调用<code>sbrk</code> 之后的程序页表。内核分配了多少空间？新内存的 PTE 包含哪些内容？</p><p>3、修改 xv6 使得内核使用超级页 4M。</p><p>4、修改 xv6，使用户程序间接引用一个空指针时，会收到一个异常，即修改 xv6，使用户程序的虚拟地址 0 不被映射。</p><p>5、Unix 实现的 exec 传统上包括对 shell 脚本的特殊处理。如果要执行的文件以文本<code>#!</code>开头， 那么第一行就被认为是要运行的程序来解释文件。例如，如果调用 <code>exec</code> 运行 <code>myprog arg1</code>， 而 <code>myprog</code> 的第一行是<code>#!/interp</code>，那么<code>exec</code> 执行<code>/interp myprog arg1</code>。在 xv6 中实现对这个约定的支持。</p><p>6、为内核实现地址空间的随机化。</p><hr><ol><li><a name="ftn1"></a>即在栈中保存了从main返回所需要的信息</li><li><a name="ftn2"></a>dereference，就是对地址取值，例如*p。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第二章</title>
      <link href="/2022/08/31/xv6-Chapter-2/"/>
      <url>/2022/08/31/xv6-Chapter-2/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章：操作系统组织"><a href="#第二章：操作系统组织" class="headerlink" title="第二章：操作系统组织"></a>第二章：操作系统组织</h2><p>操作系统的一个关键要求是同时支持几个活动。例如，使用第1章中描述的系统调用接口，一个进程可以用<strong>fork</strong>创建新进程。操作系统必须在这些进程之间分时共享计算机的资源。例如，即使进程的数量多于硬件CPU的数量，操作系统也必须保证所有的进程都有机会执行。操作系统还必须安排进程之间的隔离。也就是说，如果一个进程出现了bug并发生了故障，其不应该影响不依赖该bug进程的进程。然而，完全隔离也不可取，因为进程间可能需要进行交互，例如管道。因此，一个操作系统必须满足三个要求：多路复用、隔离和交互。</p><p>本章概述了如何组织操作系统来实现这三个要求。现实中有很多方法，但本文主要介绍以宏内核<a href="#ftn1">[1]</a>为中心的主流设计，很多Unix操作系统都采用这种设计。本章还介绍了xv6进程的概述，xv6进程是xv6中的隔离单元，还介绍了xv6启动时第一个进程的创建。</p><p>Xv6运行在多核<a href="#ftn2">[2]</a>RISC-V微处理器上，它的许多底层功能（例如，它的进程实现）是RISC-V所特有的。RISC-V是一个64位的CPU，xv6是用 “LP64 “C语言编写的，这意味着C编程语言中的long(L)和指针(P)是64位的，但int是32位的。本书假定读者在某种架构上做过一点机器级的编程，并会介绍一些RISC-V特有的思想。RISC-V有用的参考资料是 “The RISC-V Reader,An Open Architecture Attlas”［12］。用户级ISA[2]和特权架构[1]是官方规范。</p><p>一台完整的计算机中的CPU被支持它的硬件所包围，这些硬件大部分呈I/O接口的形式。编写XV6时，支撑它的硬件是通过带”-machine virt “选项的qemu模拟出来的。其中包括RAM、包含启动代码的ROM、与用户键盘/屏幕的串行连接以及用于存储的磁盘。</p><h3 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h3><p>​    遇到一个操作系统，人们可能会问的第一个问题是为什么需要它呢？答案是，我们可以把图1.2中的系统调用作为一个库来实现，应用程序与之连接。在这个想法中，每个应用程序可以根据自己的需要定制自己的库。应用程序可以直接与硬件资源进行交互，并以最适合应用程序的方式使用这些资源（例如，实现高效、可预测的性能）。一些用于嵌入式设备或实时系统的操作系统就是以这种方式组织的。</p><p>这种系统库方式的缺点是，如果有多个应用程序在运行，这些应用程序必须正确执行。例如，每个应用程序必须定期放弃CPU，以便其他应用程序能够运行。如果所有的应用程序都相互信任并且没有bug，这样的<strong><em>cooperative</em></strong>分时方案可能是OK的。更典型的情况是，应用程序之间互不信任，并且有bug，所以人们通常希望比<strong><em>cooperative</em></strong>方案提供更强的隔离性。</p><p>为了实现强隔离，禁止应用程序直接访问敏感的硬件资源，而将资源抽象为服务是很有帮助的。例如，Unix应用程序只通过文件系统的<code>open</code>、<code>read</code>、<code>write</code>和<code>close</code>系统调用与文件系统进行交互，而不是直接读写磁盘。这为应用程序带来了路径名的便利，而且它允许操作系统（作为接口的实现者）管理磁盘。即使不考虑隔离问题，那些有意交互的程序（或者只是希望互不干扰）很可能会发现文件系统是一个比直接使用磁盘更方便的抽象。</p><p>同样，Unix在进程之间透明地切换硬件CPU，必要时保存和恢复寄存器状态，这样应用程序就不必意识到时间共享。这种透明性允许操作系统共享CPU，即使一些应用程序处于无限循环中。</p><p>另一个例子是，Unix进程使用<code>exec</code>来建立它们的内存映像，而不是直接与物理内存交互。这使得操作系统可以决定将进程放在内存的什么位置；如果内存紧张，操作系统甚至可能将进程的部分数据存储在磁盘上。<code>exec</code>还允许用户将可执行文件储存在文件系统中。</p><p>Unix进程之间的许多形式的交互都是通过文件描述符进行的。文件描述符不仅可以抽象出许多细节（例如，管道或文件中的数据存储在哪里），而且它们的定义方式也可以简化交互。例如，如果管道中的一个应用程序崩溃了，内核就会为管道中的另一个进程产生一个文件结束信号。</p><p>图1.2中的系统调用接口经过精心设计，既为程序员提供了便利，又提供了强隔离的可能。Unix接口并不是抽象资源的唯一方式，但事实证明它是一种非常好的方式。</p><h3 id="2-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="2.2 User mode, supervisor mode, and system calls"></a>2.2 User mode, supervisor mode, and system calls</h3><p>强隔离要求应用程序和操作系统之间有一个分界线。如果应用程序发生错误，我们不希望操作系统崩溃，也不希望其他应用程序崩溃。相反，操作系统应该能够清理崩溃的应用程序并继续运行其他应用程序。为了实现强隔离，操作系统必须安排应用程序不能修改（甚至不能读取）操作系统的数据结构和指令，应用程序不能访问其他进程的内存。</p><p>CPU提供了强隔离的硬件支持。例如，RISC-V有三种模式，CPU可以执行指令：<strong>机器模式</strong>、<strong>监督者（supervisor）模式</strong>和<strong>用户模式</strong>。在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6会在机器模式下执行几条指令，然后转为监督者模式。</p><p>在监督者（supervisor）模式下，CPU被允许执行特权指令：例如，启用和禁用中断，读写保存页表地址的寄存器等。如果用户模式下的应用程序试图执行一条特权指令，CPU不会执行该指令，而是切换到监督者模式，这样监督者模式的代码就可以终止该应用程序，因为它做了不该做的事情。第1章的图1.1说明了这种组织方式。一个应用程序只能执行用户模式的指令（如数字相加等），被称为运行在用户空间，而处于监督者模式的软件也可以执行特权指令，被称为运行在内核空间。运行在内核空间（或监督者模式）的软件称为内核。</p><p>一个应用程序如果要调用内核函数（如xv6中的<code>read</code>系统调用），必须过渡到内核。CPU提供了一个特殊的指令，可以将CPU从用户模式切换到监督者模式，并在内核指定的入口处进入内核。(RISC-V为此提供了<code>ecall</code>指令。)一旦CPU切换到监督者模式，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝或执行该操作。由内核控制监督者模式的入口点是很重要的；如果应用程序可以决定内核的入口点，那么恶意应用程序就能够在跳过参数验证的情况下进入内核。</p><h3 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h3><p>一个关键的设计问题是操作系统的哪一部分应该在监督者模式下运行。一种可能是整个操作系统驻留在内核中，这样所有系统调用的实现都在监督者模式下运行。这种组织方式称为<strong><em>宏内核</em></strong>。</p><p>在这种组织方式中，整个操作系统以全硬件权限运行。这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要全硬件权限。此外，操作系统的不同部分更容易合作。例如，一个操作系统可能有一个缓冲区，其被缓存文件系统和虚拟内存系统共享。</p><p>宏内核组织方式的一个缺点是操作系统的不同部分之间的接口通常是复杂的（我们将在本文的其余部分看到），因此操作系统开发者很容易在这上面出错。在宏内核中，一个错误是致命的，因为监督者模式下的错误往往会导致内核崩溃。如果内核崩溃，计算机就会停止工作，因此所有的应用程序也会崩溃。计算机必须重启。</p><p>为了降低内核出错的风险，操作系统设计者可以尽量减少在监督者模式下运行的操作系统代码量，而在用户模式下执行操作系统的大部分代码。这种内核组织方式称为<strong><em>微内核</em></strong>。</p><p><img src="/img/Figure-2.1.png" alt="Figure-2.1"></p><p>图2.1说明了这种微内核设计。在图中，文件系统作为一个用户级进程运行。作为进程运行的OS服务称为服务器。为了让应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，用于从一个用户模式进程向另一个进程发送消息。例如，如果一个像shell这样的应用程序想要读写文件，它就会向文件服务器发送一个消息，并等待响应。</p><p>在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织方式使得内核相对简单，因为大部分操作系统驻留在用户级服务器中。</p><p>xv6和大多数Unix操作系统一样，是以宏内核的形式实现的。因此，xv6内核接口与操作系统接口相对应，内核实现了完整的操作系统。由于xv6不提供很多服务，所以它的内核比一些微内核要小，但从概念上讲xv6是宏内核。</p><h3 id="2-4-Code-xv6-organization"><a href="#2-4-Code-xv6-organization" class="headerlink" title="2.4 Code: xv6 organization"></a>2.4 Code: xv6 organization</h3><p>xv6内核源码在<code>kernel/</code>子目录下。按照模块化的概念，源码被分成了多个文件，图2.2列出了这些文件。模块间的接口在<code>kernel/defs.h</code>中定义。</p><p><img src="/img/Figure-2.2.png" alt="Figure-2.2"></p><h3 id="2-5-Process-overview"><a href="#2-5-Process-overview" class="headerlink" title="2.5 Process overview"></a>2.5 Process overview</h3><p>xv6中的隔离单位（和其他Unix操作系统一样）是一个进程。进程抽象可以防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核，所以进程不能破坏内核的隔离机制。内核必须小心翼翼地实现进程抽象，因为一个错误或恶意的应用程序可能会欺骗内核或硬件做一些不好的事情（例如，规避隔离）。内核用来实现进程的机制包括：用户/监督模式标志、地址空间和线程的时间片轮转。</p><p>为了帮助实施隔离，进程抽象为程序提供了一种错觉，即它有自己的私有机器。一个进程为程序提供了一个看似私有的内存系统，或者说是地址空间，其他进程不能对其进行读写。进程还为程序提供了“私有”的CPU，用来执行程序的指令。</p><p>Xv6使用页表（由硬件实现）给每个进程提供自己的地址空间。RISC-V页表将<strong>虚拟地址</strong>（RISC-V指令操作的地址）转换（或 “映射”）为<strong>物理地址</strong>（CPU芯片发送到主存储器的地址）。</p><p>Xv6为每个进程维护一个单独的页表，定义该进程的地址空间。如图2.3所示，进程的用户空间内存的地址空间是从虚拟地址0开始的。指令存放在最前面，其次是全局变量，然后是栈，最后是一个堆区（用于<strong>malloc</strong>），进程可以根据需要扩展。有一些因素限制了进程地址空间的最大长度：RISC-V上的指针是64位宽；硬件在页表中查找虚拟地址时只使用低的39位；xv6只使用39位中的38位。因此，最大地址是$2^{38}-1$ = 0x3fffffffff，也就是<code>MAXVA</code>（kernel/riscv.h:348）。在地址空间的顶端，xv6保留了一页，用于<strong>trampoline</strong>和映射进程<strong>trapframe</strong>的页，以便切换到内核，我们将在第4章中解释。</p><p><img src="/img/Figure-2.3.png" alt="Figure-2.3"></p><p>xv6内核为每个进程维护了许多状态，记录在<code>proc</code>结构体(kernel/proc.h:86)。一个进程最重要的内核状态是它的页表、内核栈和运行状态。我们用<code>p-&gt;xxx</code>来表示<code>proc</code>结构的元素，例如，<code>p-&gt;pagetable</code>是指向进程页表的指针。</p><p>每个进程都有一个执行线程（简称线程），执行进程的指令。一个线程可以被暂停，然后再恢复。为了在进程之间透明地切换，内核会暂停当前运行的线程，并恢复另一个进程的线程。线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的栈中。每个进程有两个栈：用户栈和内核栈（<code>p-&gt;kstack</code>）。当进程在执行用户指令时，只有它的用户栈在被使用，而它的内核栈是空的。当进程进入内核时（因为系统调用或中断），内核代码在进程的内核栈上执行；当进程在内核中时，它的用户栈仍然包含保存的数据，但不被主动使用。进程的线程在用户栈和内核栈中交替执行。内核栈是独立的（并且受到保护，不受用户代码的影响），所以即使一个进程用户栈被破坏了，内核也可以执行。</p><p>一个进程可以通过执行RISC-V <code>ecall</code>指令进行系统调用。该指令提高硬件权限级别，并将程序计数器改变为内核定义的入口点。入口点的代码会切换到内核栈，并执行实现系统调用的内核指令。当系统调用完成后，内核切换回用户栈，并通过调用<code>sret</code>指令返回用户空间，降低硬件特权级别，恢复执行系统调用前的用户指令。进程的线程可以在内核中阻塞等待I/O，当I/O完成后，再从离开的地方恢复。</p><p><code>p-&gt;state</code>表示进程是创建、就绪、运行、等待I/O，还是退出。</p><p><code>p-&gt;pagetable</code>以RISC-V硬件需要的格式保存进程的页表，当进程在用户空间执行时，xv6使分页硬件使用进程的<code>p-&gt;pagetable</code>。进程的页表也会记录分配给该进程内存的物理页地址。</p><h3 id="2-6-Code-starting-xv6-and-the-first-process"><a href="#2-6-Code-starting-xv6-and-the-first-process" class="headerlink" title="2.6 Code: starting xv6 and the first process"></a>2.6 Code: starting xv6 and the first process</h3><p>为了使xv6更加具体，我们将概述内核如何启动和运行第一个进程。后面的章节将更详细地描述这个概述中出现的机制。</p><p>当RISC-V计算机开机时，它会初始化自己，并运行一个存储在只读存储器中的<strong>boot loader</strong>。<strong>Boot loader</strong>将xv6内核加载到内存中。然后，在机器模式下，CPU从 <code>_entry</code>（kernel/entry.S:6）开始执行xv6。RISC-V在禁用分页硬件的情况下启动：虚拟地址直接映射到物理地址。</p><p>loader将xv6内核加载到物理地址<code>0x80000000</code>的内存中。之所以将内核放在<code>0x80000000</code>而不是<code>0x0</code>，是因为地址范围<code>0x0:0x80000000</code>包含I/O设备。</p><p><code>_entry</code>处的指令设置了一个栈，这样xv6就可以运行C代码。Xv6在文件<code>start.c</code>(kernel/start.c:11)中声明了初始栈的空间，即<code>stack0</code>。在<code>_entry</code>处的代码加载栈指针寄存器<code>sp</code>，地址为<code>stack0+4096</code>，也就是栈的顶部，因为RISC-V的栈是向下扩张的。现在内核就拥有了栈，<code>_entry</code>调用<code>start</code>(kernel/start.c:21)，并执行其C代码。</p><p>函数<code>start</code>执行一些只有在机器模式下才允许的配置，然后切换到监督者模式。为了进入监督者模式，RISC-V提供了指令<code>mret</code>。这条指令最常用来从上一次的调用中返回，上一次调用从监督者模式到机器模式。<code>start</code>并不是从这样的调用中返回，而是把事情设置得像有过这样的调用一样：它在寄存器<code>mstatus</code>中把上一次的特权模式设置为特权者模式，它把<code>main</code>的地址写入寄存器<code>mepc</code>中，把返回地址设置为<code>main</code>函数的地址，在特权者模式中把<code>0</code>写入页表寄存器<code>satp</code>中，禁用虚拟地址转换，并把所有中断和异常委托给特权者模式。</p><p>在进入特权者模式之前，<code>start</code>还要执行一项任务：对时钟芯片进行编程以初始化定时器中断。在完成了这些基本管理后，<code>start</code>通过调用<code>mret</code>“返回”到监督者模式。这将导致程序计数器变为<code>main</code>（kernel/main.c:11）的地址。</p><p>在<code>main</code>(kernel/main.c:11)初始化几个设备和子系统后，它通过调用<code>userinit</code>(kernel/proc.c:212)来创建第一个进程。第一个进程执行一个用RISC-V汇编编写的小程序<code>initcode.S</code>（user/initcode.S:1），它通过调用<code>exec</code>系统调用重新进入内核。正如我们在第一章中所看到的，<code>exec</code>用一个新的程序（本例中是<code>/init</code>）替换当前进程的内存和寄存器。</p><p>一旦内核完成<code>exec</code>，它就会在<code>/init</code>进程中返回到用户空间。<code>init</code> (user/init.c:15)在需要时会创建一个新的控制台设备文件，然后以文件描述符0、1和2的形式打开它。然后它在控制台上启动一个shell。这样系统就启动了。</p><h3 id="2-7-Real-world"><a href="#2-7-Real-world" class="headerlink" title="2.7 Real world"></a>2.7 Real world</h3><p>在现实世界中，既可以找到宏内核，也可以找到微内核。许多Unix内核都是宏内核。例如，Linux的内核，尽管有些操作系统的功能是作为用户级服务器运行的（如windows系统）。L4、Minix和QNX等内核是以服务器的形式组织的微内核，并在嵌入式环境中得到了广泛的部署。大多数操作系统都采用了进程概念，大多数进程都与xv6的相似。</p><p>然而，现代操作系统支持进程可以拥有多个线程，以允许一个进程利用多个CPU。在一个进程中支持多个线程涉及到不少xv6没有的机制，包括潜在的接口变化(如Linux的<code>clone</code>，<code>fork</code>的变种)，以控制线程所共享进程的那些部分。</p><h3 id="2-8-Exercises"><a href="#2-8-Exercises" class="headerlink" title="2.8 Exercises"></a>2.8 Exercises</h3><p>1、你可以使用gdb来观察kernel mode到user mode的第一次转换。运行<code>make qemu-gdb</code>。在同一目录下的另一个窗口中，运行<code>gdb</code>。输入gdb命令<code>break *0x3ffffff10e</code>，这将在内核中跳转到用户空间的<code>sret</code>指令处设置一个断点。输入<code>continue</code> gdb命令，gdb应该在断点处停止，并即将执行<code>sret</code>。gdb现在应该显示它正在地址0x0处执行，该地址在<code>initcode.S</code>的用户空间开始处。</p><hr><ol><li><p><a name="ftn1"></a>与微内核设计理念相对应的理念，这也是一个源自操作系统级别的概念。对于宏内核来说，整个操作系统就是一个整体，包括了进程管理、内存管理、文件系统等等</p></li><li><p><a name="ftn2"></a>本文所说的 “多核 “是指多个共享内存但并行执行的CPU，每个CPU都有自己的一套寄存器。本文有时使用多处理器一词作为多核的同义词，但多处理器也可以更具体地指具有多个不同处理器芯片的计算机。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第一章</title>
      <link href="/2022/08/31/xv6-Chapter-1/"/>
      <url>/2022/08/31/xv6-Chapter-1/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：操作系统接口"><a href="#第一章：操作系统接口" class="headerlink" title="第一章：操作系统接口"></a>第一章：操作系统接口</h2><p>   操作系统的工作是将计算机的资源在多个程序间共享，并且给程序提供一系列比硬件本身支持的更有用的服务。操作系统管理并抽象底层硬件，因此，举例来说，一个文字处理程序不需要去关心自己使用的是何种硬盘。操作系统还对硬件进行多路复用，使多个程序可以同时运行的(或者看起来是同时运行)。最后，操作系统为程序提供了一种可控的交互方式，使得多个程序可以共享数据，共同工作。</p><p>​    操作系统通过接口向用户程序提供服务。设计一个好的接口实际上是很困难的。一方面，我们希望接口简单和精准，这样它就容易正确地实现；另一方面，我们可能又想为应用提供许多更加复杂的功能。解决这种矛盾的诀窍是让接口的设计依赖于一些<em>机制</em> (<em>mechanism)</em>，并通过这些机制的组合来提供通用性。</p><p>​    本书以一个操作系统为例，来说明操作系统的概念。这个操作系统就是xv6，它提供了在Ken Thompson和Dennis Ritchie的Unix操作系统[14]中引入的基本接口，同时也模仿了Unix的内部设计。Unix提供了一个机制组合得非常良好的窄接口，具有惊人的通用性。这样的接口设计非常成功，这也使得BSD，Linux，Mac OS X，Solaris这样的现代操作系统，甚至Windows都有类似Unix的接口。理解xv6是理解这些操作系统的一个良好起点。</p><p>​    如图1.1所示，xv6使用了传统形式的<strong>内核</strong>——一个向其他运行中的程序提供服务的特殊程序。每一个正在运行的程序（称为<strong>进程</strong>），都拥有自己的包含指令、数据、栈的内存空间。指令实现程序的运算，数据是用于运算过程的变量，栈则管理程序的过程调用。一台计算机通常有许多进程，但只有一个内核。</p><p><img src="/img/Figure-1.1.png" alt="Figure-1.1"></p><p>​    当一个进程需要调用一个内核服务时，它就会调用<strong>系统调用</strong>，这是操作系统接口中的一个调用。系统调用会进入内核，让内核执行服务然后返回。所以进程会在用户空间和内核空间之间交替运行。</p><p>​    内核使用CPU<a href="#ftn1">[1]</a>提供的硬件保护机制来确保在用户空间中执行的每个进程只能访问自己的内存。内核运行时拥有硬件特权，可以访问这些受到保护的资源，而用户程序运行时则没有这些特权。当用户程序调用系统调用时，硬件提高特权级别并开始执行内核中预定义的函数。</p><p>内核提供的系统调用集合就是用户程序可见的接口。xv6内核提供了传统Unix内核所提供的服务和系统调用的一个子集。图1.2列出了xv6的所有系统调用。</p><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td><strong>int fork()</strong></td><td>创建一个进程，返回子进程的PID。</td></tr><tr><td><strong>int exit(int status)</strong></td><td>终止当前进程，并将status传递给wait()。不会返回。</td></tr><tr><td><strong>int wait(int *status)</strong></td><td>等待子进程结束，并将status接收到参数*status中，返回其PID。</td></tr><tr><td><strong>int kill(int pid)</strong></td><td>终止给定PID的进程，成功返回0，失败返回-1。</td></tr><tr><td><strong>int getpid()</strong></td><td>返回当前进程的PID。</td></tr><tr><td><strong>int sleep(int n)</strong></td><td>睡眠n个时钟周期。</td></tr><tr><td><strong>int exec(char *file, char *argv[])</strong></td><td>通过给定参数加载并执行一个文件；只在错误时返回。</td></tr><tr><td><strong>char *sbrk(int n)</strong></td><td>使进程内存增加n字节，返回新内存的起始地址。</td></tr><tr><td><strong>int open(char *file, int flags)</strong></td><td>打开一个文件，flags表示读或写，返回fd（文件描述符）。</td></tr><tr><td><strong>int write(int fd, char *buf, int n)</strong></td><td>将buf中n字节写入到文件描述符中；返回n。</td></tr><tr><td><strong>int read(int fd, char *buf, int n)</strong></td><td>从文件描述符中读取n字节到buf；返回读取字节数，文件结束返回0。</td></tr><tr><td><strong>int close(int fd)</strong></td><td>释放文件描述符fd。</td></tr><tr><td><strong>int dup(int fd)</strong></td><td>返回一个新文件描述符，其引用与fd相同的文件。</td></tr><tr><td><strong>int pipe(int p[])</strong></td><td>创建管道，将读/写文件描述符放置在p[0]和p[1]。</td></tr><tr><td><strong>int chdir(char *dir)</strong></td><td>改变当前目录。</td></tr><tr><td><strong>int mkdir(char *dir)</strong></td><td>创建新目录。</td></tr><tr><td><strong>int mknod(char *file, int, int)</strong></td><td>创建新设备文件。</td></tr><tr><td><strong>int fstat(int fd, struct stat *st)</strong></td><td>将打开的文件的信息放置在*st中。</td></tr><tr><td><strong>int stat(char *file, struct stat *st)</strong></td><td>将命名文件信息放置在*st中。</td></tr><tr><td><strong>int link(char *file1, char * file2)</strong></td><td>为文件file1创建一个新的名称(file2)。</td></tr><tr><td><strong>int unlink(char *file)</strong></td><td>移除一个文件。</td></tr></tbody></table></div><p>图1.2  xv6系统调用. 如果没有特别说明, 这些调用成功时返回0，失败时返回-1。</p><p>​    </p><p>​    本章剩下的部分概述了xv6的服务的概貌——进程、内存、文件描述符、管道和文件系统，并通过代码片段对其进行了说明，然后讨论了<strong>shell</strong>（Unix的命令行用户接口）中是如何使用它们的。这些系统调用在shell中的应用说明了系统调用的设计如何精巧。</p><p>​    shell是一个普通的程序，它从用户读取命令并执行它们。shell是一个用户程序，而不是内核的一部分，这一事实说明了系统调用接口的强大：shell没有什么特别之处。这也意味着shell是很容易被替换的;因此，事实上现代Unix系统中有各种各样的shell，每个都有自己的用户界面和脚本特性。xv6 shell是Unix Bourne shell的一个简单实现。它的实现可以在（<code>user/sh.c:1</code>）找到。</p><h3 id="1-1-Processes-and-memory-1-1-进程和内存"><a href="#1-1-Processes-and-memory-1-1-进程和内存" class="headerlink" title="1.1 Processes and memory[1.1 进程和内存]"></a>1.1 Processes and memory[1.1 进程和内存]</h3><p>一个xv6进程由用户空间内存（指令、数据和堆栈）和内核私有的进程状态组成。Xv6对进程提供<strong>分时</strong>特性：它透明地切换当前cpu正在执行的进程。当一个进程暂时不使用cpu时，xv6会保存它的CPU寄存器，在下次运行该进程时恢复它们。内核为每个进程关联一个<strong>PID</strong>(进程标识符)。</p><p> 可以使用<strong>fork</strong>系统调用创建一个新的进程。<strong>fork</strong>创建的新进程被称为<strong>子进程</strong>，其内存内容与调用的进程完全相同，原进程被称为<strong>父进程</strong>。在父进程和子进程中，fork都会返回。在父进程中，fork返回子进程的PID；在子进程中，fork返回0。例如，考虑以下用C编程语言编写的程序片段[6]。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">pid = wait((*<span class="type">int</span>* *)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>exit</strong>系统调用会使得调用它的进程退出，并释放资源，例如内存和打开的文件。<strong>exit</strong>需要一个整数状态参数，通常0表示成功，1表示失败。<strong>wait</strong>系统调用返回当前进程的一个已退出（或被杀死）的子进程的PID，并将该子进程的退出状态码复制到一个地址，该地址由wait参数提供；如果调用者的子进程都没有退出，则<strong>wait</strong>等待一个子进程退出。如果调用者没有子进程，wait立即返回-1。如果父进程不关心子进程的退出状态，可以传递一个0地址给wait。</p><p>​    在上面的例子中，输出为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br></pre></td></tr></table></figure><p>可能会以任何一种顺序输出，这取决于是父进程还是子进程先执行它的<strong>printf</strong>调用。在子程序退出后，父进程的<strong>wait</strong>返回，父进程打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child 1234 is done</span><br></pre></td></tr></table></figure><p>虽然子进程最初与父进程拥有相同的内存内容，但父进程和子进程是在不同的内存和不同的寄存器中执行的：改变其中一个进程中的变量不会影响另一个进程。例如，当<strong>wait</strong>的返回值存储到父进程的<strong>pid</strong>变量中时，并不会改变子进程中的变量<strong>pid</strong>。子进程中的<strong>pid</strong>值仍然为零。</p><p><strong>exec</strong>系统调用使用新内存映像来替换进程的内存， 新内存映像从文件系统中的文件中进行读取。这个文件必须有特定的格式，它指定了文件中哪部分存放指令，哪部分是数据，在哪条指令开始，等等。xv6使用ELF格式，第3章将详细讨论。当<strong>exec</strong>成功时，它并不返回到调用程序；相反，从文件中加载的指令在ELF头声明的入口点开始执行。<strong>exec</strong>需要两个参数：包含可执行文件的文件名和一个字符串参数数组。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>  上述代码会执行/bin/echo程序，并将argv数组作为参数。大多数程序都会忽略参数数组的第一个元素，也就是程序名称。</p><p>xv6 shell使用上述调用来在用户空间运行程序。shell的主结构很简单，参见<strong>main</strong>(user/sh.c:145)。主循环用<strong>getcmd</strong>读取用户的一行输入，然后调用<strong>fork</strong>，创建shell副本。父进程调用wait，而子进程则运行命令。例如，如果用户向shell输入了<strong>echo hello</strong>，那么就会调用<strong>runcmd</strong>，参数为<strong>echo hello</strong>。<strong>runcmd</strong> (user/sh.c:58) 运行实际的命令。对于<strong>echo hello</strong>，它会调用<strong>exec</strong> (user/sh.c:78)。如果<strong>exec</strong>成功，那么子进程将执行echo程序的指令，而不是<strong>runcmd</strong>的。在某些时候，<strong>echo</strong>会调用<strong>exit</strong>，这将使父程序从main(user/sh.c:145)中的<strong>wait</strong>返回。</p><p> 你可能会奇怪为什么<strong>fork</strong>和<strong>exec</strong>没有结合在一次调用中，我们后面会看到shell在实现I/O重定向时利用了这种分离的特性。为了避免创建相同进程并立即替换它（使用exec）所带来的浪费，内核通过使用虚拟内存技术（如copy-on-write）来优化这种用例的fork实现（见4.6节）。</p><p>Xv6隐式分配大部分用户空间内存：<strong>fork</strong>复制父进程的内存到子进程，<strong>exec</strong>分配足够的内存来容纳可执行文件。一个进程如果在运行时需要更多的内存（可能是为了<strong>malloc</strong>），可以调用sbrk(n)将其数据内存增长n个字节；sbrk返回新内存的位置。</p><h3 id="1-2-I-O-and-File-descriptors-1-2-I-O-和文件描述符"><a href="#1-2-I-O-and-File-descriptors-1-2-I-O-和文件描述符" class="headerlink" title="1.2 I/O and File descriptors[1.2 I/O 和文件描述符]"></a>1.2 I/O and File descriptors[1.2 I/O 和文件描述符]</h3><p><strong>文件描述符</strong>是一个小整数，代表一个可由进程读取或写入的内核管理对象。一个进程可以通过打开一个文件、目录、设备，或者通过创建一个管道，或者通过复制一个现有的描述符来获得一个文件描述符。为了简单起见，我们通常将文件描述符所指向的对象称为文件；文件描述符接口将文件、管道和设备之间的差异抽象化，使它们看起来都像字节流。我们把输入和输出称为<strong>I/O</strong>。</p><p>在内部，xv6内核为每一个进程单独维护一个以文件描述符为索引的表，因此每个进程都有一个从0开始的文件描述符私有空间。按照约定，一个进程从文件描述符0(标准输入)读取数据，向文件描述符1(标准输出)写入输出，向文件描述符2(标准错误)写入错误信息。正如我们将看到的那样，shell利用这个约定来实现I/O重定向和管道。shell确保自己总是有三个文件描述符打开（user/sh.c:151），这些文件描述符默认是控制台的文件描述符。</p><p><strong>read</strong>/<strong>write</strong>系统调用可以从文件描述符指向的文件读写数据。调用<strong>read(fd, buf, n)</strong>从文件描述符<strong>fd</strong>中读取不超过<strong>n</strong>个字节的数据，将它们复制到<strong>buf</strong>中，并返回读取的字节数。每个引用文件的文件描述符都有一个与之相关关联偏移量。<strong>read</strong>从当前文件偏移量中读取数据，然后按读取的字节数推进偏移量，随后的<strong>read</strong>将返回上次读取之后的数据。当没有更多的字节可读时，读返回零，表示文件结束。</p><p><strong>write(fd, buf, n)</strong>表示将<strong>buf</strong>中的<strong>n</strong>个字节写入文件描述符<strong>fd</strong>中，并返回写入的字节数。若写入字节数小于n则该次写入发生错误。和<strong>read</strong>一样，<strong>write</strong>在当前文件偏移量处写入数据，然后按写入的字节数将偏移量向前推进：每次<strong>write</strong>都从上一次写入的地方开始。</p><p>下面的程序片段(程序<strong>cat</strong>的核心代码)将数据从其标准输入复制到其标准输出。如果出现错误，它会向标准错误写入一条消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">    n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write(<span class="number">1</span>, buf, n) != n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码片段中，需要注意的是，<strong>cat</strong>不知道它是从文件、控制台还是管道中读取的。同样，<strong>cat</strong>也不知道它是在打印到控制台、文件还是其他什么地方。文件描述符的使用和0代表输入，1代表输出的约定，使得<strong>cat</strong>可以很容易实现。</p><p><strong>close</strong>系统调用会释放一个文件描述符，使它可以被以后的<strong>open</strong>、<strong>pipe</strong>或<strong>dup</strong>系统调用所重用（见下文）。新分配的文件描述符总是当前进程中最小的未使用描述符。</p><p>文件描述符和<strong>fork</strong>相互作用，使I/O重定向易于实现。<strong>fork</strong>将父进程的文件描述符表和它的内存一起复制，这样子进程开始时打开的文件和父进程完全一样。系统调用<strong>exec</strong>替换调用进程的内存，但会保留文件描述符表。这种行为允许shell通过<strong>fork</strong>实现I/O重定向，在子进程中重新打开所选的文件描述符，然后调用<strong>exec</strong>运行新程序。下面是shell运行<strong>cat &lt; input.txt</strong>命令的简化版代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>);  <span class="comment">// 释放标准输入的文件描述符</span></span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);  <span class="comment">// 这时input.txt的文件描述符为0</span></span><br><span class="line">    <span class="comment">// 即标准输入为input.txt</span></span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv);  <span class="comment">// cat从0读取，并输出到1，见上个代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子进程关闭文件描述符0后，<strong>open</strong>保证对新打开的<strong>input.txt</strong>使用该文件描述符0。因为此时0将是最小的可用文件描述符。然后<strong>cat</strong>执行时，文件描述符0（标准输入）会指向<strong>input.txt</strong>。这不会改变父进程的文件描述符，它只会修改子进程的描述符。</p><p>xv6 shell中的I/O重定向代码正是以这种方式工作的（user/sh.c:82）。回想一下shell的代码，shell已经<strong>fork</strong>子shell，<strong>runcmd</strong>将调用<strong>exec</strong>来加载新的程序。</p><p><strong>open</strong>的第二个参数由一组用位表示的标志组成，用来控制<strong>open</strong>的工作。可能的值在文件控制(fcntl)头(kernel/fcntl.h:1-5)中定义。<strong>O_RDONLY,</strong> <strong>O_WRONLY,</strong> <strong>O_RDWR</strong>, <strong>O_CREATE</strong>, 和 <strong>O_TRUNC,</strong> 它们分别指定open打开文件时的功能，读、写、读和写、如果文件不存在则创建文件、将文件长度截断为0。</p><p>现在应该清楚为什么<strong>fork</strong>和<strong>exec</strong>是分开调用的：在这两个调用之间，shell有机会重定向子进程的I/O，而不干扰父进程的I/O设置。我们可以假设一个由<strong>fork</strong>和<strong>exec</strong>组成的系统调用<strong>forkexec</strong>，但是用这种调用来做I/O重定向似乎很笨拙。shell在调用<strong>forkexec</strong>之前修改自己的I/O设置（然后取消这些修改），或者<strong>forkexec</strong>可以将I/O重定向的指令作为参数，或者（最糟糕的方案）每个程序（比如cat）都需要自己做I/O重定向。</p><p>虽然<strong>fork</strong>复制了文件描述符表，但每个底层文件的偏移量都是父子共享的。想一想下面的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个片段的最后，文件描述符1所引用的文件将包含数据hello world。父进程中的<strong>write</strong>（由于有了<strong>wait</strong>，只有在子进程结束后才会运行）会从子进程的<strong>write</strong>结束的地方开始。这种行为有助于从shell命令的序列中产生有序的输出，比如<strong>(echo hello; echo world) &gt;output.txt</strong>。</p><p><strong>dup</strong>系统调用复制一个现有的文件描述符，返回一个新的描述符，它指向同一个底层I/O对象。两个文件描述符共享一个偏移量，就像被<strong>fork</strong>复制的文件描述符一样。这是将hello world写进文件的另一种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>如果两个文件描述符是通过一系列的<strong>fork</strong>和<strong>dup</strong>调用从同一个原始文件描述符衍生出来的，那么这两个文件描述符共享一个偏移量。否则，文件描述符不共享偏移量，即使它们是由同一个文件的打开调用产生的。<strong>dup</strong>允许shell实现这样的命令：l<strong>s existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</strong>。2&gt;&amp;1表示2是1的复制（<strong>dup(1)</strong>），即重定向错误信息到标准输出，已存在文件的名称和不存在文件的错误信息都会显示在文件tmp1中。xv6 shell不支持错误文件描述符的I/O重定向，但现在你知道如何实现它了。</p><p>文件描述符是一个强大的抽象，因为它们隐藏了它们连接的细节：一个向文件描述符1写入的进程可能是在向一个文件、控制台等设备或向一个管道写入。</p><h3 id="1-3-Pipes-1-3-管道"><a href="#1-3-Pipes-1-3-管道" class="headerlink" title="1.3 Pipes[1.3 管道]"></a>1.3 Pipes[1.3 管道]</h3><p><strong>管道</strong>是一个小的内核缓冲区，作为一对文件描述符提供给进程，一个用于读，一个用于写。将数据写入管道的一端就可以从管道的另一端读取数据。管道为进程提供了一种通信方式。</p><p>下面的示例代码运行程序wc，标准输入连接到管道的读取端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>);  <span class="comment">// 释放文件描述符0</span></span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// 复制一个p[0](管道读端)，此时文件描述符0（标准输入）也引用管道读端，故改变了标准输入。</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv); <span class="comment">// wc 从标准输入读取数据，并写入到参数中的每// 一个文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序调用<strong>pipe</strong>，创建一个新的管道，并将读写文件描述符记录在数组<strong>p</strong>中，经过<strong>fork</strong>后，父进程和子进程的文件描述符都指向管道。子进程调用<strong>close</strong>和<strong>dup</strong>使文件描述符0引用管道的读端，并关闭p中的文件描述符，并调用<strong>exec</strong>运行<strong>wc</strong>。当<strong>wc</strong>从其标准输入端读取时，它将从管道中读取。父进程关闭管道的读端，向管道写入，然后关闭写端。</p><p>如果没有数据可用，管道上的<strong>read</strong>会等待数据被写入，或者等待所有指向写端的文件描述符被关闭；在后一种情况下，读将返回0，就像数据文件的结束一样。事实上，如果没有数据写入，读会无限阻塞，直到新数据不可能到达为止（写端被关闭），这也是子进程在执行上面的<strong>wc</strong>之前关闭管道的写端很重要的一个原因：如果wc的一个文件描述符仍然引用了管道的写端，那么<strong>wc</strong>将永远看不到文件的关闭（被自己阻塞）。</p><p>xv6的shell实现了管道，如<strong>grep fork sh.c | wc -l</strong>，shell的实现类似于上面的代码（user/sh.c:100）。执行shell的子进程创建一个管道来连接管道的左端和右端（去看源码，不看难懂）。然后，它在管道左端（写入端）调用<strong>fork</strong>和<strong>runcmd</strong>，在右端（读取端）调用<strong>fork</strong>和<strong>runcmd</strong>，并等待两者结束。管道的右端（读取端）可以是一个命令，也可以是包含管道的多个命令（例如，<strong>a | b | c</strong>），它又会分叉为两个新的子进程（一个是<strong>b</strong>，一个是<strong>c</strong>）。因此，shell可以创建一棵进程树。这棵树的叶子是命令，内部（非叶子）节点是等待左右子进程结束的进程。</p><p>原则上，我们可以让内部节点（非叶节点）运行管道的左端，但这样的实现会更加复杂。考虑只做以下修改：修改sh.c，使其不为<strong>runcmd(p-&gt;left)</strong>  fork进程，直接递归运行<strong>runcmd(p-&gt;left)</strong>。像这样，<strong>echo hi | wc</strong>不会产生输出，因为当<strong>echo hi</strong>在<strong>runcmd</strong>中退出时，内部进程会退出，而不会调用<strong>fork</strong>来运行管道的右端。这种不正确的行为可以通过不在<strong>runcmd</strong>中为内部进程调用<strong>exit</strong>来修正，但是这种修正会使代码变得复杂：<strong>runcmd</strong>需要知道该进程是否是内部进程（非叶节点）。当不为<strong>runcmd(p-&gt;right)</strong>  <strong>fork</strong>进程时，也会出现复杂的情况。像这样的修改，<strong>sleep 10 | echo hi</strong>就会立即打印出hi，而不是10秒后，因为<strong>echo</strong>会立即运行并退出，而不是等待<strong>sleep</strong>结束。由于sh.c的目标是尽可能的简单，所以它并没有试图避免创建内部进程。</p><p>管道似乎没有比临时文件拥有更多的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world | wc</span><br></pre></td></tr></table></figure><p>不使用管道：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</span><br></pre></td></tr></table></figure><p>在这种情况下，管道比临时文件至少有四个优势。首先，管道会自动清理自己；如果是文件重定向，shell在完成后必须小心地删除/tmp/xyz。第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。第三，管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。第四，如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。</p><h3 id="1-4-File-system-1-4-文件系统"><a href="#1-4-File-system-1-4-文件系统" class="headerlink" title="1.4 File system[1.4 文件系统]"></a>1.4 File system[1.4 文件系统]</h3><p>xv6文件系统包含了数据文件（拥有字节数组）和目录（拥有对数据文件和其他目录的命名引用）。这些目录形成一棵树，从一个被称为根目录的特殊目录开始。像<strong>/a/b/c</strong>这样的路径指的是根目录<strong>/</strong>中的<strong>a</strong>目录中的<strong>b</strong>目录中的名为<strong>c</strong>的文件或目录。不以<strong>/</strong>开头的路径是相对于调用进程的当前目录进行计算其绝对位置的，可以通过<strong>chdir</strong>系统调用来改变进程的当前目录。下面两个<strong>open</strong>打开了同一个文件（假设所有涉及的目录都存在）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p>前两行将进程的当前目录改为<strong>/a/b</strong>；后面两行既不引用也不改变进程的当前目录。</p><p>有一些系统调用来可以创建新的文件和目录：<strong>mkdir</strong>创建一个新的目录，用<strong>open</strong>加上<strong>O_CREATE</strong>标志创建并打开一个新的数据文件，以及<strong>mknod</strong>创建一个新的设备文件。这个例子说明了这三个系统调用的使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>mknod</strong>创建了一个引用设备的特殊文件。与设备文件相关联的是主要设备号和次要设备号(<strong>mknod</strong>的两个参数)，它们唯一地标识一个内核设备。当一个进程打开设备文件后，内核会将系统的读写调用转移到内核设备实现上，而不是将它们传递给文件系统。</p><p>文件名称与文件是不同的；底层文件（非磁盘上的文件）被称为<strong>inode</strong>，一个inode可以有多个名称，称为<strong>链接</strong>。每个链接由目录中的一个项组成；该项包含一个文件名和对inode的引用。inode保存着一个文件的<strong><em>metadata\</em></strong>（元数据），包括它的类型（文件或目录或设备），它的长度，文件内容在磁盘上的位置，以及文件的链接数量。</p><p><strong>fstat</strong>系统调用从文件描述符引用的inode中检索信息。它定义在<strong>stat.h</strong> (kernel/stat.h)的 <strong>stat</strong> 结构中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1    <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     <span class="comment">// File system’s disk device</span></span><br><span class="line">    uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">    <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">    <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">    uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>link</strong>系统调用创建了一个引用了同一个inode的文件（文件名）。下面的片段创建了引用了同一个inode两个文件a和b。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><p>读写a与读写b是一样的，每个inode都有一个唯一的inode号来标识。经过上面的代码序列后，可以通过检查fstat的结果来确定a和b指的是同一个底层内容：两者将返回相同的inode号（<strong>ino</strong>），并且nlink计数为2。</p><p><strong>unlink</strong>系统调用会从文件系统中删除一个文件名。只有当文件的链接数为零且没有文件描述符引用它时，文件的inode和存放其内容的磁盘空间才会被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面这行代码会删除a，此时只有b会引用inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE | O_RDWR);</span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>);</span><br></pre></td></tr></table></figure><p>这段代码是创建一个临时文件的一种惯用方式，它创建了一个无名称inode，故会在进程关闭<strong>fd</strong>或者退出时删除文件。</p><p>Unix提供了shell可调用的文件操作程序，作为用户级程序，例如<strong>mkdir</strong>、<strong>ln</strong>和<strong>rm</strong>。这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。现在看来，这个设计似乎是显而易见的，但在Unix时期设计的其他系统通常将这类命令内置到shell中（并将shell内置到内核中）。</p><p>有一个例外，那就是cd，它是在shell中实现的 (user/sh.c:160)。cd 必须改变 shell 自身的当前工作目录。如果cd作为一个普通命令执行，那么shell就会fork一个子进程，而子进程会运行cd，cd只会改变子进程的当前工作目录。父进程（即shell）的工作目录则保持不变。</p><h3 id="1-5-Real-world-1-5-现实情况"><a href="#1-5-Real-world-1-5-现实情况" class="headerlink" title="1.5 Real world[1.5 现实情况]"></a>1.5 Real world[1.5 现实情况]</h3><p>Unix将标准文件描述符、管道和方便的shell语法结合起来进行操作，是编写通用可重用程序的一大进步。这个想法引发了一种“软件工具”文化，这也是Unix强大和流行的主要原因，而shell是第一种所谓的脚本语言。Unix系统调用接口今天仍然存在于BSD、Linux和Mac OS X等操作系统中。</p><p>Xv6并不符合 POSIX 标准：它缺少许多系统调用（包括基本的系统调用，如 <strong>lseek</strong>），而且它提供的许多系统调用与标准不同。我们对xv6的主要目标是简单明了，同时提供一个简单的类似UNIX的系统调用接口。一些人已经添加了一些系统调用和一个简单的C库扩展了xv6，以便运行基本的Unix程序。然而，现代内核比xv6提供了更多的系统调用和更多种类的内核服务。例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。现代内核不断快速发展，并提供了许多超越POSIX的功能。</p><p>Unix用一套文件名和文件描述符接口统一了对多种类型资源（文件、目录和设备）的访问。这个思想可以扩展到更多种类的资源，一个很好的例子是Plan 9项目[13]，它把资源就是文件的概念应用到网络、图形等方面。然而，大多数Unix衍生的操作系统都没有遵循这一路线。</p><p>文件系统和文件描述符已经是强大的抽象。即便如此，操作系统接口还有其他模式。Multics是Unix的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，产生了一种截然不同的接口。Multics设计的复杂性直接影响了Unix的设计者，他们试图建立一些更简单的东西。</p><p>Xv6没有用户系统；用Unix的术语来说，所有的xv6进程都以root身份运行。</p><p>本书研究的是xv6如何实现其类似Unix的接口，但其思想和概念不仅仅适用于Unix。任何操作系统都必须将进程复用到底层硬件上，将进程相互隔离，并提供受控进程间通信的机制。在学习了xv6之后，您应该能够研究其他更复杂的操作系统，并在这些系统中看到xv6中蕴含的基本概念。</p><h3 id="1-6-Exercises-1-6-练习"><a href="#1-6-Exercises-1-6-练习" class="headerlink" title="1.6 Exercises[1.6 练习]"></a>1.6 Exercises[1.6 练习]</h3><ol><li>使用UNIX的系统调用编写一个程序，通过一对管道在两个进程之间交换一个字节，每个方向各一个。以交换次数/秒为单位测量程序的性能。</li></ol><hr><ol><li><a name="ftn1"></a>本文一般用CPU中央处理单元的缩写来指代执行计算的硬件单元。其他文本(如RISC-V规范)也使用processor、core和hart等词代替CPU。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 riscv book 中文版声明</title>
      <link href="/2022/08/31/xv6-Chapter-0/"/>
      <url>/2022/08/31/xv6-Chapter-0/</url>
      
        <content type="html"><![CDATA[<h1 id="xv6-riscv-book-Chinese"><a href="#xv6-riscv-book-Chinese" class="headerlink" title="xv6-riscv-book-Chinese"></a>xv6-riscv-book-Chinese</h1><p>本项目是MIT 6.S081与6.828课程用书xv6-riscv-book的中文翻译。</p><p>此版翻译基于<a href="https://github.com/pleasewhy/xv6-book-2020-Chinese">xv6-book-2020-Chinese</a>修改与校对完成，全部内容转为Markdown格式。</p><p><strong>如果您在阅读过程中发现翻译中有任何错误或可以改进的地方，欢迎提出issue或pull request。</strong></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>操作系统接口（Operating system interfaces）</li><li>操作系统组织（Operating system organization）</li><li>页表（Page tables）</li><li>陷阱和系统调用（Traps and system calls）</li><li>中断和设备驱动（Interrupts and device drivers）</li><li>锁（Locking）</li><li>调度（Scheduling）</li><li>文件系统（FIle system）</li><li>并发（Concurrency revisited）</li></ol><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>以下人员参与了此版中文xv6-book的主要翻译与校对工作。</p><p>王辉宇，臧振宇，丁睿，何思齐，刘雨俊，刘俊豪，陈冬，杭心语，刘又铭，贾子菡，仲殷旻。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://pdos.csail.mit.edu/6.828/2020/index.html">MIT课程地址</a></li><li><a href="https://github.com/mit-pdos/xv6-riscv">xv6-riscv Github repository</a></li><li><a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">英文原版xv6-riscv-book-rev1</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6实验1</title>
      <link href="/2022/08/30/xv6-lab1/"/>
      <url>/2022/08/30/xv6-lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>在 UPROGS 项中最后一行添加 $U/_sleep\<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br><span class="line">$U/_sleep\</span><br></pre></td></tr></table></figure></p><p>sleep.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;(nothing happens for a little while)\n&quot;</span>);</span><br><span class="line">sleep(atoi((<span class="type">const</span> <span class="type">char</span>*) argv[<span class="number">1</span>])); <span class="comment">// convert ascii to integer and use system call sleep</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage:sleep number...\n&quot;</span>);  <span class="comment">// put the error masssage to the file descriptor 2</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// terminate the process, </span></span><br><span class="line">    <span class="comment">// status = 1: indicates failure, and reported to wait() </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>在 UPROGS 项中最后一行添加 $U/_pingpong\</p><p>pingpong.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p1[<span class="number">2</span>]; <span class="comment">// parent -&gt; child</span></span><br><span class="line"><span class="type">int</span> p2[<span class="number">2</span>]; <span class="comment">// child -&gt; parent</span></span><br><span class="line"><span class="type">char</span> buffer[] = &#123;<span class="string">&#x27;x&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(buffer);</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: pingpong\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pipe(p1);</span><br><span class="line">pipe(p2);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123; <span class="comment">// child</span></span><br><span class="line">close(p1[<span class="number">1</span>]);</span><br><span class="line">close(p2[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(read(p1[<span class="number">0</span>], buffer, length) == <span class="number">1</span>)&#123;  <span class="comment">// child receives the byte</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">write(p2[<span class="number">1</span>], buffer, length);     <span class="comment">// child sends the byte to child</span></span><br><span class="line">close(p2[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(p2[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  <span class="comment">// parent</span></span><br><span class="line">close(p1[<span class="number">0</span>]);</span><br><span class="line">close(p2[<span class="number">1</span>]);</span><br><span class="line">write(p1[<span class="number">1</span>], buffer,  length); <span class="comment">// parent sends a byte to the child</span></span><br><span class="line">close(p1[<span class="number">1</span>]);</span><br><span class="line">wait((<span class="type">int</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(read(p2[<span class="number">0</span>], buffer, length) == <span class="number">1</span>)&#123;  <span class="comment">// parent receives the byte</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>在 UPROGS 项中最后一行添加 $U/_primes\</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">close_pipe</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">primes</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n, p, len;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the frist number from previous prime </span></span><br><span class="line"><span class="keyword">if</span> ((len = read(<span class="number">0</span>, &amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// print first number to console</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, n);</span><br><span class="line">  </span><br><span class="line">pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">dup(fd[<span class="number">0</span>]);  <span class="comment">// link the std i/o 0 to fd[0] </span></span><br><span class="line">close_pipe(fd);</span><br><span class="line">primes();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;      <span class="comment">// parent process</span></span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">dup(fd[<span class="number">1</span>]); <span class="comment">// link the std i/o 1 to fd[1]</span></span><br><span class="line">close_pipe(fd); </span><br><span class="line"><span class="keyword">while</span> ((len = read(<span class="number">0</span>, &amp;p, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &gt; <span class="number">0</span> &amp;&amp; p &gt; <span class="number">0</span>) &#123;  <span class="comment">// read the number from the prime</span></span><br><span class="line"><span class="keyword">if</span> (p % n != <span class="number">0</span>) &#123;</span><br><span class="line"> write(<span class="number">1</span>, &amp;p, <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// filter the number</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">wait((<span class="type">int</span> *)<span class="number">0</span>);   </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">  </span><br><span class="line">pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// child process</span></span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">dup(fd[<span class="number">0</span>]);  <span class="comment">// link the std i/o 0 to the fd[0]</span></span><br><span class="line">close_pipe(fd);</span><br><span class="line"> primes();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">dup(fd[<span class="number">1</span>]);  <span class="comment">// link the std i/o 1 to the fd[1]</span></span><br><span class="line">close_pipe(fd);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">write(<span class="number">1</span>, &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">wait((<span class="type">int</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>在 UPROGS 项中最后一行添加 $U/_find\</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span>  <span class="comment">// 将路径格式化为文件名</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find first character after last slash. 从字符串末尾开始遍历，直到遇到&#x27;/&#x27;或者到字符串的头部为止</span></span><br><span class="line"><span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--) ;</span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return blank-padded name.</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)  <span class="comment">// 字符串太长了</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">memmove(buf, p, <span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *file)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 路径不存在</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;   <span class="comment">// 获取不了该路径的状态</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line"><span class="keyword">case</span> T_FILE:  <span class="comment">// 如果这是一个文件</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(fmtname(path), file) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> T_DIR: <span class="comment">// 如果这是一个目录</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;  <span class="comment">// 路径太长，缓冲区装不下</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path); </span><br><span class="line">p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">*p++ = <span class="string">&#x27;/&#x27;</span>;  <span class="comment">// 在路径末尾添加&#x27;/&#x27;</span></span><br><span class="line"><span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;  <span class="comment">// 从该路径读取出文件名或者目录名</span></span><br><span class="line"><span class="keyword">if</span>(de.inum == <span class="number">0</span> || de.inum == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">memmove(p, de.name, DIRSIZ);  <span class="comment">// 在路径后面添加文件名or目录</span></span><br><span class="line">p[DIRSIZ] = <span class="number">0</span>;      <span class="comment">// the end of string is &#x27;\0&#x27;</span></span><br><span class="line">find(buf, file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find &lt;path&gt; &lt;file&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>在 UPROGS 项中最后一行添加 $U/_xargs\</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *arguments[MAXARG];</span><br><span class="line"><span class="type">char</span> buff[<span class="number">255</span>];</span><br><span class="line"><span class="type">char</span> *p = buff, *q = buff;</span><br><span class="line"><span class="type">int</span> i, offset;</span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: xargc &lt;command&gt;...\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;  <span class="comment">// get the command which is behind the &quot;xargs&quot;</span></span><br><span class="line">  arguments[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">&#125;</span><br><span class="line">i = i - <span class="number">1</span>;</span><br><span class="line">offset = i;  <span class="comment">// backup</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(read(<span class="number">0</span>, p, <span class="number">1</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(*p == <span class="string">&#x27;\n&#x27;</span>)&#123;  <span class="comment">// meet the &#x27;\n&#x27; and execute it with arguments</span></span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    arguments[i] = q;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    exec(arguments[<span class="number">0</span>], arguments);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    wait((<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">    p = buff;</span><br><span class="line">    q = p;</span><br><span class="line">    i = offset;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="string">&#x27; &#x27;</span> || *p == <span class="string">&#x27;\t&#x27;</span>)&#123;  <span class="comment">// meet the &#x27; &#x27; or &#x27;\t&#x27;, find an argument</span></span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    arguments[i] = q;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    p = p + <span class="number">1</span>;</span><br><span class="line">    q = p; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    p = p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="git查看修改记录"><a href="#git查看修改记录" class="headerlink" title="git查看修改记录"></a>git查看修改记录</h2><p>查看文件的变化<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu:~/xv6-labs-2020$ git diff origin/util util --stat</span><br><span class="line"> Makefile        |   5 +++++</span><br><span class="line"> gradelib.pyc    | Bin 0 -&gt; 22972 bytes</span><br><span class="line"> user/find.c     |  84 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> user/pingpong.c |  40 ++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> user/primes.c   |  67 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> user/sleep.c    |  17 +++++++++++++++++</span><br><span class="line"> user/xargs.c    |  47 +++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> 7 files changed, 260 insertions(+)</span><br></pre></td></tr></table></figure></p><hr><p>查看具体修改内容<code>git diff origin/util util</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index 0fbaf7c..b2addd4 100644</span><br><span class="line">--- a/Makefile</span><br><span class="line">+++ b/Makefile</span><br><span class="line">@@ -149,6 +149,11 @@ UPROGS=\</span><br><span class="line"> $U/_grind\</span><br><span class="line"> $U/_wc\</span><br><span class="line"> $U/_zombie\</span><br><span class="line">+$U/_sleep\</span><br><span class="line">+$U/_pingpong\</span><br><span class="line">+$U/_find\</span><br><span class="line">+$U/_xargs\</span><br><span class="line">+$U/_primes\</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> ifeq ($(LAB),syscall)</span><br><span class="line">diff --git a/gradelib.pyc b/gradelib.pyc</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..634a0f3</span><br><span class="line">Binary files /dev/null and b/gradelib.pyc differ</span><br><span class="line">diff --git a/user/find.c b/user/find.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..8070f86</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/find.c</span><br><span class="line">@@ -0,0 +1,84 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;kernel/stat.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+#include &quot;kernel/fs.h&quot;</span><br><span class="line">+</span><br><span class="line">+char*</span><br><span class="line">+fmtname(char *path)  // 将路径格式化为文件名</span><br><span class="line">+&#123;</span><br><span class="line">+  static char buf[DIRSIZ+1];</span><br><span class="line">+  char *p;</span><br><span class="line">+</span><br><span class="line">+  // Find first character after last slash. 从字符串末尾开始遍历，直到遇到&#x27;/&#x27;或者到字符串的头部为止</span><br><span class="line">+  for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != &#x27;/&#x27;; p--) ;</span><br><span class="line">+  p++;</span><br><span class="line">+</span><br><span class="line">+  // Return blank-padded name.</span><br><span class="line">+  if(strlen(p) &gt;= DIRSIZ)  // 字符串太长了</span><br><span class="line">+    return p;</span><br><span class="line">+  memmove(buf, p, strlen(p)+1);</span><br><span class="line">+  return buf;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+void</span><br><span class="line">+find(char *path, char *file)</span><br><span class="line">+&#123;</span><br><span class="line">+  char buf[512], *p;</span><br><span class="line">+  int fd;</span><br><span class="line">+  struct dirent de;</span><br><span class="line">+  struct stat st;</span><br><span class="line">+</span><br><span class="line">+  if((fd = open(path, 0)) &lt; 0)&#123;  // 路径不存在</span><br><span class="line">+    fprintf(2, &quot;find: cannot open %s\n&quot;, path);</span><br><span class="line">+    return;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  if(fstat(fd, &amp;st) &lt; 0)&#123;   // 获取不了该路径的状态</span><br><span class="line">+    fprintf(2, &quot;find: cannot stat %s\n&quot;, path);</span><br><span class="line">+    close(fd);</span><br><span class="line">+    return;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  switch(st.type)&#123;</span><br><span class="line">+  case T_FILE:  // 如果这是一个文件</span><br><span class="line">+    if(strcmp(fmtname(path), file) == 0)&#123;</span><br><span class="line">+printf(&quot;%s\n&quot;, path);</span><br><span class="line">+&#125;</span><br><span class="line">+    break;</span><br><span class="line">+</span><br><span class="line">+  case T_DIR: // 如果这是一个目录</span><br><span class="line">+    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;  // 路径太长，缓冲区装不下</span><br><span class="line">+      printf(&quot;find: path too long\n&quot;);</span><br><span class="line">+      break;</span><br><span class="line">+    &#125;</span><br><span class="line">+    strcpy(buf, path); </span><br><span class="line">+    p = buf+strlen(buf);</span><br><span class="line">+    *p++ = &#x27;/&#x27;;  // 在路径末尾添加&#x27;/&#x27;</span><br><span class="line">+    while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123;  // 从该路径读取出文件名或者目录名</span><br><span class="line">+      if(de.inum == 0 || de.inum == 1)</span><br><span class="line">+        continue;</span><br><span class="line">+      if (strcmp(de.name, &quot;.&quot;) == 0 || strcmp(de.name, &quot;..&quot;) == 0)</span><br><span class="line">+        continue;</span><br><span class="line">+      memmove(p, de.name, DIRSIZ);  // 在路径后面添加文件名or目录</span><br><span class="line">+      p[DIRSIZ] = 0;      // the end of string is &#x27;\0&#x27;</span><br><span class="line">+      find(buf, file);</span><br><span class="line">+    &#125;</span><br><span class="line">+    break;</span><br><span class="line">+</span><br><span class="line">+  default:</span><br><span class="line">+    break;</span><br><span class="line">+  &#125;</span><br><span class="line">+  close(fd);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(int argc, char *argv[])</span><br><span class="line">+&#123;</span><br><span class="line">+if(argc != 3)&#123;</span><br><span class="line">+fprintf(2, &quot;Usage: find &lt;path&gt; &lt;file&gt;\n&quot;);</span><br><span class="line">+exit(1);</span><br><span class="line">+&#125;</span><br><span class="line">+find(argv[1], argv[2]);</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/user/pingpong.c b/user/pingpong.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..caecc4b</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/pingpong.c</span><br><span class="line">@@ -0,0 +1,40 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;kernel/stat.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(int argc, char *argv[])</span><br><span class="line">+&#123;</span><br><span class="line">+int p1[2]; // parent -&gt; child</span><br><span class="line">+int p2[2]; // child -&gt; parent</span><br><span class="line">+    char buffer[] = &#123;&#x27;x&#x27;&#125;;</span><br><span class="line">+    int length = sizeof(buffer);</span><br><span class="line">+if(argc != 1)&#123;</span><br><span class="line">+fprintf(2, &quot;Usage: pingpong\n&quot;);</span><br><span class="line">+exit(1);</span><br><span class="line">+&#125;</span><br><span class="line">+pipe(p1);</span><br><span class="line">+pipe(p2);</span><br><span class="line">+if(fork() == 0)&#123; // child</span><br><span class="line">+close(p1[1]);</span><br><span class="line">+close(p2[0]);</span><br><span class="line">+if(read(p1[0], buffer, length) == 1)&#123;  // child receives the byte</span><br><span class="line">+printf(&quot;%d: received ping\n&quot;, getpid());</span><br><span class="line">+write(p2[1], buffer, length);     // child sends the byte to child</span><br><span class="line">+close(p2[1]);</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">+close(p2[1]);</span><br><span class="line">+exit(1);</span><br><span class="line">+&#125;else&#123;  // parent</span><br><span class="line">+close(p1[0]);</span><br><span class="line">+close(p2[1]);</span><br><span class="line">+write(p1[1], buffer,  length); // parent sends a byte to the child</span><br><span class="line">+close(p1[1]);</span><br><span class="line">+wait((int *)0);</span><br><span class="line">+if(read(p2[0], buffer, length) == 1)&#123;  // parent receives the byte</span><br><span class="line">+printf(&quot;%d: received pong\n&quot;, getpid());</span><br><span class="line">+&#125;</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/user/primes.c b/user/primes.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..6f9180e</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/primes.c</span><br><span class="line">@@ -0,0 +1,67 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+</span><br><span class="line">+void</span><br><span class="line">+close_pipe(int *p) &#123;</span><br><span class="line">+  close(p[0]);</span><br><span class="line">+  close(p[1]);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+void</span><br><span class="line">+primes() &#123;</span><br><span class="line">+  int n, p, len;</span><br><span class="line">+  int fd[2];</span><br><span class="line">+</span><br><span class="line">+  // read the frist number from previous prime </span><br><span class="line">+  if ((len = read(0, &amp;n, sizeof(int))) &lt;= 0 || n &lt;= 0) &#123;</span><br><span class="line">+    close(1);</span><br><span class="line">+    exit(0);</span><br><span class="line">+  &#125;</span><br><span class="line">+  </span><br><span class="line">+  // print first number to console</span><br><span class="line">+  printf(&quot;prime %d\n&quot;, n);</span><br><span class="line">+  </span><br><span class="line">+  pipe(fd);</span><br><span class="line">+  if (fork() == 0) &#123; // child process</span><br><span class="line">+    close(0);</span><br><span class="line">+    dup(fd[0]);  // link the std i/o 0 to fd[0] </span><br><span class="line">+    close_pipe(fd);</span><br><span class="line">+    primes();</span><br><span class="line">+  &#125; else &#123;      // parent process</span><br><span class="line">+    close(1);</span><br><span class="line">+    dup(fd[1]); // link the std i/o 1 to fd[1]</span><br><span class="line">+    close_pipe(fd); </span><br><span class="line">+    while ((len = read(0, &amp;p, sizeof(int))) &gt; 0 &amp;&amp; p &gt; 0) &#123;  // read the number from the prime</span><br><span class="line">+      if (p % n != 0) &#123;</span><br><span class="line">+        write(1, &amp;p, sizeof(int));  // filter the number</span><br><span class="line">+      &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+    close(1);</span><br><span class="line">+    wait((int *)0);   </span><br><span class="line">+  &#125; </span><br><span class="line">+  exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(void) &#123;</span><br><span class="line">+  int i;</span><br><span class="line">+  int fd[2];</span><br><span class="line">+  </span><br><span class="line">+  pipe(fd);</span><br><span class="line">+  if (fork() == 0) &#123;  // child process</span><br><span class="line">+    close(0);</span><br><span class="line">+    dup(fd[0]);  // link the std i/o 0 to the fd[0]</span><br><span class="line">+    close_pipe(fd);</span><br><span class="line">+    primes();</span><br><span class="line">+  &#125; else &#123;</span><br><span class="line">+    close(1);</span><br><span class="line">+    dup(fd[1]);  // link the std i/o 1 to the fd[1]</span><br><span class="line">+    close_pipe(fd);</span><br><span class="line">+    for (i = 2; i &lt;= 35; i++) &#123;</span><br><span class="line">+      write(1, &amp;i, sizeof(int));</span><br><span class="line">+    &#125;</span><br><span class="line">+    close(1);</span><br><span class="line">+    wait((int *)0);</span><br><span class="line">+  &#125;</span><br><span class="line">+  exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/user/sleep.c b/user/sleep.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..1c4d51d</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/sleep.c</span><br><span class="line">@@ -0,0 +1,17 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;kernel/stat.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(int argc, char *argv[])</span><br><span class="line">+&#123;</span><br><span class="line">+if(argc == 2)&#123;</span><br><span class="line">+sleep(atoi((const char*) argv[1])); // convert ascii to integer and use system call sleep</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">+else&#123;</span><br><span class="line">+fprintf(2, &quot;Usage:sleep number...\n&quot;);  // put the error masssage to the file descriptor 2</span><br><span class="line">+exit(1); // terminate the process, </span><br><span class="line">+//status = 1: indicates failure, and reported to wait() </span><br><span class="line">+&#125;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/user/xargs.c b/user/xargs.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..1423af7</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/xargs.c</span><br><span class="line">@@ -0,0 +1,47 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+#include &quot;kernel/param.h&quot;</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(int argc, char *argv[])</span><br><span class="line">+&#123;</span><br><span class="line">+char *arguments[MAXARG];</span><br><span class="line">+char buff[255];</span><br><span class="line">+char *p = buff, *q = buff;</span><br><span class="line">+int i, offset;</span><br><span class="line">+if(argc &lt;= 1)&#123;</span><br><span class="line">+fprintf(2, &quot;Usage: xargc &lt;command&gt;...\n&quot;);</span><br><span class="line">+exit(1);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+for(i = 1; i &lt; argc; i++)&#123;  // get the command which is behind the &quot;xargs&quot;</span><br><span class="line">+        arguments[i-1] = argv[i];</span><br><span class="line">+    &#125;</span><br><span class="line">+    i = i - 1;</span><br><span class="line">+    offset = i;  // backup</span><br><span class="line">+    </span><br><span class="line">+    while(read(0, p, 1))&#123;</span><br><span class="line">+    if(*p == &#x27;\n&#x27;)&#123;  // meet the &#x27;\n&#x27; and execute it with arguments</span><br><span class="line">+    *p = &#x27;\0&#x27;;</span><br><span class="line">+    arguments[i] = q;</span><br><span class="line">+    if(fork() == 0)&#123;</span><br><span class="line">+    exec(arguments[0], arguments);</span><br><span class="line">+    exit(0);</span><br><span class="line">+    &#125;else&#123;</span><br><span class="line">+    wait((int*)0);</span><br><span class="line">+    p = buff;</span><br><span class="line">+    q = p;</span><br><span class="line">+    i = offset;</span><br><span class="line">+    &#125;</span><br><span class="line">+    &#125;else if(*p == &#x27; &#x27; || *p == &#x27;\t&#x27;)&#123;  // meet the &#x27; &#x27; or &#x27;\t&#x27;, find an argument</span><br><span class="line">+    *p = &#x27;\0&#x27;;</span><br><span class="line">+    arguments[i] = q;</span><br><span class="line">+    i = i + 1;</span><br><span class="line">+    p = p + 1;</span><br><span class="line">+    q = p; </span><br><span class="line">+    &#125;else&#123;</span><br><span class="line">+    p = p + 1;</span><br><span class="line">+    &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6调试</title>
      <link href="/2022/08/11/xv6-debug/"/>
      <url>/2022/08/11/xv6-debug/</url>
      
        <content type="html"><![CDATA[<h2 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure><h2 id="理解框架代码的编译"><a href="#理解框架代码的编译" class="headerlink" title="理解框架代码的编译"></a>理解框架代码的编译</h2><ul><li>输出到vim中<ul><li><code>make nB | vim -</code></li></ul></li><li>在 Vim 里做一些你舒适的文本处理<ul><li><code>:%s/^/\r</code> 在命令之间插入空行</li><li><code>:%s/ /\r /g</code> 将命令的参数缩进排版</li></ul></li><li>另存为新文件<ul><li><code>:w filename</code></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br></pre></td><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc </span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/entry.o</span><br><span class="line"> kernel/entry.S</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/start.o</span><br><span class="line"> kernel/start.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/console.o</span><br><span class="line"> kernel/console.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/printf.o</span><br><span class="line"> kernel/printf.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/uart.o</span><br><span class="line"> kernel/uart.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/kalloc.o</span><br><span class="line"> kernel/kalloc.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/spinlock.o</span><br><span class="line"> kernel/spinlock.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/string.o</span><br><span class="line"> kernel/string.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/main.o</span><br><span class="line"> kernel/main.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/vm.o</span><br><span class="line"> kernel/vm.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/proc.o</span><br><span class="line"> kernel/proc.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/swtch.o</span><br><span class="line"> kernel/swtch.S</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/trampoline.o</span><br><span class="line"> kernel/trampoline.S</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/trap.o</span><br><span class="line"> kernel/trap.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/syscall.o</span><br><span class="line"> kernel/syscall.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/sysproc.o</span><br><span class="line"> kernel/sysproc.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/bio.o</span><br><span class="line"> kernel/bio.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/fs.o</span><br><span class="line"> kernel/fs.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/log.o</span><br><span class="line"> kernel/log.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/sleeplock.o</span><br><span class="line"> kernel/sleeplock.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/file.o</span><br><span class="line"> kernel/file.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/pipe.o</span><br><span class="line"> kernel/pipe.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/exec.o</span><br><span class="line"> kernel/exec.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/sysfile.o</span><br><span class="line"> kernel/sysfile.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/kernelvec.o</span><br><span class="line"> kernel/kernelvec.S</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/plic.o</span><br><span class="line"> kernel/plic.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/virtio_disk.o</span><br><span class="line"> kernel/virtio_disk.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -march=rv64g</span><br><span class="line"> -nostdinc</span><br><span class="line"> -I.</span><br><span class="line"> -Ikernel</span><br><span class="line"> -c</span><br><span class="line"> user/initcode.S</span><br><span class="line"> -o</span><br><span class="line"> user/initcode.o</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-ld</span><br><span class="line"> -z</span><br><span class="line"> max-page-size=4096</span><br><span class="line"> -N</span><br><span class="line"> -e</span><br><span class="line"> start</span><br><span class="line"> -Ttext</span><br><span class="line"> 0</span><br><span class="line"> -o</span><br><span class="line"> user/initcode.out</span><br><span class="line"> user/initcode.o</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-objcopy</span><br><span class="line"> -S</span><br><span class="line"> -O</span><br><span class="line"> binary</span><br><span class="line"> user/initcode.out</span><br><span class="line"> user/initcode</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-objdump</span><br><span class="line"> -S</span><br><span class="line"> user/initcode.o</span><br><span class="line"> &gt;</span><br><span class="line"> user/initcode.asm</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-ld</span><br><span class="line"> -z</span><br><span class="line"> max-page-size=4096</span><br><span class="line"> -T</span><br><span class="line"> kernel/kernel.ld</span><br><span class="line"> -o</span><br><span class="line"> kernel/kernel</span><br><span class="line"> kernel/entry.o</span><br><span class="line"> kernel/start.o</span><br><span class="line"> kernel/console.o</span><br><span class="line"> kernel/printf.o</span><br><span class="line"> kernel/uart.o</span><br><span class="line"> kernel/kalloc.o</span><br><span class="line"> kernel/spinlock.o</span><br><span class="line"> kernel/string.o</span><br><span class="line"> kernel/main.o</span><br><span class="line"> kernel/vm.o</span><br><span class="line"> kernel/proc.o</span><br><span class="line"> kernel/swtch.o</span><br><span class="line"> kernel/trampoline.o</span><br><span class="line"> kernel/trap.o</span><br><span class="line"> kernel/syscall.o</span><br><span class="line"> kernel/sysproc.o</span><br><span class="line"> kernel/bio.o</span><br><span class="line"> kernel/fs.o</span><br><span class="line"> kernel/log.o</span><br><span class="line"> kernel/sleeplock.o</span><br><span class="line"> kernel/file.o</span><br><span class="line"> kernel/pipe.o</span><br><span class="line"> kernel/exec.o</span><br><span class="line"> kernel/sysfile.o</span><br><span class="line"> kernel/kernelvec.o</span><br><span class="line"> kernel/plic.o</span><br><span class="line"> kernel/virtio_disk.o</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-objdump</span><br><span class="line"> -S</span><br><span class="line"> kernel/kernel</span><br><span class="line"> &gt;</span><br><span class="line"> kernel/kernel.asm</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-objdump</span><br><span class="line"> -t</span><br><span class="line"> kernel/kernel</span><br><span class="line"> |</span><br><span class="line"> sed</span><br><span class="line"> <span class="string">&#x27;1,/SYMBOL</span></span><br><span class="line"><span class="string"> TABLE/d;</span></span><br><span class="line"><span class="string"> s/</span></span><br><span class="line"><span class="string"> .*</span></span><br><span class="line"><span class="string"> /</span></span><br><span class="line"><span class="string"> /;</span></span><br><span class="line"><span class="string"> /^$/d&#x27;</span></span><br><span class="line"> &gt;</span><br><span class="line"> kernel/kernel.sym</span><br></pre></td></tr></table></figure><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>makefile中的定义的make commend<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">qemu: $K/kernel fs.img</span></span><br><span class="line"><span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">.gdbinit: .gdbinit.tmpl-riscv</span></span><br><span class="line">sed <span class="string">&quot;s/:1234/:<span class="variable">$(GDBPORT)</span>/&quot;</span> &lt; <span class="variable">$^</span> &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">qemu-gdb: $K/kernel .gdbinit fs.img</span></span><br><span class="line">@echo <span class="string">&quot;*** Now run &#x27;gdb&#x27; in another window.&quot;</span> 1&gt;&amp;2</span><br><span class="line"><span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span> -S <span class="variable">$(QEMUGDB)</span></span><br><span class="line"></span><br><span class="line"><span class="section">print-gdbport:</span></span><br><span class="line">@echo <span class="variable">$(GDBPORT)</span></span><br></pre></td></tr></table></figure></p><h3 id="终端1"><a href="#终端1" class="headerlink" title="终端1"></a>终端1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (util)&gt; make qemu-gdb</span><br><span class="line">sed <span class="string">&quot;s/:1234/:26000/&quot;</span> &lt; .gdbinit.tmpl-riscv &gt; .gdbinit</span><br><span class="line">*** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26000</span><br></pre></td></tr></table></figure><p>或者make CPUS=1 qemu-gdb，Makefile中的CPUS即qemu -smp $(CPUS)，cpu核数，设置为1时，单线程，方便调试</p><h3 id="终端2"><a href="#终端2" class="headerlink" title="终端2"></a>终端2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (util)&gt; gdb-multiarch kernel/kernel</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from kernel/kernel...</span><br><span class="line">warning: File <span class="string">&quot;/home/grand/xv6-labs-2020/.gdbinit&quot;</span> auto-loading has been declined by your `auto-load safe-path<span class="string">&#x27; set to &quot;$debugdir:$datadir/auto-load&quot;.</span></span><br><span class="line"><span class="string">To enable execution of this file add</span></span><br><span class="line"><span class="string">        add-auto-load-safe-path /home/grand/xv6-labs-2020/.gdbinit</span></span><br><span class="line"><span class="string">line to your configuration file &quot;/home/grand/.gdbinit&quot;.</span></span><br><span class="line"><span class="string">To completely disable this security protection add</span></span><br><span class="line"><span class="string">        set auto-load safe-path /</span></span><br><span class="line"><span class="string">line to your configuration file &quot;/home/grand/.gdbinit&quot;.</span></span><br><span class="line"><span class="string">For more information about this security protection see the</span></span><br><span class="line"><span class="string">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span></span><br></pre></td></tr></table></figure><p>按q回车退出，在/home/grand/.gdbinit中添加add-auto-load-safe-path /home/grand/xv6-labs-2020/.gdbinit<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (util) [1]&gt; <span class="built_in">echo</span> <span class="string">&quot;add-auto-load-safe-path /home/grand/xv6-labs-2020/.gdbinit&quot;</span> &gt;&gt; <span class="string">&quot;/home/grand/.gdbinit&quot;</span></span><br></pre></td></tr></table></figure></p><p>重新运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (util)&gt; gdb-multiarch kernel/kernel</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.                                                                                   </span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from kernel/kernel...</span><br><span class="line">The target architecture is assumed to be riscv:rv64</span><br><span class="line">0x0000000000001000 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><br>现在就可以去调试了，快来试试下面的命令，了解熟悉gdb的基本调试操作。</p><h2 id="gdb常用命令"><a href="#gdb常用命令" class="headerlink" title="gdb常用命令"></a>gdb常用命令</h2><p>tui界面相关的（Text User Interface commands）</p><ul><li>tui enable    启动tui界面，默认显示源码</li><li>tui disable   关闭tui界面</li><li>layout asm    启动tui界面，查看汇编代码</li><li>layout src    启动tui界面，查看源码</li><li>layout split  启动tui界面，同时查看源码和汇编</li><li>layout reg    启动tui节目，查看寄存器</li><li>focus [win]   多个窗口时，可以聚焦到某一窗口，例如focus src, focus asm, focus reg</li></ul><p>执行相关的</p><ul><li>si            执行一条汇编指令</li><li>ni            执行一条汇编指令，若是跳转指令，则执行完返回。</li><li>s             执行一行代码，进入函数，step</li><li>n             执行一行代码，不进入函数，next</li><li>c             继续运行，遇到断点暂停，continue</li><li>r             执行整个程序，遇到断点暂停，run</li><li>finish        函数结束，遇到断点暂停</li></ul><p>断点</p><ul><li>b [func]      添加断点，如b main</li><li>b [line]      添加断点，如b 17</li><li>b filename:[line/func]  添加断点，如b kernel/main.c:15</li><li>i breakpoints 查看断点的信息</li><li>d [num]       删除断点/观察点，如b 1，不填num时，删除所有的断点</li></ul><p>观察点</p><ul><li>watch [val]  设置观察点，当某个变量的值发生变化时，暂停提示</li><li>watch [expr] 设置观察点，当表达式发生变化时，暂停提示</li><li>d [num]      删除断点/观察点</li></ul><p>查看</p><ul><li>p [var]       打印某个变量</li><li>i locals      查看局部变量</li><li>i args        查看函数的入参</li><li>i frame       查看当前栈帧信息</li><li>bt/basktrace  查看所有栈帧的位置</li><li>frame [num]   查看某个栈帧的信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/11/hello-world/"/>
      <url>/2022/05/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul><li>这里引用变量 <script type="math/tex">a_i</script></li><li><script type="math/tex; mode=display">\sigma = x_1 + y_1</script></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>如何置顶blog<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">sticky: 100</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python常用函数</title>
      <link href="/2021/08/19/python-useful-function/"/>
      <url>/2021/08/19/python-useful-function/</url>
      
        <content type="html"><![CDATA[<h2 id="1-生成6位数字随机验证码"><a href="#1-生成6位数字随机验证码" class="headerlink" title="1. 生成6位数字随机验证码"></a>1. 生成6位数字随机验证码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">num_code</span>(<span class="params">length=<span class="number">6</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成长度为length的数字随机验证码</span></span><br><span class="line"><span class="string">    :param length: 验证码长度</span></span><br><span class="line"><span class="string">    :return: 验证码</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.choice(string.digits) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length))</span><br></pre></td></tr></table></figure><h2 id="2-md5加密"><a href="#2-md5加密" class="headerlink" title="2.md5加密"></a>2.md5加密</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># md5加密</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">md5_encrypt</span>(<span class="params">en_str</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用md5二次加密生成32位的字符串</span></span><br><span class="line"><span class="string">    :param en_str: 需要加密的字符串</span></span><br><span class="line"><span class="string">    :return: 加密后的字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">   </span><br><span class="line">    md5 = hashlib.md5()  <span class="comment"># 使用MD5加密模式</span></span><br><span class="line">    md5.update(en_str.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 将参数字符串传入</span></span><br><span class="line">    md5.update(md5.hexdigest().encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># md5二次加密</span></span><br><span class="line">    <span class="keyword">return</span> md5.hexdigest()</span><br></pre></td></tr></table></figure><h2 id="3-生成唯一token"><a href="#3-生成唯一token" class="headerlink" title="3. 生成唯一token"></a>3. 生成唯一token</h2><pre><code>import uuidimport  hashlibdef only_token():    &quot;&quot;&quot;    使用md5加密uuid生成唯一的32位token    :return: 加密后的字符串    &quot;&quot;&quot;md5 = hashlib.md5()  # 使用MD5加密模式md5.update(str(uuid.uuid1()).encode(&#39;utf-8&#39;))  return md5.hexdigest()</code></pre><h2 id="4、发送手机验证码"><a href="#4、发送手机验证码" class="headerlink" title="4、发送手机验证码"></a>4、发送手机验证码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#验证码管理表</span><br><span class="line">class AuthCode(models.Model):</span><br><span class="line">    name = models.CharField(max_length=10,default=None, null=True, blank=True,verbose_name=&#x27;姓名&#x27;)</span><br><span class="line">    phone = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机号&#x27;)</span><br><span class="line">    code = models.CharField(max_length=6,verbose_name=&#x27;验证码&#x27;)</span><br><span class="line">    purpose = models.IntegerField(default=0,verbose_name=&#x27;用途:0-&gt;注册验证 1-&gt;找回密码 2-&gt;其它&#x27;)</span><br><span class="line">    sendNum = models.IntegerField(default=0,verbose_name=&#x27;发送次数&#x27;)</span><br><span class="line">    isCanGet = models.BooleanField(default=0,verbose_name=&#x27;0-&gt;可以获取,1-&gt;不可以获取&#x27;)</span><br><span class="line">    recentlySendTime = models.DateTimeField(auto_now_add=True,verbose_name=&#x27;最近一次发送时间&#x27;)</span><br><span class="line">    creation_time = models.DateTimeField(auto_now=True, verbose_name=&#x27;创建时间&#x27;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name = &#x27;手机验证码&#x27;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import http.client</span><br><span class="line">import urllib</span><br><span class="line"># 使用互亿无线</span><br><span class="line">host = &quot;106.ihuyi.com&quot;</span><br><span class="line">sms_send_uri = &quot;/webservice/sms.php?method=Submit&quot;</span><br><span class="line"></span><br><span class="line"># 查看用户名 登录用户中心-&gt;验证码通知短信&gt;产品总览-&gt;API接口信息-&gt;APIID</span><br><span class="line">account = &quot;你的用户名&quot;</span><br><span class="line"># 查看密码 登录用户中心-&gt;验证码通知短信&gt;产品总览-&gt;API接口信息-&gt;APIKEY</span><br><span class="line">password = &quot;你的密码&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_sms(text, mobile):</span><br><span class="line">    text = f&quot;您的验证码是：&#123;text&#125;。请不要把验证码泄露给其他人。&quot;</span><br><span class="line">    params = urllib.parse.urlencode(</span><br><span class="line">        &#123;&#x27;account&#x27;: account, &#x27;password&#x27;: password, &#x27;content&#x27;: text, &#x27;mobile&#x27;: mobile, &#x27;format&#x27;: &#x27;json&#x27;&#125;)</span><br><span class="line">    headers = &#123;&quot;Content-type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Accept&quot;: &quot;text/plain&quot;&#125;</span><br><span class="line">    conn = http.client.HTTPConnection(host, port=80, timeout=30)</span><br><span class="line">    conn.request(&quot;POST&quot;, sms_send_uri, params, headers)</span><br><span class="line">    response = conn.getresponse()</span><br><span class="line">    response_str = response.read()</span><br><span class="line">    conn.close()</span><br><span class="line">    return response_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mobile = &quot;手机号&quot;</span><br><span class="line">    text = &#x27;123122&#x27;</span><br><span class="line"></span><br><span class="line">    print(json.loads(send_sms(text, mobile).decode(&#x27;utf-8&#x27;)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5、生成二维码"><a href="#5、生成二维码" class="headerlink" title="5、生成二维码"></a>5、生成二维码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import qrcode</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">def maker_qrcode(url):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    生成二维码</span><br><span class="line">    :param url: 需要生成二维码的url</span><br><span class="line">    :return: 返回图片字节流</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    image = qrcode.make(url)  # 创建二维码片</span><br><span class="line"></span><br><span class="line">    buffer = io.BytesIO()</span><br><span class="line">    # 将图片内容丢入容器</span><br><span class="line">    image.save(buffer, &#x27;png&#x27;)</span><br><span class="line">    # 返回容器内的字节</span><br><span class="line">    return buffer.getvalue()</span><br><span class="line">    </span><br><span class="line">或者</span><br><span class="line">from .settings import BASE_DIR</span><br><span class="line"></span><br><span class="line">def create_qrcode(name, url):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    生成机器扫码支付二维码</span><br><span class="line">    :param name: 图片名称</span><br><span class="line">    :param url: 支付路由</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    img = qrcode.make(url, border=0)  # 创建二维码片</span><br><span class="line">    save_path = BASE_DIR + &#x27;/&#x27; + name + &#x27;.png&#x27;</span><br><span class="line">    print(save_path)</span><br><span class="line">    img.save(save_path)</span><br><span class="line">    return img</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-微信群发"><a href="#6-微信群发" class="headerlink" title="6.微信群发"></a>6.微信群发</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf8</span><br><span class="line">import itchat, time</span><br><span class="line"></span><br><span class="line">itchat.auto_login(True)</span><br><span class="line"></span><br><span class="line">SINCERE_WISH = u&#x27;祝%s新年快乐！&#x27;</span><br><span class="line"></span><br><span class="line">friendList = itchat.get_friends(update=True)[35:]</span><br><span class="line">count = 0</span><br><span class="line"></span><br><span class="line">for  index,friend in enumerate(friendList):</span><br><span class="line">    print(index,friend[&#x27;DisplayName&#x27;],friend[&#x27;NickName&#x27;])</span><br><span class="line">    itchat.send(SINCERE_WISH % (friend[&#x27;DisplayName&#x27;]</span><br><span class="line">                                or friend[&#x27;NickName&#x27;]), friend[&#x27;UserName&#x27;])</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&#x27;备注名称&#x27;,friend[&#x27;DisplayName&#x27;],&#x27;昵称&#x27;,friend[&#x27;NickName&#x27;],&#x27;用户名&#x27;,friend[&#x27;UserName&#x27;])</span><br><span class="line"></span><br><span class="line">print(&quot;----end----&quot;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 发送文本</span><br><span class="line">itchat.send(&#x27;Hello, WeChat!&#x27;)</span><br><span class="line"># 发送图片</span><br><span class="line">itchat.send_image(&#x27;my_picture.png&#x27;)</span><br><span class="line"># 发送视频</span><br><span class="line">itchat.send_video(&#x27;my_video.mov&#x27;)</span><br><span class="line"># 发送文件</span><br><span class="line">itchat.send_file(&#x27;my_file.zip&#x27;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="7、微信自动回复"><a href="#7、微信自动回复" class="headerlink" title="7、微信自动回复"></a>7、微信自动回复</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding=utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">import itchat</span><br><span class="line">import random</span><br><span class="line">#图灵机器人</span><br><span class="line">#http://www.tuling123.com/member/robot/1380138/center/frame.jhtml?page=0&amp;child=0获取apikey</span><br><span class="line">KEY = &#x27;你的KEY&#x27;</span><br><span class="line"></span><br><span class="line">def get_response(msg):</span><br><span class="line">    apiUrl = &#x27;http://www.tuling123.com/openapi/api&#x27;</span><br><span class="line">    data = &#123;</span><br><span class="line">        &#x27;key&#x27;    : KEY,</span><br><span class="line">        &#x27;info&#x27;   : msg,</span><br><span class="line">        &#x27;userid&#x27; : &#x27;wechat-robot&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">    try:</span><br><span class="line">        r = requests.post(apiUrl, data=data).json()</span><br><span class="line">        return r.get(&#x27;text&#x27;)</span><br><span class="line">    except:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">@itchat.msg_register(itchat.content.TEXT)</span><br><span class="line">def tuling_reply(msg):</span><br><span class="line">    defaultReply = &#x27;I received: &#x27; + msg[&#x27;Text&#x27;]</span><br><span class="line">    robots=[&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;]</span><br><span class="line">    reply = get_response(msg[&#x27;Text&#x27;])+random.choice(robots)</span><br><span class="line">    return reply or defaultReply</span><br><span class="line"></span><br><span class="line">itchat.auto_login(enableCmdQR=False)</span><br><span class="line">itchat.run()</span><br></pre></td></tr></table></figure><h2 id="8、提取Django中model中的字段名变成字典、列表"><a href="#8、提取Django中model中的字段名变成字典、列表" class="headerlink" title="8、提取Django中model中的字段名变成字典、列表"></a>8、提取Django中model中的字段名变成字典、列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">t = &quot;&quot;&quot;</span><br><span class="line">    goods_id = models.IntegerField(verbose_name=&#x27;商品编号&#x27;)</span><br><span class="line">    label_code = models.CharField(max_length=20, verbose_name=&#x27;商品标签&#x27;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 字典</span><br><span class="line">print(&#123;k:None for k in re.findall(&#x27;([a-z_A-Z]+)\s=\s&#x27;,t)&#125;)</span><br><span class="line"># 列表</span><br><span class="line"># print([k for k in re.findall(&#x27;([a-z_A-Z]+)\s=\s&#x27;,t)])</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">&#123;&#x27;goods_id&#x27;: None, &#x27;lable_code&#x27;: None&#125;</span><br></pre></td></tr></table></figure><h2 id="9、数据库中给表创建数据"><a href="#9、数据库中给表创建数据" class="headerlink" title="9、数据库中给表创建数据"></a>9、数据库中给表创建数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">def createData(dataDict,tableName):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    给数据表创建数据</span><br><span class="line">    :param dataDict: 字典</span><br><span class="line">    :param tableName: 表名</span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    #连接数据库</span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=&#x27;192.168.0.188&#x27;, #数据库所在地址URL</span><br><span class="line">        user=&#x27;root&#x27;, #用户名</span><br><span class="line">        password=&#x27;123456&#x27;, #密码</span><br><span class="line">        database=&#x27;名称&#x27;, #数据库名称</span><br><span class="line">        port=3306,  #端口号</span><br><span class="line">        charset=&#x27;utf8&#x27;</span><br><span class="line">    )</span><br><span class="line">    #拿到查询游标</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    clos,value = zip(*dataDict.items())</span><br><span class="line">    sql = &quot;INSERT INTO `%s`(%s) VALUES (%s)&quot; % (tableName,</span><br><span class="line">                                                &#x27;,&#x27;.join(clos),</span><br><span class="line">                                                &#x27;,&#x27;.join([&#x27;%s&#x27;] * len(value))</span><br><span class="line">                                                )</span><br><span class="line">    print(sql)</span><br><span class="line">    cursor.execute(sql, value)</span><br><span class="line">    conn.commit()</span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    print(&#x27;Done&#x27;)</span><br></pre></td></tr></table></figure><h2 id="10-捕捉异常"><a href="#10-捕捉异常" class="headerlink" title="10.捕捉异常"></a>10.捕捉异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    pass</span><br><span class="line">except 异常类型 as e:</span><br><span class="line">    pass</span><br><span class="line">finally:</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">异常类型</span><br><span class="line">Exception  全部异常</span><br><span class="line">AttributeError 试图访问一个对象没有的属性，比如foo.x，但是foo没有属性x</span><br><span class="line">IOError 输入/输出异常；基本上是无法打开文件</span><br><span class="line">ImportError 无法引入模块或包；基本上是路径问题或名称错误</span><br><span class="line">IndentationError 语法错误（的子类） ；代码没有正确对齐</span><br><span class="line">IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]</span><br><span class="line">KeyError 试图访问字典里不存在的键</span><br><span class="line">KeyboardInterrupt Ctrl+C被按下</span><br><span class="line">NameError 使用一个还未被赋予对象的变量</span><br><span class="line">SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）</span><br><span class="line">TypeError 传入对象类型与要求的不符合</span><br><span class="line">UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它</span><br><span class="line">ValueError 传入一个调用者不期望的值，即使值的类型是正确的</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11、获取当前时间"><a href="#11、获取当前时间" class="headerlink" title="11、获取当前时间"></a>11、获取当前时间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">current_time = str(datetime.datetime.now())[:19]</span><br><span class="line">print(current_time)</span><br><span class="line"></span><br><span class="line">输出格式如：2018-10-20 10:01:43</span><br><span class="line">local_time = time.strftime(&#x27;%Y%m%d%H%M%S&#x27;, time.localtime(time.time()))</span><br><span class="line">print(local_time)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12、订单编号"><a href="#12、订单编号" class="headerlink" title="12、订单编号"></a>12、订单编号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from random import Random</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def random_str(randomlength=8):</span><br><span class="line">    str = &#x27;&#x27;</span><br><span class="line">    chars = &#x27;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789&#x27;</span><br><span class="line">    length = len(chars) - 1</span><br><span class="line">    random = Random()</span><br><span class="line">    for i in range(randomlength):</span><br><span class="line">        str+=chars[random.randint(0, length)]</span><br><span class="line">    return str</span><br><span class="line"></span><br><span class="line">def order_num():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    生成付款订单号</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    local_time = time.strftime(&#x27;%Y%m%d%H%M%S&#x27;, time.localtime(time.time()))</span><br><span class="line">    result = local_time + random_str(5)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(order_num())</span><br></pre></td></tr></table></figure><h2 id="13、mysql自动填写当前时间"><a href="#13、mysql自动填写当前时间" class="headerlink" title="13、mysql自动填写当前时间"></a>13、mysql自动填写当前时间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURRENT_TIMESTAMP</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190312172747658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为表添加索引</span><br><span class="line"></span><br><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="14、drf动态过滤查询"><a href="#14、drf动态过滤查询" class="headerlink" title="14、drf动态过滤查询"></a>14、drf动态过滤查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># page.py</span><br><span class="line"></span><br><span class="line">from rest_framework.pagination import PageNumberPagination</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserPagination(PageNumberPagination):</span><br><span class="line">    &quot;&quot;&quot;用户分页器&quot;&quot;&quot;</span><br><span class="line">    page_size = 10  # 默认的页面数据数量</span><br><span class="line">    page_query_param = &#x27;page&#x27;  # 定制取数据页码key </span><br><span class="line">    page_size_query_param = &#x27;page_size&#x27;  # 默认取数据页码key </span><br><span class="line">    max_page_size = 15   # 数据每页取值的最大上限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># serializers.py</span><br><span class="line"></span><br><span class="line">from rest_framework import serializers</span><br><span class="line"></span><br><span class="line">from user.models import UserInfo</span><br><span class="line"></span><br><span class="line">class UserSerializers(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;用户收货地址&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model = UserInfo</span><br><span class="line">    # 所有字段</span><br><span class="line">        #fields = &#x27;__all__&#x27;</span><br><span class="line">        fields = [&#x27;name&#x27;, &#x27;code&#x27;, &#x27;title&#x27;,  &#x27;province&#x27;, &#x27;city&#x27;,</span><br><span class="line">                    &#x27;quxian&#x27;, &#x27;address&#x27;, &#x27;code__gte&#x27;, &#x27;code__lte&#x27;]</span><br><span class="line">        # 显示外键</span><br><span class="line">        depth = 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># views.py</span><br><span class="line">class MachineViews(APIView):</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # 从前端获取出来的过滤参数，解析成字典传进filter()函数中</span><br><span class="line">        # 动态过滤，</span><br><span class="line">        kwargs = &#123;&#125;</span><br><span class="line">        # 表中的字段名</span><br><span class="line">        columns = [&#x27;name&#x27;, &#x27;code&#x27;, &#x27;title&#x27;,  &#x27;province&#x27;, &#x27;city&#x27;,</span><br><span class="line">                    &#x27;quxian&#x27;, &#x27;address&#x27;, &#x27;code__gte&#x27;, &#x27;code__lte&#x27;]</span><br><span class="line">        for k, v in request.query_params.items():</span><br><span class="line">            if k not in columns:</span><br><span class="line">                return Response(&#x27;参数不对&#x27;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">if v:</span><br><span class="line">            kwargs[k] = v</span><br><span class="line"></span><br><span class="line">        users = UserInfo.objects.filter(**kwargs)</span><br><span class="line">        page = UserPagination()</span><br><span class="line">        page_goods_list = page.paginate_queryset(users, self.request, self)</span><br><span class="line">        ser = UserSerializers(page_goods_list, many=True)</span><br><span class="line">        return page.get_paginated_response(ser.data)</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="15、linux后台运行python程序"><a href="#15、linux后台运行python程序" class="headerlink" title="15、linux后台运行python程序"></a>15、linux后台运行python程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup /home/project_venv/user/bin/python3 -u /home/user/user_server.py &gt;&gt; /home/user/user.log 2&gt;&amp;1 &amp;   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="16、追加外键"><a href="#16、追加外键" class="headerlink" title="16、追加外键"></a>16、追加外键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb_commentPhoto ADD CONSTRAINT FK_comment_phone</span><br><span class="line">FOREIGN KEY tb_goodsComment(id) REFERENCES tb_commentPhoto(comment_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="17、写-读CSV文件，查看是否存在，若存在就从csv中删除"><a href="#17、写-读CSV文件，查看是否存在，若存在就从csv中删除" class="headerlink" title="17、写/读CSV文件，查看是否存在，若存在就从csv中删除"></a>17、写/读CSV文件，查看是否存在，若存在就从csv中删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_invite_code(random_code_pool=None, length=6, num=10, is_append=False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建随机邀请码,并写入txt文件</span><br><span class="line">    :param: random_code_pool 随机邀请码</span><br><span class="line">    :param: length 邀请码长度</span><br><span class="line">    :param: num 邀请码个数</span><br><span class="line">    :param: is_append True追加,False 覆盖</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not random_code_pool:</span><br><span class="line">        code_pool = string.ascii_uppercase + string.digits</span><br><span class="line">        random_code_pool = []</span><br><span class="line">        for i in range(num):</span><br><span class="line">            s = &#x27;&#x27;</span><br><span class="line">            for _ in range(length):</span><br><span class="line">                s += random.choice(code_pool)</span><br><span class="line">            if s and s not in random_code_pool:</span><br><span class="line">                random_code_pool.append(s)</span><br><span class="line"></span><br><span class="line">    # 写入方法。是追加还是覆盖</span><br><span class="line">    write_method = &#x27;a+&#x27; if is_append else &#x27;w&#x27;</span><br><span class="line">    # 写入文件</span><br><span class="line">    with open(&#x27;./invite_code.csv&#x27;, write_method, newline=&#x27;&#x27;) as f:</span><br><span class="line">        writer = csv.writer(f)</span><br><span class="line">        for rowData in random_code_pool:</span><br><span class="line">            # 按行写入</span><br><span class="line">            writer.writerow((rowData,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_invite_code(code):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    查看邀请码是否存在txt文件中，</span><br><span class="line">    若存在就返回True，并在txt文件中删除</span><br><span class="line">    若不存在就返回False</span><br><span class="line">    :param code:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    code_pool = []</span><br><span class="line">    with open(&#x27;./invite_code.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;,errors=&#x27;ignore&#x27;) as f:</span><br><span class="line">        allFileInfo = csv.reader(f)</span><br><span class="line">        for row in allFileInfo:</span><br><span class="line">            code_pool.append(row[0])</span><br><span class="line"></span><br><span class="line">    if code in code_pool:</span><br><span class="line">        # 删除查询的code</span><br><span class="line">        code_pool.pop(code_pool.index(code))</span><br><span class="line"></span><br><span class="line">        # 重新写入文件</span><br><span class="line">        create_invite_code(code_pool,is_append=False)</span><br><span class="line">        return True</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # create_invite_code(length=9,num=100)</span><br><span class="line">    print(check_invite_code(&#x27;WJ4PSTJG2&#x27;))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="18、django中从request获取访问路径"><a href="#18、django中从request获取访问路径" class="headerlink" title="18、django中从request获取访问路径"></a>18、django中从request获取访问路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;获取相对路径&#x27;, request.get_full_path())</span><br><span class="line">print(&#x27;获取绝对路径&#x27;, request.build_absolute_uri())</span><br><span class="line">print(request.build_absolute_uri(&#x27;?&#x27;))</span><br><span class="line">print(request.build_absolute_uri(&#x27;/&#x27;)[:-1].strip(&quot;/&quot;))</span><br><span class="line">print(request.build_absolute_uri(&#x27;/&#x27;).strip(&quot;/&quot;))</span><br><span class="line">print(request.build_absolute_uri(&#x27;/&#x27;))</span><br><span class="line">print(&#x27;----------&#x27;)</span><br><span class="line">print(request.META[&#x27;HTTP_HOST&#x27;])</span><br><span class="line">print(request.META[&#x27;PATH_INFO&#x27;])</span><br><span class="line">print(request.META[&#x27;QUERY_STRING&#x27;])</span><br><span class="line">iphost = request.META.get(&#x27;REMOTE_ADDR&#x27;, &#x27;&#x27;)  # 获取访问来源IP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出如：</span><br><span class="line">获取相对路径 /QRcode/?d=1</span><br><span class="line">获取绝对路径 http://127.0.0.1:8000/QRcode/?d=1</span><br><span class="line">http://127.0.0.1:8000/QRcode/</span><br><span class="line">http://127.0.0.1:8000</span><br><span class="line">http://127.0.0.1:8000</span><br><span class="line">http://127.0.0.1:8000/</span><br><span class="line">----------</span><br><span class="line">127.0.0.1:8000</span><br><span class="line">/QRcode/</span><br><span class="line">d=1</span><br></pre></td></tr></table></figure><h2 id="19、Django收集静态文件"><a href="#19、Django收集静态文件" class="headerlink" title="19、Django收集静态文件"></a>19、Django收集静态文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先在项目根目录下创建一个static文件夹</span><br><span class="line">然后在settings.py中设置</span><br><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;)</span><br><span class="line">最后执行下面的命令：</span><br><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure><h2 id="20、xadmin插件"><a href="#20、xadmin插件" class="headerlink" title="20、xadmin插件"></a>20、xadmin插件</h2><p><a href="https://www.cnblogs.com/lanqie/p/8340215.html">https://www.cnblogs.com/lanqie/p/8340215.html</a></p><h2 id="21、uwsgi自动重启"><a href="#21、uwsgi自动重启" class="headerlink" title="21、uwsgi自动重启"></a>21、uwsgi自动重启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"># 使用nginx连接时 使用</span><br><span class="line">socket=0.0.0.0:2019</span><br><span class="line"># 直接作为web服务器使用</span><br><span class="line">#http=0.0.0.1:8000</span><br><span class="line"># 配置工程目录</span><br><span class="line">chdir=/home/user</span><br><span class="line"># 配置项目的wsgi目录。相对于工程目录</span><br><span class="line">wsgi-file=user/wsgi.py</span><br><span class="line">virtualenv=/home/project_venv/user</span><br><span class="line">#配置进程，线程信息</span><br><span class="line">processes=1</span><br><span class="line">threads=1</span><br><span class="line">enable-threads=True</span><br><span class="line">master=True</span><br><span class="line">pidfile=uwsgi.pid</span><br><span class="line">daemonize=uwsgi.log</span><br><span class="line">#启动uwsgi的用户名和用户组</span><br><span class="line">uid=root</span><br><span class="line">gid=root</span><br><span class="line">#uwsgi自动重启</span><br><span class="line">py-autoreload=1</span><br></pre></td></tr></table></figure><h2 id="22、谷歌浏览器快捷键"><a href="#22、谷歌浏览器快捷键" class="headerlink" title="22、谷歌浏览器快捷键"></a>22、谷歌浏览器快捷键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">浏览器缓存</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+Del  清除Google浏览器缓存的快捷键</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+R  重新加载当前网页而不使用缓存内容</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="23、git克隆分支"><a href="#23、git克隆分支" class="headerlink" title="23、git克隆分支"></a>23、git克隆分支</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b dev 地址 </span><br></pre></td></tr></table></figure><h2 id="24、mysql更新语句、新增列、删除列"><a href="#24、mysql更新语句、新增列、删除列" class="headerlink" title="24、mysql更新语句、新增列、删除列"></a>24、mysql更新语句、新增列、删除列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update user set name=&#x27;张三&#x27; where id=111</span><br><span class="line"># 删除</span><br><span class="line">DELETE FROM table_name [WHERE Clause]</span><br><span class="line"></span><br><span class="line"># 增加字段</span><br><span class="line">alter table 表名 add column 列名 类型;</span><br><span class="line"># 删除字段</span><br><span class="line">alter table 表名 dropcolumn 列名 ;</span><br></pre></td></tr></table></figure><h2 id="25、删除指定格式的文件"><a href="#25、删除指定格式的文件" class="headerlink" title="25、删除指定格式的文件"></a>25、删除指定格式的文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def remove_specified_format_file(file_dir, format_name):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    删除指定格式的文件</span><br><span class="line">    :param file_dir: 文件根目录</span><br><span class="line">    :param format_name: 格式</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    for root, dirs, files in os.walk(file_dir):</span><br><span class="line">        # print(root) #当前目录路径</span><br><span class="line">        # print(dirs) #当前路径下所有子目录</span><br><span class="line">        # print(files) #当前路径下所有非目录子文件</span><br><span class="line">        for file in files:</span><br><span class="line">            if re.match(format_name, file):</span><br><span class="line">                print(os.path.join(root, file))</span><br><span class="line">                os.remove(os.path.join(root, file))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">remove_specified_format_file(r&#x27;D:\学习\LDC\java&#x27;, r&#x27;\._*&#x27;)</span><br></pre></td></tr></table></figure><h2 id="26、计算文件总数"><a href="#26、计算文件总数" class="headerlink" title="26、计算文件总数"></a>26、计算文件总数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def file_count(file_dir):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    :param file_dir: 文件根目录</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    count = 0</span><br><span class="line">    for root, dirs, files in os.walk(file_dir):</span><br><span class="line">        # print(root) #当前目录路径</span><br><span class="line">        # print(dirs) #当前路径下所有子目录</span><br><span class="line">        # print(files) #当前路径下所有非目录子文件</span><br><span class="line">        count += len(files)</span><br><span class="line">    return count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(file_count(r&#x27;D:\学习\LDC\java\Java学习\newEstore\estore\js&#x27;))</span><br></pre></td></tr></table></figure><h2 id="27、计算文件夹大小"><a href="#27、计算文件夹大小" class="headerlink" title="27、计算文件夹大小"></a>27、计算文件夹大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def file_size(file_dir):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    删除指定格式的文件</span><br><span class="line">    :param file_dir: 文件根目录</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    size = 0</span><br><span class="line">    for root, dirs, files in os.walk(file_dir):</span><br><span class="line">        # print(root) #当前目录路径</span><br><span class="line">        # print(dirs) #当前路径下所有子目录</span><br><span class="line">        # print(files) #当前路径下所有非目录子文件</span><br><span class="line">        for file in files:</span><br><span class="line">            size += os.path.getsize(os.path.join(root, file))</span><br><span class="line"># M为单位</span><br><span class="line">    return size / 1024 / 1024</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_name = r&#x27;D:\学习&#x27;</span><br><span class="line">print(file_size(file_name))</span><br></pre></td></tr></table></figure><h2 id="28、Django实现jsonp跨域"><a href="#28、Django实现jsonp跨域" class="headerlink" title="28、Django实现jsonp跨域"></a>28、Django实现jsonp跨域</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># html</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">                    url: &#x27;请求路由&#x27;,</span><br><span class="line">                    type: &#x27;GET&#x27;,</span><br><span class="line">                    dataType: &#x27;JSONP&#x27;,</span><br><span class="line">                    data:&#123;</span><br><span class="line">                      code: &#x27;yes&#x27;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    jsonp: &#x27;callback&#x27;,</span><br><span class="line">                    success: function(res) &#123;</span><br><span class="line">                       var selectData = $.parseJSON(res);</span><br><span class="line">                       alert(selectData);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    error: function(err) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line"># views.py</span><br><span class="line">def get(self, request, *args, **kwargs):</span><br><span class="line">        code = request.GET.get(&#x27;code&#x27;, &#x27;&#x27;)</span><br><span class="line">        # 跨域请求</span><br><span class="line">        callback = request.GET.get(&#x27;callback&#x27;, &#x27;&#x27;)</span><br><span class="line">        return HttpResponse(&quot;%s(&#x27;%s&#x27;)&quot; % (callback, json.dumps(&#123;&#x27;code&#x27;: code&#125;)), status=status.HTTP_200_OK)</span><br><span class="line">                    </span><br><span class="line">cors解决跨域</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/wxiaoyu/p/9578848.html</span><br></pre></td></tr></table></figure><h2 id="29、微信获取用户信息"><a href="#29、微信获取用户信息" class="headerlink" title="29、微信获取用户信息"></a>29、微信获取用户信息</h2><p>参考：<a href="https://blog.csdn.net/weixin_39735923/article/details/79202563">https://blog.csdn.net/weixin_39735923/article/details/79202563</a></p><h2 id="30、uwsgi初始配置问题"><a href="#30、uwsgi初始配置问题" class="headerlink" title="30、uwsgi初始配置问题"></a>30、uwsgi初始配置问题</h2><p><a href="https://blog.csdn.net/weixin_39735923/article/details/79202563">https://blog.csdn.net/weixin_39735923/article/details/79202563</a></p><h2 id="31、django中drf序列化"><a href="#31、django中drf序列化" class="headerlink" title="31、django中drf序列化"></a>31、django中drf序列化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 序列化器</span><br><span class="line">class MsgSerializers(serializers.ModelSerializer):</span><br><span class="line">    addtime = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">    hasread = serializers.CharField(source=&#x27;get_hasread_display&#x27;)</span><br><span class="line">    msgtype = serializers.CharField(source=&#x27;get_msgtype_display&#x27;)</span><br><span class="line">    class Meta:</span><br><span class="line">        model = MallMsg</span><br><span class="line">        # 可以混合使用</span><br><span class="line">        fields = &#x27;__all__&#x27;  # &#x27;__all__&#x27; 所有字段</span><br><span class="line">        # 数据库层级控制（序列化链表操作）</span><br><span class="line">        # depth = 1  # 外键层级</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#分页器</span><br><span class="line">from rest_framework.pagination import PageNumberPagination</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyLimitOffsetPagination(PageNumberPagination):</span><br><span class="line"></span><br><span class="line">    page_size = 3  # 默认的页面数据数量</span><br><span class="line">    page_query_param = &#x27;page&#x27;  # 定制取数据页码key ？</span><br><span class="line">    page_size_query_param = &#x27;page_size&#x27;  # 默认取数据页码key &amp;</span><br><span class="line">    max_page_size = 15  # 数据每页取值的最大上限</span><br></pre></td></tr></table></figure><h2 id="32、第三方库"><a href="#32、第三方库" class="headerlink" title="32、第三方库"></a>32、第三方库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装openssl</span><br><span class="line"> pip3 install pyOpenSSL</span><br></pre></td></tr></table></figure><h2 id="33、requests请求https携带CA证书"><a href="#33、requests请求https携带CA证书" class="headerlink" title="33、requests请求https携带CA证书"></a>33、requests请求https携带CA证书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import OpenSSL</span><br><span class="line">import requests</span><br><span class="line">import urllib3.contrib.pyopenssl</span><br><span class="line"></span><br><span class="line">urllib3.contrib.pyopenssl.inject_into_urllib3()</span><br><span class="line"></span><br><span class="line">def p12_to_pem(certname, pwd):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    从.p12文件中提取pem</span><br><span class="line">    :param certname:</span><br><span class="line">    :param pwd:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pem_name = certname + &quot;.pem&quot;</span><br><span class="line">    f_pem = open(pem_name, &#x27;wb&#x27;)</span><br><span class="line">    p12file = certname + &quot;.p12&quot;</span><br><span class="line">    p12 = OpenSSL.crypto.load_pkcs12(open(p12file, &#x27;rb&#x27;).read(), pwd)</span><br><span class="line">    f_pem.write(OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, p12.get_privatekey()))</span><br><span class="line">    f_pem.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, p12.get_certificate()))</span><br><span class="line">    ca = p12.get_ca_certificates()</span><br><span class="line">    if ca is not None:</span><br><span class="line">        for cert in ca:</span><br><span class="line">            f_pem.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert))</span><br><span class="line">    f_pem.close()</span><br><span class="line">    return pem_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post_cert_request(url, data,header, certname, pwd):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    使用证书发起https请求</span><br><span class="line">    :param url:</span><br><span class="line">    :param data:</span><br><span class="line">    :param certname:</span><br><span class="line">    :param pwd:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if (certname != &quot;&quot;):</span><br><span class="line">        cert = p12_to_pem(certname, pwd)</span><br><span class="line">    else:</span><br><span class="line">        cert = None</span><br><span class="line">    r = requests.post(url, header=header, data=data, cert=cert)</span><br><span class="line">    return r</span><br></pre></td></tr></table></figure><h2 id="34、django创建缓存命令"><a href="#34、django创建缓存命令" class="headerlink" title="34、django创建缓存命令"></a>34、django创建缓存命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createcachetable 缓存表名</span><br></pre></td></tr></table></figure><h2 id="35、Django-更改超级用户密码"><a href="#35、Django-更改超级用户密码" class="headerlink" title="35、Django 更改超级用户密码"></a>35、Django 更改超级用户密码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在工程文件目录下敲入：</span><br><span class="line">python manage.py shell</span><br><span class="line"></span><br><span class="line">再在python交互界面输入：</span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">user = User.objects.get(username = &#x27;用户名&#x27;)</span><br><span class="line">user.set_password(&#x27;密码&#x27;)</span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure><h2 id="36、restframe使用缓存"><a href="#36、restframe使用缓存" class="headerlink" title="36、restframe使用缓存"></a>36、restframe使用缓存</h2><p><a href="https://blog.csdn.net/Odyssues_lee/article/details/80872586">https://blog.csdn.net/Odyssues_lee/article/details/80872586</a></p><h2 id="37、数据库"><a href="#37、数据库" class="headerlink" title="37、数据库"></a>37、数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user  where ISNULL(code)</span><br><span class="line">update user set code=&#x27;111&#x27;,info=&#x27;微信&#x27; where ISNULL(code)</span><br></pre></td></tr></table></figure><h2 id="38、linux常用命令"><a href="#38、linux常用命令" class="headerlink" title="38、linux常用命令"></a>38、linux常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tail -f 日志名  实时监控日志</span><br><span class="line">tail -f 80_v10.log</span><br><span class="line"></span><br><span class="line">netstat -na|grep 80  查看端口tcp连接数</span><br><span class="line">netstat -na|grep 80 | wc -l 计算端口tcp连接数</span><br><span class="line"></span><br><span class="line">ps -ef|grep python  查看有多少python程序在运行</span><br><span class="line"></span><br><span class="line">gunzip 2015.csv.gz   # 解压</span><br><span class="line">unzip 19.zip # 解压zip</span><br><span class="line">wc -l 2015.csv   # 查看行数</span><br><span class="line">apt install lrzsz  # 安装</span><br><span class="line">sz 文件名  # 下载文件</span><br><span class="line"></span><br><span class="line">查找文件</span><br><span class="line">find / -name 文件名</span><br><span class="line"></span><br><span class="line">匹配执行过的以find为开头的命令</span><br><span class="line">history | grep find</span><br></pre></td></tr></table></figure><h2 id="39、xadmin禁止增加、删除"><a href="#39、xadmin禁止增加、删除" class="headerlink" title="39、xadmin禁止增加、删除"></a>39、xadmin禁止增加、删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># models.py</span><br><span class="line"># 用户管理</span><br><span class="line">class UserManage(models.Model):</span><br><span class="line">    name = models.CharField(max_length=20, verbose_name=&#x27;用户名&#x27;)</span><br><span class="line">    phone = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机号&#x27;)</span><br><span class="line">    code = models.CharField(max_length=11, unique=True, verbose_name=&#x27;编号&#x27;)</span><br><span class="line">    </span><br><span class="line">    user = models.ForeignKey(User, on_delete=models.CASCADE, editable=False, null=True, verbose_name=&#x27;管理员&#x27;)</span><br><span class="line"></span><br><span class="line"># adminx.py</span><br><span class="line"># 用户列表</span><br><span class="line">class UserAdmin(object):</span><br><span class="line">    list_display = [ &#x27;code&#x27;, &#x27;phone&#x27;, &#x27;name&#x27;,]</span><br><span class="line">    search_fields = [&#x27;code&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    list_filter = [&#x27;code&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    list_editable = [&#x27;name&#x27;]  # 数据即时编辑</span><br><span class="line">    readonly_fields = [&#x27;code&#x27;, &#x27;phone&#x27;, &#x27;name&#x27;]  # 只读字段，不能编辑</span><br><span class="line">    model_icon = &#x27;fa fa-square&#x27;</span><br><span class="line">    model = UserInfo</span><br><span class="line">    </span><br><span class="line">    def has_delete_permission(self, *args, **kwargs):</span><br><span class="line">    # 禁止删除</span><br><span class="line">        if args:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">def has_add_permission(self,*args,**kwargs):</span><br><span class="line"># 禁止增加</span><br><span class="line">        return False</span><br><span class="line">        </span><br><span class="line">    def save_models(self):</span><br><span class="line">    # 用户级别设置</span><br><span class="line">        self.new_obj.user = self.request.user</span><br><span class="line">        flag = self.org_obj is None and &#x27;create&#x27; or &#x27;change&#x27;</span><br><span class="line">        if flag == &#x27;create&#x27;:</span><br><span class="line">        # 对密码字段进行加密</span><br><span class="line">            self.new_obj.password = encrypt_oracle(self.new_obj.password)</span><br><span class="line">        elif flag == &#x27;change&#x27;:</span><br><span class="line">            if &#x27;password&#x27; in self.change_message():</span><br><span class="line">                self.new_obj.password = encrypt_oracle(self.new_obj.password)</span><br><span class="line">        else:</span><br><span class="line">        pass</span><br><span class="line">        super().save_models()</span><br><span class="line"></span><br><span class="line">xadmin.site.register(UserInfo, UserAdmin)</span><br></pre></td></tr></table></figure><h2 id="40、时间格式字符串相减"><a href="#40、时间格式字符串相减" class="headerlink" title="40、时间格式字符串相减"></a>40、时间格式字符串相减</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">start = str(datetime.datetime.now())[:19]</span><br><span class="line">time.sleep(60)</span><br><span class="line">end = str(datetime.datetime.now())[:19]</span><br><span class="line">print(start,end)</span><br><span class="line">link_start = datetime.datetime.strptime(start, &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">link_end = datetime.datetime.strptime(end, &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">link_min = round((link_end - link_start).seconds / 60, 2)</span><br><span class="line">print(link_min,&#x27;分钟&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="41、显示循环进度条"><a href="#41、显示循环进度条" class="headerlink" title="41、显示循环进度条"></a>41、显示循环进度条</h2><p>参考：<a href="https://blog.csdn.net/zejianli/article/details/77915751">https://blog.csdn.net/zejianli/article/details/77915751</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from tqdm import tqdm,trange</span><br><span class="line">from time import sleep</span><br><span class="line">text = &quot;&quot;</span><br><span class="line">for char in tqdm([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]):</span><br><span class="line">    text = text + char</span><br><span class="line">    sleep(1)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"># 方式二</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def process_bar(percent, index, total,start_time, start_str=&#x27;&#x27;, end_str=&#x27;&#x27;, total_length=100):</span><br><span class="line">    # 进度条</span><br><span class="line">    percent_length = int(percent)</span><br><span class="line">    bar = &#x27;\r&#x27; + start_str + (&#x27;\033[1;31;41m \033[0m&#x27; * percent_length + &#x27;\033[1;37;47m \033[0m&#x27; * (</span><br><span class="line">                total_length - percent_length)) + f&#x27;  &#123;round(index / total * 100, 2)&#125;%  &#x27; + f&#x27; &#123;index&#125;|&#123;end_str&#125;&#x27;+ f&#x27;   |已进行时间: &#123;round(time.time() - start_time, 2)&#125;秒&#x27;</span><br><span class="line"></span><br><span class="line">    print(bar, end=&#x27;&#x27;, flush=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    data_set = [i for i in range(23)]</span><br><span class="line">    i = 0</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    total = len(data_set)</span><br><span class="line">    end_str = &#x27;&#123;&#125;&#x27;.format(total)</span><br><span class="line">    for data in data_set:</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        i += 1</span><br><span class="line">        process_bar(i * 100 / total, i, total, start_time, start_str=&#x27;&#x27;, end_str=end_str, total_length=100)</span><br><span class="line"></span><br><span class="line"># 方式三</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">d = [i for i in range(100)]</span><br><span class="line">for i in range(len(d)):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    sys.stdout.write(&#x27;\r&gt;&gt; Downloading  %.2f%%&#x27; % (float(i) / float(len(d)) * 100.0))</span><br><span class="line">sys.stdout.flush()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="42、把列表中的字典转成csv文件"><a href="#42、把列表中的字典转成csv文件" class="headerlink" title="42、把列表中的字典转成csv文件"></a>42、把列表中的字典转成csv文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">lists = [&#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125;,&#123;&#x27;a&#x27;:2,&#x27;b&#x27;:3&#125;]</span><br><span class="line">df = pd.DataFrame(lists)</span><br><span class="line">print(df)</span><br><span class="line">df.to_csv(&#x27;result2.csv&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="43、windows添加右键新建MarkDown文件"><a href="#43、windows添加右键新建MarkDown文件" class="headerlink" title="43、windows添加右键新建MarkDown文件"></a>43、windows添加右键新建MarkDown文件</h2><p>在网上下载Typora软件安装后<br>1、在桌面上新建一个txt文件，输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br><span class="line">&quot;FileName&quot;=&quot;template.md&quot;</span><br></pre></td></tr></table></figure><p>2、另存为，改后缀为.reg，保存类型为.txt，编码为Unicode</p><p><img src="https://img-blog.csdnimg.cn/20200526232015169.png" alt="在这里插入图片描述"></p><p>3、双击运行，确定，重启电脑，此时在桌面右键就有了新建md文件</p><h2 id="44、redis设置值定时过期"><a href="#44、redis设置值定时过期" class="headerlink" title="44、redis设置值定时过期"></a>44、redis设置值定时过期</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">import redis</span><br><span class="line"></span><br><span class="line">redis_client = redis.Redis(</span><br><span class="line">    host=&#x27;127.0.0.1&#x27;,</span><br><span class="line">    port=6379,</span><br><span class="line">    db=0,</span><br><span class="line">    password=&#x27;123456&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">def redis_set():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    redis设置值定时过期</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    global redis_client</span><br><span class="line"></span><br><span class="line">    redis_client.set(&#x27;name&#x27;,&#x27;ldc&#x27;)</span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    # 设置‘name’50秒过期</span><br><span class="line">    expire_time = now + datetime.timedelta(hours=0, minutes=0, seconds=50)</span><br><span class="line">    redis_client.expireat(&#x27;name&#x27;, expire_time)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    redis_set()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="45、linux根据端口杀进程"><a href="#45、linux根据端口杀进程" class="headerlink" title="45、linux根据端口杀进程"></a>45、linux根据端口杀进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def killport(port):</span><br><span class="line">    command = &#x27;&#x27;&#x27;kill -9 $(netstat -nlp | grep :&#x27;&#x27;&#x27; + str(port) + &#x27;&#x27;&#x27; | awk &#x27;&#123;print $7&#125;&#x27; | awk -F&quot;/&quot; &#x27;&#123; print $1 &#125;&#x27;)&#x27;&#x27;&#x27;</span><br><span class="line">    os.system(command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 开始执行</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    port = 4237</span><br><span class="line">    killport(port)</span><br></pre></td></tr></table></figure><h2 id="46、监控linux网络流量"><a href="#46、监控linux网络流量" class="headerlink" title="46、监控linux网络流量"></a>46、监控linux网络流量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iftop -n -N -i eth0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nethogs eth0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim +/字符串 文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="47、win10添加右键打开cmd"><a href="#47、win10添加右键打开cmd" class="headerlink" title="47、win10添加右键打开cmd"></a>47、win10添加右键打开cmd</h2><p>通过添加注册表项实现</p><p>win + r 输入 regedit</p><p>找到注册表位置：HKEY_CLASSES_ROOT\Directory\Background\shell\</p><p>右键“shel”l,新建“项”，命名为“以管理员身份打开cmd”，</p><p>右键“以管理员身份打开cmd”，新建“DWORD(32位)值”，命名为”ShowBasedOnVelocityId”,值为“639bc8”</p><p>右键“以管理员身份打开cmd”，新建“项”，命名为“command”</p><p>右键“command”，点击“默认”，点击“修改”，填写数值为 cmd.exe /s /k pushd “%V”</p><h2 id="48、xadmin后台无法显示下拉框完整内容"><a href="#48、xadmin后台无法显示下拉框完整内容" class="headerlink" title="48、xadmin后台无法显示下拉框完整内容"></a>48、xadmin后台无法显示下拉框完整内容</h2><p>解决方案 在根目录中找到/static/xadmin/vendor/selectize/selectize.bootstrap3.css<br>在331行后加入 position: static;</p><p><img src="https://img-blog.csdnimg.cn/20190704184201572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="49、xadmin单点登录"><a href="#49、xadmin单点登录" class="headerlink" title="49、xadmin单点登录"></a>49、xadmin单点登录</h2><p>使用中间件实现。</p><p>新建一个utils.py文件，存放以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.sessions.models import Session</span><br><span class="line">from django.db.models import Q</span><br><span class="line">from django.utils import timezone</span><br><span class="line">from django.utils.deprecation import MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class XadminMiddleware(MiddlewareMixin):</span><br><span class="line">    def process_request(self, request):</span><br><span class="line">        &quot;&quot;&quot;xadmin后台单点登录&quot;&quot;&quot;</span><br><span class="line">        PATH_INFO = request.META.get(&#x27;PATH_INFO&#x27;, &#x27;&#x27;)</span><br><span class="line">        if PATH_INFO and &#x27;xadmin&#x27; in PATH_INFO:</span><br><span class="line">            request.session.clear_expired()   # 清除过期的key</span><br><span class="line">            session_key = request.session.session_key</span><br><span class="line">            for session in Session.objects.filter(~Q(session_key=session_key), expire_date__gte=timezone.now()):</span><br><span class="line">                data = session.get_decoded()</span><br><span class="line">                if data.get(&#x27;_auth_user_id&#x27;, None) == str(request.user.id):</span><br><span class="line">                    session.delete()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在urls.py中设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">...</span><br><span class="line">re_path(&#x27;^xadmin/&#x27;, xadmin.site.urls),</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后在settings.py中注册中间件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   MIDDLEWARE = [</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   &#x27;utils.xadminauth.XadminMiddleware&#x27;,</span><br><span class="line">   ...</span><br><span class="line">   ]</span><br><span class="line">SESSION_COOKIE_AGE = 1209600  # 设置过期时间</span><br><span class="line">   SESSION_SAVE_EVERY_REQUEST = Ture  # 每次请求都更新</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【参考】 <a href="https://blog.csdn.net/Python_anning">https://blog.csdn.net/Python_anning</a></p><h2 id="50、Django-restful-多个models数据表序列化合并返回（一次请求返回多个序列化器数据）"><a href="#50、Django-restful-多个models数据表序列化合并返回（一次请求返回多个序列化器数据）" class="headerlink" title="50、Django restful 多个models数据表序列化合并返回（一次请求返回多个序列化器数据）"></a>50、Django restful 多个models数据表序列化合并返回（一次请求返回多个序列化器数据）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># 导入第三方包</span><br><span class="line">pip install django-crispy-forms==1.7.2</span><br><span class="line"></span><br><span class="line"># 在settings.py中添加应用</span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">...</span><br><span class="line">&#x27;drf_multiple_model&#x27;,</span><br><span class="line">&#x27;rest_framework&#x27;,</span><br><span class="line">...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 在views.py中使用</span><br><span class="line">    from drf_multiple_model.pagination import MultipleModelLimitOffsetPagination</span><br><span class="line">    from drf_multiple_model.views import ObjectMultipleModelAPIView</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    class LimitPagination(MultipleModelLimitOffsetPagination):</span><br><span class="line">        # 多个models数据表联合查询，分页，每页限制数据10条</span><br><span class="line">        default_limit = 10</span><br><span class="line">        </span><br><span class="line">    class StudentSerializers(serializers.ModelSerializer):</span><br><span class="line">        &quot;&quot;&quot;学生表序列化器&quot;&quot;&quot;</span><br><span class="line">        # merchant = MerchantSerializers()</span><br><span class="line">        </span><br><span class="line">        register_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">       </span><br><span class="line">        class Meta:</span><br><span class="line">            model = Student</span><br><span class="line">            fields = &#x27;__all__&#x27;</span><br><span class="line">    class ClassesSerializers(serializers.ModelSerializer):</span><br><span class="line">        &quot;&quot;&quot;班级表序列化器&quot;&quot;&quot;</span><br><span class="line">        # merchant = MerchantSerializers()</span><br><span class="line">        </span><br><span class="line">        add_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">       </span><br><span class="line">        class Meta:</span><br><span class="line">            model = Classes</span><br><span class="line">            fields = &#x27;__all__&#x27;</span><br><span class="line">    </span><br><span class="line">    class SchoolSerializers(serializers.ModelSerializer):</span><br><span class="line">        &quot;&quot;&quot;学校表序列化器&quot;&quot;&quot;</span><br><span class="line">        # merchant = MerchantSerializers()</span><br><span class="line">        </span><br><span class="line">        add_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">       </span><br><span class="line">        class Meta:</span><br><span class="line">            model = School</span><br><span class="line">            fields = &#x27;__all__&#x27;      </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    class StudentInfo(ObjectMultipleModelAPIView):</span><br><span class="line">        # 获取学生信息，班级信息，学校信息</span><br><span class="line">    </span><br><span class="line">        def get(self, request, *args, **kwargs):</span><br><span class="line">            uid = request.GET.get(&#x27;uid&#x27;, &#x27;&#x27;)  # 学生id</span><br><span class="line">            cid = request.GET.get(&#x27;cid&#x27;, &#x27;&#x27;)  # 班级id</span><br><span class="line">            sid = request.GET.get(&#x27;sid&#x27;, &#x27;&#x27;)  # 学校id</span><br><span class="line">            </span><br><span class="line">            self.querylist = [</span><br><span class="line">                &#123;&#x27;queryset&#x27;: Student.objects.filter(id=uid).order_by(&#x27;-id&#x27;),</span><br><span class="line">                    &#x27;serializer_class&#x27;:  StudentSerializers, &#x27;label&#x27;: &#x27;student&#x27;, &#125;,</span><br><span class="line">                &#123;&#x27;queryset&#x27;: Classes.objects.filter(id=cid).order_by(&#x27;-id&#x27;),</span><br><span class="line">                    &#x27;serializer_class&#x27;:  ClassesSerializers, &#x27;label&#x27;: &#x27;classes&#x27;, &#125;,</span><br><span class="line">                &#123;&#x27;queryset&#x27;: School.objects.filter(id=sid).order_by(&#x27;-id&#x27;),</span><br><span class="line">                    &#x27;serializer_class&#x27;:  SchoolSerializers, &#x27;label&#x27;: &#x27;school&#x27;, &#125;,</span><br><span class="line">            ]</span><br><span class="line">    </span><br><span class="line">            return self.list(request, *args, **kwargs)</span><br><span class="line">    </span><br><span class="line">        pagination_class = LimitPagination</span><br></pre></td></tr></table></figure><h2 id="51、-Django序列化器返回外键关联数据"><a href="#51、-Django序列化器返回外键关联数据" class="headerlink" title="51、 Django序列化器返回外键关联数据"></a>51、 Django序列化器返回外键关联数据</h2><p>通过 related_name=’goods_price’把两个表关联起来，当返回Goods的信息时也会返回相应的GoodsPrice信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class GoodsPriceSerializers(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;商品价格表序列化器&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    class Meta:</span><br><span class="line">        model = GoodsPrice</span><br><span class="line">        fields = [&#x27;price&#x27;]</span><br><span class="line"></span><br><span class="line">class GoodsSerializers(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;商品表序列化器&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    goods_price = GoodsPriceSerializers(many=True, read_only=True)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model = Goods</span><br><span class="line">        fields = [&#x27;title&#x27;,&#x27;goods_price&#x27;]</span><br><span class="line">        depth = 2</span><br><span class="line"></span><br><span class="line">class Goods(models.Model):</span><br><span class="line">    &quot;&quot;&quot;商品表&quot;&quot;&quot;</span><br><span class="line">    title = models.CharField(max_length=50, verbose_name=&#x27;商品名称&#x27;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &#x27;goods&#x27;</span><br><span class="line">        verbose_name = &#x27;商品信息表&#x27;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br><span class="line"></span><br><span class="line">class GoodsPrice(models.Model):</span><br><span class="line">    &quot;&quot;&quot;商品价格表,通过外键关联商品信息表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    price = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=&#x27;售价&#x27;)</span><br><span class="line">    goods = models.ForeignKey(to=&#x27;Goods&#x27;, related_name=&#x27;goods_price&#x27;, on_delete=models.SET_NULL, blank=True, null=True,verbose_name=&#x27;商品&#x27;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return str(self.price)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        managed = True</span><br><span class="line">        db_table = &#x27;goodsPrice&#x27;</span><br><span class="line">        verbose_name = &#x27;商品售价&#x27;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure><h2 id="52、python-Django通过User-Agent判断请求来源是微信扫一扫或者是支付宝扫一扫"><a href="#52、python-Django通过User-Agent判断请求来源是微信扫一扫或者是支付宝扫一扫" class="headerlink" title="52、python Django通过User Agent判断请求来源是微信扫一扫或者是支付宝扫一扫"></a>52、python Django通过User Agent判断请求来源是微信扫一扫或者是支付宝扫一扫</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Footest(APIView):</span><br><span class="line"> def get(self, request, *args, **kwargs):</span><br><span class="line">     # print(request.META)</span><br><span class="line">     if &#x27;MicroMessenger&#x27; in request.META[&#x27;HTTP_USER_AGENT&#x27;]:</span><br><span class="line">         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是微信&#x27;&#125;)</span><br><span class="line">     elif &#x27;AlipayClient&#x27; in request.META[&#x27;HTTP_USER_AGENT&#x27;]:</span><br><span class="line">         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是支付宝&#x27;&#125;)</span><br><span class="line">     else:</span><br><span class="line">         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是其他&#x27;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</p><p>浏览器的 UA 字串</p><p>标准格式为： 浏览器标识 (操作系统标识; 加密等级标识; 浏览器语言) 渲染引擎标识 版本信息</p><p>获取user-Agent 之后，<br>通过识别MicroMessenger或者AlipayClient这样的关键字应该就可以判断是微信还是支付宝<br>【参考文章】 <a href="https://blog.csdn.net/fly910905/article/details/82498813?utm_source=blogxgwz4">https://blog.csdn.net/fly910905/article/details/82498813?utm_source=blogxgwz4</a></p><h2 id="53、xadmin后台集成’导入‘插件，导入excel文件"><a href="#53、xadmin后台集成’导入‘插件，导入excel文件" class="headerlink" title="53、xadmin后台集成’导入‘插件，导入excel文件"></a>53、xadmin后台集成’导入‘插件，导入excel文件</h2><p>效果图：</p><p><img src="https://img-blog.csdnimg.cn/20190426190357134.png" alt="在这里插入图片描述"></p><p>1、添加</p><p>在虚拟环境根目录\Lib\site-packages\xadmin\plugins中添加excel.py文件</p><p><img src="https://img-blog.csdnimg.cn/20190426190440451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>from xadmin.views import BaseAdminPlugin, ListAdminViewfrom django.template import loaderimport xadminclass ListExcelImportPlugin(BaseAdminPlugin):    # 重写init_request    import_excel = False    def init_request(self, *args, **kwargs):        return self.import_excel    def block_top_toolbar(self, context, nodes):        # 这里 xadmin/excel/model_list.top_toolbar.import.html 是自己写的html文件      nodes.append(loader.render_to_string(&quot;xadmin/excel/model_list.top_toolbar.import.html&quot;))xadmin.site.register_plugin(ListExcelImportPlugin, ListAdminView)</code></pre><p>在虚拟环境根目录\Lib\site-packages\xadmin\plugins<strong>init</strong>.py中</p><pre><code>PLUGINS = (...    &#39;excel&#39;,...)</code></pre><p>2、添加html文件</p><p><img src="https://img-blog.csdnimg.cn/20190426190455263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在虚拟环境根目录\Lib\site-packages\xadmin\templates\xadmin\中增加文件夹excel,在文件夹中添加model_list.top_toolbar.import.html文件</p><pre><code>    &#123;% load i18n %&#125;&lt;div class=&quot;btn-group export&quot;&gt;    &lt;a class=&quot;dropdown-toggle btn btn-default btn-sm&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt;        &lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入数据 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;    &lt;/a&gt;    &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dLabel&quot;&gt;        &lt;li&gt;&lt;a data-toggle=&quot;modal&quot; data-target=&quot;#export-modal-import-excel&quot;&gt;&lt;i class=&quot;icon-circle-arrow-down&quot;&gt;&lt;/i&gt; 导入            Excel&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div id=&quot;export-modal-import-excel&quot; class=&quot;modal fade&quot;&gt;        &lt;div class=&quot;modal-dialog&quot;&gt;            &lt;div class=&quot;modal-content&quot;&gt;                &lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;                    &lt;!--&#123;% csrf_token %&#125;--&gt;                    &lt;div class=&quot;modal-header&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;×&lt;/button&gt;                        &lt;h4 class=&quot;modal-title&quot;&gt;导入 Excel&lt;/h4&gt;                    &lt;/div&gt;                    &lt;div class=&quot;modal-body&quot;&gt;                        &lt;input type=&quot;file&quot; onchange=&quot;fileChange(this)&quot; name=&quot;excel&quot; id=&quot;submit_upload&quot;&gt;                    &lt;/div&gt;                    &lt;div class=&quot;modal-footer&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;&#123;% trans "Close" %&#125;&lt;/button&gt;                        &lt;button class=&quot;btn btn-success&quot; type=&quot;button&quot; id=&quot;submit_upload_b&quot;&gt;&lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入                        &lt;/button&gt;                    &lt;/div&gt;                &lt;/form&gt;            &lt;/div&gt;&lt;!-- /.modal-content --&gt;        &lt;/div&gt;&lt;!-- /.modal-dalog --&gt;    &lt;/div&gt;&lt;!-- /.modal --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function fileChange(target) &#123;        //检测上传文件的类型        var imgName = document.all.submit_upload.value;        var ext, idx;        if (imgName == &#39;&#39;) &#123;            document.all.submit_upload_b.disabled = true;            alert(&quot;请选择需要上传的 xls 文件!&quot;);            return;        &#125; else &#123;            idx = imgName.lastIndexOf(&quot;.&quot;);            if (idx != -1) &#123;                ext = imgName.substr(idx + 1).toUpperCase();                ext = ext.toLowerCase();                if (ext != &#39;xls&#39; &amp;&amp; ext != &#39;xlsx&#39;) &#123;                    document.all.submit_upload_b.disabled = true;                    alert(&quot;只能上传 .xls 类型的文件!&quot;);                    return;                &#125;            &#125; else &#123;                document.all.submit_upload_b.disabled = true;                alert(&quot;只能上传 .xls 类型的文件!&quot;);                return;            &#125;        &#125;    &#125;    $(document).ready(function () &#123;        $(&#39;#submit_upload_b&#39;).click(function () &#123;            var form_data = new FormData();            var file_info = $(&#39;#submit_upload&#39;)[0].files[0];            form_data.append(&#39;file&#39;, file_info);            form_data.append(&#39;file_source&#39;, $(&#39;.breadcrumb li&#39;).eq(1).text().trim());            var url = window.location.protocol + &#39;//&#39; + window.location.host + &#39;/importkdorderno/&#39;            $.ajax(&#123;                url: url,                type: &#39;POST&#39;,                data: form_data,                dataType: &quot;json&quot;,                beforeSend: function (xhr) &#123;                    xhr.setRequestHeader(&quot;X-CSRFToken&quot;, $.getCookie(&quot;csrftoken&quot;))                &#125;,                processData: false,  // tell jquery not to process the data                contentType: false, // tell jquery not to set contentType                success: function (res) &#123;                    alert(res.msg);                    window.location.reload();                &#125;,                error: function (err) &#123;                &#125;            &#125;);        &#125;);    &#125;)&lt;/script&gt;</code></pre><p>3、在views.py处理上传的excel文件</p><pre><code>import pandas as pdfrom rest_framework.views import APIViewclass ImportKDOrderNo(APIView):    def post(self, request, *args, **kwargs):        file = request.FILES.get(&#39;file&#39;)        # read = InMemoryUploadedFile().open()        data = pd.read_excel(file)  # 使用pandas处理excel文件        file_source = request.POST.get(&#39;file_source&#39;, &#39;&#39;)  # 文件来源        if &#39;订单号&#39; and &#39;物流单号&#39; not in data:            return Response(data=&#123;&#39;msg&#39;: &#39;文件格式有误，第一行第一列应该为【订单号】，第一行第二列应该为【物流单号】&#39;&#125;)        ordernos = data[&#39;订单号&#39;]        logistics = data[&#39;物流单号&#39;]        for i in range(len(ordernos)):            print(&#39;订单号&#39;, ordernos[i], &#39;物流单号&#39;, logistics[i])        return Response(data=&#123;&#39;msg&#39;: &#39;上传成功&#39;&#125;)</code></pre><p>4、在urls.py中添加访问路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from 你的应用名称 import views</span><br><span class="line"></span><br><span class="line">app_name = &#x27;你的应用名称&#x27;</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    # 其他路由</span><br><span class="line">    ...</span><br><span class="line">    # 导入物流单号</span><br><span class="line">    path(&#x27;importkdorderno/&#x27;, views.ImportKDOrderNo.as_view(), name=&#x27;importkdorderno&#x27;),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="54、Django中查找今天进账金额"><a href="#54、Django中查找今天进账金额" class="headerlink" title="54、Django中查找今天进账金额"></a>54、Django中查找今天进账金额</h2><p>views.py</p><pre><code>from datetime import datetimeclass CountFee(APIView):    def get(self, request, *args, **kwargs):        # 获取当前时间的年月日，然后使用聚合函数添加fee字段的值        year = datetime.now().year        month = datetime.now().month        day = datetime.now().day        count_fees = FeeDetail.objects.filter(addtime__year=year, addtime__month=month, addtime__day=day).aggregate(Sum(&#39;fee&#39;))        all_fee = count_fees[&#39;fee__sum&#39;] if count_fees[&#39;fee__sum&#39;] else 0        print(all_fee)        return Response(&#123;&#39;code&#39;: 1, &#39;msg&#39;: &#39;success&#39;, &#39;data&#39;: &#123;&#39;all_fee&#39;: all_fee&#125;&#125;)</code></pre><h2 id="55、判断是什么系统"><a href="#55、判断是什么系统" class="headerlink" title="55、判断是什么系统"></a>55、判断是什么系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import platform</span><br><span class="line">PlATFORM = platform.system()</span><br><span class="line">if PlATFORM == &quot;Linux&quot;:</span><br><span class="line">    print(&#x27;linux&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;其他&#x27;) </span><br></pre></td></tr></table></figure><h2 id="56、sql查询"><a href="#56、sql查询" class="headerlink" title="56、sql查询"></a>56、sql查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 联合更新</span><br><span class="line">update malluser set master_master_id=3 where master_id in (select a.id from (select id from  malluser where id like &#x27;15%&#x27;)a) </span><br><span class="line"># 统计某字段重复数据</span><br><span class="line">SELECT phone, COUNT(*) AS sumCount FROM malluser GROUP BY phone HAVING sumCount &gt; 1;</span><br></pre></td></tr></table></figure><h2 id="57、-xadmin后台删除数据出现错误"><a href="#57、-xadmin后台删除数据出现错误" class="headerlink" title="57、 xadmin后台删除数据出现错误"></a>57、 xadmin后台删除数据出现错误</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`get_deleted_objects() takes 3 positional arguments but 5 were given`</span><br></pre></td></tr></table></figure><p>这是由于Django2.1版本和xadmin不兼容导致的</p><p>知道虚拟环境\Lib\site-packages\xadmin\plugins\actions.py</p><p>修改93行，</p><p>把</p><pre><code>deletable_objects, model_count, perms_needed, protected = get_deleted_objects(            queryset, self.opts, self.user, self.admin_site, using)</code></pre><p>改为</p><pre><code>deletable_objects, model_count, perms_needed, protected = get_deleted_objects(            queryset, self.user, self.admin_site)</code></pre><p>然后在adminx.py文件中对应的模型类中允许删除</p><pre><code>class MaterialAdmin(object):    &quot;&quot;&quot;素材库分类&quot;&quot;&quot;    list_display = [&#39;id&#39;, &#39;name&#39;, &#39;class_id&#39;, &#39;is_delete&#39;, &#39;addtime&#39;]    def has_delete_permission(self, *args, **kwargs):        return True</code></pre><h2 id="58、xdamin限制用户点击"><a href="#58、xdamin限制用户点击" class="headerlink" title="58、xdamin限制用户点击"></a>58、xdamin限制用户点击</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//如果登录z=xadmin后台的账号不是【root】的就不能点击更新操作</span><br><span class="line">    var master_name = $(&#x27;#top-nav&#x27;).find(&#x27;strong&#x27;).text();</span><br><span class="line">        master_name =  master_name.substring(4);</span><br><span class="line">    if(master_name != &#x27;root&#x27;)&#123;</span><br><span class="line">            $(&quot;.grid-item a&quot;).each(function(index, element) &#123;</span><br><span class="line">                $(this).attr(&#x27;href&#x27;,&#x27;#&#x27;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="59、获取公众号关注url"><a href="#59、获取公众号关注url" class="headerlink" title="59、获取公众号关注url"></a>59、获取公众号关注url</h2><p>在微信网页版，打开公众号，点击右上角“…”，在弹框中选择右下角中间的“查看历史记录”，然后在弹框中选择左上角倒数第一个，“用默认浏览器打开”，就可以在打开的浏览器中获取该公众号的关注url，当把这个url发给好友时，好友点开的就是去关注公众号的页面。</p><h2 id="60、xadmin后台用户操作表权限"><a href="#60、xadmin后台用户操作表权限" class="headerlink" title="60、xadmin后台用户操作表权限"></a>60、xadmin后台用户操作表权限</h2><p>虚拟环境根目录\Lib\site-packages\xadmin\views\base.py</p><p>可以找到：</p><p><img src="https://img-blog.csdnimg.cn/20190627140512311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在项目子应用下的adminx.py中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line"></span><br><span class="line">from machine.models import Machine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MachineAdmin(object):</span><br><span class="line">    list_display = [&#x27;code&#x27;,]  # 显示的字段</span><br><span class="line"></span><br><span class="line">    search_fields = [&#x27;code&#x27;]  # 搜索的字段</span><br><span class="line">    list_filter = [&#x27;code&#x27;, &#x27;is_delete&#x27;] # 过滤的字段</span><br><span class="line">    ordering = (&#x27;-id&#x27;,) # 按id降序排序</span><br><span class="line">    list_editable = [&#x27;is_delete&#x27;, ]  # 数据即时编辑</span><br><span class="line">    list_per_page = 30  # 每页显示数据数量</span><br><span class="line">    model_icon = &#x27;fa fa-cog fa-spin&#x27;  # 左侧显示的小图标</span><br><span class="line"></span><br><span class="line">    def has_delete_permission(self, *args, **kwargs): </span><br><span class="line">        # 删除权限</span><br><span class="line">        if self.request.user.is_superuser:  # 管理员才能增加</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def has_add_permission(self, *args, **kwargs):</span><br><span class="line">        if self.request.user.is_superuser:  # 管理员才能增加</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def has_change_permission(self, *args, **kwargs):</span><br><span class="line">        if self.request.user.is_superuser: # 管理员才能修改</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def queryset(self):</span><br><span class="line">        qs = super(MachineAdmin, self).queryset()</span><br><span class="line">        if self.request.user.is_superuser:  # 管理员可以查看所有</span><br><span class="line">            return qs</span><br><span class="line">        else:</span><br><span class="line">            # 登录用户只能看到自己修改的数据</span><br><span class="line">            return qs.filter(master_id=self.request.user.last_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xadmin.site.register(MallMachine, MallMachineAdmin)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="61、使用nginx部署项目"><a href="#61、使用nginx部署项目" class="headerlink" title="61、使用nginx部署项目"></a>61、使用nginx部署项目</h2><p>先在/etc/nginx/sites-available中创建一个配置文件，文件名为test(注意没有后缀):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#设定虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen 80;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        #定义使用 www.nginx.cn访问</span><br><span class="line">#ssl on;</span><br><span class="line">        server_name  xxx.xxx.com;</span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root /root/项目名称;</span><br><span class="line">ssl_session_timeout 5m; </span><br><span class="line">        ssl_certificate   /etc/nginx/cert/xxx.pem;</span><br><span class="line">        ssl_certificate_key  /etc/nginx/cert/xxx.key;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        #access_log  logs/nginx.access.log  main;</span><br><span class="line"> </span><br><span class="line">        #默认请求</span><br><span class="line">        location / &#123;</span><br><span class="line">            #倒入了uwsgi的配置</span><br><span class="line">            include uwsgi_params; </span><br><span class="line">    client_max_body_size50m;</span><br><span class="line">            #连接uwsgi的超时时间</span><br><span class="line">           # uwsgi_connect_timeout 30; </span><br><span class="line">     #设定了uwsig服务器位置</span><br><span class="line">     uwsgi_pass 127.0.0.1:8002;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /static&#123;</span><br><span class="line">      alias /root/项目名称/static;</span><br><span class="line">        &#125;</span><br><span class="line">location /media &#123;</span><br><span class="line">alias /root/项目名称/media;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中xxx.xxx.com表示域名.如果没有https，就使用#把ssl注释掉就可以了。</p><p>然后把test映射到/etc/nginx/sites-enabled</p><p>命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/nginx/sites-available/test /etc/nginx/sites-enabled/test</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即可<br>注意：<br>uwsgi中配置listen=1024时，启动uwsgi时可能会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django + uwsgi + nginx 日志Listen queue size is greater than the system max net.core.somaxconn (128).</span><br></pre></td></tr></table></figure><p>解决方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改系统参数</span><br><span class="line"></span><br><span class="line">/proc/sys/net/ipv4/tcp_max_syn_backlog  原来2048    改为8192</span><br><span class="line">/proc/sys/net/core/somaxconn原来128     改为262144</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="62、xadmin后台发送邮件找回密码"><a href="#62、xadmin后台发送邮件找回密码" class="headerlink" title="62、xadmin后台发送邮件找回密码"></a>62、xadmin后台发送邮件找回密码</h2><p><img src="https://img-blog.csdnimg.cn/20190710230444358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>输入你用户绑定的邮箱</p><p><img src="https://img-blog.csdnimg.cn/20190710230454725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>想要发送邮件，需要在settings.py中设置邮件发送器</p><p>settings.py最下面增加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ------------------------邮箱配置-----------------------------------------</span><br><span class="line">EMAIL_BACKEND = &#x27;django.core.mail.backends.smtp.EmailBackend&#x27; #把要发送的邮件显示再控制台上，方便调试</span><br><span class="line">EMAIL_USE_SSL = True</span><br><span class="line">EMAIL_HOST = &#x27;smtp.qq.com&#x27;  # 如果是 163 改成 smtp.163.com</span><br><span class="line">EMAIL_PORT = 465</span><br><span class="line">EMAIL_HOST_USER = &#x27;邮箱账号&#x27; # 帐号</span><br><span class="line">EMAIL_HOST_PASSWORD = &#x27;授权码&#x27;  # 到邮箱里开通</span><br><span class="line">DEFAULT_FROM_EMAIL = EMAIL_HOST_USER</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于django2与xadmin有些地方不兼容，需要修改源码：</p><p>找到虚拟环境根目录\Lib\site-packages\xadmin\plugins\passwords.py</p><p>在passwords.py文件中大概79行，修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">return password_reset_confirm(request=request, uidb36=uidb36, token=token,</span><br><span class="line">                                      template_name=self.password_reset_confirm_template,</span><br><span class="line">                                      token_generator=self.password_reset_token_generator,</span><br><span class="line">                                      set_password_form=self.password_reset_set_form,</span><br><span class="line">                                      post_reset_redirect=self.get_admin_url(&#x27;xadmin_password_reset_complete&#x27;),</span><br><span class="line">                                      current_app=self.admin_site.name, extra_context=context).dispatch(request=request,</span><br><span class="line">                                                                                                        uidb64=uidb36,token=token)</span><br><span class="line">             </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到虚拟环境根目录Lib\site-packages\django\contrib\auth\views.py</p><p>在views.py文件中大概258行，增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 成功后跳转路由,根据自己实际来定</span><br><span class="line">self.success_url = self.request.build_absolute_uri(&#x27;/&#x27;) + &#x27;xadmin/&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020052620533440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="63、xadmin外键下拉框添加过滤"><a href="#63、xadmin外键下拉框添加过滤" class="headerlink" title="63、xadmin外键下拉框添加过滤"></a>63、xadmin外键下拉框添加过滤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MallGoodsAdmin(object):</span><br><span class="line">    &quot;&quot;&quot;商品管理&quot;&quot;&quot;</span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;show_photo&#x27;, &#x27;nickname&#x27;, &#x27;merchant&#x27;, &#x27;goods_class&#x27;, &#x27;label&#x27;,]</span><br><span class="line">    search_fields = [&#x27;nickname&#x27;]</span><br><span class="line">    list_filter = [&#x27;goods_class&#x27;, &#x27;label&#x27;,]</span><br><span class="line">    model_icon = &#x27;fa fa-bars&#x27;</span><br><span class="line">    list_editable = [&#x27;goods_class&#x27;, ]</span><br><span class="line">    #,重写虚拟环境根目录下\Lib\site-packages\xadmin\views\edit.py中的formfield_for_dbfield</span><br><span class="line">    def formfield_for_dbfield(self, db_field, **kwargs):</span><br><span class="line">        # 对MallGoodsClass这个表项的下拉框选择进行过滤</span><br><span class="line">        # MallGoods中有一个goods_class商品分类外键MallGoodsClass，过滤掉外键MallGoodsClass中 </span><br><span class="line">        # master_class为空的值</span><br><span class="line">        if db_field.name == &quot;goods_class&quot;:</span><br><span class="line">            kwargs[&quot;queryset&quot;] = MallGoodsClass.objects.filter(master_class__isnull=False)</span><br><span class="line">            # 对assigned_recipient这个表项的下拉选择进行过滤</span><br><span class="line">        return db_field.formfield(**dict(**kwargs))</span><br><span class="line">        return super().formfield_for_dbfield(db_field, **kwargs)</span><br><span class="line"></span><br><span class="line">xadmin.site.register(models.MallGoods, MallGoodsAdmin)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="64、xadmin即时编辑器去掉空标签"><a href="#64、xadmin即时编辑器去掉空标签" class="headerlink" title="64、xadmin即时编辑器去掉空标签"></a>64、xadmin即时编辑器去掉空标签</h2><p><img src="https://img-blog.csdnimg.cn/20190716151440115.png" alt="在这里插入图片描述"></p><p>虚拟环境根目录下\Lib\site-packages\xadmin\plugins\editable.py，在大概</p><p>129行增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">form.fields[fields[0]].empty_label = None</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190716151459680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="65、用户增加的小组件，让其他用户可见"><a href="#65、用户增加的小组件，让其他用户可见" class="headerlink" title="65、用户增加的小组件，让其他用户可见"></a>65、用户增加的小组件，让其他用户可见</h2><p>找到虚拟环境根目录\Lib\site-packages\xadmin\views\dashboard.py</p><p>在548行、554行</p><p><img src="https://img-blog.csdnimg.cn/20190723175537371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@filter_hook</span><br><span class="line">    def get_widgets(self):</span><br><span class="line"></span><br><span class="line">        if self.widget_customiz:</span><br><span class="line">            portal_pos = UserSettings.objects.filter(</span><br><span class="line">               key=self.get_portal_key())</span><br><span class="line">            if len(portal_pos):</span><br><span class="line">                portal_pos = portal_pos[0].value</span><br><span class="line">                widgets = []</span><br><span class="line"></span><br><span class="line">                if portal_pos:</span><br><span class="line">                    user_widgets = dict([(uw.id, uw) for uw in UserWidget.objects.filter(page_id=self.get_page_id())])</span><br><span class="line">                    for col in portal_pos.split(&#x27;|&#x27;):</span><br><span class="line">                        ws = []</span><br><span class="line">                        for wid in col.split(&#x27;,&#x27;):</span><br><span class="line">                            try:</span><br><span class="line">                                widget = user_widgets.get(int(wid))</span><br><span class="line">                                if widget:</span><br><span class="line">                                    ws.append(self.get_widget(widget))</span><br><span class="line">                            except Exception as e:</span><br><span class="line">                                import logging</span><br><span class="line">                                logging.error(e, exc_info=True)</span><br><span class="line">                        widgets.append(ws)</span><br><span class="line"></span><br><span class="line">                return widgets</span><br><span class="line"></span><br><span class="line">        return self.get_init_widget()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="66、pip-install-uwsgi出错"><a href="#66、pip-install-uwsgi出错" class="headerlink" title="66、pip install uwsgi出错"></a>66、pip install uwsgi出错</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins/python/uwsgi_python.h:2:20: fatal error: Python.h: No such file or directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先安装python3环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install python3-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再虚拟环境中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uwsgi</span><br></pre></td></tr></table></figure><h2 id="66、xadmin后台加载数据慢，解决方案"><a href="#66、xadmin后台加载数据慢，解决方案" class="headerlink" title="66、xadmin后台加载数据慢，解决方案"></a>66、xadmin后台加载数据慢，解决方案</h2><p>list_filter: 过滤器要慎用，不要使用类似id这些数据量大的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MallUserAdmin(object):</span><br><span class="line">    &quot;&quot;&quot;用户管理&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;tp_icon&#x27;, &#x27;nickname&#x27;, &#x27;phone&#x27;, &#x27;level&#x27;, &#x27;balance&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 显示字段</span><br><span class="line">    search_fields = [&#x27;id&#x27;, &#x27;nickname&#x27;, &#x27;phone&#x27;]  # 搜索</span><br><span class="line">    list_filter = [&#x27;level&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 过滤器</span><br><span class="line">    # list_filter = [&#x27;id&#x27;, &#x27;level&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 如果加id，xadmin加载回来的数据就会很慢，所以不要在过滤器上使用id</span><br><span class="line">    list_per_page = 30  # 默认每页数量</span><br><span class="line">    model_icon = &#x27;fa fa-users&#x27;  # 左侧图标</span><br><span class="line">    ordering = [&#x27;-id&#x27;]  # 排序</span><br><span class="line">    readonly_fields = [&#x27;subscribe&#x27;, &#x27;wx_openid&#x27;, &#x27;phone&#x27;]  # 只读字段</span><br><span class="line">    is_addbalance = True   # 加载自定义的插件</span><br><span class="line">    relfield_style = &#x27;fk-ajax&#x27;  # 其他表如果外键到用户表就做ajax搜索查询，不一次性加载数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="67-、xadmin导出插件处理，增加导出勾选数据项"><a href="#67-、xadmin导出插件处理，增加导出勾选数据项" class="headerlink" title="67 、xadmin导出插件处理，增加导出勾选数据项"></a>67 、xadmin导出插件处理，增加导出勾选数据项</h2><p>常规的导出只有两个选择【导出表头】、【导出全部数据】</p><p><img src="https://img-blog.csdnimg.cn/20190917141511283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在想要做的是增加一个选择，即【导出表头】、【导出全部数据】、【导出勾选数据】，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20190917141839822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>需要修改xadmin源代码，具体如下</p><h4 id="1、加载js文件"><a href="#1、加载js文件" class="headerlink" title="1、加载js文件"></a>1、加载js文件</h4><p>找到虚拟环境\Lib\site-packages\xadmin\views\list.py，在607行增加’xadmin.plugin.importexport.js’，如下图所示</p><p><img src="https://img-blog.csdnimg.cn/20190917141853832.png" alt="在这里插入图片描述"></p><h4 id="2、修改export-py，后端处理下载文件"><a href="#2、修改export-py，后端处理下载文件" class="headerlink" title="2、修改export.py，后端处理下载文件"></a>2、修改export.py，后端处理下载文件</h4><p>找到虚拟环境\Lib\site-packages\xadmin\plugins\export.py</p><p>在84行把rows = context[‘results’]修改成如下函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 新增导出所选数据</span><br><span class="line"># rows = context[&#x27;results&#x27;]  </span><br><span class="line">rows = []</span><br><span class="line">select_across = self.request.GET.get(&#x27;_select_across&#x27;, False) == &#x27;1&#x27;</span><br><span class="line">selected = self.request.GET.get(&#x27;_selected_actions&#x27;, &#x27;&#x27;)</span><br><span class="line">if self.request.GET.get(&#x27;selected&#x27;, &#x27;off&#x27;) == &#x27;on&#x27;:</span><br><span class="line">    if not select_across:</span><br><span class="line">        selected_pk = selected.split(&#x27;,&#x27;)</span><br><span class="line">        for i in context[&#x27;results&#x27;]:</span><br><span class="line">            if str(i[&#x27;object&#x27;].id) in selected_pk:</span><br><span class="line">                rows.append(i)</span><br><span class="line">    else:</span><br><span class="line">        rows = context[&#x27;results&#x27;]</span><br><span class="line">else:</span><br><span class="line">    rows = context[&#x27;results&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019091714200418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3、 修改model_list.top_toolbar.exports.html<br>找到虚拟环境\Lib\site-packages\xadmin\templates\xadmin\blocks\model_list.top_toolbar.exports.html</p><p>使用以下代码覆盖原文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load i18n %&#125;</span><br><span class="line">&lt;div class=&quot;btn-group export&quot;&gt;</span><br><span class="line">    &lt;a id=&quot;export-menu&quot; class=&quot;dropdown-toggle btn btn-default btn-sm&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;fa fa-share&quot;&gt;&lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dLabel&quot;&gt;</span><br><span class="line">        &#123;% for et in export_types %&#125;</span><br><span class="line">        &lt;li&gt;&lt;a data-toggle=&quot;modal&quot; data-target=&quot;#export-modal-&#123;&#123;et.type&#125;&#125;&quot;&gt;&lt;i class=&quot;fa fa-arrow-circle-down&quot;&gt;</span><br><span class="line">        &lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125; &#123;&#123;et.name&#125;&#125;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">    &#123;% for et in export_types %&#125;</span><br><span class="line">    &lt;div id=&quot;export-modal-&#123;&#123;et.type&#125;&#125;&quot; class=&quot;modal fade&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;modal-dialog&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;modal-content&quot;&gt;</span><br><span class="line">                &lt;form method=&quot;get&quot; action=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;div class=&quot;modal-header&quot;&gt;</span><br><span class="line">                        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt;</span><br><span class="line">                        &lt;h4 class=&quot;modal-title&quot;&gt;&#123;% trans &quot;Export&quot; %&#125; &#123;&#123;et.name&#125;&#125;&lt;/h4&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;modal-body&quot;&gt;</span><br><span class="line">                        &#123;&#123; form_params|safe &#125;&#125;</span><br><span class="line">                        &lt;input type=&quot;hidden&quot; name=&quot;export_type&quot; value=&quot;&#123;&#123;et.type&#125;&#125;&quot;&gt;</span><br><span class="line">                        &lt;!-- 增加 导出所选数据 一栏 --&gt;</span><br><span class="line">                        &lt;input type=&quot;hidden&quot; name=&quot;_selected_actions&quot; value=&quot;&quot;/&gt;</span><br><span class="line">                        &lt;input type=&quot;hidden&quot; name=&quot;_select_across&quot; value=&quot;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;label class=&quot;checkbox&quot;&gt;</span><br><span class="line">                            &#123;% if et.type == &quot;xlsx&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xlsx_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with table header.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                            &#123;% if et.type == &quot;xls&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xls_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with table header.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                            &#123;% if et.type == &quot;csv&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_csv_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with table header.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                            &#123;% if et.type == &quot;xml&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xml_format&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with format.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                            &#123;% if et.type == &quot;json&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_json_format&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with format.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                        &lt;/label&gt;</span><br><span class="line">                        &lt;label class=&quot;checkbox&quot;&gt;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;all&quot; value=&quot;on&quot;&gt; &#123;% trans &quot;Export all data.&quot; %&#125;</span><br><span class="line">                        &lt;/label&gt;</span><br><span class="line">                        &lt;!-- 增加 导出所选数据 一栏 --&gt;</span><br><span class="line">                        &lt;label class=&quot;checkbox&quot;&gt;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;selected&quot; value=&quot;on&quot;&gt; 导出勾选数据</span><br><span class="line">                        &lt;/label&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;modal-footer&quot;&gt;</span><br><span class="line">                        &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;&#123;% trans &quot;Close&quot; %&#125;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;button class=&quot;btn btn-success myexport  glyphicon glyphicon-export &quot; type=&quot;submit&quot;&gt;&lt;i</span><br><span class="line">                                class=&quot;fa fa-share&quot;&gt;&lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125;</span><br><span class="line">                        &lt;/button&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;&lt;!-- /.modal-content --&gt;</span><br><span class="line">        &lt;/div&gt;&lt;!-- /.modal-dalog --&gt;</span><br><span class="line">    &lt;/div&gt;&lt;!-- /.modal --&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 如果是订单导出，把待出货订单设置成待收货订单</span><br><span class="line">    $(document).ready(function () &#123;</span><br><span class="line">        $(&#x27;.myexport&#x27;).click(function () &#123;</span><br><span class="line">            // 当把订单导出时，需要修改订单状态为待收货状态</span><br><span class="line">            var url = window.location.protocol + &#x27;//&#x27; + window.location.host + &quot;/exportorder/&quot;;</span><br><span class="line">            $(&quot;input[name=&#x27;_select_across&#x27;]&quot;).val($(&quot;input[name=&#x27;select_across&#x27;]&quot;).val());</span><br><span class="line">            if ($(&quot;input[name=&#x27;selected&#x27;]&quot;).is(&#x27;:checked&#x27;)) &#123;</span><br><span class="line">                var arr = [];</span><br><span class="line">                $.each($(&#x27;.action-select&#x27;), function () &#123;</span><br><span class="line">                    if (true == $(this).prop(&#x27;checked&#x27;)) &#123;</span><br><span class="line">                        arr.push($(this).val());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                if(arr.length == 0)&#123;</span><br><span class="line">                    alert(&#x27;请先勾选导出数据&#x27;)</span><br><span class="line">                    return false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                var arr = []</span><br><span class="line">                var order_type = $(&#x27;.breadcrumb li&#x27;).eq(1).text().trim()</span><br><span class="line">                $(&#x27;.grid-item&#x27;).each(function (index, el) &#123;</span><br><span class="line"></span><br><span class="line">                    arr.push($(el).find(&#x27;td&#x27;).eq(1).text().trim())</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            if (($(&#x27;.breadcrumb &gt; li&#x27;).eq(1).text()).indexOf(&#x27;订单&#x27;) != -1) &#123;</span><br><span class="line">                // 5秒后执行</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    $.ajax(&#123;</span><br><span class="line">                        type: &quot;POST&quot;,</span><br><span class="line">                        url: url,</span><br><span class="line">                        data: &#123;&#x27;orderlist&#x27;: JSON.stringify(arr), &#x27;order_type&#x27;: order_type,&#125;,</span><br><span class="line">                        beforeSend: function (xhr) &#123;</span><br><span class="line">                            xhr.setRequestHeader(&quot;X-CSRFToken&quot;, $.getCookie(&quot;csrftoken&quot;))</span><br><span class="line">                        &#125;,</span><br><span class="line">                        success: function (data) &#123;</span><br><span class="line">                            window.location.reload();</span><br><span class="line">                        &#125;,</span><br><span class="line">                        error: function (xhr) &#123;</span><br><span class="line">                            alert(&quot;出现未知错误&quot;);</span><br><span class="line">                            window.location.reload();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;, 5000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="68、使用F查询更新用户重要数据"><a href="#68、使用F查询更新用户重要数据" class="headerlink" title="68、使用F查询更新用户重要数据"></a>68、使用F查询更新用户重要数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import F</span><br><span class="line"># 使用F查询更新用户余额</span><br><span class="line">balance = 5  </span><br><span class="line">MallUser.objects.filter(id=1).update(balance=F(&#x27;balance&#x27;) + balance)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相当于sql的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update Malluser set balance=balance + 5 where id=1;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="69、日志输出模块"><a href="#69、日志输出模块" class="headerlink" title="69、日志输出模块"></a>69、日志输出模块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import platform</span><br><span class="line"># 全局函数</span><br><span class="line">PlATFORM = platform.system()</span><br><span class="line">if (PlATFORM == &quot;Linux&quot;):</span><br><span class="line">    # linux系统,文件保存在var下</span><br><span class="line">    SERVER_LOG_PATH = &#x27;/var/mylog.log&#x27;</span><br><span class="line">else:</span><br><span class="line">    # windows系统,文件保存在D盘下</span><br><span class="line">    SERVER_LOG_PATH = &#x27;D:\mylog.log&#x27;</span><br><span class="line"># 定义一个logging的对象，命名为mylog</span><br><span class="line">LOGGER = logging.getLogger(&#x27;mylog&#x27;)</span><br><span class="line"># 设置级别为WARNING</span><br><span class="line">LOGGER.setLevel(logging.WARNING)</span><br><span class="line"># 创建一个handler，用于写入日志文件</span><br><span class="line">fh = logging.FileHandler(SERVER_LOG_PATH, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">fh.setLevel(logging.WARNING)</span><br><span class="line"># 定义handler的输出格式</span><br><span class="line">formatter = logging.Formatter(&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;, datefmt=&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line"># 给Logger添加handler</span><br><span class="line">LOGGER.addHandler(fh)</span><br><span class="line"># 不在控制台显示</span><br><span class="line">LOGGER.propagate = False</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="70、字典排序"><a href="#70、字典排序" class="headerlink" title="70、字典排序"></a>70、字典排序</h2><p>字典在内存中发布是无序的，当想对键值或者键名进行排序时可以先把字典转成元组，这可以达到排序的目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">score = &#123;&#x27;小明&#x27;: &#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90, &#125;,</span><br><span class="line">     &#x27;小红&#x27;: &#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59, &#125;,</span><br><span class="line">     &#x27;小黑&#x27;: &#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70, &#125;,</span><br><span class="line">     &#x27;小白&#x27;: &#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80, &#125;,</span><br><span class="line">     &#125;</span><br><span class="line"># 对姓名进行排序，即对键名进行排序</span><br><span class="line">b = sorted(score.items(), key=lambda x: x[0], reverse=True)</span><br><span class="line">show_str = &#x27;&#x27;</span><br><span class="line">for info in b:</span><br><span class="line">    # print(info)</span><br><span class="line">    key, value = info[0], info[1]</span><br><span class="line">    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\r\n&#x27;</span><br><span class="line">print(&#x27;对姓名进行排序&#x27;)</span><br><span class="line">print(show_str)</span><br><span class="line"># 对平均分进行排序</span><br><span class="line">b = sorted(score.items(), key=lambda x: x[1][&#x27;avg_score&#x27;], reverse=True)</span><br><span class="line">show_str = &#x27;&#x27;</span><br><span class="line">for info in b:</span><br><span class="line">    # print(info)</span><br><span class="line">    key, value = info[0], info[1]</span><br><span class="line">    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\r\n&#x27;</span><br><span class="line">print(&#x27;对平均分进行排序&#x27;)</span><br><span class="line">print(show_str)</span><br><span class="line"></span><br><span class="line"># 对英语成绩进行排序</span><br><span class="line">b = sorted(score.items(), key=lambda x: x[1][&#x27;English&#x27;], reverse=True)</span><br><span class="line">show_str = &#x27;&#x27;</span><br><span class="line">for info in b:</span><br><span class="line">    # print(info)</span><br><span class="line">    key, value = info[0], info[1]</span><br><span class="line">    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\r\n&#x27;</span><br><span class="line">print(&#x27;对英语成绩进行排序&#x27;)</span><br><span class="line">print(show_str)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">对姓名进行排序</span><br><span class="line">姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;</span><br><span class="line">姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;</span><br><span class="line">姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;</span><br><span class="line">姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;</span><br><span class="line"></span><br><span class="line">对平均分进行排序</span><br><span class="line">姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;</span><br><span class="line">姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;</span><br><span class="line">姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;</span><br><span class="line">姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;</span><br><span class="line"></span><br><span class="line">对英语成绩进行排序</span><br><span class="line">姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;</span><br><span class="line">姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;</span><br><span class="line">姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;</span><br><span class="line">姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;</span><br></pre></td></tr></table></figure><h3 id="对列表中字典按多个键值排序"><a href="#对列表中字典按多个键值排序" class="headerlink" title="对列表中字典按多个键值排序"></a>对列表中字典按多个键值排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from operator import itemgetter</span><br><span class="line">data = [</span><br><span class="line">    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 300, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 2, &#x27;position&#x27;: 255, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 3, &#x27;position&#x27;: 256, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 500, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 5, &#x27;position&#x27;: 455, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 322, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 6, &#x27;position&#x27;: 676, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">]</span><br><span class="line">data = sorted(data, key=itemgetter(&#x27;code&#x27;, &#x27;position&#x27;))</span><br><span class="line"></span><br><span class="line">print(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 300, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 322, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 500, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 2, &#x27;position&#x27;: 255, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 3, &#x27;position&#x27;: 256, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 5, &#x27;position&#x27;: 455, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 6, &#x27;position&#x27;: 676, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;]</span><br></pre></td></tr></table></figure><h2 id="71、时间格式与字符串互转、比较大小"><a href="#71、时间格式与字符串互转、比较大小" class="headerlink" title="71、时间格式与字符串互转、比较大小"></a>71、时间格式与字符串互转、比较大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># 当前时间转字符串</span><br><span class="line">now = datetime.datetime.strftime(datetime.datetime.now(), &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line"># 字符串转时间格式</span><br><span class="line">now = datetime.datetime.strptime(now, &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">a = now + datetime.timedelta(minutes=-15)</span><br><span class="line"># 时间比较大小</span><br><span class="line">if a &lt; now:</span><br><span class="line">    print(&#x27;yes&#x27;)</span><br></pre></td></tr></table></figure><h2 id="72、python把’-u’开头的字符串转中文"><a href="#72、python把’-u’开头的字符串转中文" class="headerlink" title="72、python把’\u’开头的字符串转中文"></a>72、python把’\u’开头的字符串转中文</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str_data = &#x27;\\u7528\\u6237 ID \\u6216\\u5bc6\\u7801\\u9519\\u8bef&#x27;</span><br><span class="line"># 字符串.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode_escape&#x27;)</span><br><span class="line">str_data_to_zh = str_data.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode_escape&#x27;)</span><br><span class="line">print(str_data_to_zh)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">用户 ID 或密码错误</span><br></pre></td></tr></table></figure><h2 id="73、django进行数据迁移时出现No-changes-detected解决方案"><a href="#73、django进行数据迁移时出现No-changes-detected解决方案" class="headerlink" title="73、django进行数据迁移时出现No changes detected解决方案"></a>73、django进行数据迁移时出现No changes detected解决方案</h2><p>原因：可能是由于app下面没有migrations文件夹<br>所以需要创建这个文件夹，命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations --empty 你的app名称</span><br></pre></td></tr></table></figure><h2 id="74、ubuntu下载文件到windows桌面"><a href="#74、ubuntu下载文件到windows桌面" class="headerlink" title="74、ubuntu下载文件到windows桌面"></a>74、ubuntu下载文件到windows桌面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install lrzsz</span><br><span class="line">sz 123.txt</span><br></pre></td></tr></table></figure><h2 id="75、git查看提交日志"><a href="#75、git查看提交日志" class="headerlink" title="75、git查看提交日志"></a>75、git查看提交日志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;ldc&quot;</span><br></pre></td></tr></table></figure><h2 id="76、python翻译模块"><a href="#76、python翻译模块" class="headerlink" title="76、python翻译模块"></a>76、python翻译模块</h2><p>可以把英文翻译成中文，也可以把中文翻译成英文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pip install  translate</span><br><span class="line"></span><br><span class="line">from translate import Translator</span><br><span class="line"></span><br><span class="line">name = &#x27;giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca&#x27;</span><br><span class="line">translator = Translator(to_lang=&quot;chinese&quot;)</span><br><span class="line">translation = translator.translate(name)</span><br><span class="line">print(translation)</span><br><span class="line"></span><br><span class="line">translator= Translator(from_lang=&quot;chinese&quot;,to_lang=&quot;english&quot;)</span><br><span class="line">translation = translator.translate(&quot;我想你&quot;)</span><br><span class="line">print(translation)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">大熊猫，熊猫，熊猫熊，浣熊，大熊猫</span><br><span class="line">I missed you.</span><br></pre></td></tr></table></figure><h2 id="77、python实现字符串转字典"><a href="#77、python实现字符串转字典" class="headerlink" title="77、python实现字符串转字典"></a>77、python实现字符串转字典</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import ast</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">target_str = &#x27;&#123;&quot;h&quot;: 1, &quot;e&quot;: 2, &quot;l&quot;: 3, &quot;l&quot;: 4, &quot;o&quot;: 5&#125;&#x27;</span><br><span class="line">target_str2 = &quot;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 3, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 方式1：使用json，缺点，字符串中不能出现单引号</span><br><span class="line"># 由于 json 语法规定 数组或对象之中的字符串必须使用双引号，不能使用单引号</span><br><span class="line"># 官网https://www.json.org/json-en.html上有一段描述是</span><br><span class="line"># A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes</span><br><span class="line">print(json.loads(target_str))</span><br><span class="line"># print(json.loads(target_str2))   # 使用json转这个字符串会报错 Expecting property name enclosed in double quotes</span><br><span class="line"></span><br><span class="line"># 方式2：使用eval函数，缺点，不安全</span><br><span class="line">print(eval(target_str))</span><br><span class="line">print(eval(target_str2))</span><br><span class="line"># print(eval(&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;))  # 会列出当前的目录文件，如果字符串是一些删除命令，则可以把整个目录清空！</span><br><span class="line"></span><br><span class="line"># 方式3，使用ast.literal_eval，没有json与eval的缺点，推荐使用这个</span><br><span class="line">print(ast.literal_eval(target_str))</span><br><span class="line">print(ast.literal_eval(target_str2))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br></pre></td></tr></table></figure><h2 id="78、django-app-如何在后台显示中文名"><a href="#78、django-app-如何在后台显示中文名" class="headerlink" title="78、django app 如何在后台显示中文名"></a>78、django app 如何在后台显示中文名</h2><p>1.在app (这里以user为例)下面的<strong>init</strong>.py文件中</p><p>添加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_app_config = &#x27;user.apps.UserConfig&#x27;</span><br></pre></td></tr></table></figure><p>2.在apps.py中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.apps import AppConfig</span><br><span class="line"></span><br><span class="line">class UserConfig(AppConfig):</span><br><span class="line">    name = &#x27;user&#x27;</span><br><span class="line">    verbose_name = &#x27;用户&#x27;</span><br></pre></td></tr></table></figure><h2 id="79、使用python给Excel指定行添加数据"><a href="#79、使用python给Excel指定行添加数据" class="headerlink" title="79、使用python给Excel指定行添加数据"></a>79、使用python给Excel指定行添加数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import openpyxl, sys</span><br><span class="line"></span><br><span class="line">wb = openpyxl.load_workbook(&#x27;b.xlsx&#x27;)</span><br><span class="line">sheet = wb[&#x27;Sheet1&#x27;]</span><br><span class="line"></span><br><span class="line"># 在excel表格第二行添加新数据</span><br><span class="line">addrow = 1   # 增加一行</span><br><span class="line">row = 2  # 在第二行新增一行</span><br><span class="line">name = &#x27;b-back.xlsx&#x27; # 新的表名</span><br><span class="line"></span><br><span class="line">wb1 = openpyxl.Workbook()</span><br><span class="line">sheet1 = wb1[&#x27;Sheet&#x27;]</span><br><span class="line"></span><br><span class="line"># 复制前row行</span><br><span class="line">for i in range(1, row):</span><br><span class="line">    for j in range(1, sheet.max_column + 1):</span><br><span class="line">        sheet1.cell(row=i, column=j).value = sheet.cell(row=i, column=j).value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 复制后row行</span><br><span class="line">for i in range(row, sheet.max_row + 1):</span><br><span class="line">    for j in range(1, sheet.max_column + 1):</span><br><span class="line">        if i == row:</span><br><span class="line">            # 给第row行添加新的数据</span><br><span class="line">            sheet1.cell(row=row, column=j).value = &#x27;新增&#x27;</span><br><span class="line">        sheet1.cell(row=i + addrow, column=j).value = sheet.cell(row=i, column=j).value</span><br><span class="line"></span><br><span class="line">wb1.save(name)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200526120005871.png" alt="在这里插入图片描述"></p><h2 id="80、python中的format格式拼接字符串"><a href="#80、python中的format格式拼接字符串" class="headerlink" title="80、python中的format格式拼接字符串"></a>80、python中的format格式拼接字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 5&#125;</span><br><span class="line"></span><br><span class="line">print(&#x27;&#123;a&#125;,&#123;b&#125;&#x27;.format(**d))</span><br><span class="line">print(&#x27;&#123;0&#125;,&#123;1&#125;,&#123;0&#125;&#x27;.format(&#x27;a&#x27;, &#x27;b&#x27;))</span><br><span class="line">print(f&quot;&#123;d[&#x27;a&#x27;]&#125;&quot;)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2</span><br><span class="line">a,b,a</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="81、数据库inner-join、full-join、left-join、union、union-all区别"><a href="#81、数据库inner-join、full-join、left-join、union、union-all区别" class="headerlink" title="81、数据库inner join、full join、left join、union、union all区别"></a>81、数据库inner join、full join、left join、union、union all区别</h2><p>表a_test</p><p><img src="https://img-blog.csdnimg.cn/20200529102527295.png#pic_center" alt="在这里插入图片描述"></p><p>表b_test</p><p><img src="https://img-blog.csdnimg.cn/20200529102549669.png#pic_center" alt="在这里插入图片描述"></p><p>INNER JOIN</p><p>是A和B的交集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test INNER JOIN b_test ON a_test.name = b_test.namesa</span><br><span class="line"></span><br><span class="line">Inner join 产生的结果集中，是A和B的交集。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102631494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>FULL OUTER JOIN</p><p>产生A和B的并集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test FULL OUTER JOIN b_test ON a_test.name = b_test.name </span><br><span class="line"></span><br><span class="line">Full outer join 产生A和B的并集。</span><br><span class="line">但是需要注意的是，对于没有匹配的记录，则会以null做为值。</span><br><span class="line">可以使用IF NULL判断。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102702865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test FULL OUTER JOIN b_test ON a_test.name = b_test.name</span><br><span class="line">WHERE a_test.id IS null OR b_test.id IS null</span><br><span class="line"></span><br><span class="line">产生A表和B表没有交集的数据集。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102724731.png#pic_center" alt="在这里插入图片描述"></p><p>LEFT [OUTER] JOIN</p><p>产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test LEFT OUTER JOIN b_test ON a_test.name = b_test.name</span><br><span class="line">有些数据库可以不要OUTER</span><br><span class="line">SELECT * FROM a_test LEFT  JOIN b_test ON a_test.name = b_test.name</span><br><span class="line">Left outer join 产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102808618.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test LEFT OUTER JOIN b_test ON a_test.name = b_test.name </span><br><span class="line">WHERE b_test.id IS null</span><br><span class="line"></span><br><span class="line">产生在A表中有而在B表中没有的集合。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102828846.png#pic_center" alt="在这里插入图片描述"></p><p>RIGHT [OUTER] JOIN</p><p>RIGHT OUTER JOIN 是后面的表为基础，与LEFT OUTER JOIN用法类似。</p><p>UNION 与 UNION ALL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</span><br><span class="line">请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。</span><br><span class="line">列也必须拥有相似的数据类型。</span><br><span class="line">同时，每条 SELECT 语句中的列的顺序必须相同。</span><br><span class="line">UNION 只选取记录，而UNION ALL会列出所有记录。</span><br><span class="line"></span><br><span class="line">SELECT name FROM a_test UNION SELECT name FROM b_test</span><br><span class="line"></span><br><span class="line">选取不同值</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102855430.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT a_test.id,a_test.name  FROM a_test </span><br><span class="line">UNION </span><br><span class="line">SELECT b_test.id,b_test.name FROM b_test</span><br><span class="line"></span><br><span class="line">由于 id 51 xh   与 id 4 xh 并不相同，不合并</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102917488.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM a_test UNION ALL SELECT name FROM b_test</span><br><span class="line"></span><br><span class="line">全部列出来</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102937801.png#pic_center" alt="在这里插入图片描述"></p><p>还需要注意的是我们还有一个是“交差集” cross join, 这种Join没有办法用文式图表示，因为其就是把表A和表B的数据进行一个N*M的组合，即笛卡尔积。</p><p>表达式如下：SELECT * FROM a_test CROSS JOIN b_test</p><p>这个笛卡尔乘积会产生 4 x 4 = 16 条记录，一般来说，我们很少用到这个语法。但是我们得小心，如果不是使用嵌套的select语句，一般系统都会产生笛卡尔乘积然再做过滤。这是对于性能来说是非常危险的，尤其是表很大的时候。</p><h2 id="82、windows电脑查看端口使用情况"><a href="#82、windows电脑查看端口使用情况" class="headerlink" title="82、windows电脑查看端口使用情况"></a>82、windows电脑查看端口使用情况</h2><p>找出8000端口对应的PID进程，命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano|findstr 8000</span><br></pre></td></tr></table></figure><p>进程信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP    0.0.0.0:8000           0.0.0.0:0              LISTENING       1620</span><br><span class="line">UDP    0.0.0.0:8000           *:*                                    1620</span><br></pre></td></tr></table></figure><p>找出进程对应的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasklist |findstr 1620</span><br><span class="line"></span><br><span class="line">KGService.exe                 1620 Console                    1     18,696 K</span><br></pre></td></tr></table></figure><p>关进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /pid 1620 /F</span><br></pre></td></tr></table></figure><p>查看程序占用内存<br>比如查看python占用运行内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist  /fi &quot;imagename eq python.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a61afd069e964e6f9d755c5c1884ca6f.png" alt="在这里插入图片描述"></p><h2 id="83、Django生成表和反向生成Model"><a href="#83、Django生成表和反向生成Model" class="headerlink" title="83、Django生成表和反向生成Model"></a>83、Django生成表和反向生成Model</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正向生成：</span><br><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line"></span><br><span class="line">反向：</span><br><span class="line">会根据设置的数据库中的表在自动生成对应的Model代码，并打印出来</span><br><span class="line">python manage.py inspectdb</span><br><span class="line"></span><br><span class="line">以直接将打印的代码直接导入到指定的Model文件中</span><br><span class="line">python manage.py inspectdb &gt; models.py</span><br></pre></td></tr></table></figure><h2 id="84、windows的hosts文件位置"><a href="#84、windows的hosts文件位置" class="headerlink" title="84、windows的hosts文件位置"></a>84、windows的hosts文件位置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><h2 id="85、postgresql数据库"><a href="#85、postgresql数据库" class="headerlink" title="85、postgresql数据库"></a>85、postgresql数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"># 如果表存在就先删除</span><br><span class="line">drop table if exists student;</span><br><span class="line"># 创建学生表</span><br><span class="line"># id      serial not null  表示id自增</span><br><span class="line"># id      integer not null  表示id不自增</span><br><span class="line">create table student</span><br><span class="line">(</span><br><span class="line">    id                    serial not null</span><br><span class="line">        constraint student_pk</span><br><span class="line">            primary key,</span><br><span class="line">    name                  varchar,</span><br><span class="line">    class_id              integer,</span><br><span class="line">    height                numeric,</span><br><span class="line">    weight                numeric,</span><br><span class="line">    write_date            timestamp</span><br><span class="line">    </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">comment on table student is &#x27;学生表&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.name is &#x27;名称&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.class_id is &#x27;班级ID&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.height is &#x27;身高&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.weight is &#x27;体重&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.write_date is &#x27;修改时间&#x27;;</span><br><span class="line"></span><br><span class="line">alter table student</span><br><span class="line">    owner to odoo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 更新</span><br><span class="line">update user set name=&#x27;张三&#x27; where id=111</span><br><span class="line"></span><br><span class="line"># 更新表a的字段为表b的值</span><br><span class="line">update account_invoice </span><br><span class="line">set sale_order_id=so.id </span><br><span class="line">from sale_order so </span><br><span class="line">where account_invoice.origin=so.name</span><br><span class="line"></span><br><span class="line"># 新增</span><br><span class="line">insert into &quot;user&quot; (name,sex) values (&#x27;小明&#x27;,1),(&#x27;小红&#x27;, 0)</span><br><span class="line"># 新增或更新</span><br><span class="line">如果id冲突就更新</span><br><span class="line">INSERT INTO  student(id, name)</span><br><span class="line">   VALUES(12, &#x27;小明&#x27;),(13, &#x27;小红&#x27;)</span><br><span class="line">   ON conflict(id) DO UPDATE</span><br><span class="line">   SET name =&#x27;未知&#x27;;</span><br><span class="line">如果id冲突就什么也不做</span><br><span class="line">INSERT INTO  student(id, name)</span><br><span class="line">   VALUES(12, &#x27;小明&#x27;),(13, &#x27;小红&#x27;)</span><br><span class="line">   ON conflict(id) DO NOTHING;</span><br><span class="line"></span><br><span class="line"># 把一个表中的数据插入到另一个表中</span><br><span class="line">insert into 目标表名 (column1,column2,columnn) select value1,value2,valuen from  源表名</span><br><span class="line">比如：</span><br><span class="line">insert into student (name, classs_name,create_date) select  student_name as name, class_name, now() from class_table;</span><br><span class="line"></span><br><span class="line"># 获取当前时间</span><br><span class="line">now()</span><br><span class="line">select now()</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">DELETE FROM table_name [WHERE Clause]</span><br><span class="line"></span><br><span class="line"># 增加字段</span><br><span class="line">alter table 表名 add column 列名 类型;</span><br><span class="line"># 删除字段</span><br><span class="line">alter table 表名 dropcolumn 列名 ;</span><br><span class="line"></span><br><span class="line"># postgresql数据库查看表所有字段</span><br><span class="line">select * from information_schema.columns where table_schema=&#x27;public&#x27; and table_name=&#x27;表名&#x27;;</span><br><span class="line"></span><br><span class="line"># postgresql获取所有表名</span><br><span class="line">select tablename from pg_tables where schemaname=&#x27;public&#x27;</span><br><span class="line"></span><br><span class="line"># 对查询结果按id降序显示</span><br><span class="line">select * from table_name order by id desc</span><br><span class="line"></span><br><span class="line"># 对查询结果按id升序显示</span><br><span class="line">select * from table_name order by id asc</span><br><span class="line"></span><br><span class="line"># 转义字符, 查找name中包含单引号的记录</span><br><span class="line">select * from student where name like  E&#x27;%\&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line"># 查看表记录总数</span><br><span class="line">select relname as TABLE_NAME, reltuples as rowCounts from pg_class where relkind = &#x27;r&#x27; and relnamespace = (select oid from pg_namespace where nspname=&#x27;public&#x27;) order by rowCounts desc;</span><br><span class="line"></span><br><span class="line"># 将结果转换为数组</span><br><span class="line">SELECT array(SELECT &quot;name&quot; FROM sale_order);</span><br><span class="line"></span><br><span class="line"># 将数组合并为字符串</span><br><span class="line">select array_to_string(array[1,2,3], &#x27;,&#x27;)</span><br><span class="line"></span><br><span class="line"># 联合子集更新，把sale_order_line的name连接换行符，然后按id更新到表a_test中对应的name</span><br><span class="line">update a_test set name=array_to_string(array(select name from sale_order_line where order_id=a_test.id),&#x27;&lt;br/&gt;&#x27;);</span><br><span class="line"></span><br><span class="line"># PostgreSQL合并查询同一列的多条记录，针对一对多，多对多字段</span><br><span class="line">比如表：</span><br><span class="line"></span><br><span class="line">id   name                  </span><br><span class="line">1    小明                   </span><br><span class="line">1    小红                     id   name</span><br><span class="line">1    小亮        --&gt;          1    小明，小亮，小红</span><br><span class="line">2    小强                     2    小强，小王</span><br><span class="line">2    小王</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">    id, array_to_string(ARRAY(SELECT unnest(array_agg(name order by name desc))),&#x27;,&#x27;) AS all_name</span><br><span class="line">FROM  </span><br><span class="line">    student</span><br><span class="line">GROUP BY id;</span><br><span class="line"></span><br><span class="line"># case语句</span><br><span class="line">case var</span><br><span class="line">when condition1 then statement1</span><br><span class="line">when condition2 then statement2</span><br><span class="line">else statementn</span><br><span class="line">end as new_name</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">select case name</span><br><span class="line">when &#x27;小明&#x27; then &#x27;xm&#x27;</span><br><span class="line">when &#x27;小红&#x27; then &#x27;xh&#x27;</span><br><span class="line">when &#x27;小刚&#x27; then &#x27;xg&#x27;</span><br><span class="line">else &#x27;xw&#x27;</span><br><span class="line">end as short_name</span><br><span class="line">from student</span><br><span class="line"></span><br><span class="line"># 临时表、字符串合并、类型转换、时间格式转换、当前时间</span><br><span class="line">WITH TEMP AS ( </span><br><span class="line">SELECT CAST ( concat ( bam.account_period_code, &#x27;-01&#x27; ) AS TIMESTAMP ) </span><br><span class="line">   AS account_period_time </span><br><span class="line"> FROM bi_account_move AS bam ) </span><br><span class="line">SELECT</span><br><span class="line">account_period_time,</span><br><span class="line">to_char(CURRENT_DATE,&#x27;yyyy-MM-dd hh24:MI:ss&#x27;) as current_date,</span><br><span class="line">to_char( account_period_time, &#x27;yyyy&#x27; ) as year,</span><br><span class="line">to_char( account_period_time, &#x27;MM&#x27; ) as month,</span><br><span class="line">to_char( account_period_time, &#x27;dd&#x27; ) as day </span><br><span class="line">FROM TEMP</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">account_period_timecurrent_date    yearmonthday</span><br><span class="line">2019-06-01 0:00:002020-06-24 00:00:002019 06     01</span><br><span class="line">2019-06-01 0:00:002020-06-24 00:00:002019 06     01</span><br><span class="line"></span><br><span class="line"># 多个字符串拼接</span><br><span class="line">select </span><br><span class="line">concat(&#x27;payment_&#x27;, CAST(ap.id as varchar)) as line_key</span><br><span class="line">from ap</span><br><span class="line"></span><br><span class="line"># 将查询所得结果集的某一字段拼接成字符串，默认的是逗号</span><br><span class="line">select GROUP_CONCAT(id) from test where id&gt;5;</span><br><span class="line">结果为：</span><br><span class="line">1,2,3,4,5,6,7</span><br><span class="line"># 使用其他分隔符拼接</span><br><span class="line">select GROUP_CONCAT(id separator &#x27;-&#x27;) from test where id&gt;5;</span><br><span class="line">结果为：</span><br><span class="line">1-2-3-4-5-6-7</span><br><span class="line"># 多个临时表</span><br><span class="line">WITH temp_student AS ( SELECT ID, NAME, sex FROM student WHERE sex = TRUE ),</span><br><span class="line">temp_class AS (</span><br><span class="line">SELECT</span><br><span class="line">ID,</span><br><span class="line">NAME,</span><br><span class="line">student_id,</span><br><span class="line">teacher_id</span><br><span class="line">FROM</span><br><span class="line">the_class </span><br><span class="line">),</span><br><span class="line">temp_teacher AS (</span><br><span class="line">SELECT </span><br><span class="line">  ID,</span><br><span class="line">NAME,</span><br><span class="line">age </span><br><span class="line">FROM</span><br><span class="line">teacher </span><br><span class="line">) </span><br><span class="line">SELECT</span><br><span class="line">ts.NAME AS student_name,</span><br><span class="line">tc.NAME AS class_name,</span><br><span class="line">te.NAME AS teacher_name</span><br><span class="line">from temp_student as ts</span><br><span class="line">LEFT JOIN temp_class AS tc ON tc.student_id = ts.ID  </span><br><span class="line">LEFT JOIN teacher AS te ON te.id = tc.teacher_id  </span><br><span class="line"></span><br><span class="line"># null转成有意义的值</span><br><span class="line">select COALESCE(name, &#x27;&#x27;) as name from a_test</span><br><span class="line">意思就是如果name为null，就转为空字符串</span><br><span class="line"></span><br><span class="line"># 字符串截取</span><br><span class="line">select SUBSTRING(&#x27;abcd&#x27;,1,2); -- result:ab 表示从下标从1开始,截取2个字符</span><br><span class="line"></span><br><span class="line"># 使用 interval 时间相加减(+/-)</span><br><span class="line">当前时间 + 10秒，</span><br><span class="line">select to_char(now() + interval &#x27;10 second&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line">当前时间 - 10秒</span><br><span class="line">select to_char(now() + interval &#x27;-10 second&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line"> </span><br><span class="line">当前时间 + 10分，</span><br><span class="line">select to_char(now() + interval &#x27;10 minute&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate  from account_period;</span><br><span class="line"> </span><br><span class="line">当前时间 + 10时，</span><br><span class="line">select to_char(now() + interval &#x27;10 hour&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line"> </span><br><span class="line">当前时间 + 10天，</span><br><span class="line">select to_char(now() + interval &#x27;10 day&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line"></span><br><span class="line">当前时间 + 10年，</span><br><span class="line">select to_char(now() + interval &#x27;10 year&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line"></span><br><span class="line"># UNION types numeric and text cannot be matched</span><br><span class="line">NULL::NUMERIC</span><br><span class="line"> 这个问题，是因为几个sql组合在一起时，同一个字段的值，遇到null时，需要进行类型转换。</span><br><span class="line"></span><br><span class="line"># 对行记录定义行编号，使用函数ROW_NUMBER()</span><br><span class="line"># 按分数进行降序，然后给行记录标记行编号，可以作为排名来使用</span><br><span class="line">select           </span><br><span class="line">ROW_NUMBER() OVER (ORDER BY score desc) AS sequence_number,</span><br><span class="line">name,score</span><br><span class="line">from</span><br><span class="line">b_test</span><br><span class="line"></span><br><span class="line"># 数字转字符串  </span><br><span class="line">select cast(123 as VARCHAR); </span><br><span class="line"></span><br><span class="line"># 字符串转数字  </span><br><span class="line">select cast(&#x27;123&#x27; as INTEGER);</span><br></pre></td></tr></table></figure><h2 id="86、python控制台输出带颜色的文字方法"><a href="#86、python控制台输出带颜色的文字方法" class="headerlink" title="86、python控制台输出带颜色的文字方法"></a>86、python控制台输出带颜色的文字方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#格式：　　设置颜色开始 ：\033[显示方式;前景色;背景色m</span><br><span class="line">#说明：</span><br><span class="line">前景色            背景色           颜色</span><br><span class="line">---------------------------------------</span><br><span class="line">30                40              黑色</span><br><span class="line">31                41              红色</span><br><span class="line">32                42              绿色</span><br><span class="line">33                43              黃色</span><br><span class="line">34                44              蓝色</span><br><span class="line">35                45              紫红色</span><br><span class="line">36                46              青蓝色</span><br><span class="line">37                47              白色</span><br><span class="line">显示方式           意义</span><br><span class="line">-------------------------</span><br><span class="line">0                终端默认设置</span><br><span class="line">1                高亮显示</span><br><span class="line">4                使用下划线</span><br><span class="line">5                闪烁</span><br><span class="line">7                反白显示</span><br><span class="line">8                不可见</span><br><span class="line"> </span><br><span class="line">#例子：</span><br><span class="line">\033[1;31;40m    &lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&gt;</span><br><span class="line">\033[0m          &lt;!--采用终端默认设置，即取消颜色设置--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line">print(&#x27;紫红字体 \033[1;35m hello world \033[0m!&#x27;)</span><br><span class="line">print(&#x27;褐色背景绿色字体 \033[1;32;43m hello world \033[0m!&#x27;)</span><br><span class="line">print(&#x27;\033[1;33;44mhello world\033[0m&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200615143709116.png" alt="在这里插入图片描述"></p><h2 id="87、控制台输出白色方框"><a href="#87、控制台输出白色方框" class="headerlink" title="87、控制台输出白色方框"></a>87、控制台输出白色方框</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;█&#x27;)</span><br></pre></td></tr></table></figure><h2 id="88、xadmin后台编辑多对多字段"><a href="#88、xadmin后台编辑多对多字段" class="headerlink" title="88、xadmin后台编辑多对多字段"></a>88、xadmin后台编辑多对多字段</h2><p>在models.py定义了多对多字段，想要在编辑时可以灵活使用这个字段的话，可以按以下方法设置：<br>modes.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    title = models.CharField(verbose_name=&quot;书名&quot;, max_length=32)</span><br><span class="line">    second_title = models.CharField(verbose_name=&quot;副标题&quot;, max_length=32, blank=True, null=True)</span><br><span class="line">    author = models.CharField(verbose_name=&quot;作者&quot;, max_length=32)</span><br><span class="line">    translator = models.CharField(verbose_name=&quot;译者&quot;, max_length=32, blank=True, null=True)</span><br><span class="line">    intro = models.TextField(verbose_name=&quot;描述&quot;)</span><br><span class="line">    pic = models.FileField(verbose_name=&quot;封面图片&quot;, max_length=64, upload_to=&#x27;book_cover&#x27;, null=True, blank=True)</span><br><span class="line">    tags = models.ManyToManyField(Tags, verbose_name=&#x27;书籍标签&#x27;, blank=True)</span><br><span class="line">    prizes = models.ManyToManyField(Prizes, verbose_name=&#x27;获奖详情&#x27;, blank=True)</span><br><span class="line">    sump = models.IntegerField(verbose_name=&quot;收藏人数&quot;, default=0)</span><br><span class="line">    rate_num = models.IntegerField(verbose_name=&quot;评分人数&quot;, default=0)</span><br><span class="line">    num = models.IntegerField(verbose_name=&quot;浏览量&quot;, default=0)</span><br><span class="line">    published_time = models.DateField(blank=True, null=True, verbose_name=&#x27;出版时间&#x27;)</span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=True, verbose_name=&#x27;创建时间&#x27;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &#x27;book&#x27;</span><br><span class="line">        verbose_name = &quot;图书&quot;</span><br><span class="line">        verbose_name_plural = &quot;图书&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br></pre></td></tr></table></figure><p>adminx.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 书籍管理</span><br><span class="line">class BookAdmin(object):</span><br><span class="line">    search_fields = [&#x27;title&#x27;, &#x27;author&#x27;, &#x27;intro&#x27;]  # 检索字段</span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;show_pic&#x27;, &#x27;title&#x27;, &#x27;second_title&#x27;, &#x27;author&#x27;, &#x27;translator&#x27;, &#x27;published_time&#x27;, &#x27;intro&#x27;,</span><br><span class="line">                    &#x27;tags&#x27;, &#x27;prizes&#x27;, &#x27;num&#x27;, &#x27;sump&#x27;, &#x27;rate_num&#x27;]  # 要显示的字段</span><br><span class="line">    list_filter = [&#x27;published_time&#x27;, &#x27;tags&#x27;, &#x27;prizes&#x27;]  # 分组过滤的字段</span><br><span class="line">    ordering = (&#x27;id&#x27;,)  # 设置默认排序字段，负号表示降序排序</span><br><span class="line">    list_per_page = 30  # 默认每页显示多少条记录，默认是100条</span><br><span class="line">    model_icon = &#x27;fa fa-book&#x27;  # 左侧小图标</span><br><span class="line">    list_editable = [&#x27;title&#x27;, &#x27;author&#x27;, &#x27;intro&#x27;, &#x27;published_time&#x27;]  # 可编辑字段</span><br><span class="line">    style_fields = &#123;&#x27;tags&#x27;: &#x27;m2m_transfer&#x27;, &#x27;prizes&#x27;: &#x27;m2m_transfer&#x27;&#125;  # 控制字段的显示样式</span><br><span class="line">    filter_horizontal = (&#x27;tags&#x27;, &#x27;prizes&#x27;)  # 水平选择编辑多对多字段</span><br></pre></td></tr></table></figure><p>重点是设置style_fields 和filter_horizontal ，效果：</p><p><img src="https://img-blog.csdnimg.cn/20200621214122315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="89、Django后台通过按钮显示TextField字段内容"><a href="#89、Django后台通过按钮显示TextField字段内容" class="headerlink" title="89、Django后台通过按钮显示TextField字段内容"></a>89、Django后台通过按钮显示TextField字段内容</h2><p>由于TextField字段类型内容可能很长，在后台显示时很占屏幕位置，可以通过按钮来控制显示，代码如下：<br>models.py中定义了一个TextField字段类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Prizes(models.Model):</span><br><span class="line">    name = models.CharField(max_length=32, verbose_name=&quot;奖项&quot;)</span><br><span class="line">    intro = models.TextField(blank=True, null=True, verbose_name=&#x27;简介&#x27;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &#x27;prizes&#x27;</span><br><span class="line">        verbose_name = &quot;奖项&quot;</span><br><span class="line">        verbose_name_plural = &quot;奖项&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br></pre></td></tr></table></figure><p>这里使用xadmin作为后台管理框架，在adminx.py中代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from django.utils.safestring import mark_safe</span><br><span class="line">from xadmin import views</span><br><span class="line"></span><br><span class="line">from .models import *</span><br><span class="line"></span><br><span class="line"># 奖项管理</span><br><span class="line">class PrizesAdmin(object):</span><br><span class="line">    search_fields = [&#x27;name&#x27;]  # 检索字段</span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;show_intro&#x27;]</span><br><span class="line">    list_filter = [&#x27;name&#x27;]</span><br><span class="line">    ordering = (&#x27;id&#x27;,)</span><br><span class="line"></span><br><span class="line">    def show_intro(self, obj):</span><br><span class="line">        # 显示简介</span><br><span class="line">        if not obj.intro:</span><br><span class="line">            return mark_safe(&#x27;&#x27;)</span><br><span class="line">        if len(obj.intro) &lt; 20:</span><br><span class="line">            return mark_safe(obj.intro)</span><br><span class="line"></span><br><span class="line">        short_id = f&#x27;&#123;obj._meta.db_table&#125;_short_text_&#123;obj.id&#125;&#x27;</span><br><span class="line">        short_text_len = len(obj.intro) // 4</span><br><span class="line">        short_text = obj.intro[:short_text_len] + &#x27;......&#x27;</span><br><span class="line">        detail_id = f&#x27;&#123;obj._meta.db_table&#125;_detail_text_&#123;obj.id&#125;&#x27;</span><br><span class="line">        detail_text = obj.intro</span><br><span class="line"></span><br><span class="line">        text = &quot;&quot;&quot;&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">                        #%s,%s &#123;padding:10px;border:1px solid green;&#125; </span><br><span class="line">                  &lt;/style&gt;</span><br><span class="line">                    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    function openShutManager(oSourceObj,oTargetObj,shutAble,oOpenTip,oShutTip,oShortObj)&#123;</span><br><span class="line">                        var sourceObj = typeof oSourceObj == &quot;string&quot; ? document.getElementById(oSourceObj) : oSourceObj;</span><br><span class="line">                        var targetObj = typeof oTargetObj == &quot;string&quot; ? document.getElementById(oTargetObj) : oTargetObj;</span><br><span class="line">                        var shortObj = typeof oShortObj == &quot;string&quot; ? document.getElementById(oShortObj) : oShortObj;</span><br><span class="line">                        var openTip = oOpenTip || &quot;&quot;;</span><br><span class="line">                        var shutTip = oShutTip || &quot;&quot;;</span><br><span class="line">                        if(targetObj.style.display!=&quot;none&quot;)&#123;</span><br><span class="line">                           if(shutAble) return;</span><br><span class="line">                           targetObj.style.display=&quot;none&quot;;</span><br><span class="line">                           shortObj.style.display=&quot;block&quot;;</span><br><span class="line">                           if(openTip  &amp;&amp;  shutTip)&#123;</span><br><span class="line">                            sourceObj.innerHTML = shutTip; </span><br><span class="line">                           &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                           targetObj.style.display=&quot;block&quot;;</span><br><span class="line">                           shortObj.style.display=&quot;none&quot;;</span><br><span class="line">                           if(openTip  &amp;&amp;  shutTip)&#123;</span><br><span class="line">                            sourceObj.innerHTML = openTip; </span><br><span class="line">                           &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;/script&gt;</span><br><span class="line">                    &lt;p id=&quot;%s&quot;&gt;%s&lt;/p&gt;</span><br><span class="line">                    &lt;p&gt;&lt;a href=&quot;###&quot; οnclick=&quot;openShutManager(this,&#x27;%s&#x27;,false,&#x27;点击关闭&#x27;,&#x27;点击展开&#x27;,&#x27;%s&#x27;)&quot;&gt;点击展开&lt;/a&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;p id=&quot;%s&quot; style=&quot;display:none&quot;&gt;</span><br><span class="line">                       %s</span><br><span class="line">                    &lt;/p&gt;</span><br><span class="line">                    &quot;&quot;&quot; % (short_id, detail_id, short_id, short_text, detail_id, short_id, detail_id, detail_text)</span><br><span class="line">        return mark_safe(text)</span><br><span class="line"></span><br><span class="line">    show_intro.short_description = &#x27;描述&#x27;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：复制代码后需要做如下修改：</p><p><img src="https://img-blog.csdnimg.cn/20200815204246956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>一开始效果</p><p><img src="https://img-blog.csdnimg.cn/20200621230038819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击展开效果：<img src="https://img-blog.csdnimg.cn/20200621230120177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="90、前端判断上传的文件是否为图片且限制大小为300kB"><a href="#90、前端判断上传的文件是否为图片且限制大小为300kB" class="headerlink" title="90、前端判断上传的文件是否为图片且限制大小为300kB"></a>90、前端判断上传的文件是否为图片且限制大小为300kB</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en-us&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;body class=&quot;login&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;input class=&quot;form-control input-lg&quot; id=&quot;id_icon&quot; name=&quot;icon&quot; type=&quot;file&quot; onchange=&quot;imgTypeSize(&#x27;id_icon&#x27;,300)&quot;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    //判断是否为图片，若为图片，判断其大小是否大于0.3M</span><br><span class="line">    function imgTypeSize(FileId, maxsize) &#123;</span><br><span class="line">        /*获取图片内容对象*/</span><br><span class="line">        var imgFile = document.getElementById(FileId).files[0];</span><br><span class="line">        if (imgFile.name == &quot;&quot;) &#123;</span><br><span class="line">            alert(&quot;请上传头像哦&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*图片类型正则验证*/</span><br><span class="line">            var imgStr = /\.(jpg|jpeg|png|bmp|BMP|JPG|PNG|JPEG)$/;</span><br><span class="line">            if (!imgStr.test(imgFile.name)) &#123;</span><br><span class="line">                alert(&quot;文件不是图片类型&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /*图片大小*/</span><br><span class="line">                var imagSize = imgFile.size;</span><br><span class="line">                if (imagSize &lt; (1024 * maxsize)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    alert(imgFile.name + &quot;大小不能超过&quot; + maxsize + &quot;kB&quot;);</span><br><span class="line">                    document.getElementById(FileId).value = &quot;&quot;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="91、form表单提交前验证"><a href="#91、form表单提交前验证" class="headerlink" title="91、form表单提交前验证"></a>91、form表单提交前验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot; id=&quot;login-form&quot; onsubmit=&quot;return toVaild()&quot;&gt;</span><br><span class="line">&lt;input class=&quot;form-control&quot; id=&quot;id_account&quot; name=&quot;account&quot; type=&quot;text&quot; placeholder=&quot;账号&quot;/&gt;</span><br><span class="line">&lt;input class=&quot;form-control&quot; id=&quot;id_password&quot; name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot;&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&#x27;id_username&#x27;).focus()</span><br><span class="line"></span><br><span class="line">    function toVaild() &#123;</span><br><span class="line">        var account = document.getElementById(&quot;id_account&quot;).value;</span><br><span class="line">        var password = document.getElementById(&quot;id_password&quot;).value;</span><br><span class="line">        if (account == &quot;&quot; || password == &quot;&quot;) &#123;</span><br><span class="line">            alert(&quot;请输入账号和密码&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="92、有序字典"><a href="#92、有序字典" class="headerlink" title="92、有序字典"></a>92、有序字典</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import collections</span><br><span class="line"></span><br><span class="line">d1 = collections.OrderedDict()  # 创建一个有序字典</span><br><span class="line">d1[&#x27;a&#x27;] = &#x27;A&#x27;</span><br><span class="line">d1[&#x27;b&#x27;] = &#x27;B&#x27;</span><br><span class="line">d1[&#x27;c&#x27;] = &#x27;C&#x27;</span><br><span class="line">d1[&#x27;d&#x27;] = &#x27;D&#x27;</span><br><span class="line">for k, v in d1.items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure><h2 id="93、Python在Windows系统下实现TTS（文字转语音）"><a href="#93、Python在Windows系统下实现TTS（文字转语音）" class="headerlink" title="93、Python在Windows系统下实现TTS（文字转语音）"></a>93、Python在Windows系统下实现TTS（文字转语音）</h2><p>导入包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip install pypiwin32</span><br><span class="line"></span><br><span class="line">import win32com.client</span><br><span class="line">spk = win32com.client.Dispatch(&quot;SAPI.SpVoice&quot;)</span><br><span class="line">spk.Speak(u&quot;my name is ldc,what is your name&quot;)</span><br><span class="line">spk.Speak(u&quot;大家好&quot;)</span><br></pre></td></tr></table></figure><h2 id="94、定义一个简单闹钟"><a href="#94、定义一个简单闹钟" class="headerlink" title="94、定义一个简单闹钟"></a>94、定义一个简单闹钟</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># pip install pypiwin32 -i https://pypi.python.org/simple</span><br><span class="line">import win32com.client</span><br><span class="line">import time </span><br><span class="line">import winsound</span><br><span class="line"></span><br><span class="line">spk = win32com.client.Dispatch(&quot;SAPI.SpVoice&quot;)</span><br><span class="line"># 定义闹钟时间</span><br><span class="line">clocktime = [[19, 19], [11, 10], [12, 10], [18, 47]]  </span><br><span class="line">runinghour = 1  # 定义运行时间</span><br><span class="line">times = runinghour * 3600  # 次数</span><br><span class="line">print(times)</span><br><span class="line">for i in range(1, times):</span><br><span class="line">    time_now = [time.localtime(time.time()).tm_hour, time.localtime(time.time()).tm_min]</span><br><span class="line">    if time_now in clocktime:</span><br><span class="line">        print(time_now)</span><br><span class="line">        winsound.Beep(1000, 1000)</span><br><span class="line">        spk.Speak(u&quot;快去看下饭好了没有？&quot;)</span><br><span class="line">    time.sleep(60)  # 每分钟对比一次时间</span><br></pre></td></tr></table></figure><h2 id="95、根据年月获取当月天数"><a href="#95、根据年月获取当月天数" class="headerlink" title="95、根据年月获取当月天数"></a>95、根据年月获取当月天数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def get_month_days(year, month):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据年份，月份信息显示此月份天数</span><br><span class="line">    :param year: 年份：</span><br><span class="line">    :param month: 月份（1～12）：</span><br><span class="line">    :return: 当月天数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if month &gt;12 or month &lt;= 0:</span><br><span class="line">        return -1</span><br><span class="line">    if month == 2:</span><br><span class="line">        return 29 if year % 4 == 0 and year % 100 != 0 or year % 400 == 0 else 28</span><br><span class="line"></span><br><span class="line">    if month in (4, 6, 9, 11):</span><br><span class="line">        return 30</span><br><span class="line">    else:</span><br><span class="line">        return 31</span><br><span class="line"></span><br><span class="line">a = &#x27;2020-04&#x27;.split(&#x27;-&#x27;)</span><br><span class="line">year = int(a[0])</span><br><span class="line">month = int(a[1])</span><br><span class="line">print(get_month_days(year,month))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="96、Django获取favicon-ico图标"><a href="#96、Django获取favicon-ico图标" class="headerlink" title="96、Django获取favicon.ico图标"></a>96、Django获取favicon.ico图标</h2><p>制作一个ico文件，使用PS或者某些在线生成ico的网站</p><p>将此文件命名为“favicon.ico”后放在static/下</p><p><img src="https://img-blog.csdnimg.cn/20200805104730363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在urls.py中定义路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from django.views.generic import RedirectView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"># 访问favicon.ico 网站图标</span><br><span class="line">    path(&quot;favicon.ico&quot;,RedirectView.as_view(url=&#x27;static/favicon.ico&#x27;)),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="97、django-静态文件配置"><a href="#97、django-静态文件配置" class="headerlink" title="97、django 静态文件配置"></a>97、django 静态文件配置</h2><p>settings.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = &#x27;/static/&#x27;</span><br><span class="line"># 添加静态资源路由地址</span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, &#x27;static&#x27;),</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"># 使用python manage.py collectstatic收集静态文件时时使用STATIC_ROOT</span><br><span class="line"># STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>urls.py</p><pre><code>from django.urls import path, re_pathfrom django.views.generic import RedirectViewfrom django.views.static import servefrom &#39;你的项目名称&#39; import settingsurlpatterns = [    path(&quot;favicon.ico&quot;,RedirectView.as_view(url=&#39;static/favicon.ico&#39;)),    re_path(&#39;static/(?P&lt;path&gt;.*)$&#39;, serve, &#123;&#39;document_root&#39;: settings.STATICFILES_DIRS[0]&#125;),]</code></pre><h2 id="98、django-JsonResponse返回中文时显示unicode编码（-u67e5-u8be2）"><a href="#98、django-JsonResponse返回中文时显示unicode编码（-u67e5-u8be2）" class="headerlink" title="98、django JsonResponse返回中文时显示unicode编码（\u67e5\u8be2）"></a>98、django JsonResponse返回中文时显示unicode编码（\u67e5\u8be2）</h2><p>原因<br>这个unicode编码，是python3默认返回的编码。</p><p>解决方案<br>JsonResponse里面有个参数json_dumps_params，设置为json_dumps_params={‘ensure_ascii’:False}即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&#x27;msg&#x27;: &#x27;创建成功&#x27;,&#125;</span><br><span class="line">return JsonResponse(data=data, json_dumps_params=&#123;&#x27;ensure_ascii&#x27;: False&#125;)</span><br></pre></td></tr></table></figure><h2 id="99、获取当前时间月份的首日与最后一天"><a href="#99、获取当前时间月份的首日与最后一天" class="headerlink" title="99、获取当前时间月份的首日与最后一天"></a>99、获取当前时间月份的首日与最后一天</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import calendar</span><br><span class="line"></span><br><span class="line">def get_month_start_and_end(date=datetime.datetime.now()):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取当前时间的月份首日与最后一天</span><br><span class="line">    :param date:</span><br><span class="line">    :return: (首日，最后一天)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    year, month = str(date).split(&#x27;-&#x27;)[0], str(date).split(&#x27;-&#x27;)[1]</span><br><span class="line">    end = calendar.monthrange(int(year), int(month))[1]</span><br><span class="line">    return f&#x27;&#123;year&#125;-&#123;month&#125;-01&#x27;, f&#x27;&#123;year&#125;-&#123;month&#125;-&#123;end&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="100、xadmin后台批量操作"><a href="#100、xadmin后台批量操作" class="headerlink" title="100、xadmin后台批量操作"></a>100、xadmin后台批量操作</h2><p>adminx.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from django.db.models import  Sum</span><br><span class="line">from xadmin.plugins.actions import BaseActionView</span><br><span class="line"></span><br><span class="line">class MyCountFeeAction(BaseActionView):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">        用户余额统计</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">    action_name = &quot;countuserfee&quot;  #: 相当于这个 Action 的唯一标示, 尽量用比较针对性的名字</span><br><span class="line">    description = u&#x27;统计用户总余额&#x27;  #: 描述, 出现在 Action 菜单中, 可以使用 ``%(verbose_name_plural)s`` 代替 Model 的名字.</span><br><span class="line">    model_perm = &#x27;view&#x27;  # 权限</span><br><span class="line"></span><br><span class="line">    def do_action(self, queryset):</span><br><span class="line">        all_balance = MallUser.objects.all().aggregate(Sum(&#x27;balance&#x27;))</span><br><span class="line">        return HttpResponse(f&#x27;用户总余额&#123;all_balance&#125;&#x27;)</span><br><span class="line">class UserAdmin(object):</span><br><span class="line">    &quot;&quot;&quot;用户信息管理&quot;&quot;&quot;</span><br><span class="line">    list_display = [&#x27;username&#x27;, &#x27;balance&#x27;, &#x27;status&#x27;, &#x27;addtime&#x27;]</span><br><span class="line">    search_fields = [&#x27;username&#x27;, ]</span><br><span class="line">    list_filter = [&#x27;status&#x27;, &#x27;addtime&#x27;]</span><br><span class="line">    list_per_page = 30  # 默认每页数量</span><br><span class="line">    model_icon = &#x27;fa fa-user&#x27;</span><br><span class="line">    list_editable = [&#x27;status&#x27;]</span><br><span class="line">    ordering = [&#x27;-addtime&#x27;]</span><br><span class="line">    actions = [ MyCountFeeAction]  # 添加批量选择操作</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200812233442373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）"><a href="#101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）" class="headerlink" title="101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）"></a>101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）</h2><p>首先，修改xadmin源码，修改xadmin/filters.py,在401行，做如下修改，</p><pre><code>把self.lookup_choices = field.get_choices(include_blank=False)改为：# 调用自定义的方法if hasattr(model_admin, &#39;&#123;field&#125;_choices&#39;.format(field=field.name)):        self.lookup_choices = getattr(model_admin, &#39;&#123;field&#125;_choices&#39;.format(field=field.name))(field, request,params, model,model_admin,field_path)    else:        self.lookup_choices = field.get_choices(include_blank=False)</code></pre><p>如图:</p><p><img src="https://img-blog.csdnimg.cn/20200812234011656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>然后，在adminx.py中定义过滤的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from django.db.models import  Q, Sum</span><br><span class="line">from xadmin.plugins.actions import BaseActionView</span><br><span class="line"></span><br><span class="line">class MeasurePointAdmin(object):</span><br><span class="line">    # search_fields = [&#x27;user__name&#x27;, &#x27;user__account&#x27;]  # 检索字段</span><br><span class="line">    list_display = [&#x27;num&#x27;, &#x27;elevation&#x27;, &#x27;correct_num&#x27;, &#x27;cumulative_amount&#x27;]</span><br><span class="line">    list_filter = [&#x27;user&#x27;, &#x27;is_default&#x27;, &#x27;create_time&#x27;]  # 分组过滤的字段</span><br><span class="line">    list_editable = [&#x27;num&#x27;, &#x27;elevation&#x27;, &#x27;correct_num&#x27;, &#x27;cumulative_amount&#x27;]</span><br><span class="line">    ordering = (&#x27;id&#x27;,)  # 设置默认排序字段，负号表示降序排序</span><br><span class="line">    list_per_page = 30  # 默认每页显示多少条记录，默认是100条</span><br><span class="line">    model_icon = &#x27;fa fa-users&#x27;  # 左侧小图标</span><br><span class="line">    readonly_fields = [&#x27;user&#x27;, &#x27;is_default&#x27;]</span><br><span class="line">    import_excel = True</span><br><span class="line">    actions = [MyCountFeeAction]</span><br><span class="line"></span><br><span class="line"># 定义的函数名必须是  字段名_choices</span><br><span class="line">    def user_choices(self, field, request, params, model, model_admin, field_path):</span><br><span class="line">        # 超级用户不做控制</span><br><span class="line">        if self.request.user.is_superuser:</span><br><span class="line">            return field.get_choices(include_blank=False)</span><br><span class="line"></span><br><span class="line">        # 过滤器只显示自己与超级管理员</span><br><span class="line">        user_lst = field.related_model._default_manager.filter(Q(id=self.request.user.id) | Q(is_superuser=True))</span><br><span class="line">        # 返回格式 [(&#x27;pk&#x27;,&#x27;标题&#x27;),]</span><br><span class="line">        return [(user.id, user.username) for user in user_lst]</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="https://img-blog.csdnimg.cn/2020081223440761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="102、Django中的CSRF局部禁用"><a href="#102、Django中的CSRF局部禁用" class="headerlink" title="102、Django中的CSRF局部禁用"></a>102、Django中的CSRF局部禁用</h2><p>为了避免没有csrf token而产生的403的forbidden错误，可以使用csrf_exempt装饰器来处理POST、GET请求的View, 这种方式是CSRF局部禁用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.utils.decorators import method_decorator</span><br><span class="line">from django.views.decorators.csrf import csrf_exempt</span><br><span class="line"></span><br><span class="line">@method_decorator(csrf_exempt)</span><br><span class="line">def update_data(request):</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">    pass</span><br><span class="line">elif request.method == &#x27;GET&#x27;:</span><br><span class="line">    pass</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="103、使用python命令创建django项目"><a href="#103、使用python命令创建django项目" class="headerlink" title="103、使用python命令创建django项目"></a>103、使用python命令创建django项目</h2><p>创建django项目<br>方式一：直接打开pycharm创建，选择file-&gt;new project-&gt;django<br>方式二：通过命令创建<br>先创建虚拟环境：python -m venv django_venv<br>然后导入django库：pip install django -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>最后使用命令创建：django-admin startproject my_django_project</p><h2 id="104、-二维列表、二维数组行求和与列求和"><a href="#104、-二维列表、二维数组行求和与列求和" class="headerlink" title="104、 二维列表、二维数组行求和与列求和"></a>104、 二维列表、二维数组行求和与列求和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line"># 二维数组，对列和行求和</span><br><span class="line">a = [</span><br><span class="line">    [&#x27;&#x27;, 0, &#x27;&#x27;, 1, 4.1],</span><br><span class="line">    [&#x27;&#x27;, 0, &#x27;&#x27;, &#x27;&#x27;, 4],</span><br><span class="line">    [&#x27;123&#x27;, 0, &#x27;&#x27;, 3, 4, 6,7],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def aa(x, y):</span><br><span class="line">    x = 0 if isinstance(x, str) else x</span><br><span class="line">    y = 0 if isinstance(y, str) else y</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line"># 对行求和</span><br><span class="line">row_sum = [reduce(aa, i) for i in a]</span><br><span class="line"># 对列求和，只能处理相同长度的子元素</span><br><span class="line">column_sum_1 = [reduce(aa, i) for i in zip(*a)]</span><br><span class="line"># 对列求和，可以处理不同长度的子元素</span><br><span class="line">column_sum_2 = list(dict(pd.DataFrame(a).fillna(0).apply(lambda x: &#x27;&#x27; if any(isinstance(d, str) for d in x) else round(x.sum(), 2))).values())</span><br><span class="line">print(&#x27;行求和：&#123;&#125;\r\n列求和(相同长度)：&#123;&#125;\r\n列求和：&#123;&#125;&#x27;.format(row_sum, column_sum_1, column_sum_2))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行求和：[5.1, 4, 20]</span><br><span class="line">列求和(相同长度)：[0, 0, 0, 4, 12.1]</span><br><span class="line">列求和：[&#x27;&#x27;, 0, &#x27;&#x27;, &#x27;&#x27;, 12.1, 6.0, 7.0]</span><br></pre></td></tr></table></figure><h2 id="105、获取时间字符串的月份数"><a href="#105、获取时间字符串的月份数" class="headerlink" title="105、获取时间字符串的月份数"></a>105、获取时间字符串的月份数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">    </span><br><span class="line">def get_months(start_month_str, end_month_str):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 获取时间字符串中的月份数</span><br><span class="line">    :param start_month_str: 开始字符串</span><br><span class="line">    :param end_month_str: 结束字符串</span><br><span class="line">    :return: 月份数</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    end_month_date = datetime.strptime(end_month_str, &#x27;%Y-%m&#x27;)</span><br><span class="line">    start_month_date = datetime.strptime(start_month_str, &#x27;%Y-%m&#x27;)</span><br><span class="line">    end_year, end_month = end_month_date.year, end_month_date.month</span><br><span class="line">    start_year, start_month = start_month_date.year, start_month_date.month</span><br><span class="line"></span><br><span class="line">    return (end_year - start_year) *12 + (end_month - start_month) + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end_month_str = &#x27;2021-02&#x27;</span><br><span class="line">start_month_str = &#x27;2020-07&#x27;</span><br><span class="line">print(get_months(start_month_str, end_month_str))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="106、字符串不足补零"><a href="#106、字符串不足补零" class="headerlink" title="106、字符串不足补零"></a>106、字符串不足补零</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;hello world&#x27;.zfill(15)) # 补0</span><br><span class="line">print(&#x27;hello world&#x27;.rjust(15)) # 右对齐，补空格</span><br><span class="line">print(&#x27;hello world&#x27;.ljust(15)) # 左对齐，补空格</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">0000hello world</span><br><span class="line">    hello world</span><br><span class="line">hello world  </span><br></pre></td></tr></table></figure><h2 id="107、时间戳转字符串日期"><a href="#107、时间戳转字符串日期" class="headerlink" title="107、时间戳转字符串日期"></a>107、时间戳转字符串日期</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">t1 = time.time()</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime(t1)))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1621741567.082192</span></span><br><span class="line"><span class="number">2021</span>-05-<span class="number">23</span> <span class="number">11</span>:<span class="number">46</span>:07</span><br></pre></td></tr></table></figure><p>使用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># !/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@contact: 微信 1257309054</span><br><span class="line">@file: 时间戳转日期.py</span><br><span class="line">@time: 2022/6/27 17:16</span><br><span class="line">@author: LDC</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import time</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 正确10位长度的时间戳可精确到秒，11-14位长度则是包含了毫秒</span><br><span class="line">def int_to_datetime(intValue):</span><br><span class="line">    if len(str(intValue)) == 10:</span><br><span class="line">        # 精确到秒</span><br><span class="line">        timeValue = time.localtime(intValue)</span><br><span class="line">        tempDate = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeValue)</span><br><span class="line">        datetimeValue = datetime.datetime.strptime(tempDate, &quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">    elif 10 &lt; len(str(intValue)) and len(str(intValue)) &lt; 15:</span><br><span class="line">        # 精确到毫秒</span><br><span class="line">        k = len(str(intValue)) - 10</span><br><span class="line">        timetamp = datetime.datetime.fromtimestamp(intValue / (1 * 10 ** k))</span><br><span class="line">        datetimeValue = timetamp.strftime(&quot;%Y-%m-%d %H:%M:%S.%f&quot;)</span><br><span class="line">    else:</span><br><span class="line">        return -1</span><br><span class="line">    return datetimeValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time1 = 1656321420</span><br><span class="line">time2 = 1656321086560</span><br><span class="line">print(int_to_datetime(time1))</span><br><span class="line">print(int_to_datetime(time2))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">2022-06-27 17:17:00</span><br><span class="line">2022-06-27 17:11:26.560000</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h2 id="108、列表转字符串"><a href="#108、列表转字符串" class="headerlink" title="108、列表转字符串"></a>108、列表转字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,a)))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">`<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>`</span><br></pre></td></tr></table></figure><h2 id="109、pip国内镜像源"><a href="#109、pip国内镜像源" class="headerlink" title="109、pip国内镜像源"></a>109、pip国内镜像源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pip install 库名 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">清华：-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">阿里云：-i http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">中国科技大学 -i https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"></span><br><span class="line">华中理工大学：-i http://pypi.hustunique.com/</span><br><span class="line"></span><br><span class="line">山东理工大学：-i http://pypi.sdutlinux.org/ </span><br><span class="line"></span><br><span class="line">豆瓣：-i http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure><h2 id="110、python把时间字符串转换成刚刚、1天前、3个月前、1年前"><a href="#110、python把时间字符串转换成刚刚、1天前、3个月前、1年前" class="headerlink" title="110、python把时间字符串转换成刚刚、1天前、3个月前、1年前"></a>110、python把时间字符串转换成刚刚、1天前、3个月前、1年前</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def date_interval(date_str):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    获取时间间隔</span><br><span class="line">    1分钟前，2分钟前，10分钟前，1小时前，2小时前，1天前，2天前，3天前，1个月前，3个月前，1年前，3年前</span><br><span class="line">    :param date_str: 时间字符串</span><br><span class="line">    :return: 字符串</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    date_str = time.strptime(date_str, &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    # 将时间元组转换为时间戳</span><br><span class="line">    t = time.mktime(date_str)</span><br><span class="line"></span><br><span class="line">    # 当前时间</span><br><span class="line">    seconds = time.time() - t</span><br><span class="line"></span><br><span class="line">    years = int(seconds // (60 * 60 * 24 * 365))</span><br><span class="line">    if years:</span><br><span class="line">        return &#x27;&#123;&#125;年前&#x27;.format(years)</span><br><span class="line">    months = int(seconds // (60 * 60 * 24 * 30))</span><br><span class="line">    if months:</span><br><span class="line">        return &#x27;&#123;&#125;月前&#x27;.format(months)</span><br><span class="line">    days = int(seconds // (60 * 60 * 24))</span><br><span class="line">    if days:</span><br><span class="line">        return &#x27;&#123;&#125;天前&#x27;.format(days)</span><br><span class="line">    hours = int(seconds // (60 * 60))</span><br><span class="line">    if hours:</span><br><span class="line">        return &#x27;&#123;&#125;小时前&#x27;.format(hours)</span><br><span class="line">    minutes = int(seconds // (60))</span><br><span class="line">    if minutes:</span><br><span class="line">        return &#x27;&#123;&#125;分钟前&#x27;.format(minutes)</span><br><span class="line">    return &#x27;刚刚&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    date1 = &#x27;2019-07-10 15:27:51&#x27;</span><br><span class="line">    date2 = &#x27;2021-07-10 15:27:51&#x27;</span><br><span class="line">    date3 = &#x27;2021-08-10 15:27:51&#x27;</span><br><span class="line">    date4 = &#x27;2021-08-12 11:01:51&#x27;</span><br><span class="line">    date5 = datetime.datetime.now() + datetime.timedelta(seconds=-3)</span><br><span class="line">    date5 = date5.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    print(date_interval(date1))</span><br><span class="line">    print(date_interval(date2))</span><br><span class="line">    print(date_interval(date3))</span><br><span class="line">    print(date_interval(date4))</span><br><span class="line">    print(date_interval(date5))</span><br></pre></td></tr></table></figure><h2 id="111、Django使用ORM执行sql语句"><a href="#111、Django使用ORM执行sql语句" class="headerlink" title="111、Django使用ORM执行sql语句"></a>111、Django使用ORM执行sql语句</h2><p>通过raw函数执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alarm_datas = gsm.AlertMessage.objects.raw(&#x27;&#x27;&#x27;</span><br><span class="line">                select am_all.id, am_all.sensor_number</span><br><span class="line">                    FROM alert_message as am_all</span><br><span class="line">                    where </span><br><span class="line">                        am_all.real=&#x27;1&#x27;</span><br><span class="line">                        and am_all.is_show=1</span><br><span class="line">                    order by am_all.alarm_level desc</span><br><span class="line">                &#x27;&#x27;&#x27;)</span><br><span class="line">for ad in alarm_datas:</span><br><span class="line">print(ad.sensor_number)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="112、Django通过变量字段获取数据"><a href="#112、Django通过变量字段获取数据" class="headerlink" title="112、Django通过变量字段获取数据"></a>112、Django通过变量字段获取数据</h2><p>通过方法<code>__getattribute__</code>来获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert_messages = AlertMessage.objects.filter(real=0)</span><br><span class="line">am_fields = [&#x27;id&#x27;, &#x27;real&#x27;, &#x27;name&#x27;]</span><br><span class="line">for am in alert_messages:</span><br><span class="line">for i in range(len(am_fields)):</span><br><span class="line">print(am_fields[i], am.__getattribute__(am_fields[i]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="113、Django查询变量字段、更新变量字段"><a href="#113、Django查询变量字段、更新变量字段" class="headerlink" title="113、Django查询变量字段、更新变量字段"></a>113、Django查询变量字段、更新变量字段</h2><p>通过<code>**&#123;变量名:值&#125;</code>来操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">field = &#x27;device_code&#x27;</span><br><span class="line"># 查询</span><br><span class="line">device_infos = gsm.DeviceInfo.objects.filter(**&#123;field: &#x27;012&#x27;&#125;)</span><br><span class="line"># 更新</span><br><span class="line">gsm.DeviceInfo.objects.filter(device_code=&#x27;012&#x27;).update(**&#123;field : &#x27;0&#x27;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="114、vue生成dist文件"><a href="#114、vue生成dist文件" class="headerlink" title="114、vue生成dist文件"></a>114、vue生成dist文件</h2><p>安装npm，到<a href="https://nodejs.org/en/download/">官网下载</a><br>在vue项目下打开cmd，输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>如果报错，npm ERR! missing script: build，<br>则使用以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><p>具体看package.json</p><p><img src="https://img-blog.csdnimg.cn/eff15dcd4c1d499f9641d0ac25c09bc0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Lic5pyo5pyI,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="115、python获取电脑磁盘、CPU、内存使用情况"><a href="#115、python获取电脑磁盘、CPU、内存使用情况" class="headerlink" title="115、python获取电脑磁盘、CPU、内存使用情况"></a>115、python获取电脑磁盘、CPU、内存使用情况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import psutil</span><br><span class="line">#  pip install psutil</span><br><span class="line"></span><br><span class="line"># 获取本机磁盘使用率和剩余空间G信息</span><br><span class="line">def get_disk_info():</span><br><span class="line">    # 循环磁盘分区</span><br><span class="line">    content = &quot;&quot;</span><br><span class="line">    for disk in psutil.disk_partitions():</span><br><span class="line">        # 读写方式 光盘 or 有效磁盘类型</span><br><span class="line">        if &#x27;cdrom&#x27; in disk.opts or disk.fstype == &#x27;&#x27;:</span><br><span class="line">            continue</span><br><span class="line">        disk_name_arr = disk.device.split(&#x27;:&#x27;)</span><br><span class="line">        disk_name = disk_name_arr[0]</span><br><span class="line">        disk_info = psutil.disk_usage(disk.device)</span><br><span class="line">        # 磁盘剩余空间，单位G</span><br><span class="line">        free_disk_size = disk_info.free//1024//1024//1024</span><br><span class="line">        # 当前磁盘使用率和剩余空间G信息</span><br><span class="line">        info = &quot;&#123;&#125;盘使用率：&#123;&#125;%%， 剩余空间：&#123;&#125;G &quot;.format(disk_name, str(disk_info.percent), free_disk_size)</span><br><span class="line">        # 拼接多个磁盘的信息</span><br><span class="line">        content = content + info</span><br><span class="line">    print(content)</span><br><span class="line"></span><br><span class="line"># cpu信息</span><br><span class="line">def get_cpu_info():</span><br><span class="line">    cpu_percent = psutil.cpu_percent(interval=1)</span><br><span class="line">    cpu_info = &quot;CPU使用率：%i%%&quot; % cpu_percent</span><br><span class="line">    print(cpu_info)</span><br><span class="line"></span><br><span class="line"># 内存信息</span><br><span class="line">def get_memory_info():</span><br><span class="line">    virtual_memory = psutil.virtual_memory()</span><br><span class="line">    used_memory = virtual_memory.used/1024/1024/1024</span><br><span class="line">    free_memory = virtual_memory.free/1024/1024/1024</span><br><span class="line">    memory_percent = virtual_memory.percent</span><br><span class="line">    memory_info = &quot;内存使用：%0.2fG，使用率%0.1f%%，剩余内存：%0.2fG&quot; % (used_memory, memory_percent, free_memory)</span><br><span class="line">    print(memory_info)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    get_disk_info()</span><br><span class="line">    get_cpu_info()</span><br><span class="line">    get_memory_info()</span><br></pre></td></tr></table></figure><h2 id="116、max比较字典列表"><a href="#116、max比较字典列表" class="headerlink" title="116、max比较字典列表"></a>116、max比较字典列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">使用max函数比较字典列表对象</span><br><span class="line">需求：找出用户组最大id的字典</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">def com_id(f):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    比较用用户ids列表</span><br><span class="line">    :param f: 字典</span><br><span class="line">    :return: 返回最大的用户id</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    return max(f[&#x27;user_ids&#x27;])</span><br><span class="line"></span><br><span class="line">friends_added = [</span><br><span class="line">        &#123;&#x27;user_ids&#x27;: [1, 2], &#x27;create_at&#x27;: &#x27;2020-01-01&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;user_ids&#x27;: [2, 1], &#x27;create_at&#x27;: &#x27;2020-02-02&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;user_ids&#x27;: [4, 1], &#x27;create_at&#x27;: &#x27;2020-02-02&#x27;&#125;,</span><br><span class="line">    ]</span><br><span class="line"># max函数中使用key参数，指定自定义函数来比较</span><br><span class="line">item = max(friends_added, key=com_id)</span><br><span class="line">item_1 = max(friends_added, key=lambda f: max(f[&#x27;user_ids&#x27;])) # com_id可以转成lambda函数</span><br><span class="line">print(item)</span><br><span class="line">print(item_1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;</span><br><span class="line">&#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="117、django查询表的具体字段"><a href="#117、django查询表的具体字段" class="headerlink" title="117、django查询表的具体字段"></a>117、django查询表的具体字段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExampleModel.objects.values(&#x27;id&#x27;, &#x27;username&#x27;)</span><br><span class="line"># 返回的结果是QuerySet， 里面的元素是dict格式</span><br><span class="line"># [&#123;&#x27;id&#x27;:1, &#x27;username&#x27;: &#x27;Austin&#x27;&#125;, &#123;&#x27;id&#x27;:2, &#x27;username&#x27;:&#x27;Sam&#x27;&#125;, ...]</span><br><span class="line"># 相当于SQL中的SELECT id, username FROM ......, </span><br><span class="line"># 只返回对应属性（字段）的值</span><br></pre></td></tr></table></figure><h2 id="118、MySQL查询数据添加自增序号"><a href="#118、MySQL查询数据添加自增序号" class="headerlink" title="118、MySQL查询数据添加自增序号"></a>118、MySQL查询数据添加自增序号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set @i = 0;</span><br><span class="line">select waveform, &#x27;沿桥风吹&#x27; as label ,(@i:=@i+1) xh from alert_message where is_real=1 and node_id=138</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="119、MySQL-时间截取年月日"><a href="#119、MySQL-时间截取年月日" class="headerlink" title="119、MySQL 时间截取年月日"></a>119、MySQL 时间截取年月日</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id,</span><br><span class="line">addtime, </span><br><span class="line">date_format(addtime,&#x27;%Y-%m-%d&#x27;) as short_time </span><br><span class="line">from alert_message </span><br><span class="line">where date_format(addtime,&#x27;%Y-%m-%d&#x27;) = &#x27;2022-03-13&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/37cec67fa1e1458f9aba1b745600a493.png" alt="在这里插入图片描述"></p><h2 id="120、-列表取奇数下标值"><a href="#120、-列表取奇数下标值" class="headerlink" title="120、 列表取奇数下标值"></a>120、 列表取奇数下标值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;奇数下标值&#x27;</span>,list1[<span class="number">1</span>::<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">奇数下标值 [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="121、列表取偶数下标值"><a href="#121、列表取偶数下标值" class="headerlink" title="121、列表取偶数下标值"></a>121、列表取偶数下标值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;偶数下标值&#x27;</span>,list1[::<span class="number">2</span>])</span><br><span class="line">偶数下标值 [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="122、列表相同元素分类、分组"><a href="#122、列表相同元素分类、分组" class="headerlink" title="122、列表相同元素分类、分组"></a>122、列表相同元素分类、分组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">a =[<span class="built_in">list</span>(group) <span class="keyword">for</span> key, group <span class="keyword">in</span> itertools.groupby(data)]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]]</span><br></pre></td></tr></table></figure><h2 id="123、ubuntu切换用户"><a href="#123、ubuntu切换用户" class="headerlink" title="123、ubuntu切换用户"></a>123、ubuntu切换用户</h2><p>1）从user用户切换到root用户<br>sudo su<br>2）从root用户切回user用户<br>su user (user是你自己安装时候的用户名)，或是直接输入exit，也可Ctrl+D组合键推出</p><h2 id="124、numpy二维数组获取某一列"><a href="#124、numpy二维数组获取某一列" class="headerlink" title="124、numpy二维数组获取某一列"></a>124、numpy二维数组获取某一列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = [</span><br><span class="line">    [1, 2, 3, 4, 5, 6],</span><br><span class="line">    [7, 8, 9, 10, 11, 12],</span><br><span class="line">    [13.2, 14.8, 15.9, 16.10, 16.11, 17.12],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">a_np = np.array(a)  # 把二维列表转成numpy数组</span><br><span class="line">print(&#x27;第一行&#x27;, a_np[0].tolist())  # 获取第一行</span><br><span class="line">print(&#x27;第一列&#x27;, a_np[:, 0].tolist())  # 获取第一列</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">第一行 [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]</span><br><span class="line">第一列 [1.0, 7.0, 13.2]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自制电子时钟</title>
      <link href="/2020/08/19/clock-conclusion/"/>
      <url>/2020/08/19/clock-conclusion/</url>
      
        <content type="html"><![CDATA[<h1 id="自制电子时钟—总结"><a href="#自制电子时钟—总结" class="headerlink" title="自制电子时钟—总结"></a>自制电子时钟—总结</h1><h2 id="使用到的模块及其功能："><a href="#使用到的模块及其功能：" class="headerlink" title="使用到的模块及其功能："></a>使用到的模块及其功能：</h2><ul><li>DS1302：低功耗实时时钟芯片，它可以对年、月、日、周、时、分、秒进行计时，且具有闰年补偿等多种功能。</li><li>LCD1602：用来显示字母、数字、符号等的点阵型液晶模块，能够同时显示16x02即32个字符。</li><li>按键k1,k2,k3,k4：<br>k1：切换模式，比如工作模式、计时模式、设置模式。<br>k2：设置模式: plus；计时模式: 打开计时，暂停计时<br>k3：设置模式: shift；计时模式：归零<br>k4：闹钟响时，关闭闹钟</li><li>蜂鸣器：闹钟铃声，天空之城</li></ul><h2 id="主要原理："><a href="#主要原理：" class="headerlink" title="主要原理："></a>主要原理：</h2><p>&emsp; &emsp; 工作模式下，51单片机从DS1302中获取数据，再把数据传递到LCD来显示时间和日期；设置模式下，通过k2和k3来改变数据；计时模式下，通过k2来打开或关闭定时器1，来实现开始/暂停计时，通过k3来计时初始化；闹钟响时，打开定时器1，通过天空之城乐谱来控制蜂鸣器的音调。  </p><h2 id="DS1302"><a href="#DS1302" class="headerlink" title="DS1302"></a>DS1302</h2><p>编码是BCD8421编码，用4位二进制数来表示1位十进制数中的0~9这10个数字  </p><div class="table-container"><table><thead><tr><th style="text-align:center">十进制数</th><th style="text-align:center">8421码</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0001</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0010</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0011</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0100</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0101</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">0110</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">0111</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1001</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*BCD8421编码，十进制数据转换成BCD码 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">encode_BCD</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>   </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat1,dat2;</span><br><span class="line">dat1 = dat/<span class="number">10</span>;</span><br><span class="line">dat2 = dat%<span class="number">10</span>;</span><br><span class="line">dat = dat2 + dat1*<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> dat; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BCD8421解码，BCD码转换成十进制数据   */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">decode_BCD</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat1,dat2;</span><br><span class="line">dat1 = dat/<span class="number">16</span>;</span><br><span class="line">dat2 = dat%<span class="number">16</span>;</span><br><span class="line">dat = dat2 + dat1*<span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>读写数据到DS1302<br>  DS1302的数据读写是通过I/O串行进行的。当进行一次读写操作时最少得发送两个字节，第一个字节是控制字节，就是一个命令，告诉DS1302是读还是写操作，是对RAM还是对CLOK寄存器操作，以及操作的地址。第二个字节就是要读或写的数据了。 </p><ol><li>控制字节<br><img src="http://www.elecfans.com/uploads/allimg/171020/2362487-1G02009234UB.jpg" alt="控制指令">  <ul><li>位0就是读写位，当位0为1时，就是告诉DS1302，下面是进行读出操作，而当位0为0时就是写入操作。  </li><li>位0－位5是要进行操作的DS1302寄存器地址。<br>位6就是告诉DS1302，是要对RAM进行操作还是对时间寄存器进行操作，0就是对时间寄存器操作，一般我们都是对时间寄存器进行操作。  </li><li>位7就是固定的1。  </li><li>现在就知道为什么控制字80H是写秒寄存器，而81H是读秒寄存器了吧。80H换成二进制就是10000000。而81H的二进制就是10000001，一个是写操作，另一个是读操作嘛！  </li></ul></li><li>读写操作<br><img src="http://www.elecfans.com/uploads/allimg/171020/2362487-1G02009241L44.jpg" alt="读写">  <ul><li>写：<br>在进行操作之前先得将CE（也可说是RST）置高电平，然后单片机将控制字的位0放到I/O上，当I/O的数据稳定后，将SCLK置高电平，DS1302检测到SCLK的上升沿后就将I/O上的数据读取，然后单片机将SCLK置为低电平，再将控制字的位1放到I/O上，如此反复，将一个字节控制字的8个位传给DS1302。<br>接下来就是传一个字节的数据给DS1302，在SCLK低电平时单片机将数据放到IO上，当SCLK上升沿时，DS1302读取。当传完数据后，单片机将CE置为低电平，操作结束。</li><li>读：<br>在进行操作之前先得将CE（也可说是RST）置高电平，然后单片机将控制字的位0放到I/O上，当I/O的数据稳定后，将SCLK置高电平，DS1302检测到SCLK的上升沿后就将I/O上的数据读取，然后单片机将SCLK置为低电平，再将控制字的位1放到I/O上，如此反复，将一个字节控制字的8个位传给DS1302。<br>接下来就是从DS1302读数据，在SCLK高电平时DS1302放数据到IO上，将SCLK置为低电平后，产生下降沿电压，单片机就可从IO上读取数据。当传完数据后，单片机将CE置为低电平，操作结束。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写入数据到DS1302*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_DS1302_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">TRST = <span class="number">0</span>;</span><br><span class="line">_nop_(); </span><br><span class="line">TSCLK = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line"></span><br><span class="line">TRST = <span class="number">1</span>; <span class="comment">//拉高CE，开始读写数据</span></span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//写入地址</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">TIO = addr &amp; <span class="number">0x01</span>;<span class="comment">//发送地址的最低位 </span></span><br><span class="line">addr &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">TSCLK = <span class="number">1</span>;<span class="comment">//产生上升沿电压，写入命令</span></span><br><span class="line">_nop_();</span><br><span class="line">TSCLK = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//写入数据</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">TIO = dat &amp; <span class="number">0x01</span>;<span class="comment">//发送数据的最低位</span></span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">TSCLK = <span class="number">1</span>;<span class="comment">//产生上升沿电压，写入数据</span></span><br><span class="line">_nop_();</span><br><span class="line">TSCLK = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line">TRST = <span class="number">0</span>; <span class="comment">//数据传输结束</span></span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从DS1302读取数据*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">read_DS1302_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i,dat=<span class="number">0</span>,dat1=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">TRST = <span class="number">0</span>;</span><br><span class="line">_nop_(); </span><br><span class="line">TSCLK = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line"></span><br><span class="line">TRST = <span class="number">1</span>; <span class="comment">//拉高CE，开始读写数据</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//开始传送八位地址命令</span></span><br><span class="line">&#123;    </span><br><span class="line">TIO = addr &amp; <span class="number">0x01</span>;<span class="comment">//发送地址的最低位 </span></span><br><span class="line">addr &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">TSCLK = <span class="number">1</span>;<span class="comment">//产生上升沿电压，写入命令</span></span><br><span class="line">_nop_();</span><br><span class="line">TSCLK = <span class="number">0</span>;<span class="comment">//DS1302下降沿时，放置数据</span></span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//读取8位数据</span></span><br><span class="line">&#123;</span><br><span class="line">dat1 = TIO;<span class="comment">//从最低位开始接收</span></span><br><span class="line">dat = (dat&gt;&gt;<span class="number">1</span>) | (dat1&lt;&lt;<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">TSCLK = <span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">TSCLK = <span class="number">0</span>;<span class="comment">//产生下降沿电压，读取数据</span></span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TRST = <span class="number">0</span>;</span><br><span class="line">_nop_();<span class="comment">//以下为DS1302复位的稳定时间,必须的。</span></span><br><span class="line">TSCLK = <span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">TIO = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">TIO = <span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="LCD1602"><a href="#LCD1602" class="headerlink" title="LCD1602"></a>LCD1602</h2><ul><li>LCD操作模式  </li></ul><div class="table-container"><table><thead><tr><th>输入</th><th>输出</th><th>输出</th></tr></thead><tbody><tr><td>读状态</td><td>RS=0,RW=H,EN为高变低脉冲</td><td>D0~D7个状态值</td></tr><tr><td>读数据</td><td>RS=1,RW=1,EN为高变低脉冲</td><td>无</td></tr><tr><td>写指令</td><td>RS=0,RW=0,D0—D7=数据,EN由高脉冲变为低脉冲</td><td>D0—D7状态值</td></tr><tr><td>写数据</td><td>RS=1, RW=0, D0—D7=数据，EN由高脉冲变为低脉冲</td><td>D0—D7状态值</td></tr></tbody></table></div><ul><li><p>详细说明：<br>(1) RS和RW都为0时表示对LCD写指令操作，包括写入LCD的显示模式和设定LCD地址的指令。.显示模式包括清屏、地址归为、显示状态、进入点设定、功能设定、游标显示模式操作;关于地址的操作包括设定CGRAM地址、设定DDRAM地址。<br>(2) 当RS=0,RW=1时，表示读LCD状态，此时可以读取LCD忙信号，同时可以读取地址计数器的值。忙信号的状态用来确定LCD内部动作是否完成，若在LCD内部出于忙状态时对LCD进行读写操作将会失败。<br>(3) 当RS=1时，若RW=0表示写数据操作，若RW=1表示读数据操作  </p></li><li><p>地址：<br>LCD供两行，第一行可立即显示字符的地址为00H—0FH，第二行可立即显示字符的地址为40H—67H。  </p></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断液晶是否忙，如果忙就等待</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_busy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> busy;</span><br><span class="line">P0 = <span class="number">0xff</span>;</span><br><span class="line">RS = <span class="number">0</span>;</span><br><span class="line">RW = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">EN = <span class="number">1</span>;</span><br><span class="line">busy = P0;   <span class="comment">//读状态，RS = 0;RW = 1;EN = 1;</span></span><br><span class="line">EN = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(busy &amp; <span class="number">0x80</span>); <span class="comment">//判断状态码最高位，STA7读写使能，1：禁止，0：允许</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写1字节指令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span>   <span class="comment">//RS=L,RW=L,E=下降沿脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">read_busy();</span><br><span class="line">RS = <span class="number">0</span>;</span><br><span class="line">RW = <span class="number">0</span>;</span><br><span class="line">P0 = cmd;</span><br><span class="line">EN = <span class="number">1</span>;</span><br><span class="line">EN = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写1字节数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>   <span class="comment">//RS=H,RW=L,E=下降沿脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">read_busy();</span><br><span class="line">RS = <span class="number">1</span>;</span><br><span class="line">RW = <span class="number">0</span>;</span><br><span class="line">P0 = dat;</span><br><span class="line">EN = <span class="number">1</span>;</span><br><span class="line">EN = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><p>核心代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> <span class="comment">//us延时 12MHz下</span></span><br><span class="line">&#123;</span><br><span class="line">t/=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(t;t;t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">play_tone</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> tone)</span> <span class="comment">//播音调函数，就是方波发生器</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Buzzer=!Buzzer; </span><br><span class="line">delay_us(tone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>定时器获取延时时间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> <span class="comment">//毫秒延时12MHz下</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">75</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_init</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD|=<span class="number">0x10</span>; <span class="comment">//使用定时器1</span></span><br><span class="line">TH1=(<span class="number">65536</span><span class="number">-65000</span>)/<span class="number">256</span>; <span class="comment">//装初值</span></span><br><span class="line">TL1=(<span class="number">65536</span><span class="number">-65000</span>)%<span class="number">256</span>;</span><br><span class="line">EA =  <span class="number">1</span>; <span class="comment">//开中断，打开定时器开关</span></span><br><span class="line">ET1 = <span class="number">1</span>;</span><br><span class="line">TR1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer1_interrupt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *song)</span>  <span class="comment">//定时器1 中断</span></span><br><span class="line">&#123;</span><br><span class="line">TH1=(<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>; <span class="comment">//装初值</span></span><br><span class="line">TL1=(<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">music_s++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(music_s&gt;=<span class="number">4</span>*t_tone) <span class="comment">//一个音节播放的时间，这里可以通过调t_tone前的系数可以改变时长</span></span><br><span class="line">&#123;</span><br><span class="line">music_s=<span class="number">0</span>; <span class="comment">//讲计时器清零</span></span><br><span class="line"><span class="keyword">if</span>((*tone_p)!=<span class="number">0</span>) <span class="comment">//如果音不是0</span></span><br><span class="line">tone = tones[*tone_p+<span class="number">7</span>*(*(tone_p+<span class="number">1</span>))<span class="number">-1</span>];  <span class="comment">//赋值音调</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">tone = <span class="number">0</span>;     <span class="comment">//关了蜂鸣器</span></span><br><span class="line">t_tone = *(tone_p+<span class="number">2</span>); <span class="comment">//取时间啊</span></span><br><span class="line"></span><br><span class="line">tone_p+=<span class="number">3</span>; <span class="comment">//移动指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*tone_p == <span class="number">8</span>) tone_p = song;   <span class="comment">//结束标志</span></span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">30</span>); <span class="comment">//延时一下，不延时特别难听</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>歌曲谱子数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tones[]=    <span class="comment">//C调音调</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">3816</span>,<span class="number">3401</span>,<span class="number">3030</span>,<span class="number">2865</span>,<span class="number">2551</span>,<span class="number">2272</span>,<span class="number">2024</span>, <span class="comment">//低音</span></span><br><span class="line"><span class="number">1912</span>,<span class="number">1703</span>,<span class="number">1517</span>,<span class="number">1432</span>,<span class="number">1275</span>,<span class="number">1136</span>,<span class="number">1012</span>, <span class="comment">//中音</span></span><br><span class="line"><span class="number">965</span>, <span class="number">851</span>, <span class="number">758</span>, <span class="number">715</span>, <span class="number">605</span>, <span class="number">538</span>, <span class="number">466</span> <span class="comment">//高音</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code sky[]=&#123; <span class="comment">//谱子，天空之城</span></span><br><span class="line"><span class="comment">//格式： 音调， 音度， 拍数</span></span><br><span class="line"><span class="comment">//例： 4，1，1 //音调fa，中音，时长半拍</span></span><br><span class="line"><span class="comment">//0代表空音</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line"><span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">8</span><span class="comment">//结束标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sbit Buzzer=P1^<span class="number">5</span>; <span class="comment">//定义buzzer引脚</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> music_s=<span class="number">0</span>, t_tone=<span class="number">0</span>;     <span class="comment">//music_s用作定时器计时， t_tone保存音调时长</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  tone=<span class="number">0</span>;     <span class="comment">//tone保存音调，</span></span><br><span class="line"><span class="type">char</span> *tone_p=sky; <span class="comment">//指针指向要播放的曲目</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo：搭建自己的blog</title>
      <link href="/2020/08/18/build-blog/"/>
      <url>/2020/08/18/build-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用gitee-hexo在gitee上部署blog"><a href="#如何使用gitee-hexo在gitee上部署blog" class="headerlink" title="如何使用gitee+hexo在gitee上部署blog"></a>如何使用gitee+hexo在gitee上部署blog</h1><h2 id="我搭建的blog网站：kiloGrand"><a href="#我搭建的blog网站：kiloGrand" class="headerlink" title="我搭建的blog网站：kiloGrand"></a>我搭建的blog网站：<a href="https://kilogrand.github.io/">kiloGrand</a></h2><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>下载git，推荐下载地址：<a href="https://pc.qq.com/detail/13/detail_22693.html">链接</a> ，在腾讯软件中心下载比较快</li><li>下载nodejs <a href="http://nodejs.cn/download/">官方下载</a>，我使用的版本是12.16.2，版本太高可能会出问题，推荐使用12.x.x系列的版本</li></ul><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ul><li>git 除了安装路径可以改之外，其他的不用改，一直next就行</li><li>nodejs 同上  </li></ul><h2 id="注册Gitee和GitHub账号"><a href="#注册Gitee和GitHub账号" class="headerlink" title="注册Gitee和GitHub账号"></a>注册Gitee和GitHub账号</h2><p><a href="https://github.com/">github官网</a><br><a href="https://gitee.com/">gitee官网</a><br>注意：在gitee和github中的设置-多邮件管理中,  “ [  ] 不公关我的邮箱地址”，这里不打勾，同时也要把你的邮箱设为提交邮箱<br><img src="https://img-blog.csdnimg.cn/20200821220646123.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>下载hexo主题sakura <a href="https://github.com/honjun/hexo-theme-sakura">github的Sakura链接</a>  ，推荐下载链接：<a href="https://gitee.com/wczzsmmn/hexo-theme-sakura">gitee的Sakura下载链接</a></li><li><p>下载cdn文件 <a href="https://github.com/honjun/cdn">cdn文件github下载链接</a> ，推荐下载链接：<a href="https://gitee.com/kiloGrand/cdn">cdn文件下载gitee链接</a>  </p><p>gitee上下载文件的方法：点击右上角克隆/下载—-下载zip<br><img src="https://img-blog.csdnimg.cn/202008212219345.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ul><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">*</span> <span class="string">配置git</span>  </span><br><span class="line">  <span class="string">打开git</span>    </span><br><span class="line">    <span class="string">$</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&#x27;gitee用户名&#x27;</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&#x27;gitee登陆邮箱&#x27;</span></span><br><span class="line"><span class="string">*</span> <span class="string">安装hexo</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span>  </span><br><span class="line"><span class="string">*</span> <span class="string">安装hexo-deployer-git</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line"><span class="string">*</span> <span class="string">初始化项目</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">cd</span> <span class="string">E://blog_project</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">hexo</span> <span class="string">init</span> <span class="string">blog</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">cd</span> <span class="string">E://blog_project/blog</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">//依据网页文件和新的css样式生成新的网站文件</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">hexo</span> <span class="string">s</span> <span class="string">//启动本地服务器，可以在&lt;http://localhost:4000&gt;查看网站效果</span>  </span><br></pre></td></tr></table></figure><h2 id="使用jsDeliver-github搭建免费的cdn"><a href="#使用jsDeliver-github搭建免费的cdn" class="headerlink" title="使用jsDeliver+github搭建免费的cdn"></a>使用jsDeliver+github搭建免费的cdn</h2><p>参考教程见 <a href="https://www.jianshu.com/p/467290ea7e9f">简书链接</a>  </p><ol><li>在github上新建一个名为cdn的仓库 </li><li><p>把下载好的cdn文件解压到E://cdn中，里面的图片可以替换，文件名最后不要改变，建议在cdn目录下加一个大小在20m以内的短视频，后面会用到，下面是修改后并且上传到github后的样子：<br><img src="https://img-blog.csdnimg.cn/2020082122362875.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>打开git<br> cd E://blog_project/cdn   </p></li><li><p>提交到github仓库上</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">init</span><span class="string">//初始化</span></span><br><span class="line"><span class="string">git</span> <span class="string">status</span> <span class="string">//查看状态</span>  </span><br><span class="line"><span class="string">git</span> <span class="string">add</span> <span class="string">.</span>  <span class="string">//添加文件到暂存区</span>  </span><br><span class="line"><span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&#x27;第一次提交&#x27;</span> <span class="string">//</span> <span class="string">提交到本地库</span> </span><br><span class="line"><span class="string">​git</span> <span class="string">remote</span> <span class="string">add</span> <span class="string">github</span> <span class="string">cdn仓库链接</span> <span class="string">//关联远程仓库</span>  </span><br><span class="line"><span class="string">​git</span> <span class="string">pull</span> <span class="string">--rebase</span> <span class="string">github</span> <span class="string">master</span> <span class="string">//合并远程仓库和本地仓库的冲突</span>  </span><br><span class="line"><span class="string">git</span> <span class="string">push</span> <span class="string">github</span> <span class="string">master</span> <span class="string">//推送到远程仓库上</span>  </span><br><span class="line"><span class="string">(jsDeliver不支持加载超过20M的资源，所以一些视频最好压缩到20M以下)</span></span><br></pre></td></tr></table></figure></li><li><p>发布仓库：浏览器打开github中新建的cdn，点击release发布, 发布版本号1.0（自定义）<br>使用方法：<br><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file">https://cdn.jsdelivr.net/gh/user/repo@version/file</a><br><a href="https://cdn.jsdelivr.net/gh/user/repo/file">https://cdn.jsdelivr.net/gh/user/repo/file</a><br>eg：  <a href="https://cdn.jsdelivr.net/gh/kiloGrand/cdn@1.2/img/custom/avatar.jpg">https://cdn.jsdelivr.net/gh/kiloGrand/cdn@1.2/img/custom/avatar.jpg</a>    <a href="https://cdn.jsdelivr.net/gh/kiloGrand/cdn/img/custom/avatar.jpg">https://cdn.jsdelivr.net/gh/kiloGrand/cdn/img/custom/avatar.jpg</a><br>版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源</p></li></ol><h2 id="blog配置"><a href="#blog配置" class="headerlink" title="blog配置"></a>blog配置</h2><ol><li>首先，在gitee上新建一个仓库，仓库名为你的账户名</li><li><p>用编辑器打开blog文件夹，我用的是vscode：<img src="https://img-blog.csdnimg.cn/20200821231313130.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>把blog/source中的所有md文件、blog/themes/Sakura/languages/zh-cn.yml和blog/themes/Sakura/_config.yml中的 ‘<a href="https://cdn.jsdelivr.net/gh/">https://cdn.jsdelivr.net/gh/</a>…’ 改成自己的cdn的文件链接。</p></li><li>按照<a href="https://docs.hojun.cn/sakura/docs/#/home">官方文档</a>进行配置，每当配置完一部份，可以使用下面的命令来生成网页，访问<a href="http://localhost:4000">http://localhost:4000</a>查看网站效果<br> $ hexo clean<br> $ hexo g<br> $ hexo s  </li><li>配置scaffolds文件夹下的md文件，这个文件夹是关于博客文章的。</li></ol><p>注意：在配置首页媒体时，aplayer的ID是网易云音乐的歌单号，比如<a href="https://music.163.com/#/playlist?id=4958788236">https://music.163.com/#/playlist?id=4958788236</a> ，它的ID是 4958788236，只需把原来的ID替换成你想要的歌单的ID就行了，其实这个项目的所有的音乐部分的ID都是网易云歌单号的ID，你可以用自己的网易云账户创建一个歌单，供blog使用。</p><h2 id="blog部署"><a href="#blog部署" class="headerlink" title="blog部署"></a>blog部署</h2><ol><li>生成部署文件<br> $ hexo clean<br> $ hexo g<br> $ hexo d    //上传到远程在码云上的仓库  </li><li>登录码云账户，打开和自己用户名相同的仓库, 点击服务，打开giteePages，点击开启。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200821225438232.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="深入开发"><a href="#深入开发" class="headerlink" title="深入开发"></a>深入开发</h4><ul><li><a href="https://blog.csdn.net/u011759205/article/details/104839472">xx博客</a></li><li><a href="https://hexo.io/zh-cn/docs/index.html">hexo文档</a>  </li><li><a href="https://guole.fun/posts/butterfly-custom/">xxblog</a></li></ul><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ul><li>无法push到gitee/GitHub，可能是邮箱没有设置好，或者是_config.yml中的repo配置错了</li><li>hexo -g生成的public中的index是空的，可能是nodejs的版本太高，建议安装nvm来切换nodejs的版本  </li></ul><h2 id="博客使用"><a href="#博客使用" class="headerlink" title="博客使用"></a>博客使用</h2><p>编写文章的两种方法：  </p><ul><li>在git下执行<br>$ hexo new 博客文章名<br>同时会在 根目录下 /source/_posts 目录下生成md文件  </li><li>手动到根目录下 /source/_posts 目录下，创建一个makedown 文件进行编写就可以了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
