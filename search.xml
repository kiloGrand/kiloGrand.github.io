<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自制深度学习框架--导入数据</title>
      <link href="/2023/03/14/kuiper_infer-L3/"/>
      <url>/2023/03/14/kuiper_infer-L3/</url>
      
        <content type="html"><![CDATA[<h2 id="从CSV文件中初始化Tensor张量类"><a href="#从CSV文件中初始化Tensor张量类" class="headerlink" title="从CSV文件中初始化Tensor张量类"></a>从CSV文件中初始化Tensor张量类</h2><blockquote><p>CSV（逗号分隔值）文件是一种特殊的文件类型，可在 Excel 中创建或编辑。<br>CSV文件采用逗号分隔的形式来存储文本和数字信息，总体来说，这种形式的文件格式具有扩展性好，移植性强的特点。</p></blockquote><p>作用：</p><ul><li>对比推理结果<ul><li>把pytorch的结果输出到csv文件中，KuiperInfer读取，然后再对比</li></ul></li><li>导入模型权值<ul><li>把pytorch的模型权值输出到csv文件中，KuiperInfer读取，进行推理</li></ul></li></ul><p>接口定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSVDataLoader</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> std::shared_ptr&lt;Tensor&lt;<span class="type">float</span> &gt;&gt; <span class="built_in">LoadData</span>(<span class="type">const</span> std::string &amp;file_path, <span class="type">char</span> split_char = <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> std::shared_ptr&lt;Tensor&lt;<span class="type">float</span> &gt;&gt; <span class="built_in">LoadDataWithHeader</span>(<span class="type">const</span> std::string &amp;file_path,</span><br><span class="line">                                       std::vector&lt;std::string&gt; &amp;headers, <span class="type">char</span> split_char = <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; <span class="title">GetMatrixSize</span><span class="params">(std::ifstream &amp;file, <span class="type">char</span> split_char)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><a href="https://www.apiref.com/cpp-zh/cpp/memory/shared_ptr.html">std::shared_ptr的API Doc</a><ul><li>通过<code>std::shared_ptr::operator-&gt;</code>来访问成员变量和成员函数，如<code>input_tensor-&gt;at(0)</code></li></ul></li><li><a href="https://www.apiref.com/cpp-zh/cpp/memory/shared_ptr.html">std::make_shared的API Doc</a><ul><li>make_shared函数的主要功能是在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，如<code>std::make_shared&lt;Tensor&lt;float&gt;&gt;(1, rows, cols)</code></li></ul></li><li><a href="https://www.apiref.com/cpp-zh/cpp/io/basic_iostream.html">std::basic_iostream的API Doc</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取矩阵维度的大小</span></span><br><span class="line"><span class="comment">// 读取文件的每一行，记录行数；</span></span><br><span class="line"><span class="comment">// 按照分隔符对每一行的字符串读取，记录最大的列数</span></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; <span class="title">CSVDataLoader::GetMatrixSize</span><span class="params">(std::ifstream &amp;file, <span class="type">char</span> split_char)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> load_ok = file.<span class="built_in">good</span>();  # 检查是否没有发生错误</span><br><span class="line">  file.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">size_t</span> fn_rows = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> fn_cols = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> std::ifstream::pos_type start_pos = file.<span class="built_in">tellg</span>();  # 返回输入位置指示器</span><br><span class="line"></span><br><span class="line">  std::string token;</span><br><span class="line">  std::string line_str;</span><br><span class="line">  std::stringstream line_stream;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (file.<span class="built_in">good</span>() &amp;&amp; load_ok) &#123;</span><br><span class="line">    std::<span class="built_in">getline</span>(file, line_str);  # 读取一行</span><br><span class="line">    <span class="keyword">if</span> (line_str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    line_stream.<span class="built_in">clear</span>();  # 修改状态标志</span><br><span class="line">    line_stream.<span class="built_in">str</span>(line_str);</span><br><span class="line">    <span class="type">size_t</span> line_cols = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::string row_token;</span><br><span class="line">    <span class="keyword">while</span> (line_stream.<span class="built_in">good</span>()) &#123;</span><br><span class="line">      std::<span class="built_in">getline</span>(line_stream, row_token, split_char);</span><br><span class="line">      ++line_cols;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (line_cols &gt; fn_cols) &#123;</span><br><span class="line">      fn_cols = line_cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++fn_rows;</span><br><span class="line">  &#125;</span><br><span class="line">  file.<span class="built_in">clear</span>();  # 修改状态标志</span><br><span class="line">  file.<span class="built_in">seekg</span>(start_pos);   # 设置输入位置指示器</span><br><span class="line">  <span class="keyword">return</span> &#123;fn_rows, fn_cols&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取不带有header的文件</span></span><br><span class="line">std::shared_ptr&lt;Tensor&lt;<span class="type">float</span> &gt;&gt; CSVDataLoader::<span class="built_in">LoadData</span>(<span class="type">const</span> std::string &amp;file_path, <span class="type">char</span> split_char) &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!file_path.<span class="built_in">empty</span>()) &lt;&lt; <span class="string">&quot;File path is empty!&quot;</span>;</span><br><span class="line">  <span class="function">std::ifstream <span class="title">in</span><span class="params">(file_path)</span></span>;</span><br><span class="line">  <span class="built_in">CHECK</span>(in.<span class="built_in">is_open</span>() &amp;&amp; in.<span class="built_in">good</span>()) &lt;&lt; <span class="string">&quot;File open failed! &quot;</span> &lt;&lt; file_path;</span><br><span class="line"></span><br><span class="line">  std::string line_str;</span><br><span class="line">  std::stringstream line_stream;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> &amp;[rows, cols] = CSVDataLoader::<span class="built_in">GetMatrixSize</span>(in, split_char);  <span class="comment">// 读取矩阵的维度大小</span></span><br><span class="line">  std::shared_ptr&lt;Tensor&lt;<span class="type">float</span>&gt;&gt; input_tensor = std::make_shared&lt;Tensor&lt;<span class="type">float</span>&gt;&gt;(<span class="number">1</span>, rows, cols);</span><br><span class="line">  arma::fmat &amp;data = input_tensor-&gt;<span class="built_in">at</span>(<span class="number">0</span>);  <span class="comment">// 第一个通道的矩阵</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> row = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (in.<span class="built_in">good</span>()) &#123;</span><br><span class="line">    std::<span class="built_in">getline</span>(in, line_str);</span><br><span class="line">    <span class="keyword">if</span> (line_str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string token;</span><br><span class="line">    line_stream.<span class="built_in">clear</span>();</span><br><span class="line">    line_stream.<span class="built_in">str</span>(line_str);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (line_stream.<span class="built_in">good</span>()) &#123;</span><br><span class="line">      std::<span class="built_in">getline</span>(line_stream, token, split_char);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        data.<span class="built_in">at</span>(row, col) = std::<span class="built_in">stof</span>(token);  <span class="comment">// str-&gt;float</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Parse CSV File meet error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      col += <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">CHECK</span>(col &lt;= cols) &lt;&lt; <span class="string">&quot;There are excessive elements on the column&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    row += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CHECK</span>(row &lt;= rows) &lt;&lt; <span class="string">&quot;There are excessive elements on the row&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> input_tensor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取带有header的CSV文件</span></span><br><span class="line">std::shared_ptr&lt;Tensor&lt;<span class="type">float</span>&gt;&gt; CSVDataLoader::<span class="built_in">LoadDataWithHeader</span>(<span class="type">const</span> std::string &amp;file_path,</span><br><span class="line">                                                                  std::vector&lt;std::string&gt; &amp;headers,</span><br><span class="line">                                                                  <span class="type">char</span> split_char) &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!file_path.<span class="built_in">empty</span>()) &lt;&lt; <span class="string">&quot;File path is empty!&quot;</span>;</span><br><span class="line">  <span class="function">std::ifstream <span class="title">in</span><span class="params">(file_path)</span></span>;</span><br><span class="line">  <span class="built_in">CHECK</span>(in.<span class="built_in">is_open</span>() &amp;&amp; in.<span class="built_in">good</span>()) &lt;&lt; <span class="string">&quot;File open failed! &quot;</span> &lt;&lt; file_path;</span><br><span class="line"></span><br><span class="line">  std::string line_str;</span><br><span class="line">  std::stringstream line_stream;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> &amp;[rows, cols] = CSVDataLoader::<span class="built_in">GetMatrixSize</span>(in, split_char);</span><br><span class="line">  <span class="built_in">CHECK</span>(rows &gt;= <span class="number">1</span>);</span><br><span class="line">  std::shared_ptr&lt;Tensor&lt;<span class="type">float</span>&gt;&gt; input_tensor = std::make_shared&lt;Tensor&lt;<span class="type">float</span>&gt;&gt;(<span class="number">1</span>, rows - <span class="number">1</span>, cols);</span><br><span class="line">  arma::fmat &amp;data = input_tensor-&gt;<span class="built_in">at</span>(<span class="number">0</span>);  <span class="comment">// 第一个通道的矩阵</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> row = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (in.<span class="built_in">good</span>()) &#123;</span><br><span class="line">    std::<span class="built_in">getline</span>(in, line_str);</span><br><span class="line">    <span class="keyword">if</span> (line_str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string token;</span><br><span class="line">    line_stream.<span class="built_in">clear</span>();</span><br><span class="line">    line_stream.<span class="built_in">str</span>(line_str);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (line_stream.<span class="built_in">good</span>()) &#123;</span><br><span class="line">      std::<span class="built_in">getline</span>(line_stream, token, split_char);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 能够读取到第一行的csv列名，并存放在headers中</span></span><br><span class="line">        <span class="comment">// 能够读取到第二行之后的csv数据，并相应放置在data变量的row，col位置中</span></span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>)</span><br><span class="line">        headers.<span class="built_in">push_back</span>(token);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        data.<span class="built_in">at</span>(row<span class="number">-1</span>, col) = std::<span class="built_in">stof</span>(token);  <span class="comment">// str-&gt;float</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Parse CSV File meet error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      col += <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">CHECK</span>(col &lt;= cols) &lt;&lt; <span class="string">&quot;There are excessive elements on the column&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    row += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CHECK</span>(row &lt;= rows) &lt;&lt; <span class="string">&quot;There are excessive elements on the row&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> input_tensor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(test_data_load, load_csv1) &#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> kuiper_infer;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> std::string &amp;file_path = <span class="string">&quot;../tmp/data1.csv&quot;</span>;</span><br><span class="line">  std::shared_ptr&lt;Tensor&lt;<span class="type">float</span>&gt;&gt; data = CSVDataLoader::<span class="built_in">LoadData</span>(file_path, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="type">uint32_t</span> index = <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint32_t</span> rows = data-&gt;<span class="built_in">rows</span>();</span><br><span class="line">  <span class="type">uint32_t</span> cols = data-&gt;<span class="built_in">cols</span>();</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(rows, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(cols, <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> r = <span class="number">0</span>; r &lt; rows; ++r) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> c = <span class="number">0</span>; c &lt; cols; ++c) &#123;</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(data-&gt;<span class="built_in">at</span>(<span class="number">0</span>, r, c), index);</span><br><span class="line">      index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_data_load, load_csv_with_head1) &#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> kuiper_infer;</span><br><span class="line">  <span class="type">const</span> std::string &amp;file_path = <span class="string">&quot;../tmp/data2.csv&quot;</span>;</span><br><span class="line">  std::vector&lt;std::string&gt; headers;</span><br><span class="line">  std::shared_ptr&lt;Tensor&lt;<span class="type">float</span>&gt;&gt; data = CSVDataLoader::<span class="built_in">LoadDataWithHeader</span>(file_path, headers, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> index = <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint32_t</span> rows = data-&gt;<span class="built_in">rows</span>();</span><br><span class="line">  <span class="type">uint32_t</span> cols = data-&gt;<span class="built_in">cols</span>();</span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; data;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(rows, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(cols, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(headers.<span class="built_in">size</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(headers.<span class="built_in">at</span>(<span class="number">0</span>), <span class="string">&quot;ROW1&quot;</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(headers.<span class="built_in">at</span>(<span class="number">1</span>), <span class="string">&quot;ROW2&quot;</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(headers.<span class="built_in">at</span>(<span class="number">2</span>), <span class="string">&quot;ROW3&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> r = <span class="number">0</span>; r &lt; rows; ++r) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> c = <span class="number">0</span>; c &lt; cols; ++c) &#123;</span><br><span class="line">      <span class="built_in">ASSERT_EQ</span>(data-&gt;<span class="built_in">at</span>(<span class="number">0</span>, r, c), index);</span><br><span class="line">      index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kuiper_infer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自制深度学习框架--张量</title>
      <link href="/2023/03/13/kuiper_infer-L2/"/>
      <url>/2023/03/13/kuiper_infer-L2/</url>
      
        <content type="html"><![CDATA[<p>本文以arma::cube为基础实现了Tensor类，提供了更方便的访问方式和对外接口。</p><h2 id="Tensor类模板"><a href="#Tensor类模板" class="headerlink" title="Tensor类模板"></a>Tensor类模板</h2><p>C++类模板例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="comment">// 或者template&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(T1 a, T2 b) : _a(a), _b(b);</span><br><span class="line">    Complex&lt;T1, T2&gt; <span class="keyword">operator</span>+(Complex&lt;T1, T2&gt; &amp;c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 _a;</span><br><span class="line">    T2 _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板-全特化（具体化）</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> a, <span class="type">int</span> b) : _a(a), _b(b);</span><br><span class="line">    Complex&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="keyword">operator</span>+(Complex&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Complex&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>模板分为类模板与函数模板，特化分为全特化与偏特化（partial specialization）。 </p><p>对于模板、模板的全特化和模板的偏特化, 以及同名普通函数都存在的情况下，编译器在编译阶段进行匹配时，只匹配普通函数和模板, 匹配顺序如下:</p><ol><li>查找普通函数中有没有匹配的,如果有就选它</li><li>查找模板中有没有匹配的, 并选则最匹配的版本, 然后进行下面两步</li></ol><p>注意, 上面规则没提到特化版本, 如果编译器匹配到了规则2, 然后才进行特化版本的匹配</p><ol><li>查找全特化版本中有没有匹配的</li><li>查找偏特化版本中有没有匹配的</li></ol><p>Tensor共有两个类型，一个类型是Tensor<float>，另一个类型是Tensor<uint8_t>, Tensor<uint8_t> 可能会在后续的量化课程中进行使用，目前还暂时未实现.<br>我们把Tensor<float>和Tensor<uint8_t>全特化，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tensor</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tensor</span>&lt;<span class="type">uint8_t</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 待实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tensor</span>&lt;<span class="type">float</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 待实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">const小结</a><br><a href="https://www.jianshu.com/p/66eb9078757b">常量引用</a></p><ul><li>const修饰实参：表示不能改变实参的值</li><li>const成员函数：表示不能改变所有成员变量的值</li><li>常量引用：不能通过引用修改其所绑定的对象，但能以其它方式修改这个对象。</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 默认</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Tensor</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">// 参数构造</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Tensor</span><span class="params">(<span class="type">uint32_t</span> channels, <span class="type">uint32_t</span> rows, <span class="type">uint32_t</span> cols)</span></span>;</span><br><span class="line">  <span class="comment">// 拷贝构造</span></span><br><span class="line">  <span class="built_in">Tensor</span>(<span class="type">const</span> Tensor &amp;tensor);</span><br><span class="line">  <span class="comment">// 赋值构造</span></span><br><span class="line">  Tensor&lt;<span class="type">float</span>&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Tensor &amp;tensor);</span><br><span class="line"></span><br><span class="line">Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">Tensor</span>(<span class="type">uint32_t</span> channels, <span class="type">uint32_t</span> rows, <span class="type">uint32_t</span> cols) &#123;</span><br><span class="line">  data_ = arma::<span class="built_in">fcube</span>(rows, cols, channels);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">Tensor</span>(<span class="type">const</span> Tensor &amp;tensor) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;data_ = tensor.data_;</span><br><span class="line">  <span class="keyword">this</span>-&gt;raw_shapes_ = tensor.raw_shapes_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tensor&lt;<span class="type">float</span>&gt; &amp;Tensor&lt;<span class="type">float</span>&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> Tensor &amp;tensor) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;tensor) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data_ = tensor.data_;</span><br><span class="line">    <span class="keyword">this</span>-&gt;raw_shapes_ = tensor.raw_shapes_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="张量的维度大小"><a href="#张量的维度大小" class="headerlink" title="张量的维度大小"></a>张量的维度大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 返回行数</span></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">rows</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="comment">// 返回列数</span></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">cols</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="comment">// 返回通道数</span></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">channels</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="comment">// 返回张量中元素的个数</span></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="comment">// 返回每个维度大小</span></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">shapes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">rows</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.n_rows;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">cols</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.n_cols;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">channels</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.n_slices;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">size</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">uint32_t</span>&gt; Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">shapes</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>-&gt;<span class="built_in">channels</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">rows</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">cols</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取数据和索引"><a href="#取数据和索引" class="headerlink" title="取数据和索引"></a>取数据和索引</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 返回data</span></span><br><span class="line">  <span class="function">arma::fcube &amp;<span class="title">data</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> arma::fcube &amp;<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回某一通道的数据</span></span><br><span class="line">  <span class="function">arma::fmat &amp;<span class="title">at</span><span class="params">(<span class="type">uint32_t</span> channel)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> arma::fmat &amp;<span class="title">at</span><span class="params">(<span class="type">uint32_t</span> channel)</span> <span class="type">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 索引，返回data[channel, row, col]</span></span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">at</span><span class="params">(<span class="type">uint32_t</span> channel, <span class="type">uint32_t</span> row, <span class="type">uint32_t</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">float</span> &amp;<span class="title">at</span><span class="params">(<span class="type">uint32_t</span> channel, <span class="type">uint32_t</span> row, <span class="type">uint32_t</span> col)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 第channel * Rows * Cols + row * Cols + col 个数据，相当于展平为1维后的索引</span></span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">index</span><span class="params">(<span class="type">uint32_t</span> offset)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">arma::fcube &amp;Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">data</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> arma::fcube &amp;Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">data</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arma::fmat &amp;Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">at</span>(<span class="type">uint32_t</span> channel) &#123;</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(channel, <span class="keyword">this</span>-&gt;<span class="built_in">channels</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.<span class="built_in">slice</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> arma::fmat &amp;Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">at</span>(<span class="type">uint32_t</span> channel) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(channel, <span class="keyword">this</span>-&gt;<span class="built_in">channels</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.<span class="built_in">slice</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">at</span>(<span class="type">uint32_t</span> channel, <span class="type">uint32_t</span> row, <span class="type">uint32_t</span> col) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(row, <span class="keyword">this</span>-&gt;<span class="built_in">rows</span>());</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(col, <span class="keyword">this</span>-&gt;<span class="built_in">cols</span>());</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(channel, <span class="keyword">this</span>-&gt;<span class="built_in">channels</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.<span class="built_in">at</span>(row, col, channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> &amp;Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">at</span>(<span class="type">uint32_t</span> channel, <span class="type">uint32_t</span> row, <span class="type">uint32_t</span> col) &#123;</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(row, <span class="keyword">this</span>-&gt;<span class="built_in">rows</span>());</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(col, <span class="keyword">this</span>-&gt;<span class="built_in">cols</span>());</span><br><span class="line">  <span class="built_in">CHECK_LT</span>(channel, <span class="keyword">this</span>-&gt;<span class="built_in">channels</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.<span class="built_in">at</span>(row, col, channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">index</span>(<span class="type">uint32_t</span> offset) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(offset &lt; <span class="keyword">this</span>-&gt;data_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.<span class="built_in">at</span>(offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化张量"><a href="#初始化张量" class="headerlink" title="初始化张量"></a>初始化张量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 赋值</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_data</span><span class="params">(<span class="type">const</span> arma::fcube &amp;data)</span></span>;</span><br><span class="line">  <span class="comment">// 全为1</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Ones</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 随机</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Rand</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">set_data</span>(<span class="type">const</span> arma::fcube &amp;data) &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(data.n_rows == <span class="keyword">this</span>-&gt;data_.n_rows) &lt;&lt; data.n_rows &lt;&lt; <span class="string">&quot; != &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;data_.n_rows;</span><br><span class="line">  <span class="built_in">CHECK</span>(data.n_cols == <span class="keyword">this</span>-&gt;data_.n_cols) &lt;&lt; data.n_cols &lt;&lt; <span class="string">&quot; != &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;data_.n_cols;</span><br><span class="line">  <span class="built_in">CHECK</span>(data.n_slices == <span class="keyword">this</span>-&gt;data_.n_slices) &lt;&lt; data.n_slices &lt;&lt; <span class="string">&quot; != &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;data_.n_slices;</span><br><span class="line">  <span class="keyword">this</span>-&gt;data_ = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">Rand</span>() &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">this</span>-&gt;data_.<span class="built_in">randn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">Ones</span>() &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">this</span>-&gt;data_.<span class="built_in">fill</span>(<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="张量填充"><a href="#张量填充" class="headerlink" title="张量填充"></a>张量填充</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 边界填充</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Padding</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;pads, <span class="type">float</span> padding_value)</span></span>;</span><br><span class="line">  <span class="comment">// 用标量值填充</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fill</span><span class="params">(<span class="type">float</span> value)</span></span>;</span><br><span class="line">  <span class="comment">// 用vector填充</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fill</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt; &amp;values)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">Padding</span>(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;pads, <span class="type">float</span> padding_value) &#123;</span><br><span class="line">  <span class="comment">// Usage: tensor.Padding(&#123;1, 1, 1, 1&#125;, 0); // 边缘填充为0</span></span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(pads.<span class="built_in">size</span>(), <span class="number">4</span>);</span><br><span class="line">  <span class="type">uint32_t</span> pad_rows1 = pads.<span class="built_in">at</span>(<span class="number">0</span>);  <span class="comment">// up</span></span><br><span class="line">  <span class="type">uint32_t</span> pad_rows2 = pads.<span class="built_in">at</span>(<span class="number">1</span>);  <span class="comment">// bottom</span></span><br><span class="line">  <span class="type">uint32_t</span> pad_cols1 = pads.<span class="built_in">at</span>(<span class="number">2</span>);  <span class="comment">// left</span></span><br><span class="line">  <span class="type">uint32_t</span> pad_cols2 = pads.<span class="built_in">at</span>(<span class="number">3</span>);  <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// at column 0, insert a copy of pad_rows1;</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;data_.<span class="built_in">insert_rows</span>(<span class="number">0</span>, pad_rows1);</span><br><span class="line">  <span class="keyword">this</span>-&gt;data_.<span class="built_in">insert_rows</span>(<span class="keyword">this</span>-&gt;data_.n_rows, pad_rows2);</span><br><span class="line">  <span class="keyword">this</span>-&gt;data_.<span class="built_in">insert_cols</span>(<span class="number">0</span>, pad_cols1);</span><br><span class="line">  <span class="keyword">this</span>-&gt;data_.<span class="built_in">insert_cols</span>(<span class="keyword">this</span>-&gt;data_.n_cols, pad_cols2);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">Fill</span>(<span class="type">float</span> value) &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">this</span>-&gt;data_.<span class="built_in">fill</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">Fill</span>(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt; &amp;values) &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> total_elems = <span class="keyword">this</span>-&gt;data_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(values.<span class="built_in">size</span>(), total_elems);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> rows = <span class="keyword">this</span>-&gt;<span class="built_in">rows</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> cols = <span class="keyword">this</span>-&gt;<span class="built_in">cols</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> planes = rows * cols;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> channels = <span class="keyword">this</span>-&gt;data_.n_slices;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; channels; i++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;channel_data = <span class="keyword">this</span>-&gt;data_.<span class="built_in">slice</span>(i);</span><br><span class="line">    <span class="comment">// values.data() 返回指向作为元素存储工作的底层数组的指针</span></span><br><span class="line">    <span class="type">const</span> arma::fmat &amp;<span class="type">channel_data_t</span> = arma::<span class="built_in">fmat</span>(values.<span class="built_in">data</span>() + i * planes, <span class="keyword">this</span>-&gt;<span class="built_in">cols</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">rows</span>());</span><br><span class="line">    channel_data = <span class="type">channel_data_t</span>.<span class="built_in">t</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 判断张量是否为空，未初始化</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="comment">// 输出张量</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 展平张量</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Flatten</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">empty</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">Show</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;<span class="built_in">channels</span>(); ++i) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Channel: &quot;</span> &lt;&lt; i;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;data_.<span class="built_in">slice</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Tensor&lt;<span class="type">float</span>&gt;::<span class="built_in">Flatten</span>() &#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="keyword">this</span>-&gt;data_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> size = <span class="keyword">this</span>-&gt;data_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function">arma::fcube <span class="title">linear_cube</span><span class="params">(size, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> channel = <span class="keyword">this</span>-&gt;<span class="built_in">channels</span>();</span><br><span class="line">  <span class="type">uint32_t</span> rows = <span class="keyword">this</span>-&gt;<span class="built_in">rows</span>();</span><br><span class="line">  <span class="type">uint32_t</span> cols = <span class="keyword">this</span>-&gt;<span class="built_in">cols</span>();</span><br><span class="line">  <span class="type">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> c = <span class="number">0</span>; c &lt; channel; ++c) &#123;</span><br><span class="line">    <span class="type">const</span> arma::fmat &amp;matrix = <span class="keyword">this</span>-&gt;data_.<span class="built_in">slice</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> r = <span class="number">0</span>; r &lt; rows; ++r) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">uint32_t</span> c_ = <span class="number">0</span>; c_ &lt; cols; ++c_) &#123;</span><br><span class="line">        linear_cube.<span class="built_in">at</span>(index, <span class="number">0</span>, <span class="number">0</span>) = matrix.<span class="built_in">at</span>(r, c_);</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(index, size);</span><br><span class="line">  <span class="keyword">this</span>-&gt;data_ = linear_cube;</span><br><span class="line">  <span class="keyword">this</span>-&gt;raw_shapes_ = std::vector&lt;<span class="type">uint32_t</span>&gt;&#123;size&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整的接口定义"><a href="#完整的接口定义" class="headerlink" title="完整的接口定义"></a>完整的接口定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tensor</span>&lt;<span class="type">float</span>&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Tensor</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Tensor</span><span class="params">(<span class="type">uint32_t</span> channels, <span class="type">uint32_t</span> rows, <span class="type">uint32_t</span> cols)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Tensor</span>(<span class="type">const</span> Tensor &amp;tensor);</span><br><span class="line"></span><br><span class="line">  Tensor&lt;<span class="type">float</span>&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Tensor &amp;tensor);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">rows</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">cols</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">channels</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_data</span><span class="params">(<span class="type">const</span> arma::fcube &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">index</span><span class="params">(<span class="type">uint32_t</span> offset)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">shapes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">arma::fcube &amp;<span class="title">data</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> arma::fcube &amp;<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">arma::fmat &amp;<span class="title">at</span><span class="params">(<span class="type">uint32_t</span> channel)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> arma::fmat &amp;<span class="title">at</span><span class="params">(<span class="type">uint32_t</span> channel)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">at</span><span class="params">(<span class="type">uint32_t</span> channel, <span class="type">uint32_t</span> row, <span class="type">uint32_t</span> col)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">float</span> &amp;<span class="title">at</span><span class="params">(<span class="type">uint32_t</span> channel, <span class="type">uint32_t</span> row, <span class="type">uint32_t</span> col)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Padding</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;pads, <span class="type">float</span> padding_value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fill</span><span class="params">(<span class="type">float</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Fill</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt; &amp;values)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Ones</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Rand</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Flatten</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;<span class="type">uint32_t</span>&gt; raw_shapes_;</span><br><span class="line">  arma::fcube data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(test_tensor, create) &#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> kuiper_infer;</span><br><span class="line">  <span class="function">Tensor&lt;<span class="type">float</span>&gt; <span class="title">tensor</span><span class="params">(<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">channels</span>(), <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">rows</span>(), <span class="number">32</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">cols</span>(), <span class="number">32</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">empty</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_tensor, fill) &#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> kuiper_infer;</span><br><span class="line">  <span class="function">Tensor&lt;<span class="type">float</span>&gt; <span class="title">tensor</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">channels</span>(), <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">rows</span>(), <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">cols</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">float</span>&gt; values;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; ++i) &#123;</span><br><span class="line">    values.<span class="built_in">push_back</span>((<span class="type">float</span>) i);</span><br><span class="line">  &#125;</span><br><span class="line">  tensor.<span class="built_in">Fill</span>(values);</span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; tensor.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; tensor.<span class="built_in">channels</span>(); ++c) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c_ = <span class="number">0</span>; c_ &lt; tensor.<span class="built_in">cols</span>(); ++c_) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; tensor.<span class="built_in">rows</span>(); ++r) &#123;</span><br><span class="line">        <span class="built_in">ASSERT_EQ</span>(values.<span class="built_in">at</span>(index), tensor.<span class="built_in">at</span>(c, c_, r));</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Test1 passed!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_tensor, padding1) &#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> kuiper_infer;</span><br><span class="line">  <span class="function">Tensor&lt;<span class="type">float</span>&gt; <span class="title">tensor</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">channels</span>(), <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">rows</span>(), <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">cols</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  tensor.<span class="built_in">Fill</span>(<span class="number">1.f</span>); <span class="comment">// 填充为1</span></span><br><span class="line">  tensor.<span class="built_in">Padding</span>(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, <span class="number">0</span>); <span class="comment">// 边缘填充为0</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">rows</span>(), <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">cols</span>(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 检查一下边缘被填充的行、列是否都是0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; tensor.<span class="built_in">channels</span>(); ++c) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c_ = <span class="number">0</span>; c_ &lt; tensor.<span class="built_in">cols</span>(); ++c_) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; tensor.<span class="built_in">rows</span>(); ++r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c_ == <span class="number">0</span> || r == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">ASSERT_EQ</span>(tensor.<span class="built_in">at</span>(c, c_, r), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Test2 passed!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kuiper_infer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习调优指南中文版</title>
      <link href="/2023/02/26/tuning_playbook-zh_cn/"/>
      <url>/2023/02/26/tuning_playbook-zh_cn/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习调优指南中文版"><a href="#深度学习调优指南中文版" class="headerlink" title="深度学习调优指南中文版"></a>深度学习调优指南中文版</h1><p><em>这不是官方认证的 Google 产品。</em></p><p><strong>Varun Godbole † , George E. Dahl † , Justin Gilmer † , Christopher J. Shallue ‡ , Zachary Nado †</strong></p><p>† 谷歌研究，谷歌大脑团队</p><p>‡ 哈佛大学</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#这份手册是为谁准备的">这份手册是为谁准备的？</a></li><li><a href="#为什么需要这份调优手册">为什么需要这份调优手册？</a></li><li><a href="#开始新项目的指南">开始新项目的指南</a><ul><li><a href="#选择模型架构">选择模型架构</a></li><li><a href="#选择优化器">选择优化器</a></li><li><a href="#选择Batchsize">选择BatchSize</a></li><li><a href="#选择初始配置">选择初始配置</a></li></ul></li><li><a href="#提高模型性能的科学方法">提高模型性能的科学方法</a><ul><li><a href="#增量调整策略">增量调整策略</a></li><li><a href="#探索与利用">探索与利用</a></li><li><a href="#选择下一轮实验的目标">选择下一轮实验的目标</a></li><li><a href="#设计下一轮实验">设计下一轮实验</a></li><li><a href="#确定是否采用此训练工作流更改或超参数配置">确定是否采用此训练工作流更改或超参数配置</a></li><li><a href="#探索结束后">探索结束后</a></li></ul></li><li><a href="#确定每次训练运行的步数">确定每次训练运行的步数</a><ul><li><a href="#当训练不受计算限制时如何决定该训练多久">当训练不受计算限制时如何决定该训练多久</a></li><li><a href="#当训练受计算限制时如何决定该训练多久">当训练受计算限制时如何决定该训练多久</a></li></ul></li><li><a href="#关于训练工作流的额外补充">关于训练工作流的额外补充</a><ul><li><a href="#优化输入管道">优化输入管道</a></li><li><a href="#评估模型性能">评估模型性能</a></li><li><a href="#保存检查点并追溯选择最佳检查点">保存检查点并追溯选择最佳检查点</a></li><li><a href="#设置实验跟踪">设置实验跟踪</a></li><li><a href="#batchnorm的实现细节">BatchNorm的实现细节</a></li><li><a href="#多主机工作流的注意事项">多主机工作流的注意事项</a></li></ul></li><li><a href="#常见问题的回答">常见问题的回答</a></li><li><a href="#致谢">致谢</a></li><li><a href="#引用">引用</a></li><li><a href="#关于贡献">关于贡献</a></li></ul><h2 id="这份手册是为谁准备的？"><a href="#这份手册是为谁准备的？" class="headerlink" title="这份手册是为谁准备的？"></a>这份手册是为谁准备的？</h2><p><strong>本文档适用于对最大化深度学习的性能</strong>感兴趣的工程师和研究人员（包括个人和团队）。我们假定您具备机器学习和深度学习概念的基本知识。</p><p>我们的重点是<strong>超参数调优的过程</strong>，但我们还涉及深度学习学习的其他方面。例如工作流实施和优化，但这些方面并不详尽</p><p>我们假设机器学习问题是监督学习或类似的东西（例如自监督学习）。但是，本文档中描述的技术也可能适用于其他类型的问题。</p><h2 id="为什么需要这份调优手册？"><a href="#为什么需要这份调优手册？" class="headerlink" title="为什么需要这份调优手册？"></a>为什么需要这份调优手册？</h2><p>目前，要使深度神经网络在实践中正常运行，需要付出大量的努力和猜测。更糟糕的是，目前很少有人记录下那些深度学习中获得良好结果的实际方法。一方面，通常，论文忽略了导致最终结果的过程，以呈现更清晰的原理。另一方面，处理商业问题的机器学习工程师很少有时间回顾并概括他们的调参过程。教科书也往往回避实用指南，而偏重于基本原理，即使它们的作者具有在应用工作中提供有用建议的经验。在准备创建此文档时，我们找不到任何系统性的资料来解释<em>如何使用深度学习获得良好的结果</em>. 相反，我们看到了博客文章和社交媒体上的建议片段、从研究论文附录中收集的技巧、特定项目或工作流的偶然案例研究，以及很多困惑。在深度学习领域，专家和新手用着表面上类似的方法，但所取得的结果之间存在着巨大的差距。与此同时，这些专家也很乐意承认他们所做的一些事情可能没有充分的理由。随着深度学习的成熟并对世界产生更大的影响，社区需要更多涵盖有用方法的资源，包括对于获得良好结果至关重要的所有实用细节。</p><p>我们是一个由五名研究人员和工程师组成的团队，多年来一直致力于深度学习。我们已经将深度学习应用到从语音识别到天文学的方方面面，并在此过程中学到了很多东西。本文档源于我们自己训练神经网络、教授学生以及为我们的同事提供实践建议的经验。虽然深度学习已经从少数学术研究实验室中实践的机器学习方法发展成为为数十亿人使用的产品提供动力的技术，但深度学习在工程领域仍处于起步阶段，我们希望本文档能鼓励其他人也来帮助系统化该领域的实验细节。</p><p>这份文件是在我们试图实现我们自己的深度学习方法时产生的，因此它只代表作者在撰写本文时的观点，而不是任何客观事实。它被特别强调是因为我们在调整超参数方面遇到了困难，但它也涵盖了我们在工作中遇到（或看到出错）的其他重要问题。我们希望这项工作成为一份活的文件，能随着我们理解的改变从而成长和演变。例如，一份关于如何调试和如何减少训练失败的文档在两年前是不可能写出来的，因为它这得基于最近的结果和正在进行的研究。不可避免地，我们的在此文档中一些建议也将需要更新以考虑新的结果和改进的工作流程。我们不知道最好的深度学习秘诀，但在大众开始记录它并讨论各个步骤之前，我们不能指望找到它。为此，我们鼓励发现我们的建议存在问题的读者提出替代建议以及令人信服的证据，以便我们更新建议。我们也希望看到可能有不同建议的替代指南和方式，以帮助大众追求最佳方法。最后，任何标有🤖表情符号的地方是我们要进一步调查的地方。只有在尝试编写这本 playbook 之后，我们才完全清楚在深度学习从业者的工作流程中可以找到多少有趣及被忽视的研究问题。</p><h2 id="开始新项目的指南"><a href="#开始新项目的指南" class="headerlink" title="开始新项目的指南"></a>开始新项目的指南</h2><p>在调优过程中的许多抉择，我们可以在项目开始时一次性做出决定。只有偶尔在情况发生变化时，才需要重新考虑。</p><p>在开始调优之前，请确保您满足以下假设：</p><ul><li>问题制定、数据清理等基本工作已经完成，花时间在模型架构和训练配置上是有意义的。</li><li>已经有一个工作流设置用来进行训练和评估，并且可以很容易地为各种感兴趣的模型执行训练和预测工作。</li><li>已选择并实现适当的评估指标。这些指标应该尽可能地代表在部署环境中测量的内容。</li></ul><h3 id="选择模型架构"><a href="#选择模型架构" class="headerlink" title="选择模型架构"></a>选择模型架构</h3><p><strong><em>总结</em></strong>： <em>在开始一个新项目时，尽量重用有效的模型。</em></p><ul><li>首先选择一个完善且常用的模型架构来开始工作。这样可以尽早让模型进入工作状态，之后再构建自定义模型也是可行的。</li><li>模型架构通常具有各种超参数，用于确定模型的大小和其他细节（例如层数、层宽度、激活函数类型）。<ul><li>因此，选择架构实际上意味着选择一整个系列的各种模型（每个模型都有不同的超参数设置）。</li></ul></li><li>如果可以的话，请尝试找到一篇尽可能接近手头问题的相关论文，并将复现该论文中的模型作为起点。</li></ul><h3 id="选择优化器"><a href="#选择优化器" class="headerlink" title="选择优化器"></a>选择优化器</h3><p><strong><em>总结</em></strong>： <em>从针对手头问题类型的最常用的优化器开始。</em></p><ul><li><p>没有一个优化器是适用于所有类型的机器学习问题和模型架构的‘最佳’优化器。即使只是 <a href="https://arxiv.org/abs/1910.05446">比较优化器的性能</a>也是一项艰巨的任务。 🤖</p></li><li><p>我们建议坚持使用成熟、流行的优化器，尤其是在开始新项目时。</p><ul><li>理想情况下，选择用于同类问题的最常用优化器。</li></ul></li><li><p>做好关注选择的优化器的 <b>*所有*</b> 超参数的准备。</p><ul><li><p>具有更多超参数的优化器可能需要更多的调优工作才能找到最佳配置。</p></li><li><p>当我们试图找到各种其他超参数（例如架构超参数）的最佳值时，将优化器超参数视为<a href="#identifying-scientific-nuisance-and-fixed-hyperparameters">冗余参数</a>是有意义的，这在项目的初始阶段尤其重要。</p></li><li>在项目的初始阶段，从更简单的优化器开始会更可取（例如，具有固定动量的 SGD 或具有固定 $\epsilon$、$\beta<em>{1}$ 和 $\beta</em>{2}$ 的 Adam ) ，之后可以切换到更通用的优化器。</li></ul></li><li><p>常用且较为完善的优化器包括（但不限于）：</p><ul><li><a href="#what-are-the-update-rules-for-all-the-popular-optimization-algorithms">SGD with momentum</a>（Nesterov 变体）</li><li><a href="#what-are-the-update-rules-for-all-the-popular-optimization-algorithms">Adam and NAdam</a>，它们比具有动量的 SGD 更通用。请注意，Adam 有 4 个可调超参数，<a href="https://arxiv.org/abs/1910.05446">他们都很重要</a>！<ul><li>参见 <a href="#Adam 的超参数应该如何调整？">Adam 的超参数应该如何调整？</a></li></ul></li></ul></li></ul><h3 id="选择BatchSize"><a href="#选择BatchSize" class="headerlink" title="选择BatchSize"></a>选择BatchSize</h3><p><strong><em>总结</em></strong>： <em>Batch Size决定训练速度，并且不应该被直接用于调整验证集性能。通常来说，可用硬件支持的最大Batch Size是较为理想的数值。</em></p><ul><li>Batch Size是决定<em>训练时间</em>和<em>计算资源消耗</em>的关键因素。</li><li>增加Batch Size通常会减少训练时间。这非常有益，因为它：<ul><li>能使固定时间间隔内超参数调整更彻底，最终训练出更好的模型。</li><li>减少开发周期的延迟，能更多地测试新想法。</li></ul></li><li>资源消耗和Batch Size之间并没有明确的关系，增加Batch Size让资源消耗增加、减少或是保持不变都有可能。</li><li>Batch Size<em>不应该</em>被当作验证集性能的可调超参数。<ul><li>只要调整好所有超参数（尤其是学习率和正则化超参数）并且训练步数足够，理论上任意的Batch Size都能获得相同的最终性能（参见 <a href="https://arxiv.org/abs/1811.03600">Shallue et al. 2018</a>） .</li><li>详见 <a href="#为什么不应该调整Batch Size来直接提高验证集性能？">为什么不应该调整Batch Size来直接提高验证集性能？</a></li></ul></li></ul><h4 id="确定可行的Batch-Size并估计训练吞吐量"><a href="#确定可行的Batch-Size并估计训练吞吐量" class="headerlink" title="确定可行的Batch Size并估计训练吞吐量"></a>确定可行的Batch Size并估计训练吞吐量</h4><details><summary><em>[点击展开]</em></summary><br>-   对于给定的模型和优化器，可用硬件通常能能够支持一系列Batch Size。限制因素通常是加速器（GPU/TPU 等）的内存。-   不幸的是，如果不运行或者编译完整的训练程序，就很难计算出适合内存的Batch Size。-   最简单的解决方案通常是以不同的批次大小（例如，用 2 的幂来尝试）运行少量的训练实验，直到其中一个实验超过可用内存。-   对于每个Batch Size，我们应该训练足够长的时间以准确估计*训练吞吐量*<p align="center">训练吞吐量 =每秒处理的样本数量</p><p align="center">或者，我们可以估计<em>每步时间</em> :</p><p align="center">每步时间 =（Batch Size）/（训练吞吐量）</p>-   当加速器内存未饱和时，如果Batch Size加倍，训练吞吐量也应该加倍（或至少接近加倍）。等效地，随着Batch Size的增加，每步的时间应该是恒定的（或至少接近恒定的）。-   如果与上述情况不符，那么训练工作流可能存在瓶颈，例如 I/O 或计算节点间的同步。有必要在开始下一步前对此进行诊断和矫正。-   如果训练吞吐量到某个Batch Size之后就不再增加，那么我们只考虑使用该Batch Size（即使硬件支持更大的Batch Size）    -   使用更大Batch Size的所有好处都假定训练吞吐量增加。如果没有，请修复瓶颈或使用较小的Batch Size。    -   使用**梯度积累**技术可以支持的更大的Batch Size。但其不提供任何训练吞吐量优势，故在应用工作中通常应避免使用它。-   每次更改模型或优化器时，可能都需要重复这些步骤（例如，不同的模型架构可能允许更大的Batch Size）。</details><h4 id="选择合适的Batch-Size以最小化训练时间"><a href="#选择合适的Batch-Size以最小化训练时间" class="headerlink" title="选择合适的Batch Size以最小化训练时间"></a>选择合适的Batch Size以最小化训练时间</h4><details><summary><em>[点击展开]</em></summary><br><p align="center">训练时间 =（每步时间）x（总步数）</p>-   对于所有可行的Batch Size，我们通常可以认为每步的时间近似恒定(实际上，增加Batch Size通常会产生一些开销)。-   Batch Size越大，达到某一性能目标所需的步数通常会减少（前提是在更改Batch Size时重新调整所有相关超参数；[Shallue et al. 2018](https://arxiv.org/abs/1811.03600)）。    -   例如，将Batch Size翻倍可能会使训练步数减半。这称为**完美缩放**。    -   完美缩放适用于Batch Size在临界值之前，超过该临界总步数的减少效果将会下降。    -   最终，增加Batch Size不会再使训练步数减少（永远不会增加）。-   因此，最小化训练时间的Batch Size通常是最大的Batch Size，也同时减少了所需的训练步数。    -   Batch Size取决于数据集、模型和优化器，除了通过实验为每个新问题找到它之外，如何计算它是一个悬而未决的问题。🤖    -   比较Batch Size时，请注意效果(epoch)预算（运行所有实验，固定训练样本的数量达到设定的效果所花的时间）和步数预算（运行设定步数的试验）之间的区别。        -   将Batch Size与效果预算进行比较只会涉及到完美缩放的范围，即使更大的Batch Size仍可能通过减少所需的训练步数来提供有意义的加速。    -   通常，可用硬件支持的最大Batch Size将小于临界Batch Size。因此，一个好的经验法则（不运行任何实验）是使用尽可能大的Batch Size。-   如果最终增加了训练时间，那么使用更大的Batch Size就没有意义了。</details><h4 id="选择合适的Batch-Size以最小化资源消耗"><a href="#选择合适的Batch-Size以最小化资源消耗" class="headerlink" title="选择合适的Batch Size以最小化资源消耗"></a>选择合适的Batch Size以最小化资源消耗</h4><details><summary><em>[点击展开]</em></summary><br>- 有两种类型的资源成本与增加 batch size有关。      1. 前期成本，例如购买新硬件或重写训练工作流以实现多GPU/多TPU训练。      1. 使用成本，例如，根据团队的资源预算计费，从云供应商处计费，电力/维护成本。如果增加 batch size有很大的前期成本，那么直到项目成熟且容易权衡成本效益前，推迟其的增加可能更好。实施多机并行训练程序可能会引入[错误](https://link.zhihu.com/?target=https%3A//github.com/google-research/tuning_playbook%23considerations-for-multi-host-pipelines)和[一些棘手的细节](https://link.zhihu.com/?target=https%3A//github.com/google-research/tuning_playbook%23batch-normalization-implementation-details)，所以无论如何，一开始最好是用一个比较简单的工作流。(另一方面，当需要进行大量的调优实验时，训练时间的大幅加速可能会在过程的早期非常有利）。我们把总的使用成本（可能包括多种不同类型的成本）称为 "资源消耗 "。我们可以将资源消耗分解为以下几个部分。资源消耗 = (每步的资源消耗) x (总步数)- 增加 batch size通常可以减少总步骤数。资源消耗是增加还是减少，将取决于每步的消耗如何变化。- - 增加 batch size可能会减少资源消耗。例如，如果大batch size的每一步都可以在与小batch size相同的硬件上运行（每一步只增加少量时间），那么每一步资源消耗的增加可能被步骤数的减少所抵消。  - 增加 batch size可能不会改变资源消耗。例如，如果将batch size增加一倍，所需的步骤数减少一半，所使用的GPU数量增加一倍，总消耗量（以GPU小时计）将不会改变。  - 增加 batch size可能会增加资源消耗。例如，如果增加batch size需要升级硬件，那么每步消耗的增加可能超过训练所需步数的减少。</details><h4 id="更改Batch-Size需要重新调整大多数超参数"><a href="#更改Batch-Size需要重新调整大多数超参数" class="headerlink" title="更改Batch Size需要重新调整大多数超参数"></a>更改Batch Size需要重新调整大多数超参数</h4><details><summary><em>[点击展开]</em></summary><br>-   大多数超参数的最佳值对Batch Size敏感。因此，更改Batch Size通常需要重新开始调整过程。-   与Batch Size交互最强烈的超参数是优化器超参数（学习率、动量等）和正则化超参数，所以有必要对于针对每个Batch Size单独调整它们。-   在项目开始时选择Batch Size时请记住，如果您以后需要切换到不同的Batch Size，则为新的Batch Size重新调整所有内容可能会很困难、耗时且成本高昂。</details><h4 id="Batch-Norm会对Batch-Size的选择造成什么影响？"><a href="#Batch-Norm会对Batch-Size的选择造成什么影响？" class="headerlink" title="Batch Norm会对Batch Size的选择造成什么影响？"></a>Batch Norm会对Batch Size的选择造成什么影响？</h4><details><summary><em>[点击展开]</em></summary><br>Batch norm 很复杂，一般来说，应该使用与计算梯度不同的 batch size 来计算统计数据(像[Ghost Batch Norm](https://arxiv.org/abs/1705.08741)采用固定值的batch size)。有关详细讨论，请参阅[BatchNorm的实现细节](#BatchNorm的实现细节)</details><h4 id="选择初始配置"><a href="#选择初始配置" class="headerlink" title="选择初始配置"></a>选择初始配置</h4><ul><li>在开始超参数调整之前，我们必须确定起点。这包括指定 (1) 模型配置（例如层数），(2) 优化器超参数（例如学习率），以及 (3) 训练步数。</li><li>确定此初始配置将需要一些手动配置的训练运行和反复试验。</li><li>我们的指导原则是找到一个简单、相对快速、资源消耗相对较低的配置，以获得“合理”的结果。<ul><li>“简单”意味着尽可能避免花里胡哨的东西；这些总是可以在以后添加。即使花里胡哨的东西在未来被证明是有用的，但在初始配置中添加它们可能会浪费时间调整无用的功能和/或烘烤不必要的并发症。<ul><li>例如，在添加花哨的衰减方案之前以恒定的学习率开始。</li></ul></li><li>选择快速且消耗最少资源的初始配置将使超参数调整更加高效。<ul><li>例如，从较小的模型开始。</li></ul></li><li>“合理”性能取决于问题，但至少意味着经过训练的模型在验证集上的性能比随机机会好得多（尽管它可能很糟糕，不值得部署）。</li></ul></li><li>选择训练步数的数量涉及平衡以下方面：<ul><li>一方面，训练更多的步数可以提高性能并使超参数调整更容易（参见 <a href="https://arxiv.org/abs/1811.03600">Shallue et al. 2018</a>）。</li><li>另一方面，更少步数的训练意味着每次训练运行得更快并且使用更少的资源，通过减少周期之间的时间并允许并行运行更多实验来提高调整效率。此外，如果一开始选择了一个不必要的大训练步数，那么以后可能很难改变它，例如，已经将学习率针对该步数进行了调整。</li></ul></li></ul><h2 id="提高模型性能的科学方法"><a href="#提高模型性能的科学方法" class="headerlink" title="提高模型性能的科学方法"></a>提高模型性能的科学方法</h2><p>机器学习开发的最终目标是最大化模型的效用。尽管不同应用场景的开发流程有所不同（例如时间长度、可用计算资源、模型类型等），基本步骤和原则都是相似的。</p><p>接下来的指南中我们做出了这些假设：</p><ul><li>已有能运行且得到不错结果的训练工作流。</li><li>有足够的计算资源来进行调参实验，至少能够并行发起数个训练流程。</li></ul><h3 id="增量调整策略"><a href="#增量调整策略" class="headerlink" title="增量调整策略"></a>增量调整策略</h3><p><strong><em>总结</em></strong>： <em>从简单的配置开始，循序渐进，同时进一步了解问题。确保任何改进都有据可循，以避免增加不必要的复杂度。</em></p><ul><li>我们的最终目标是找到一种训练配置来最大化我们模型的性能。<ul><li>在某些情况下，我们的目标是在固定截止日期（例如提交给竞赛）之前最大限度地改进模型。</li><li>在其他情况下，我们希望无限期地改进模型（例如，不断改进生产中使用的模型）。</li></ul></li><li>原则上，我们可以使用算法自动搜索整个配置空间来最大化性能，但实践中这往往不实际。<ul><li>配置空间可能非常大，目前还没有任何算法可以在没有人工指导的情况下有效地搜索这个空间。</li></ul></li><li>大多数自动搜索算法依赖于人工设计的<em>搜索空间</em>，这些搜索空间往往非常重要。</li><li>更有效的方法是从简单的配置开始，逐步添加功能并进行改进，同时深化对问题的理解。<ul><li>我们在每一轮调整中都使用自动搜索算法，并随着我们理解的深度不断更新我们的搜索空间。</li></ul></li><li>随着我们的探索，我们自然会找到越来越好的配置，因此我们的“最佳”模型将不断改进。<ul><li>当我们更新我们的最佳配置时，我们称之为<em>上线</em>（这不一定对应线上模型的实际上线）。</li><li>对于每次上线，我们必须确保更改是有据可循的——而不仅仅是碰运气找到的配置——以避免给训练工作流增加不必要的复杂性。</li></ul></li></ul><p>综上所述，我们的增量调优策略需要重复以下四个步骤：</p><ol><li>为下一轮实验确定适当的目标。</li><li>设计并展开实验，朝着这个目标取得进展。</li><li>从实验结果中获取经验。</li><li>考虑是否上线新的最佳配置。</li></ol><p>本节的其余部分将更详细地讲解增量调优策略。</p><h3 id="探索与利用"><a href="#探索与利用" class="headerlink" title="探索与利用"></a>探索与利用</h3><p><strong><em>总结</em></strong>： <em>大多数时候，我们的目标是更深入地理解问题。</em></p><ul><li>尽管有些人认为我们会花大部分时间来提升验证集的指标，实际上我们把重心放在进一步理解问题上，而不是降低验证集错误率。<ul><li>也就是说，我们大部分时间都花在了“探索”上，只有一小部分时间花在了“利用”上。</li></ul></li><li>从长远来看，如果我们想最大化我们的最终效果，深入理解问题是至关重要的。将深化理解置于短期收益之上可以帮助我们：<ul><li>避免仅因历史原因而表现良好的不必要更改。</li><li>确定验证集效果对哪些超参数最敏感，哪些超参数交互最多，因此需要一起重新调整，以及哪些超参数对其他变化相对不敏感，因此可以在未来的实验中固定住。</li><li>发现潜在的新方向，例如在出现过拟合问题时使用新的正则化器。</li><li>确定无效的方向并将其删除，从而降低后续实验的复杂度。</li><li>判断超参数的优化空间是否已经饱和。</li><li>围绕最佳值缩小我们的搜索空间，以提高调整效率。</li></ul></li><li>最终，我们可以集中提升验证集效果，即便我们无法从新的实验中进一步了解问题的结构了。</li></ul><h3 id="选择下一轮实验的目标"><a href="#选择下一轮实验的目标" class="headerlink" title="选择下一轮实验的目标"></a>选择下一轮实验的目标</h3><p><strong><em>总结</em></strong>： <em>每轮实验都应该有一个明确的目标，并且范围要足够小，这样实验才能真正朝着目标取得进展。</em></p><ul><li>每轮实验都应该有一个明确的目标，并且范围要足够小，这样实验才能真正朝着目标取得进展：如果我们试图一次添加多个特征或回答多个问题，我们可能无法理清各自的影响。</li><li>举个例子，目标可以包括：<ul><li>尝试对训练流程进行改进（例如，新的正则化器、预处理方法等）。</li><li>了解特定模型超参数（例如激活函数）的影响</li><li>最大化验证集指标。</li></ul></li></ul><h3 id="设计下一轮实验"><a href="#设计下一轮实验" class="headerlink" title="设计下一轮实验"></a>设计下一轮实验</h3><p><strong><em>总结</em></strong>： <em>根据实验目标，将超参数分为三类：目标超参数、冗余超参数和固定超参数。创建一系列研究以比较目标超参数的不同值，同时优化冗余超参数。注意选择冗余超参数的搜索空间，以平衡资源成本与科学价值。</em></p><h4 id="识别目标超参数、冗余超参数和固定超参数"><a href="#识别目标超参数、冗余超参数和固定超参数" class="headerlink" title="识别目标超参数、冗余超参数和固定超参数"></a>识别目标超参数、冗余超参数和固定超参数</h4><details><summary><em>[点击展开]</em></summary><br>-   对于给定的目标，所有超参数都将是**目标超参数**、**冗余超参数**或**固定超参数**。    -   目标超参数是指，我们希望测量出其对于模型由何种影响的参数。    -   冗余超参数是指，必须优化才能公平比较不同目标超参数值的参数。类似于统计中的[冗余参数](https://en.wikipedia.org/wiki/Nuisance_parameter)。    -   固定超参数是指，在当前轮次实验中取固定值的参数。在比较目标超参数的不同值时，固定超参数的值不需要（或者我们不希望它们）改变。        -   因为实验固定了某些超参数，从实验得出的结论可能对固定超参数的其他值无效。换句话说，固定的超参数对我们的实验结论做了限定。-   举个例子，如果我们的目标是“确定更深的模型是否会减少验证集错误”，那么模型层数就是目标超参数。    -   学习率是一个冗余超参数，如果我们要公平对比不同深度的模型，我们必须分别调整学习率（通常情况下最优学习率和模型结构有关）。    -   激活函数是一个固定超参数。我们可能通过过去的实验发现最优激活函数和模型深度无关。或者我们接受实验得到的最优深度的仅在某个激活函数上有效。或者我们也可以将激活函数作为一个冗余超参数和深度一起调优。-   一个超参数是目标超参数、冗余超参数还是固定超参数是根据实验目标来决定的。    -   比如，激活函数的选择可以是一个目标超参数（对于当前问题，ReLU 或 tanh 是更好的选择吗？），一个冗余超参数（允许使用不同的激活函数，最好的 5 层模型是否优于最好的 6 层模型？），或一个固定超参数（对于一个由 ReLU 构成的网络，在特定位置添加批标准化是否有帮助？）。-   在设计新一轮实验时，我们根据实验目的确定目标超参数。    -   在此阶段，我们将所有其他超参数视为冗余超参数。-   接下来，我们将一些冗余超参数转作为固定超参数。    -   如果有无限的计算资源，我们会将所有非目标超参数保留为冗余超参数，这样我们从实验中得出的结论就不会受到固定超参数的限定。    -   然而，冗余超参数越多，我们没能充分针对每个目标超参数调优冗余超参数的风险就越高，从而我们从实验中得出错误结论的风险也越高。        -   如[下文](#平衡实验的信息量和成本)所述，我们可以通过增加计算资源来应对这种风险，但通常我们的最大资源预算低于调整所有非目标超参数所需的计算资源。    -   当我们判断将一个冗余超参数转换为固定超参数所带来的限制少于调优它所需的计算资源时，我们可以进行这种转换。        -   一个冗余超参数和目标超参数的相互影响越多，固定这个参数所带来的限制就越多。例如，权重衰减强度的最佳值通常取决于模型大小，因此固定权重衰减的强度来比较不同的模型大小，往往得不出有效的结论。-   尽管超参数的类型取决于实验目标，但对于某些类别的超参数，我们有以下经验法则：    -   在各种优化器超参数（例如学习率、动量、学习率调度参数、Adam优化器的beta等）中，至少有一些是冗余超参数，因为它们往往与其他变化相互影响。        -   它们很少是目标超参数，因为像“训练流程的最佳学习率是多少？”这样的目标没有什么意义——最优学习率很容易随着下一次训练流程的改变而改变。        -   尽管当资源有限或有强力的证据表明它们不影响目标超参数时，我们可能固定其中一些参数，但通常应该假设优化器超参数必须单独调整，以在不同设置之间进行公平比较目标超参数。            -   此外，我们没有优化器超参数值的*先验*倾向（例如，它们通常不会以任何方式影响前向传递或梯度的计算成本）。    -   相比之下，优化器的*选择*通常是一个目标超参数或固定超参数。        -   如果我们的实验目标涉及在两个或多个不同的优化器之间进行公平比较（例如“确定哪个优化器在给定的步数中产生最低的验证错误”），那么它就是一个目标超参数。        -   或者，我们可能出于各种原因将其设为固定超参数，包括（1）先前的实验表明最好的优化器和当前的目标超参数无关；（2）当前优化器的训练曲线更容易理解 (3) 当前优化器比其他优化器使用更少的内存。    -   正则化技术引入的超参数通常是冗余超参数，但是否使用正则化技术往往是目标或固定超参数。        -   例如，dropout 增加了代码的复杂性，因此在决定是否包含它时，我们会将“no dropout”与“dropout”作为一个目标超参数，而将 dropout 率作为一个冗余超参数。            -   如果我们决定根据这个实验将 dropout 添加到我们的训练流程中，那么在未来的实验中，dropout 率将是一个冗余超参数。    -   模型结构超参数通常是目标或固定超参数，因为模型结构变化会影响服务和训练成本、延迟和内存需求。        -   例如，网络层数通常是一个目标或固定的超参数，因为它往往会对训练速度和内存使用产生巨大影响。-   在某些情况下，一个超参数是冗余还是固定超参数将取决于目标超参数的值。    -   例如，假设我们想知道 Nesterov momentum 和 Adam 中哪个优化器的验证错误率更低。目标超参数是 `optimizer`，它的值是 `{"Nesterov_momentum", "Adam"}`。值 `optimizer="Nesterov_momentum"` 引入了冗余/固定超参数 `{learning_rate, momentum}`，但值 `optimizer="Adam"` 引入了冗余/固定超参数 `{learning_rate, beta1, beta2, epsilon}`。    -   仅针对目标超参数的某些值存在的超参数称为**条件超参数**。    -   我们不应该仅仅因为两个条件超参数具有相同的名称就认为它们是相同的！在上面的示例中， `learning_rate` 对于 `optimizer="Nesterov_momentum"` 与 `optimizer="Adam"` 是*不同的*条件超参数. 它在两种算法中的作用相似（尽管不完全相同），但在每个优化器中运行良好的值范围通常相差几个数量级。</details><h4 id="创建一组研究"><a href="#创建一组研究" class="headerlink" title="创建一组研究"></a>创建一组研究</h4><details><summary><em>[点击展开]</em></summary><br>-   确定了目标和冗余超参数之后，我们会设计一个“研究”或一系列研究，以朝着实验目标取得进展。    -   一项研究指定了一组要运行的超参数配置以供后续分析。每个配置称为“试验”。    -   创建研究通常涉及几个方面：选择试验所需的超参数变量，选择这些超参数的取值范围（“搜索空间”），选择试验次数，以及选择自动搜索算法。或者，我们可以通过手动指定一组超参数配置来创建研究。-   研究的目的是使用目标超参数的不同值运行训练流程，同时 **“优化掉”**（或“优化”）冗余超参数，以便公平的比较不同的目标超参数值。-   在最简单的情况下，我们将对目标超参数的每个配置进行单独研究，其中每个研究都会调整冗余超参数。    -   例如，如果我们的目标是从 Nesterov、momentum 和 Adam 中选择最佳优化器，我们可以创建一个研究，并设置 `optimizer="Nesterov_momentum"` 和冗余超参数为 `{learning_rate, momentum}`。然后创建另一项研究，并设置 `optimizer="Adam"` 和冗余超参数为 `{learning_rate, beta1, beta2, epsilon}`。最后通过比较两个研究中的最优试验来比较这两个优化器。    -   我们可以使用任何无梯度优化算法，包括贝叶斯优化或进化算法等方法，来优化冗余超参数。但是，在[探索阶段](#探索与利用)，[我们更偏向](#为什么在优化的探索阶段使用Quasi-Random-Search而不是更复杂的黑盒优化算法？)使用准随机算法，因为这些方法在探索阶段有多种优势。在[探索结束后](#探索结束后)，我们会优先选择最先进的贝叶斯优化方法。-   在更复杂的情况下，我们想要比较大量目标超参数的值，并且我们无法进行大量相对独立的研究，我们可以将目标超参数与冗余超参数放在相同的搜索空间中，并使用搜索算法在单个研究中对*两种超参数*的值进行采样。    -   采用这种方法时，条件超参数可能会是一个问题，因为很难指定对应的搜索空间，除非所有目标超参数值都有相同的冗余超参数集。    -   在这种情况下，[我们更加偏好](#为什么在优化的探索阶段使用Quasi-Random-Search而不是更复杂的黑盒优化算法？)使用Quasi-Random-Search算法，因为它确保我们能相对均匀的采样目标超参数值。无论搜索算法如何，我们都需要确保它均匀搜索目标超参数。</details><h4 id="平衡实验的信息量和成本"><a href="#平衡实验的信息量和成本" class="headerlink" title="平衡实验的信息量和成本"></a>平衡实验的信息量和成本</h4><details><summary><em>[点击展开]</em></summary><br>-   在设计一项研究或一系列研究时，我们需要分配有限的预算，以充分满足以下三个要求：    1.  比较足够多目标超参数的不同值。    2.  在足够大的搜索空间上调整冗余超参数。    3.  对冗余超参数的搜索空间进行足够密集的采样。-   这三个必要条件，确保我们能从实验中获得足够多的经验。    -   尽可能多地比较目标超参数的值可以拓宽我们从实验中获得的经验的范围。    -   包括尽可能多的有冗余超参数，并允许每个冗余超参数有尽可能大的值域。这样我们更有信心相信，对于一个目标超参数配置，在当前搜索空间中，**存在**“好的”冗余参数。        -   否则，我们可能因为没有搜索某些冗余超参数空间，而对不同目标超参数值进行了不公平的比较。    -   尽可能密集地对冗余超参数采样，也能让我们更加有信心相信搜索流程能够找到好的冗余超参数配置。        -   否则，我们可能对不同目标超参数值进行了不公平的比较。因为某些值恰好有更好的冗余超参数配置。-   不幸的是，对这三个要求的*任何*一个进行改进都需要增加试验次数，从而增加资源成本。或者，我们只能从其他要求中想办法节约资源。    -   每个问题都有自己的特性和计算资源限制，因此如何在这三个需求之间分配资源需要一定程度的领域专业知识。    -   在进行一项研究后，我们都会总结该研究是否将冗余超参数调整得足够好（即充分搜索了足够大的空间）以公平地比较目标超参数（更详细的描述[如下](#从实验结果中获取经验)）。</details><h3 id="从实验结果中获取经验"><a href="#从实验结果中获取经验" class="headerlink" title="从实验结果中获取经验"></a>从实验结果中获取经验</h3><p><strong><em>总结</em></strong>： <em>除了尝试实现每组实验的原始科学目标之外，还要检查其他问题的清单，如果发现问题，请修改实验并重新运行。</em></p><ul><li>最终，每组实验都有一个特定的目标，我们想要评估实验为该目标提供的证据。<ul><li>然而，如果我们提出正确的问题，我们通常会发现在一组给定的实验能够朝着最初的目标取得很大进展之前需要纠正的问题。<ul><li>如果我们不问这些问题，我们可能会得出不正确的结论。</li></ul></li><li>由于运行实验的成本很高，我们还希望借此机会从每组实验中提取其他有用的见解，即使这些见解与当前目标并不直接相关。</li></ul></li><li>在分析一组给定的实验以朝着最初的目标取得进展之前，我们应该问自己以下额外的问题：<ul><li><a href="#identifying-bad-search-space-boundaries">搜索空间够大吗？</a><ul><li>如果研究的最佳点在一维或多维搜索空间的边界附近，则搜索可能不够广泛。在这种情况下，我们应该进行另一项具有扩展搜索空间的研究。</li></ul></li><li><a href="#not-sampling-enough-points-in-the-search-space">我们是否从搜索空间中采样了足够多的点？</a><ul><li>如果不是，则在调整目标中运行更多点或不那么雄心勃勃。</li></ul></li><li>每项研究中有多少试验是<strong>不可行</strong>（即出现分歧的试验、得到非常糟糕的损失值，或者因为违反某些隐式约束而根本无法运行）？<ul><li>当研究中很大一部分点是<strong>不可行</strong>时，我们应该尝试调整搜索空间以避免对这些点进行采样，这有时需要重新参数化搜索空间。</li><li>在某些情况下，大量不可行点可能表示训练代码中存在错误。</li></ul></li><li><a href="#how-can-optimization-failures-be-debugged-and-mitigated">模型是否存在优化问题？</a></li><li><a href="#examining-the-training-curves">我们可以从最佳试验的训练曲线中学到什么？</a><ul><li>例如，最好的试验是否具有与有问题的过度拟合一致的训练曲线？</li></ul></li></ul></li><li>如有必要，根据上述问题的答案，改进最近的研究（或研究组）以改进搜索空间和/或抽样更多试验，或采取其他一些纠正措施。</li><li>一旦我们回答了上述问题，我们就可以继续评估实验为我们最初的目标提供的证据（例如，<a href="#detecting-whether-a-change-is-useful-with-isolation-plots">评估改变是否有用</a>）。</li></ul><h4 id="识别错误的搜索空间边界"><a href="#识别错误的搜索空间边界" class="headerlink" title="识别错误的搜索空间边界"></a>识别错误的搜索空间边界</h4><details><summary><em>[点击展开]</em></summary><br>-   如果从搜索空间中采样的最佳点靠近其边界，那么这个搜索空间就有可疑之处。如果我们将搜索范围朝着这个方向扩大，我们可能会找到更优秀的点。-   为了检查搜索空间边界，我们喜欢在被我们称之为**基本超参数轴图**的图表绘制已完成的试验，我们在其中绘制验证目标值与其中一个超参数（例如学习率）的关系。图中的每个点都对应于一次试验。    -   每次试验的验证目标值通常应该是它在训练期间达到的最佳值。<p align="center" id="figure-1"><img src="tuning_playbook-bad_search_space.png" width="49%" alt="Example of bad search space boundaries"><img src="tuning_playbook-good_search_space.png" width="49%" alt="Example of good search space boundaries"></p><p align="center"><b>图 1：</b>不良的搜索空间边界和可接受的搜索空间边界示例。</p>-   [Figure 1](#figure-1)中的图表显示错误率（越低越好）与初始学习率的关系。-   如果最佳点聚集在搜索空间的边缘（在某个维度上），则可能需要扩展搜索空间边界，直到最佳观察点不再靠近边界。-   通常，一项研究将包括“不可行”的试验，这些试验会产生分歧或得到非常糟糕的结果（在上图中用红色 X 标记）。    -   如果所有试验对于大于某个阈值的学习率都是不可行的，并且如果表现最好的试验在该区域的边缘具有学习率，则模型[可能遇到了稳定性问题，从而无法获得更高的学习率](#how-can-optimization-failures-be-debugged-and-mitigated)。</details><h4 id="没有在搜索空间中采样足够的点"><a href="#没有在搜索空间中采样足够的点" class="headerlink" title="没有在搜索空间中采样足够的点"></a>没有在搜索空间中采样足够的点</h4><details><summary><em>[点击展开]</em></summary><br>-   一般来说，[可能很难知道](#how-many-trials-are-needed-to-get-good-results-with-quasi-random-search)是否搜索空间已经被足够密集地采样。🤖-   运行更多的试验当然更好，但代价是显而易见的。-   由于很难知道我们什么时候采样足够，我们通常会采样我们可以负担得起的代价，并尝试通过反复查看各种超参数轴图来校准我们的直觉，并试图了解有多少点位于搜索空间的“好”区域。</details><h4 id="检查训练曲线"><a href="#检查训练曲线" class="headerlink" title="检查训练曲线"></a>检查训练曲线</h4><details><summary><em>[点击展开]</em></summary><br>***总结***： *检查训练曲线是识别常见故障的一种简单方法，也可以帮助我们优先考虑下一步采取什么行动。*-   虽然在许多情况下，我们实验的主要目标只需要考虑每次试验的验证误差，但在试验中将验证误差减少到固定数字时我们必须小心，因为它可以隐藏表面下发生的事情的重要细节。-   对于每一项研究，我们总是查看至少是最好的几项试验的**训练曲线**（绘制的训练误差和验证误差与训练期间训练步数的关系图）。-   即使这对于解决主要的实验目标不是必要的，但检查训练曲线是识别常见故障模式的简单方法，也可以帮助我们优先考虑下一步采取什么行动。-   在检查训练曲线时，我们对以下问题感兴趣。-   是否有任何试验显示**过拟合**？    -   当验证误差在训练期间的某个时刻开始*增加*时，就会发生过度拟合。    -   在试验中(我们对目标超参数的不同设置选取最佳试验效果的试验[这实际上优化了冗余超参数])，我们应该*至少*在目标超参数的每个设置相对应的最佳试验中检查是否有过拟合问题。        -   如果任何最佳试验出现过拟合问题，我们通常会在比较目标超参数的不同值之前使用额外的正则化技术重新运行实验和/或更好地调整现有的正则化参数(防止因固定超参数的设置漏掉可能的优解？)。            -   如果目标超参数包括正则化参数，这可能不适用，因为如果这些正则化参数的低强度设置导致有问题的过拟合是不足为奇的。        -   使用常见的正则化技术减少过度拟合通常很简单，这些技术增加了代码复杂性的下届或额外的计算（例如，dropout、标签平滑化、权重衰减），因此在下一轮实验中添加一个或多个这些通常问题不大。        -   举个例子，如果目标超参数是“隐藏层数”，当使用最大隐藏层数的最佳试验表现出过拟合问题，那么我们通常更愿意使用额外的正则化再次尝试，而不是立即选择较小数量的隐藏层。        -   即使“最佳”试验都没有表现出有过拟合，但它发生在*所有*试验中时，这就可能存在问题。            -   选择最佳试验会抑制出现过拟合问题的配置，并偏向那些不会出现过拟合问题的配置。换句话说，它对具有更多正则化的配置更偏爱。            -   然而，任何让训练变得更糟的事情都可以作为正则化器，即使它不是故意的。例如，选择较小的学习率可以通过阻碍优化过程来规范训练，但我们通常不希望以这种方式选择学习率。            -   因此，我们必须意识到，目标超参数的每个设置的“最佳”试验是否会以有利于某些目标或冗余超参数像“坏”值的方式选择。-   在训练后期，训练或验证误差是否存在较高的步与步之间的[方差](https://math.stackexchange.com/questions/3604607/can-i-work-out-the-variance-in-batches)？    -   如果是这样，这可能会干扰我们比较目标超参数的不同值的能力（因为每个试验都随机地在 "幸运 "或 "不幸运 "的一步上结束），以及我们在生产中重现最佳试验结果的能力（因为生产模型可能不会像研究中那样在 "幸运 "一步上结束）。    -   导致步间方差的最大可能的是Batch的方差（应当从训练集中随机抽取样本），过小的验证集，以及在训练后期使用过高的学习率。     -   可能的补救措施包括增加Batch Size，使用更多的验证数据，使用学习率衰减，或使用Polyak平均法。-   训练结束时试验是否仍能改进？    -   如果是这样，这表明我们在[“计算限制”](#determining-the-number-of-steps-for-each-training-run)制度中，我们可能会受益于[增加训练步数](#Deciding-how-long-to-train-when-training-is-compute-bound)或更改学习率计划。-   训练集和验证集的性能在最后的训练步骤之前很久就饱和了吗？    -   如果是这样，这表明我们处于[“不受计算限制”](#determining-the-number-of-steps-for-each-training-run)制度中，我们可能能够[减少训练步数](#deciding-how-long-to-train-when-training-is-not-compute-bound)。-   虽然我们不能一一列举，但还有许多其他的行为可以通过检查训练曲线而变得明显（例如，训练误差在训练过程中增加，通常表明训练工作流中存在错误）。</details><h4 id="使用isolation图检测更改是否有用"><a href="#使用isolation图检测更改是否有用" class="headerlink" title="使用isolation图检测更改是否有用"></a>使用isolation图检测更改是否有用</h4><details><summary><em>[点击展开]</em></summary><br><p align="center" id="figure-2"><img src="tuning_playbook-isolation_plot.png" width="49%" alt="Isolation plot that investigates the best value of weight decay for ResNet-50 trained on ImageNet."></p><p align="center"><b>图 2：</b>研究在 ImageNet 上训练的 ResNet-50 的最佳权重衰减值的isolation图。</p>-   通常，一组实验的目标是比较目标超参数的不同值。    -   例如，我们可能想要确定导致最佳验证误差的权重衰减值。-   **isolation图**是基本超参数轴图的特例。isolation图上的每个点对应着在优化某些（或全部）冗余超参数上最佳试验的性能。    -   换句话说，我们绘制了在"优化掉"冗余超参数后模型的性能。-   isolation图可以更轻松地在目标超参数的不同值之间进行同类比较。-   例如，[图2](#图2)显示了在ImageNet上训练的ResNet-50的特定配置(学习率)下产生最佳验证性能的权重衰减值。    -   如果我们的目标是确定是否要加入权重衰减，那么我们会将此图中的最佳点与没有权重衰减的Baseline进行比较。为了公平比较，Baseline的学习率也应该同样得到很好的调整。-   当我们正在考虑为一个连续的超参数来绘制isolation图时，并且我们是使用Quasi-Random-Search(近似随机搜索)产生的超参数的不同值时，我们可以通过对基本超参数轴图的X轴值进行分桶，并在分桶定义的每个垂直切片中取最佳试验来近似绘制隔离图。</details><h4 id="自动化常用的绘图"><a href="#自动化常用的绘图" class="headerlink" title="自动化常用的绘图"></a>自动化常用的绘图</h4><details><summary><em>[点击展开]</em></summary><br>-   当第一次生成此类图表花费的努力越多，您查看这类图表的频率就越低。因此，最好将您的基础策略设为自动生成尽可能多的图表。-   至少，我们会为我们在实验中变化的所有超参数自动生成基本超参数轴图。-   此外，我们会自动为所有试验生成训练曲线，并尽可能轻松地找到每项研究中最好的几次试验并检查它们的训练曲线。-   我们可以也添加许多其他有用的潜在图表和可视化。尽管上面的例子的是一个很好的起点，但套用杰弗里 · 辛顿 (Geoffrey Hinton) 的话，“每次设计新事物时，您都会学到新事物。”</details><h3 id="确定是否采用此训练工作流更改或超参数配置"><a href="#确定是否采用此训练工作流更改或超参数配置" class="headerlink" title="确定是否采用此训练工作流更改或超参数配置"></a>确定是否采用此训练工作流更改或超参数配置</h3><p><strong><em>总结</em></strong>： <em>当决定是否对我们的模型或训练程序进行改变或采用新的超参数配置时，我们需要理解导致我们结果中不同的变化的来源。</em></p><ul><li>当我们试图改进我们的模型时，我们可能会观察到，与我们现有的配置相比，一个特定的候选变化最初取得了更好的验证误差，但在重复实验后发现，没有发现一致的优势。非正式地，我们可以把可能导致这种不一致结果的最重要的变化来源分为以下几大类。<ul><li><strong>训练程序方差</strong>、<strong>再训练方差</strong>或<strong>试验方差</strong>：我们在使用相同的超参数但不同的随机种子的训练运行之间看到的差异。<ul><li>例如，不同的随机初始化、训练数据的shuffles、dropout掩码、数据增强操作的模式和并行运算的顺序，都是试验方差的潜在来源。</li></ul></li><li><strong>超参数搜索方差</strong>或<strong>学习方差</strong>：由我们选择超参数的程序引起的结果变化。<ul><li>例如，我们可能会在特定搜索空间运行相同的实验，但使用两个不同的种子进行Quasi-Random-Search搜索，并最终选择不同的超参数值。</li></ul></li><li><strong>数据收集和抽样方差</strong>：训练数据、验证数据和测试数据的任何一种随机分割所产生的方差，或者更普遍的由于训练数据生成过程而产生的方差。</li></ul></li><li>使用严格的统计测试对有限验证集上估计的验证错误率进行比较是很好的，但往往仅试验方差就能在使用相同超参数设置的两个不同的训练模型之间产生统计上的显著差异。</li><li>当我们试图得出超出超参数空间中单个点水平的结论时，我们最关心的是学习方差。<ul><li>学习方差取决于试验次数和搜索空间，我们已经看到它大于试验方差的情况以及它小得多的情况。</li></ul></li><li>因此，在采用一个候选变化之前，考虑运行最佳试验N次，以估计训练方差。<ul><li>通常情况下，我们可以只在工作流发生重大变化后重新对试验方差进行估计，但在某些应用中，我们可能需要使用更新鲜的估计。 </li><li>在其他应用中，估计试验方差的成本太高，不值得这样做。</li></ul></li><li>归根结底，虽然我们只想采用能够产生真正改进的更改（包括新的超参数配置），但要求完全相信某些东西会有所帮助也不是正确的要求。</li><li>因此，如果一个新的超参数点（或其他变化）得到比Baseline更好的结果（尽可能考虑新点和Baseline的再训练方差），那么我们可能应该采用它作为新的Baseline为以后的比较。<ul><li>但是，我们应该只采用产生的改进超过它们增加的复杂性的更改。</li></ul></li></ul><h3 id="探索结束后"><a href="#探索结束后" class="headerlink" title="探索结束后"></a>探索结束后</h3><p><strong><em>总结</em></strong>： <em>一旦我们完成了对“好”的搜索空间的探索，并决定了哪些超参数甚至应该被调整，贝叶斯优化工具就是一个值得考虑的选择。</em></p><ul><li>在这个时候，我们的优先事项将从学习更多优化经验转向产生一个最佳配置来启动或以其他方式使用。</li><li>在这一点上，我们应该有一个精确的搜索空间，可以舒适地包含最佳观察试验周围的局部区域，并且已经过充分采样。</li><li>我们的探索工作应该已经揭示了最重要的要调整的超参数（以及它们的合理范围），我们可以使用这些超参数来构建搜索空间，以使用尽可能大的调整预算进行最终的自动调整研究。</li><li>由于我们不再关心最大化我们对优化问题的经验，<a href="#why-use-quasi-random-search-instead-of-more-sophisticated-black-box-optimization-algorithms-during-the-exploration-phase-of-tuning">Quasi-Random-Search的优化方式</a>不再适用，这时应该使用贝叶斯优化工具来自动找到最佳超参数配置。<ul><li>如果搜索空间包含大量发散点（获得 NaN 训练损失或比平均值差很多标准差的训练误差的点），使用黑盒优化工具来正确处理发散试验很重要（请参阅<a href="https://arxiv.org/abs/1403.5607">具有未知约束的贝叶斯优化</a>是处理此问题的绝佳方法）。</li></ul></li><li>此时，我们还应该考虑检查测试集上的性能。<ul><li>原则上，我们甚至可以将验证集折叠到训练集中，并重新训练通过贝叶斯优化找到的最佳配置。但是，这只适用于未来不会有这种特定工作需求的情况（例如，单次 Kaggle 竞赛）。</li></ul></li></ul><h2 id="确定每次训练运行的步数"><a href="#确定每次训练运行的步数" class="headerlink" title="确定每次训练运行的步数"></a>确定每次训练运行的步数</h2><ul><li>有两种类型的工作模式：受计算限制的和不受计算限制的。</li><li>当训练为<strong>受计算限制</strong>时，训练受限于我们愿意等待的时间，而不是受我们拥有多少训练数据或其他因素的限制。<ul><li>在这种情况下，如果我们能以某种方式延长训练时间或提高训练效率，我们应该看到较低的训练损失，并且通过适当的调整，改善验证损失。</li><li>换句话说，加快训练速度就等于改善训练效果，而 “最佳 “训练时间总是 “我们愿意等待的时间”范围内。</li><li>然而，当工作模式受计算限制时，并不意味我们只能通过更长/更快的训练来改善结果。</li></ul></li><li>当训练为<strong>不受计算限制</strong>时，我们可以负担得起训练的时间，只要我们愿意。或在某些时候，训练更长的时间并没有多大帮助（甚至会导致过拟合）。<ul><li>在这种情况下，我们应该期望能够训练到非常低的训练误差，训练时间更长可能会略微减少训练误差，但不会显着减少验证误差。</li><li>当训练不受计算限制时，慷慨的训练时间预算可以使调整更容易，特别是在调整学习率衰减计划时，因为它们与训练预算有特别强的相互作用。<ul><li>换句话说，吝啬的训练时间预算可能需要将学习率衰减计划调整到完美，以实现良好的训练效果。</li></ul></li></ul></li><li>不管一个给定的工作负载是否是计算约束，使用增加梯度方差（跨Batch）的方法通常会导致较慢的训练进度，从而可能增加达到特定验证损失所需的训练步骤。高梯度方差可能是由以下原因造成的。<ul><li>使用了较小的Batch Size</li><li>使用了数据增强技术</li><li>添加了一些类型的正则化（例如 dropout）</li></ul></li></ul><h3 id="当训练不受计算限制时如何决定该训练多久"><a href="#当训练不受计算限制时如何决定该训练多久" class="headerlink" title="当训练不受计算限制时如何决定该训练多久"></a>当训练不受计算限制时如何决定该训练多久</h3><ul><li>我们的主要目标是确保我们训练的时间足够长，以使模型达到最佳效果，同时避免在训练步数的数量上过度浪费。</li><li>在有疑问的时候，请偏向于选择延长训练时间。假设回顾性（最佳）检查点选择使用得当，并且检查点足够频繁，那么训练时间越长，性能就越不会下降。</li><li>不要在训练中调整 <code>max_train_steps</code> 以获得更好的效果。我们只需要选择一个值并将其用于所有试验。从这些试验中，绘制回顾检查点选择发现的训练steps，以优化<code>max_train_steps</code>的数值。<ul><li>例如，如果最佳step总是出现在训练过程的前10%，那么最大训练step数就太高了。</li><li>或者，如果最好的step总是出现在训练过程的最后的25%中，我们可能可以在增加训练时间和重新调整学习率衰减策略中受益(都与max_train_steps相关)。</li></ul></li><li>当模型架构或数据发生变化时(例如添加数据增强)，理想的训练的step数也会发生变化。</li><li>下面我们将描述如何根据使用恒定学习率“完全拟合”训练集所需的step数，为<code>max_train_steps</code>选择初始候选值。<ul><li>注意，我们并没有以精确或数学定义良好的方式使用短语“完美拟合训练集”。<br>它只是一个非正式的描述语，表示非常低的训练损失。<ul><li>例如，当训练损失为log loss且没有正则化项时，我们可能会看到训练损失会一直在缓慢减小(这与log loss的特性有关)，直到达到浮点极限（floating point limits），因为网络权重可以无限制地增长，模型会对训练集的预测变得越来越自信。在这种情况下，我们可能会说，当训练集中的错误分类为0时，模型“完全拟合”训练集。</li></ul></li><li>如果训练过程中 gradient noise(译注：可参考Umut Simsekl et al) 增大时，则<code>max_train_steps</code>可能需要增加起始值。<ul><li>例如，如果在模型中引入数据增强或dropout等正则化方法。</li></ul></li><li>如果训练过程以某种方式改进，可能会减少<code>max_train_steps</code>。<ul><li>例如，使用更好的优化器或更好的学习率更新策略。</li></ul></li></ul></li></ul><h4 id="使用学习率搜索算法来确定-max-train-steps-的初始值"><a href="#使用学习率搜索算法来确定-max-train-steps-的初始值" class="headerlink" title="使用学习率搜索算法来确定 max_train_steps 的初始值"></a>使用学习率搜索算法来确定 max_train_steps 的初始值</h4><details><summary><em>[点击展开]</em></summary><br>-   此过程假设不仅可以“完美”地拟合训练集，而且可以使用恒定的学习率更新策略来实现。-   如果可以完美地拟合整个训练集，那么`max_train_steps`应该有一个确定的值可以完美地拟合训练集；找到这个值作为`max_train_stepsd`的起点`N`-   在没有数据增强和正则化的情况下运行恒定的学习率搜索（即网格搜索学习率），其中每个试验训练 `N` 步骤。-   在搜索中最快达到完美训练的实验所需的步数就是我们对 `max_train_steps` 的初步猜测。-   **注意：** 错误的搜索空间可能会导致自欺欺人。    -   例如，如果一项研究中的所有学习率都太小，我们可能会错误地得出结论，认为一个非常大的`max_train_steps`的值是必要的。    -   至少，我们应该检查研究中的最佳学习率是否在搜索空间的边界(基本超参数轴图)。</details><h3 id="当训练受计算限制时如何决定该训练多久"><a href="#当训练受计算限制时如何决定该训练多久" class="headerlink" title="当训练受计算限制时如何决定该训练多久"></a>当训练受计算限制时如何决定该训练多久</h3><ul><li>在某些情况下，训练误差会无限地改善，而我们的耐心和计算资源就成为了限制因素。</li><li>如果训练误差（或甚至验证误差）可以无限地改善，我们是否应该在我们能接受的情况下一直训练？答案是不必要。<ul><li>通过运行更多的短时间的实验，我们可以更快地找到最佳的模型和优化器超参数，而不必浪费大量的计算资源和时间在不优秀的超参数上。最后，我们可能会运行少量的长时间(“production length” 指模型在生产环境中运行的时间,也就是预期的长时间训练)的实验来在最佳超参数点上获得最终模型。这样，我们就可以更有效地使用我们的资源来调整最有可能在生产环境中表现良好的模型。</li><li>我们的训练时间越长，我们对模型的理解就会越深入，这样我们就可以更好的了解模型的性能和限制，因此我们可以更确定哪些参数是最有可能在生产环境中表现良好的参数。但是，当我们的训练时间越长，我们能完成的实验就会越少，因为我们的耐心和计算资源有限。</li><li>当我们只训练 ~10% 的production length时，我们可能能够回答很多问题，但是在这个时间限制下的结论不一定适用于20%的production length的实验，更不用说100%了。这是因为训练模型的时间越长，模型就会越来越接近其最佳性能，而在较短的训练时间内得出的结论可能不能完全适用于长时间训练后的模型。</li></ul></li><li>因此我们建议在每轮调整中逐渐增加训练步数限制，以在有限的资源和耐心内获得最大的理解，并在最终长时间训练后再进行验证和确认。<ul><li>我们可以想做多少轮就做多少轮，但通常 1-3 轮是最实用的。</li><li>从本质上讲，在进行调整时要在两个方面进行平衡：相关性和彻底性。相关性指的是调整结果与最终长时间运行之间的相似性，而彻底性则指调整结果的详尽程度。因此，在进行调整时，我们应该尽量使用快速转换时间的试验来获得尽可能多的问题理解，同时保证这些结论与最终长时间运行相关。这样可以在有限的时间和资源内获得最大的理解，并尽可能地减少对最终长时间运行的影响。</li><li>一旦给定的每次试验时间限制中产生了有用的见解，我们就可以增加训练时间并继续调整，以确保它们在长时间运行中仍然适用。</li></ul></li><li>作为起点，我们建议进行两轮调整：<ul><li>第一轮：进行短时间的训练来找到较佳的模型和优化器超参数</li><li>第二轮：在较佳的超参数上进行少量长时间的训练来得到最终模型</li></ul></li><li>从 <code>Round i</code> → <code>Round i+1</code> 的最大问题是如何调整学习率衰减计划。<ul><li>在进行调整时，最大的问题是如何调整学习率衰减计划。在调整学习率衰减计划时的一个常见问题是使用了太小的学习率，如果学习率过小，模型的收敛速度会变慢，可能会需要更多的训练步骤才能达到最优状态。这可能会增加训练时间并增加计算资源的需求。</li></ul></li></ul><h4 id="第一轮"><a href="#第一轮" class="headerlink" title="第一轮"></a>第一轮</h4><details><summary><em>[点击展开]</em></summary><br>-   遗憾的是，在短时间和不完整训练中找到的超参数在增加训练长度后仍然是好选择的保证是没有的。但是，对于某些类型的超参数，它们通常具有足够的相关性，因此第一轮非常有用。-   我们期望在短运行中找到的哪些超参数值会转移到更长的训练运行中？对于这一切，我们需要更多的研究。但是根据已有的结论我们可以提出一些猜测，以下是作者的猜测，按转移概率的降序排列：    -   极有可能转移        -   在第一轮调参中，使用较少的训练步数可以解决早期训练的不稳定性。也许这些超参数是最能保证转移的选择。            -   Warmup时长            -   模型参数初始值    -   可能转移        -   模型架构 - 模型架构上的显著胜利通常会转移，但可能有很多例外。    -   可能会转移        -   优化算法/优化器超参数——我们认为这将"松散"转移。它明显比上面的东西弱。        -   数据增强方法        -   正则化            -   如果不可能完美地拟合训练集，则模型可能处于正则化不太可能有太大的帮助。    -   不太可能转移        -   学习率衰减计划：不太可能完美迁移。            -   [This paper](https://arxiv.org/abs/2203.15556)说学习率衰减计划也能转移。但我们不相信这在通常情况下是正确的。例如：在较少的训练步骤上调整开根号衰减，然后扩展到大量训练步骤将导致在过小的步骤上进行大部分训练。                -   在极端训练预算限制下，可能可以用大多数计划做到“足够好”，但如果进行了调整，可能会看到明显的性能改进。            -   [了解随机元优化中的短期偏差](https://arxiv.org/abs/1803.02021)描述了选择学习率的短视危险。</details><h4 id="第二轮"><a href="#第二轮" class="headerlink" title="第二轮"></a>第二轮</h4><details><summary><em>[点击展开]</em></summary><br>-   运行第一轮中最佳的超参数配置。-   **（推测）** 🤖使用额外的步骤来延长高学习率的训练时间。    -   例如，如果是线性计划，则保持第一轮中衰减大小的固定值，并在开始时延长恒定的lr期。    -   对于余弦衰减，只需保留第一轮的基础 lr 并像[ Chinchilla 论文 ](https://arxiv.org/abs/2203.15556)一样增大 `max_train_steps`。-   对于具有非常成熟建模和调整的工作流以及非常长且昂贵的生产训练运行的团队来说，更多回合可能更有意义，但它们通常会过于复杂。    -   我们已经描述了如何从第一轮  → 第二轮 进行转换。如果我们不关心分析时间，并且计算效率是关键因素，那么理想情况是在许多不同的调整轮次中逐渐增加训练运行的长度(从而增加完成研究的总体时间)。        -   在每一轮中，我们都系统地确保我们的选择仍然是正确的。        -   新的想法经过一个完整的工作，越来越长时间的实验逐渐降低了它不可用的风险。</details><h2 id="关于训练管道的额外补充"><a href="#关于训练管道的额外补充" class="headerlink" title="关于训练管道的额外补充"></a>关于训练管道的额外补充</h2><h3 id="优化输入管道"><a href="#优化输入管道" class="headerlink" title="优化输入管道"></a>优化输入管道</h3><p><strong><em>总结</em></strong>： <em>输入管道性能受限的原因及干预措施与具体任务高度相关，使用性能分析工具并注意常见的一些问题。</em></p><ul><li>使用适当的性能分析工具来诊性能受限的输入管道，例如，用于 JAX 的 <a href="https://jax.readthedocs.io/en/latest/profiling.html">Perfetto</a> 或用于 TensorFlow 的 <a href="https://www.tensorflow.org/guide/profiler">TensorFlow profiler</a>。</li><li>归根结底，具体原因和干预措施将高度依赖于任务。更广泛的工程考虑(如减少磁盘空间占用)可能会导致较差的输入管道性能。</li><li>常见问题：<ul><li>数据未与训练进程存放在同一位置，从而导致I/O延迟(通过网络读取训练数据时可能会发生这种情况)。</li><li>昂贵的在线数据预处理(考虑进行一次性离线预处理并保存)。</li><li>无意间的同步屏障干扰数据管道预读取。例如，在 CommonLoopUtils(<a href="https://github.com/google/CommonLoopUtils/blob/fea2518ada8814a78e1492023fd9f00edb0b0568/clu/metrics.py#L291">link</a>) 中同步设备和主机之间的数据时。</li></ul></li><li>常见技巧：<ul><li>例如使用 <a href="https://www.tensorflow.org/guide/data_performance#prefetching">tf.data.Dataset.prefetch</a> 之类的工具对输入管道预读取数据。</li><li>尽可能早地在管道中删除不必要的特征和元数据。</li><li>通过使用 <a href="https://www.tensorflow.org/api_docs/python/tf/data/experimental/service">tf.data service</a> 来增加输入管道生成数据的进程的数量。</li></ul></li></ul><h3 id="评估模型性能"><a href="#评估模型性能" class="headerlink" title="评估模型性能"></a>评估模型性能</h3><p><strong><em>总结</em></strong>： <em>使用比训练时更大的 batch size 进行评估。在固定步长间隔进行评估，而不是固定的时间间隔。（注：如100个epoch评估一次，而不是10分钟评估一次）。</em></p><h4 id="评估设置"><a href="#评估设置" class="headerlink" title="评估设置"></a>评估设置</h4><details><summary><em>[点击展开]</em></summary><br>+ 我们可以通过多种方式来评估模型的性能。    + 在线评估-当模型在生产环境中提供预测时收集指标。    + 离线评估-当模型在代表生产环境的离线训练/验证/测试集上运行时，收集指标。    + 定期评估-在模型训练期间收集的指标可能是离线评估的代理，和(或)离线评估中使用的数据的子集。+ 在线评估是最佳标准，但在模型开发阶段往往是不切实际的。+ 根据问题的不同，离线评估可能会相当复杂，并且计算成本很高。+ 定期评估是最实际和最经济的选择，但可能不能完全代表生产环境。    + 我们在定期评估时的目标是在训练期间获得可靠信号，使同时尽可能缩短评估时间。</details><h4 id="设置定期评估"><a href="#设置定期评估" class="headerlink" title="设置定期评估"></a>设置定期评估</h4><details><summary><em>[点击展开]</em></summary><br>+ 我们在训练期间定期进行评估，以实时监控其进度，以便于[追溯模型检查点选择](https://github.com/google-research/tuning_playbook#:~:text=facilitate%20retrospective%20model%20checkpoint%20selection)，以便我们可以在[训练结束时检查训练曲线](https://github.com/google-research/tuning_playbook#:~:text=examine%20the%20training%20curves%20at%20the%20end%20of%20training)。+ 其中最简单的配置是在同一计算实例中执行训练和定期评估，并定期在训练和评估之间交替。(注：比如固定步长间隔评估一次）+ 在这种情况下，用于执行评估的 batch size 大小应该至少与用于训练的 batch size 大小一样大，因为在评估期间不需要保持模型运行（注：如不用计算梯度之类的），从而降低了每个示例的计算要求。+ 定期评估应在固定步长间隔进行，而不是按时间间隔进行。    + 基于时间间隔进行评估可能会使解释训练曲线变得更加困难，尤其是在培训可能受到训练作业抢占、网络延迟问题等影响的情况下。    + 有效/测试度量中的周期性(当使用打乱后的训练/确认/测试分割时)可以指出某些实现错误，例如测试数据与训练数据重叠，或者训练数据没有被适当地打乱。这些问题可以通过在固定步长间隔进行评估来更容易地检测到。    + 当评估集不能被 batch size 整除时，会出现部分 batch 的情况。确保填充的数据被正确地加权，以防止损失函数产生偏向。通常，这些填充的数据可以被赋予零的权重。    + 最后，保存每次评估的足够信息，以支持离线分析。理想情况下，我们将保存一些单个示例的预测，因为它们对于调试来说非常有价值。        + 生成像 [SavedModels](https://www.tensorflow.org/guide/saved_model) 这样的构件可以轻松地在评估完成后进行即时模型检查。</details><h4 id="选择样本进行定期评估"><a href="#选择样本进行定期评估" class="headerlink" title="选择样本进行定期评估"></a>选择样本进行定期评估</h4><details><summary><em>[点击展开]</em></summary><br>+ 定期评估作业的运行速度可能不够快，无法在合理的时间内计算完整离线评估集的指标。这通常需要对数据进行抽样以进行定期评估。+ 在构建采样数据集时，我们会考虑以下因素：    + <u>样本量</u>        + 确保定期作业使用的采样数据集的性能与整个离线评估集的性能相似，确保采样集与完整数据集之间没有偏差。        + 用于定期评估的数据集应该足够小，以便很容易生成整个模型的预测，但也应该足够大，以便可以准确地测量模型的改进(即不被大量标签噪声影响)。        + 它应该足够大，以适应顺序试验中的多个这样的评估，并仍然产生准确的估计。也就是说，避免在多轮评估中对验证集过度适应，从而影响模型对留出集的表现。然而，这种考虑很少是一个实际的问题。    + <u>不平衡的数据集</u>        + 对于不平衡的数据集，在稀有类别样本上的表现往往会有噪音。        + 对于每个类别只有少量样本的数据集，记录正确预测样本的数量，可以更深入地了解准确性改进(.05灵敏度改进听起来很令人兴奋，但它只是因为更多的样本被正确预测了吗？)</details><h3 id="保存检查点并追溯选择最佳检查点"><a href="#保存检查点并追溯选择最佳检查点" class="headerlink" title="保存检查点并追溯选择最佳检查点"></a>保存检查点并追溯选择最佳检查点</h3><p><strong><em>总结</em></strong>：<em>运行固定步长的训练，并回顾性地从中选择最佳检查点。</em></p><ul><li>大多数深度学习框架都支持<a href="https://flax.readthedocs.io/en/latest/api_reference/flax.training.html">模型检查点</a>。模型的当前状态会定期保存在磁盘上。这允许训练作业对计算实例中断具有弹性。</li><li>最佳检查点并不一定是最后一个检查点，尤其是当验证集性能不会随时间持续增加而是围绕特定值波动时。</li><li>设置管道以跟踪到目前为止在训练期间看到的 N 个最佳检查点。在训练结束时，模型选择就是选择训练期间看到的最佳检查点。我们将此称为 <strong>回顾性最佳检查点选择</strong>。</li><li>因为预先指定了试验预算并保留了迄今为止看到的 N 个最佳检查点，所以通常不必要支持预期提前停止。</li></ul><h3 id="设置实验跟踪"><a href="#设置实验跟踪" class="headerlink" title="设置实验跟踪"></a>设置实验跟踪</h3><p><strong><em>总结</em></strong>：<em>在跟踪不同的实验时，一定要注意一些要点，比如研究中检查点的最佳性能，以及对研究的简短描述。</em></p><ul><li>我们发现，在电子表格中跟踪实验结果有助于我们解决各种建模问题。它通常有以下列：<ul><li>实验名称</li><li>实验配置存储位置的链接</li><li>实验的注释或简短描述</li><li>运行次数</li><li>最佳模型在验证集上的表现</li><li>训练所需的配置和运行命令</li></ul></li><li>选择一种跟踪系统，能够满足上述信息的记录要求并且对使用者友好易用是非常重要的，未经记录的实验可能不会得到重视。</li></ul><h3 id="BatchNorm的实现细节"><a href="#BatchNorm的实现细节" class="headerlink" title="BatchNorm的实现细节"></a>BatchNorm的实现细节</h3><p><strong><em>总结</em></strong>：<em>目前Batch Norm通常可以用Layer Norm代替，但在不能替换的情况下，在更改批大小或主机数量时会有一些棘手的细节。</em></p><ul><li>Batch norm 使用当前批次的均值和方差对激活值进行归一化，但在多设备设置中，除非明确同步处理，否则这些统计数据在每个设备上都是不同的。</li><li>据说（主要在ImageNet上）仅使用约 64 个样本计算这些归一化统计数据在实际应用中效果更好（请参阅 <a href="https://arxiv.org/abs/1705.08741">Ghost Batch Norm</a>）。</li><li>将总批大小与用于计算批归一化统计数据的样本数量分离对于批次大小的比较特别有用。</li><li>Ghost batch norm 实现并不总能正确处理每台设备的批次大小 &gt; 虚拟批次大小的情况。在这种情况下，我们实际上需要在每个设备上对批次进行二次抽样，以获得适当数量的批归一化统计样本。</li><li>在测试模式中使用的指数移动平均(EMA）仅仅是训练统计数据的线性组合，因此这些 EMA 只需要在将它们保存在检查点之前进行同步。然而一些常见的批归一化实现不同步这些EMA，并只保存第一个设备的EMA。</li></ul><h3 id="多主机管道的考虑因素"><a href="#多主机管道的考虑因素" class="headerlink" title="多主机管道的考虑因素"></a>多主机管道的考虑因素</h3><p><strong><em>总结</em></strong>： <em>在日志记录、评估、RNG(随机数生成器)、检查点和数据分片方面，多主机训练非常容易引入错误！</em></p><ul><li>保证管道只在一台主机上进行日志记录和检查点</li><li>确保在运行评估或检查点之前，批处理规范统计信息在主机之间同步</li><li>保证在多主机之间使用相同的随机数生成器种子(用于模型初始化)和不同的种子(用于数据混洗和预处理)是非常重要的，因此请确保合适地标记它们</li><li>为了提升性能，通常建议将数据文件在多台主机之间进行分片</li></ul><h2 id="常见问题的回答"><a href="#常见问题的回答" class="headerlink" title="常见问题的回答"></a>常见问题的回答</h2><h3 id="最好的学习率衰减方案是什么"><a href="#最好的学习率衰减方案是什么" class="headerlink" title="最好的学习率衰减方案是什么"></a>最好的学习率衰减方案是什么</h3><details><summary><em>[点击展开]</em></summary><br>-   这是一个开放性问题。目前尚不清楚如何构建一组严格的实验来自信地回答最佳的LR 衰减方案是什么。-   虽然我们不知道最好的方案是什么，但我们相信尝试一些（非恒定的）方案很重要并且调整它很重要。-   在优化过程中，不同的学习率在不同的时间效果最好。 有某种衰减方案可以使模型更有可能达到良好的学习率。</details><h3 id="我应该使用哪种学习率衰减方案作为默认值？"><a href="#我应该使用哪种学习率衰减方案作为默认值？" class="headerlink" title="我应该使用哪种学习率衰减方案作为默认值？"></a>我应该使用哪种学习率衰减方案作为默认值？</h3><details><summary><em>[点击展开]</em></summary><br>-   我们的偏好是linear decay或cosine decay，其他一些方案可能也不错。</details><h3 id="为什么有些论文有复杂的学习率衰减方案？"><a href="#为什么有些论文有复杂的学习率衰减方案？" class="headerlink" title="为什么有些论文有复杂的学习率衰减方案？"></a>为什么有些论文有复杂的学习率衰减方案？</h3><details><summary><em>[点击展开]</em></summary><br>-   具有复杂分段学习率 (LR) 衰减方案的论文并不少见。-   读者常常想知道作者是如何得出如此复杂的研究结果的。-   许多复杂的 LR 衰减方案是根据验证集性能以临时方式调整衰减方案的结果：    1.  使用一些简单的 LR 衰减（或恒定学习率）开始执行单次训练。    2.  继续训练，直到性能提升似乎停滞为止。如果发生这种情况，请暂停训练。 从此时开始，使用可能更陡峭的 LR 衰减方案（或更小的恒定学习率）恢复它。 重复此过程，直到会议/发布截止日期。-   随意复制生成的衰减方案通常不是一个好主意，因为最佳的特定衰减方案将对许多其他超参数选择敏感。    -   最好复制生成衰减方案的算法，尽管在人为判断生成的衰减方案时这几乎不可能。-   如果这种类型的验证错误敏感计划可以完全自动化，则可以很好地使用，但作为验证错误函数的人在循环计划是脆弱的并且不容易重现，因此我们建议避免使用它们。    -   在发布使用此类衰减方案的结果之前，请尽量确保其可重现性。</details><h3 id="Adam-的超参数应该如何调整？"><a href="#Adam-的超参数应该如何调整？" class="headerlink" title="Adam 的超参数应该如何调整？"></a>Adam 的超参数应该如何调整？</h3><details><summary><em>[点击展开]</em></summary><br>-   正如之前讨论的那样, 对搜索空间以及应该从搜索空间中采样数量做出概括性陈述是非常困难的。 请注意，并非 Adam 中的所有超参数都一样重要。 以下经验法则对应于研究中试验次数的不同“预算”。    -   如果在一次研究中，训练次数试验次数小于10，那么只需要对基本学习率进行调整。    -   如果试验次数在10到25次之间， 那么需要对学习率以及 $\beta_1$ 进行调整。    -   如果试验次数在25次以上，那么需要对学习率、 $\beta_1$ 以及 $\epsilon$ 进行调整。    -   如果可以运行的试验次数大于25次，还需要额外调整$\beta_2$。</details><h3 id="为什么在优化的探索阶段使用Quasi-Random-Search而不是更复杂的黑盒优化算法？"><a href="#为什么在优化的探索阶段使用Quasi-Random-Search而不是更复杂的黑盒优化算法？" class="headerlink" title="为什么在优化的探索阶段使用Quasi-Random-Search而不是更复杂的黑盒优化算法？"></a>为什么在优化的探索阶段使用Quasi-Random-Search而不是更复杂的黑盒优化算法？</h3><details><summary><em>[点击展开]</em></summary>-   Quasi-Random-Search（基于[低差异序列](https://en.wikipedia.org/wiki/Low-discrepancy_sequence)）    是我们在用作迭代调优过程的一部分时优于更高级的黑盒优化工具，旨在最大限度地洞察调优问题（我们称之为“探索阶段”）。贝叶斯优化和与其类似的工具更适合开发阶段。-   基于随机移动的低差异序列的Quasi-Random-Search可以被认为是“抖动的、打乱的网格搜索”，因为它统一但随机地探索给定的搜索空间，并且搜索点更为分散。-   与更复杂的黑盒优化工具（例如贝叶斯优化、遗传算法）相比，Quasi-Random-Search的优势包括：    1.  非自适应地采样搜索空间可以在不重新运行实验的情况下更改性能指标。        -   例如，我们通常希望根据任何训练点上达到的验证误差来找到最佳试验。但是Quasi-Random-Search的非自适应性质使得我们可以基于最终验证误差、训练误差或某些替代评估指标来找到最佳试验，而不需要重新运行任何实验。(译注：假设你正在训练一个深度学习模型，并使用随机搜索来调整超参数。在第一次实验中，你使用随机搜索来寻找最优的超参数组合，并使用验证误差作为评估指标。你找到了一组超参数，使得验证误差最小。现在，你想要更改评估指标，而不是使用验证误差，而是使用训练误差(可能你在解决某种模型需求)。由于你使用的是非自适应随机搜索，因此你可以在不重新运行实验的情况下，使用已经运行的实验中的数据来评估每一组超参数的训练误差。这样你就可以找到最优的超参数组合，并且可以使用训练误差作为评估指标。这样的好处在于，你可以在不重新运行实验的情况下，使用不同的评估指标来评估这些结果，从而找到最优的实验。相比之下，如果我们使用自适应随机搜索来调参，我们会根据之前实验的结果来动态调整采样策略这导致我们不能随意的更换目标，因为采样空间已经变化)    2.  Quasi-Random-Search以一致且数据上可重现的方式运行。        -   即使在搜索算法实现发生变化的情况下，只要它保持相同的均匀性，就应该可以重现六个月前的研究。 如果使用复杂的贝叶斯优化软件，实现可能会在版本之间发生重大变化，从而使旧搜索更难重现。 并非总是可以回滚到旧的实现（例如，如果优化工具作为服务运行）。    3.  它对搜索空间的统一探索使得对结果以及它们可能对搜索空间提出的建议的推理变得更容易。        -   例如，如果Quasi-Random-Search遍历中的最佳点位于搜索空间的边界，这是一个很好的（但不是万无一失的）信号，这表明应该更改搜索空间边界。我们在[这一节](#识别错误的搜索空间边界)会对此进行进一步探讨。 然而，自适应黑盒优化算法可能会因为一些不幸的早期试验而忽略了搜索空间的中间部分，尽管它包含相同优秀的点。因为正是这种不均匀性才是一个好的优化算法所需要的，它能加快搜索。    4.  与自适应算法相比，在使用Quasi-Random-Search（或其他非自适应搜索算法）时，并行运行与顺序运行不同数量的试验不会产生统计上不同的结果(这种误差会造成优化效果变差)。    5.  更复杂的搜索算法可能并不总能正确处理不可行的点，特别是如果它们在设计时未考虑神经网络超参数调整。    6.  Quasi-Random-Search很简单，在许多调优试验并行运行时特别高效。        -   实际上 [^3]，自适应算法很难击败预算是其两倍的Quasi-Random-Search，尤其是当许多试验需要并行运行时（因此当启动新试验时，很难利用先前的试验结果）。        -   如果没有贝叶斯优化和其他高级黑盒优化方法方面的专业知识，我们可能无法获得它们理论上能够提供的优势。 在实际的深度学习超参数调优条件下，很难对高级黑盒优化算法进行benchmark测试。 它们是当前研究中非常活跃的领域，对于没有经验的用户来说，更复杂的算法也有其自身的缺陷。 这些方法的专家能够获得良好的结果，但在高并行条件下，搜索空间和预算往往更为重要。-   这也就是说，如果我们的计算资源只允许少量试验并行运行，但我们能够按顺序运行许多试验。那么对我们来说，贝叶斯优化就会显得更具吸引力，尽管这会让我们更难解释我们的调优结果。[^3]: Ben Recht 和 Kevin Jamieson[指出](http://www.argmin.net/2016/06/20/hypertuning/) 使用2倍预算随机搜索作为Baseline有多强大（[Hyperband的论文](https://jmlr.org/papers/volume18/16-558/16-558.pdf)也有类似的观点），但肯定有可能找到最先进的贝叶斯优化技术可以击败两倍预算随机搜索的搜索空间和问题。然而，根据我们的经验，在高并行机制中击败 2 倍预算的随机搜索变得更加困难，因为贝叶斯优化没有机会观察先前试验的结果。</details><h3 id="在哪里可以找到Quasi-Random-Search的实现？"><a href="#在哪里可以找到Quasi-Random-Search的实现？" class="headerlink" title="在哪里可以找到Quasi-Random-Search的实现？"></a>在哪里可以找到Quasi-Random-Search的实现？</h3><details><summary><em>[点击展开]</em></summary><br>-   我们可以使用[这个实现](https://github.com/mlcommons/algorithmic-efficiency/blob/main/algorithmic_efficiency/halton.py)。它能够在给定搜索空间内生成（旨在按照https://arxiv.org/abs/1706.03200中建议来实现移位的、加扰的 Halton 序列）。-   如果基于低差异序列的Quasi-Random-Search算法不可用，则可以换成伪随机均匀搜索，虽然这可能效率稍低。    -   在 1-2 维中，网格搜索也是可以接受的，尽管在更高的维度中不行（详见[Bergstra & Bengio, 2012](https://www.jmlr.org/papers/v13/bergstra12a.html)）。</details><h3 id="需要多少次试验才能通过Quasi-Random-Search获得较好的结果？"><a href="#需要多少次试验才能通过Quasi-Random-Search获得较好的结果？" class="headerlink" title="需要多少次试验才能通过Quasi-Random-Search获得较好的结果？"></a>需要多少次试验才能通过Quasi-Random-Search获得较好的结果？</h3><details><summary><em>[点击展开]</em></summary><br><p align="center"><img src="tuning_playbook-have_we_sampled_enough.png" width="49%" alt="A box plot showing the importance of sampling enough"></p><p align="center"><b>Figure 3:</b> ResNet-50 在 ImageNet 上进行了 100 次试验调整。 通过自举，模拟了不同数量的调整预算。 上面绘制了每个试验预算的最佳性能的箱线图。-   这个问题没有办法笼统地回答，但是我们可以看具体的例子。-   正如Figure 3所示那样, 研究中的试验次数会对结果产生重大影响。    -   请注意，当对6个试验进行抽样时，与对20个试验进行抽样时的四分位间距有多大的区别。    -   即使进行了20次试验，运气特别好和运气特别差的研究之间的差异也可能大于使用固定超参数在不同随机种子上重新训练该模型之间的典型差异，对于此工作量可能约为 +/- 0.1% 的验证误差的概率约为 23%。</details><h3 id="如何调试和缓解优化失败"><a href="#如何调试和缓解优化失败" class="headerlink" title="如何调试和缓解优化失败"></a>如何调试和缓解优化失败</h3><details><summary><em>[点击展开]</em></summary><br>***总结***： *如果在优化模型时遇到困难，那么在尝试其他东西之前解决这些问题很重要。 诊断和纠正训练失败是一个活跃的研究领域。*<p align="center"><img src="tuning_playbook-stride_instability.png" width="80%" alt="Changing the strides in a single residual block in a WideResnet results in training instability."></p><p align="center"><b>Figure 4:</b> 在 WideResnet 中更改单个残差块 (2x2 -> 1x1) 中的步幅会导致训练不稳定。 这不会降低在低学习率下的性能，但由于不稳定的影响，高学习率不再能很好地进行训练。 使用1000步的学习率预热可以解决这种特殊的不稳定情况，允许以 0.1 的最大学习率进行稳定训练。</p>#### 识别不稳定的训练任务-   当学习率过大时，任何训练任务都会变得不稳定，但当不稳定迫使我们使用太小的学习率时，这才会是问题-   这里至少有两种类型的不稳定的训练任务值得需要进行区分：    1.  初始化/训练早期中存在的不稳定。    2.  训练中期突然出现的不稳定。-   我们可以采用系统的方法来找出训练任务中存在的稳定性问题.    1.  进行一次学习率扫描(不考虑学习率衰减的固定学习率)，并找到最佳的学习率 lr*.    2.  绘制学习率略高于 lr* 的训练损失曲线。    3.  如果学习率大于 lr* 的训练损失曲线显示不稳定（误差在训练期间上升而不下降），那么修复不稳定性可能会得到更好的训练结果(说明我们最佳的学习率比较临界)。-   在训练过程中记录全损失梯度的 L2 范数的变化(全损失梯度的 L2 范数是指在深度学习中，对于每个参数的梯度进行平方并相加后再取平方根的过程，反映了损失函数在当前状态下沿着梯度方向的变化程度。当前状态下的梯度向量越大，说明当前状态下的模型参数需要更大的更新量才能更好的逼近最优解)，如果我们发现全损失梯度的 L2 范数异常值非常大，这可能表明模型参数在某一时刻发生了非常大的变化，导致训练过程中出现不稳定性（例如误差上升而不下降）。 这可以告诉我们该如何选择梯度/更新剪辑。**注意：** 某些模型会在非常早期的阶段显示出不稳定的情况，随后出现恢复，这会导致出现缓慢但稳定的训练(这可能会成为问题)。 **常见的评估方法可能会因为评估不够频繁而错过这些问题！**为了检查出这一问题，我们可以使用 `lr = 2 * current best` 来进行一次仅包含500次训练的计划，但每执行一次训练都要进行一次评估。<p align="center"><img src="tuning_playbook-more_frequent_evals.png" width="80%" alt="Illustration of the value of more frequent evaluations at the start oftraining."></p><p align="center"><b>Figure 5:</b> 该图展示的是训练开始时频繁更新评估的结果。如果怀疑模型受到早期训练不稳定的影响，则很有用。</p>#### 常见不稳定模式的潜在修复方式-   使用学习率预热    -   最适合用于早期训练不稳定的情况。-   使用梯度截断    -   对于早期和中期训练中不稳定情况都有好处，可能会解决一些学习率预热无法解决的问题。-   尝试使用新的优化器    -   Adam 有时可以处理一些 Momentum 无法处理的不稳定影响。这也是该领域的一个活跃研究领域。-   确保使用最佳实践/初始化：    -   例如，如果模型中尚未包含残差连接和归一化，则添加它们。-   归一化应该是残差之前的最后一个操作。例如， x +Norm(f(x))。-   众所周知，Norm(x + f(x)) 会引起问题。(译注：Norm相当于白化，意在降低层参数的训练敏感性，而残差大大增加了训练参的敏感性，所有在残差前的f(x)归一化有助于降低不稳定性)-   尝试将残差调控因子初始化为 0 （例如，[ReZero init所示](https://arxiv.org/abs/2003.04887)）$\boldsymbol{x}_{i+1}=\boldsymbol{x}_i+\alpha_i F\left(\boldsymbol{x}_i\right)$.-   降低学习率    -   这是最终手段。#### 学习率预热<p align="center"><img src="tuning_playbook-instability_during_warmup.png" width="80%" alt="An example of instability during a warmup period (note the horizontal axis logscale)."></p><p align="center"><b>Figure 6:</b> 预热期间不稳定的示例（注意横轴的刻度是以对数的形式展示）。 在这种情况下，成功训练需要4万次的预热。</p>##### 何时对学习率进行预热<p align="center"><img src="tuning_playbook-axis_model_with_instability.png" width="49%" alt="Axis plot for model with instability"></p><p align="center"><b>Figure 7a:</b> 表现出训练不稳定性的模型的超参数轴图示例。 最佳学习率处于可行的边缘。 “不可行”试验被定义为产生 NaN 或异常高的损失值的试验。</p><p align="center"><img src="tuning_playbook-loss_model_with_instability.png" width="49%" alt="Loss curve for model with instability"></p><p align="center"><b>Figure 7b:</b> 模型训练损失中不稳定的学习率</p>-   Figure 7a 展示的是一个超参数轴图，该图表明模型正在经历训练不稳定，因为最佳学习率恰好位于可行的边缘。-   Figure 7b展示了以5-10倍的峰值学习率来训练模型中产生的训练损失是如何通过双重检查的。如果该图展示的训练损失在稳步下降后突然上升（例如，如图中10000步处展示的那样），那么该模型可能存在着优化不稳定性的情况。##### 如何对学习率进行预热<p align="center"><img src="tuning_playbook-beneficial_effect_warmup.png" width="80%" alt="Beneficial effect of warmup on training instabilities"></p><p align="center"><b>Figure 8:</b> 学习率预热对解决训练不稳定性的有益影响</p>-   在上面的内容中，我们假设从业者已经确定了让模型变得不稳定的学习率。也就是 `unstable_base_learning_rate`。-   预热的过程涉及了预先安排一个学习率计划，这个计划会将学习率从0提升到某个稳定的 `base_learning_rate`，这至少比 `unstable_base_learning_rate`要大一个数量级。    默认设置是尝试使用 `unstable_base_learning_rate` 10倍大小的 `base_learning_rate`。值得注意的是，对于使用例如100倍    `unstable_base_learning_rate`这样的数值，那么可能需要重新运行整个过程。具体安排如下：    -   在`warmup_steps`的过程中，将数值从0提升到 `base_learning_rate`。    -   `post_warmup_steps`的过程中，以一个恒定的速率进行训练。-   我们的目标是找到最少的 `warmup_steps`，以此来让我们获得远高于`unstable_base_learning_rate`的峰值学习率。-   因此，对于，每个 `base_learning_rate`来说， 我们需要对 `warmup_steps` 以及`post_warmup_steps`进行调优。 通常将 `post_warmup_steps` 设定为`warmup_steps`的两倍就可以了。-   预热可以独立于现有的衰减计划进行调整。    `warmup_steps` 应该以几个不同的数量级进行扫描。例如，在样本学习中可以以[10, 10<sup>3</sup>, 10<sup>4</sup>,10<sup>5</sup>]这样的数量级进行尝试。最大的搜索值不应超过`max_train_steps`的10%。-   一旦建立了不会破坏以 `base_learning_rate` 进行训练的`warmup_steps`，就应该将其应用于Baseline模型。    本质上，我们将这个安排添加到现有安排上，并使用上面讨论中选择的最佳检查点来将这个实验与Baseline进行比较。例如，如果我们一开始的`max_train_steps`的值是10000，    并进行了1000次`warmup_steps`。那么，新的训练过程总共应当进行了11000次。-   如果稳定训练需要较长的`warmup_steps`（大于`max_train_steps`的5%），则可能需要增加`max_train_steps`来解决这个问题。-   在整个工作量的范围中并不存在真正意义上的`标准`值。有些模型可能只需要100次训练，然而有些模型则可能需要4万次以上的训练，尤其是Transformer类。#### 梯度截断<p align="center"><img src="tuning_playbook-gradient_clipping.png" width="80%" alt="Gradient clipping on early training instabilities"></p><p align="center"><b>Figure 9:</b> 梯度截断纠正早期训练不稳定性的图示。</p>-   当出现较大或离群的梯度问题时，梯度截断会变得非常有用。-   梯度截断可以修复早期训练中出现的不稳定性（早期较大的梯度范数），或中期训练中出现的不稳定性（训练中期突然出现的梯度尖峰）。-   有时，较长的预热时间可以纠正梯度截断无法纠正的不稳定性: 请查看[之前的章节](#如何对学习率进行预热)。    -   🤖 在预热的时候，进行梯度截断会发生什么？-   理想的截断阈值要刚好高于“典型的”梯度范数。-   下面是一个关于如何进行梯度截断的案例：    -   如果梯度范数 $\left | g \right |$ 大于梯度截断的阈值 $\lambda$，那么就需要进行 ${g}'= \lambda \times \frac{g}{\left | g \right |}$。此处的 ${g}'$是新的梯度。-   在训练期间记录下未截断梯度范数。 默认情况下会生成:    -   梯度范数与步骤数量的关系图    -   聚合所有步数的梯度范数直方图-   根据梯度范数的第90百分位数选择梯度截断阈值。    -   这个阈值的大小与工作量有关。但90%是一个很好的选择。但如果这个奏效，那么可以对其进行调优。    -   🤖 那么，某种适应性策略会怎么样呢?-   如果我们尝试梯度截断并且不稳定问题仍然存在，那么我们可以更努力地尝试（例如，阈值更小）。-   极端激进的梯度截断本质上是一种降低学习率的奇怪方式。 如果我们发现自己使用了非常激进的截断，那么我们可能应该只降低学习率。-   我们通常会认为以某种方式将超过 50% 的更新剪裁为“极其激进”。-   如果我们需要进行极其激进的梯度截断来处理我们的不稳定问题，那么我们不妨降低学习率。</details><h3 id="为什么将学习率和其他优化参数称为超参数？-它们不是任何先验分布的参数。"><a href="#为什么将学习率和其他优化参数称为超参数？-它们不是任何先验分布的参数。" class="headerlink" title="为什么将学习率和其他优化参数称为超参数？ 它们不是任何先验分布的参数。"></a>为什么将学习率和其他优化参数称为超参数？ 它们不是任何先验分布的参数。</h3><details><summary><em>[点击展开]</em></summary><br>-   确实，在贝叶斯机器学习中，“超参数”这一术语拥有一种更加精确的[含义](https://en.wikipedia.org/wiki/Hyperparameter)，我们在深度学习中调优的学习率和大部分其他被叫做“超参数”的参数都是对术语的一种滥用。-   我们更愿意使用“元参数”这个术语来表示学习率、架构参数以及我们在深度学习中调整的所有其他参数， 因为它避免了因滥用“超参数”一词而引起的潜在混淆（例如，可能在讨论贝叶斯优化时，概率响应曲面模型拥有它自己的真实超参数，此时使用超参数一词是不合适的。）-   不幸的是，尽管可能会造成混淆，但超参数这个术语在深度学习社区中已经变得极为通俗。-   因此，对于一份文档而言，例如本文。为了面向普通大众，我们决定为该领域的一个混乱来源做出贡献，希望避免产生另一个混淆。-   也就是说，在发布一篇研究论文的时候，我们可能采取了一种不同的说法。并且，在大多数情况下，我们推荐其他人使用“元参数”这个说法。</details><h3 id="为什么不应该调整Batch-Size来直接提高验证集性能"><a href="#为什么不应该调整Batch-Size来直接提高验证集性能" class="headerlink" title="为什么不应该调整Batch Size来直接提高验证集性能?"></a>为什么不应该调整Batch Size来直接提高验证集性能?</h3><details><summary><em>[点击展开]</em></summary><br>-   *在不更改训练工作流其他细节的情况下*， 修改batch size 通常会影响验证集的性能。-   但是，如果针对每个batch size单独调优，则两个batch size之间的验证集性能差异通常会消失。-   受batch size影响最强烈的那些超参数，即优化器超参数（例如：学习率、动量）和正则化超参数，这些东西对于每个batch size进行单独调优的时候是最重要的。    - 由于样本方差的原因，较小的batch size会在训练算法中引入更多的不确定性，并且这些不确定性可能存在着正则化效果。因此，较大的batch size可能更容易过度拟合。并且，这可能需要更强的正则化和/或额外的正则化技术。- 此外， 当修改batch size的大小时，[训练步骤的数量可能也需要进行调整](#choosing-the-batch-size-to-minimize-training-time)。-   一旦考虑了所有这些因素带来的影响，目前还没有任何能够令人信服的证据表明batch size会影响最大可实现的验证性能（具体请阅读 [Shallue et al. 2018](https://arxiv.org/abs/1811.03600)）。</details><h3 id="所有流行的优化算法的更新规则是什么？"><a href="#所有流行的优化算法的更新规则是什么？" class="headerlink" title="所有流行的优化算法的更新规则是什么？"></a>所有流行的优化算法的更新规则是什么？</h3><details><summary><em>[点击展开]</em></summary><br>#### Stochastic gradient descent (SGD)$$\theta_{t+1} = \theta_{t} - \eta_t \nabla \mathcal{l}(\theta_t)$$#### Momentum$$v_0 = 0$$$$v_{t+1} = \gamma v_{t} + \nabla \mathcal{l}(\theta_t)$$$$\theta_{t+1} = \theta_{t} - \eta_t v_{t+1}$$#### Nesterov$$v_0 = 0$$$$v_{t+1} = \gamma v_{t} + \nabla \mathcal{l}(\theta_t)$$$$\theta_{t+1} = \theta_{t} - \eta_t( \gamma v_{t+1} + \nabla \mathcal{l}(\theta_{t})$$#### RMSProp$$v_0 = 1 \text{,} m_0 = 0$$$$v_{t+1} = \rho v_{t} + (1 - \rho) \nabla \mathcal{l}(\theta_t)^2$$$$m_{t+1} = \gamma m_{t} + \frac{\eta_t}{\sqrt{v_{t+1} + \epsilon}}\nabla \mathcal{l}(\theta_t)$$$$\theta_{t+1} = \theta_{t} - m_{t+1}$$#### ADAM$$m_0 = 0 \text{,} v_0 = 0$$$$m_{t+1} = \beta_1 m_{t} + (1 - \beta_1) \nabla \mathcal{l} (\theta_t)$$$$v_{t+1} = \beta_2 v_{t} + (1 - \beta_2) \nabla \mathcal{l}(\theta_t)^2$$$$b_{t+1} = \frac{\sqrt{1 - \beta_2^{t+1}}}{1 - \beta_1^{t+1}}$$$$\theta_{t+1} = \theta_{t} - \alpha_t \frac{m_{t+1}}{\sqrt{v_{t+1}} + \epsilon} b_{t+1}$$#### NADAM$$m_0 = 0 \text{,} v_0 = 0$$$$m_{t+1} = \beta_1 m_{t} + (1 - \beta_1) \nabla \mathcal{l} (\theta_t)$$$$v_{t+1} = \beta_2 v_{t} + (1 - \beta_2) \nabla \mathcal{l} (\theta_t)^2$$$$b_{t+1} = \frac{\sqrt{1 - \beta_2^{t+1}}}{1 - \beta_1^{t+1}}$$$$\theta_{t+1} = \theta_{t} - \alpha_t \frac{\beta_1 m_{t+1} + (1 - \beta_1) \nabla \mathcal{l} (\theta_t)}{\sqrt{v_{t+1}} + \epsilon} b_{t+1}$$</details><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li>我们要感谢Max Bileschi, Roy Frostig, Zelda Mariet, Stan<br>Bileschi, Mohammad Norouzi, Chris DuBois以及Charles Sutton 阅读本手稿并提出宝贵的意见来改进我们的内容。</li><li>我们复用了最初由Naman Agarwal为其他联合研究制作的几个分析图的一些实验数据。</li><li>我们要感谢Will Chen对文档演讲内容提出的宝贵建议。</li><li>我们还要感谢 Rohan Anil 与我们进行了有益的讨论。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@misc&#123;tuningplaybookgithub,</span><br><span class="line">  author = &#123;Varun Godbole and George E. Dahl and Justin Gilmer and Christopher J. Shallue and Zachary Nado&#125;,</span><br><span class="line">  title = &#123;Deep Learning Tuning Playbook&#125;,</span><br><span class="line">  url = &#123;http://github.com/google/tuning_playbook&#125;,</span><br><span class="line">  year = &#123;2023&#125;,</span><br><span class="line">  note = &#123;Version 1.0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于贡献"><a href="#关于贡献" class="headerlink" title="关于贡献"></a>关于贡献</h2><ul><li><p>这并不是一款由谷歌官方所支持的产品。</p></li><li><p>我们欢迎听到来自您的反馈。</p><ul><li>如果你喜欢这本手册, 请给我们 <a href="https://docs.github.com/en/get-started/exploring-projects-on-github/saving-repositories-with-stars#starring-a-repository">留一颗小星星</a>！或者，可以给我们的邮箱<br>deep-learning-tuning-playbook [at] googlegroups.com发送邮件。 这些推荐有帮于证明我们创建更多这样的内容是合理的。</li><li>如果有任何不正确的地方，欢迎在GitHub的讨论区提出相关问题。对于不适合问题的问题或其他消息，请在 GitHub 上打开一个新的讨论主题。</li></ul></li><li><p>正如在序言中所讨论的，这是一份在线文档。我们会定期进行大大小小的修改。如果你想获取相关通知，请关注我们的仓库 (具体配置请查看 <a href="https://docs.github.com/en/account-and-profile/managing-subscriptions-and-notifications-on-github/setting-up-notifications/configuring-notifications#configuring-your-watch-settings-for-an-individual-repository">操作指南</a>).</p></li><li><p>请不要在未通过问题跟踪系统与作者协调的情况下提交pull request。</p></li></ul><h3 id="贡献者许可协议"><a href="#贡献者许可协议" class="headerlink" title="贡献者许可协议"></a>贡献者许可协议</h3><p>对该项目的贡献必须附有贡献者许可协议 (CLA)。 对于你（或你的雇主）所贡献的内容将保留其相关版权； 这只是允许我们使用和重新分配您的贡献作为项目的一部分。 请前往 <a href="https://cla.developers.google.com/">https://cla.developers.google.com/</a> 查看您当前存档的协议或签署新协议。</p><p>通常，您只需要签署一次CLA协议即可。因此，如果您已经签署过一次（即使针对的是其他项目），那么您可能无需再次签署。</p><h3 id="代码审核"><a href="#代码审核" class="headerlink" title="代码审核"></a>代码审核</h3><p>所有的提交（包括来自项目成员的提交）都需要进行审核。出于这个目的，我们会使用Github提供的pull request功能来进行代码审核。 关于如何使用pull request，请查看<br><a href="https://help.github.com/articles/about-pull-requests/">GitHub Help</a> 获取更多信息.</p><h3 id="社区指南"><a href="#社区指南" class="headerlink" title="社区指南"></a>社区指南</h3><p>本项目遵循<br><a href="https://opensource.google/conduct/">谷歌开源社区指南</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BERT在情感分析ATSC子任务的应用</title>
      <link href="/2022/10/03/nlp-sentiment-analysis-bert-atsc/"/>
      <url>/2022/10/03/nlp-sentiment-analysis-bert-atsc/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍论文<a href="https://arxiv.org/abs/1908.11860">Adapt or Get Left Behind: Domain Adaptation through BERT Language Model Finetuning for Aspect-Target Sentiment Classification</a>及其代码实现。</p><span id="more"></span><p><strong>目录</strong></p><ul><li>TOC<br>{:toc}</li></ul><h2 id="论文解读"><a href="#论文解读" class="headerlink" title="论文解读"></a>论文解读</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>最早的情感分析只是判断文本(可以是一句话或者一段长文本)的情感倾向，但是很多实际应用需要更细粒度的分析，这就出现了Aspect Based Sentiment Analysis (ABSA)任务，不了解的读者可以先参考<a href="/2019/09/25/sentiment-analysis-survey/">情感分析简介</a>。ABSA任务有两种方法：ACD+ACSC和ATE+ATSC。</p><p>ACD是Aspect Category Detection的缩写，ACSC是Aspect Category Sentiment Classification的缩写。ACD是一个多标签(multi-label)分类问题，一个句子可以同时说多个aspect category。以句子”I love their dumplings”为例，ACD会把它分类为food这个category，而ACSC会把这个aspect的情感分类为正面。</p><p>ATE是Aspect Target Extraction的缩写，而ATSC是Aspect Target Sentiment Classification的缩写。还是以”I love their dumplings”为例，ATE抽取的是dumplings，ATSC会把对于dumplings的情感分类为正面。</p><p>本文解决的就是ATSC的问题，也就是给定一个句子和Aspect Target(比如dumplings)，判断它的情感分类。注意：一个句子可能包括多个Aspect Target，比如”这个酒店的位置很好但是服务一般”，则它有”位置”和”服务”两个Aspect Target，它们的情感分类分别是正面和负面。对于这个句子，会进行两次预测，首先的输入是”这个酒店的位置很好但是服务一般”+”位置”，输出应该是正面；接着输入是”这个酒店的位置很好但是服务一般”+”服务”，输出是负面。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>本文的方法非常简单，就是使用BERT来进行分类，对BERT不熟悉的读者可以先参考<a href="/2019/03/05/bert-prerequisites/">BERT课程</a>。因为有句子和Target两个输入，所以在fine-tuning是会把它们拼接起来。假设句子是s，Target是t，则BERT在fine-tuning时的输入是”[CLS] s [SEP] t [SEP]”。另外本文能取得很好结果的原因就是使用了大量领域数据来pretraining BERT，因为Wiki等语料库和评论的差别还是比较大的。比如在wiki里，”The touchscreen is an [MASK] device”，[MASK]很可能是”input”这样的词，而在评论里，[MASK]更可能是”amazing”这样的词。</p><p>论文使用了Yelp的酒店评论数据和Amazon的电子产品的评论数据来对BERT模型进行pretraining(初始为Google模型)，在酒店的ATSC任务上取得里很好的成绩，下图是实验结果。</p><p><a name='img1'><img src="/img/nlp-sentiment-analysis-bert-atsc.png" alt=""></a><br><em>图：实验结果</em></p><p>这篇文章的方法在酒店的数据集上效果很好，但是在笔记本电脑上并没有取得最好的结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><h4 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/deepopinion/domain-adapted-atsc.git</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python -m venv venv</span><br><span class="line">source venv/bin/activate</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">python -m spacy download en_core_web_sm</span><br><span class="line">mkdir -p data/raw/semeval2014  # creates directories for data</span><br><span class="line">mkdir -p data/transformed</span><br><span class="line">mkdir -p data/models</span><br></pre></td></tr></table></figure><p>为了进行fine-tuning，需要安装pytorch、pytorch-transformers和apex。我们首先安装pytorch和pytorch-transformer：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install scipy sckit-learn</span><br><span class="line">pip install https://download.pytorch.org/whl/cu100/torch-1.1.0-cp36-cp36m-linux_x86_64.whl</span><br><span class="line">pip install pytorch-transformers tensorboardX</span><br></pre></td></tr></table></figure><p>注意：上面安装的是pytorch-1.1.0的GPU版本，它需要CUDA-10.0。</p><p>接着需要安装apex：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">git clone https://github.com/NVIDIA/apex</span><br><span class="line">cd apex</span><br><span class="line">pip install -v --no-cache-dir --global-option=&quot;--cpp_ext&quot; --global-option=&quot;--cuda_ext&quot; ./</span><br></pre></td></tr></table></figure><p>作者执行最后的pip install时碰到了一些小困难。它会提示nvcc的版本和编译pytorch的不一致(因为pytorch是用pip而不是从源代码安装的)，因此需要修改setup.py去掉下面的检查的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_cuda_torch_binary_vs_bare_metal(torch.utils.cpp_extension.CUDA_HOME)</span><br></pre></td></tr></table></figure><p>去掉之后就可以用最后pip install 安装apex了。</p><h4 id="准备fine-tuning-BERT语言模型的数据"><a href="#准备fine-tuning-BERT语言模型的数据" class="headerlink" title="准备fine-tuning BERT语言模型的数据"></a>准备fine-tuning BERT语言模型的数据</h4><p>这个步骤是准备fine-tuning(其实是在BERT基础模型的基础上继续pretraining)语言模型的数据，作者也提供了他fine-tuning之后的模型，如果读者不想自己fine-tuning语言模型可以跳过这一步。</p><p>作者用来fine-tuning laptop任务的数据来自Amazon的电子产品的数据，参考<a href="http://jmcauley.ucsd.edu/data/amazon/amazon_readme.txt">这个链接</a>，大家可以发邮件给julian.mcauley@gmail.com来申请这个数据集。mcauley的邮件会给出下载的链接，读者也需要下载的是reviews_Electronics.json.gz和meta_Electronics.json.gz两个文件，注意别下载错了。这两个文件分别为1.7GB和178MB。</p><p>而fine-tuning restaurant的数据集来自yelp，大家可以点击<a href="https://www.yelp.com/dataset/download">这里</a>下载，下载得到一个yelp_dataset.tar.gz。解压它可以得到一个review.json文件，这个文件的大小是5.0GB。</p><p>把这些文件都放到data/raw下，类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lili@lili-Precision-7720:~/codes/domain-adapted-atsc/data/raw$ ls</span><br><span class="line">meta_Electronics.json.gz  review.json  reviews_Electronics.json.gz</span><br></pre></td></tr></table></figure><p>数据预处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python prepare_laptop_reviews.py</span><br><span class="line">python prepare_restaurant_reviews.py</span><br><span class="line">python prepare_restaurant_reviews.py --large  # takes some time to finish</span><br></pre></td></tr></table></figure><p>处理后在data/transformed/下会得到laptop_corpus_1019917.txt这样的文件，这是BERT pretraining需要的数据格式，我们可以看几行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ head laptop_corpus_1019917.txt </span><br><span class="line">This product has proven to be a communication breakthrough for my brother who has gone deaf in his elder years.</span><br><span class="line">He is not computer literate and cannot type.</span><br><span class="line">However, he quickly picked up on how to use this machine which plugs into the phone line.</span><br><span class="line">I love it!</span><br><span class="line">It has ended our one way conversations for he can now read whatever I send him and either respond by email or by calling (I can hear him just fine).</span><br><span class="line">I think this is a very useful product!</span><br><span class="line">I gave this product 1 star based on problems I have encountered with one I bought for my in-laws.</span><br><span class="line">(See previous review).</span><br></pre></td></tr></table></figure></p><p>文档之间用一个空行分割开，每行表示一个句子，这是BERT需要的。</p><p>因为论文还把两个数据集混合在一起训练，所以还有一个步骤是把两个数据cat到一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd data/transformed</span><br><span class="line">cat laptop_corpus_1011255.txt restaurant_corpus_1000004.txt &gt; mixed_corpus.txt</span><br></pre></td></tr></table></figure><h4 id="下载SemEval-2014数据"><a href="#下载SemEval-2014数据" class="headerlink" title="下载SemEval 2014数据"></a>下载SemEval 2014数据</h4><p>请读者去<a href="http://metashare.ilsp.gr:8080/repository/search/?q=semeval+2014">这里</a>所有SemEval 2014的数据，下载后类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lili@lili-Precision-7720:~/codes/domain-adapted-atsc/data/raw/semeval2014$ tree</span><br><span class="line">.</span><br><span class="line">├── SemEval-2014 ABSA Test Data - Gold Annotations</span><br><span class="line">│   ├── ABSA_Gold_TestData</span><br><span class="line">│   │   ├── Laptops_Test_Gold.xml</span><br><span class="line">│   │   └── Restaurants_Test_Gold.xml</span><br><span class="line">│   └── Laptops_Test_Gold.xml</span><br><span class="line">└── SemEval-2014 ABSA Train Data v2.0 &amp; Annotation Guidelines</span><br><span class="line">    ├── Laptop_Train_v2.xml</span><br><span class="line">    └── Restaurants_Train_v2.xml</span><br></pre></td></tr></table></figure><p>请参考上面的目录结构放置解压后的文件(如果是Windows的话可能文件名不能用&amp;，那么需要重命名，代码也需要修改)。</p><p>我们看一下SemEval-2014 ABSA Train Data v2.0 &amp; Annotation Guidelines/Restaurants_Train_v2.xml这个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 1 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span><br><span class="line"> 2 &lt;sentences&gt;</span><br><span class="line"> 3     &lt;sentence id=&quot;3121&quot;&gt;</span><br><span class="line"> 4         &lt;text&gt;But the staff was so horrible to us.&lt;/text&gt;</span><br><span class="line"> 5         &lt;aspectTerms&gt;</span><br><span class="line"> 6             &lt;aspectTerm term=&quot;staff&quot; polarity=&quot;negative&quot; from=&quot;8&quot; to=&quot;13&quot;/&gt;</span><br><span class="line"> 7         &lt;/aspectTerms&gt;</span><br><span class="line"> 8         &lt;aspectCategories&gt;</span><br><span class="line"> 9             &lt;aspectCategory category=&quot;service&quot; polarity=&quot;negative&quot;/&gt;</span><br><span class="line">10         &lt;/aspectCategories&gt;</span><br><span class="line">11     &lt;/sentence&gt;</span><br><span class="line">12     &lt;sentence id=&quot;2777&quot;&gt;</span><br><span class="line">13         &lt;text&gt;To be completely fair, the only redeeming factor was the food, which was above average, but co      uldn&#x27;t make up for all the other deficiencies of Teodora.&lt;/text&gt;</span><br><span class="line">14         &lt;aspectTerms&gt;</span><br><span class="line">15             &lt;aspectTerm term=&quot;food&quot; polarity=&quot;positive&quot; from=&quot;57&quot; to=&quot;61&quot;/&gt;</span><br><span class="line">16         &lt;/aspectTerms&gt;</span><br><span class="line">17         &lt;aspectCategories&gt;</span><br><span class="line">18             &lt;aspectCategory category=&quot;food&quot; polarity=&quot;positive&quot;/&gt;</span><br><span class="line">19             &lt;aspectCategory category=&quot;anecdotes/miscellaneous&quot; polarity=&quot;negative&quot;/&gt;</span><br><span class="line">20         &lt;/aspectCategories&gt;</span><br><span class="line">21     &lt;/sentence&gt;</span><br></pre></td></tr></table></figure><p>对于ATSC这个任务，输入是”But the staff was so horrible to us.”和”staff”，输出是negative这个分类。</p><p>因为SemEval 2014分类包括冲突(conflict)，作者把冲突的数据去掉了。下面的脚本就是处理掉这些数据，首先是laptop的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># laptops</span><br><span class="line"># laptops without conflict label</span><br><span class="line">python prepare_semeval_datasets.py \</span><br><span class="line">--files &quot;data/raw/semeval2014/SemEval-2014 ABSA Train Data v2.0 &amp; Annotation Guidelines/Laptop_Train_v2.xml&quot; \</span><br><span class="line">--output_dir data/transformed/laptops_noconfl \</span><br><span class="line">--istrain \</span><br><span class="line">--noconfl</span><br><span class="line">python prepare_semeval_datasets.py \</span><br><span class="line">--files &quot;data/raw/semeval2014/SemEval-2014 ABSA Test Data - Gold Annotations/ABSA_Gold_TestData/Laptops_Test_Gold.xml&quot; \</span><br><span class="line">--output_dir data/transformed/laptops_noconfl \</span><br><span class="line">--noconfl</span><br></pre></td></tr></table></figure><p>然后是restaurant：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># restaurants without conflict label</span><br><span class="line">python prepare_semeval_datasets.py \</span><br><span class="line">--files &quot;data/raw/semeval2014/SemEval-2014 ABSA Train Data v2.0 &amp; Annotation Guidelines/Restaurants_Train_v2.xml&quot; \</span><br><span class="line">--output_dir data/transformed/restaurants_noconfl \</span><br><span class="line">--istrain \</span><br><span class="line">--noconfl</span><br><span class="line">python prepare_semeval_datasets.py \</span><br><span class="line">--files &quot;data/raw/semeval2014/SemEval-2014 ABSA Test Data - Gold Annotations/ABSA_Gold_TestData/Restaurants_Test_Gold.xml&quot; \</span><br><span class="line">--output_dir data/transformed/restaurants_noconfl \</span><br><span class="line">--noconfl</span><br></pre></td></tr></table></figure><p>最后是混合的训练数据：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># mixed without conflict label</span><br><span class="line">python prepare_semeval_datasets.py \</span><br><span class="line">--files &quot;data/raw/semeval2014/SemEval-2014 ABSA Train Data v2.0 &amp; Annotation Guidelines/Restaurants_Train_v2.xml&quot; \</span><br><span class="line">&quot;data/raw/semeval2014/SemEval-2014 ABSA Train Data v2.0 &amp; Annotation Guidelines/Laptop_Train_v2.xml&quot; \</span><br><span class="line">--output_dir data/transformed/mixed_noconfl \</span><br><span class="line">--istrain --noconfl</span><br><span class="line">python prepare_semeval_datasets.py \</span><br><span class="line">--files &quot;data/raw/semeval2014/SemEval-2014 ABSA Test Data - Gold Annotations/ABSA_Gold_TestData/Restaurants_Test_Gold.xml&quot; \</span><br><span class="line">&quot;data/raw/semeval2014/SemEval-2014 ABSA Test Data - Gold Annotations/ABSA_Gold_TestData/Laptops_Test_Gold.xml&quot; \</span><br><span class="line">--output_dir data/transformed/mixed_noconfl --noconfl</span><br></pre></td></tr></table></figure></p><h4 id="使用作者pretraining好的BERT语言模型来fine-tuning-ATSC-restaurant任务"><a href="#使用作者pretraining好的BERT语言模型来fine-tuning-ATSC-restaurant任务" class="headerlink" title="使用作者pretraining好的BERT语言模型来fine-tuning ATSC restaurant任务"></a>使用作者pretraining好的BERT语言模型来fine-tuning ATSC restaurant任务</h4><p>我们这里只尝试restaurant数据集，首先在<a href="https://drive.google.com/file/d/1DmVrhKQx74p1U5c7oq6qCTVxGIpgvp1c/view?usp=sharing">这里</a>下载作者pretraining好的BERT模型。下载后放到data/models下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lili@lili-Precision-7720:~/codes/domain-adapted-atsc/data/models$ tree restaurants_10mio_ep3/</span><br><span class="line">restaurants_10mio_ep3/</span><br><span class="line">├── added_tokens.json</span><br><span class="line">├── config.json</span><br><span class="line">├── pytorch_model.bin</span><br><span class="line">├── special_tokens_map.json</span><br><span class="line">└── vocab.txt</span><br></pre></td></tr></table></figure><p>然后基于这个模型进行监督的fine-tuning：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd finetuning_and_classification</span><br><span class="line">python run_glue.py \ </span><br><span class="line">--model_type bert \</span><br><span class="line">--model_name_or_path ../data/models/restaurants_10mio_ep3 \</span><br><span class="line">--do_train --evaluate_during_training --do_eval \</span><br><span class="line">--logging_steps 100 --save_steps 1200 --task_name=semeval2014-atsc \</span><br><span class="line">--seed 42 --do_lower_case \</span><br><span class="line">--data_dir=../data/transformed/restaurants_noconfl \</span><br><span class="line">--output_dir=../data/models/semeval2014-atsc-bert-ada-restaurants-restaurants \</span><br><span class="line">--max_seq_length=128 --learning_rate 3e-5 --per_gpu_eval_batch_size=8 --per_gpu_train_batch_size=8 \</span><br><span class="line">--gradient_accumulation_steps=1 --max_steps=800 --overwrite_output_dir --overwrite_cache --warmup_steps=120 --fp16</span><br></pre></td></tr></table></figure><p>请根据GPU的内存修改per_gpu_eval_batch_size和per_gpu_train_batch_size两个参数，我这里使用是8。</p><p>最终作者得到的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10/21/2019 09:41:51 - INFO - __main__ -   ***** Eval results  *****</span><br><span class="line">10/21/2019 09:41:51 - INFO - __main__ -     acc = 0.8723214285714286</span><br><span class="line">10/21/2019 09:41:51 - INFO - __main__ -     f1_macro = 0.7945154951637271</span><br></pre></td></tr></table></figure><p>基本和论文里的87%的准确率以及80%的F1得分是差不多的。</p><h4 id="自己使用Yelp来pretrainng语言模型"><a href="#自己使用Yelp来pretrainng语言模型" class="headerlink" title="自己使用Yelp来pretrainng语言模型"></a>自己使用Yelp来pretrainng语言模型</h4><p>因为训练1000万的语料太费时间，我这里只使用里100万的数据进行了3个epoch。</p><p>首先需要生成BERT需要的训练数据，这可以使用下面的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">python pregenerate_training_data.py \</span><br><span class="line">--train_corpus \</span><br><span class="line">../data/transformed/restaurant_corpus_1000000.txt \</span><br><span class="line">--bert_model \</span><br><span class="line">bert-base-uncased \</span><br><span class="line">--do_lower_case \</span><br><span class="line">--output_dir \</span><br><span class="line">dev_corpus_prepared/ \</span><br><span class="line">--epochs_to_generate \</span><br><span class="line">3 \</span><br><span class="line">--max_seq_len \</span><br><span class="line">256</span><br></pre></td></tr></table></figure><p>接着进行pretraining：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python finetune_on_pregenerated.py \</span><br><span class="line">--pregenerated_data dev_corpus_prepared/ \</span><br><span class="line">--bert_model bert-base-uncased \</span><br><span class="line">--do_lower_case \</span><br><span class="line">--output_dir dev_corpus_finetuned/ \</span><br><span class="line">--epochs 2 \</span><br><span class="line">--train_batch_size 4 \</span><br></pre></td></tr></table></figure></p><p>然后用自己pretraining的模型再进行fine-tuning：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python run_glue.py \ </span><br><span class="line">--model_type bert \</span><br><span class="line">--model_name_or_path dev_corpus_finetuned/ \</span><br><span class="line">--do_train --evaluate_during_training --do_eval \</span><br><span class="line">--logging_steps 100 --save_steps 1200 --task_name=semeval2014-atsc \</span><br><span class="line">--seed 42 --do_lower_case \</span><br><span class="line">--data_dir=../data/transformed/restaurants_noconfl \</span><br><span class="line">--output_dir=../data/models/semeval2014-atsc-bert-ada-restaurants-restaurants \</span><br><span class="line">--max_seq_length=128 --learning_rate 3e-5 --per_gpu_eval_batch_size=8 --per_gpu_train_batch_size=8 \</span><br><span class="line">--gradient_accumulation_steps=1 --max_steps=800 --overwrite_output_dir --overwrite_cache --warmup_steps=120 --fp16</span><br></pre></td></tr></table></figure><p>这个和前面的唯一区别就是--model_name_or_path使用了我们自己的模型。因为没有使用大量的数据，最终的效果比作者pretraining的要差一些。从这里也能看出，如果读者要对自己领域的数据进行情感分析的话，最好还是找大量未标注的语料库pretraining之后在用监督数据进行fine-tuning效果会更好。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentiment analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情感分析简介</title>
      <link href="/2022/10/02/nlp-sentiment-analysis-survey/"/>
      <url>/2022/10/02/nlp-sentiment-analysis-survey/</url>
      
        <content type="html"><![CDATA[<p>本文是对情感分析这个问题(领域)的调研，对于问题的定义和介绍主要参考了<a href="https://www.cs.uic.edu/~liub/FBS/sentiment-opinion-emotion-analysis.html">Sentiment Analysis: mining sentiments, opinions, and emotions</a>，虽然这本书写于2015年，很多当时SOTA的方法现在已经过时了，但是本书对于问题的介绍和描述非常详细和清晰，强烈建议对情感分析领域有兴趣的读者阅读。</p><span id="more"></span><p><strong>目录</strong></p><ul><li>TOC<br>{:toc}</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><p>情感分析(sentiment analysis)，也叫作观点挖掘(opinion mining)，它的研究问题是分析人们通过文本表达的对某个实体(entity)的观点(opinion)、情感(sentiment)、评价(appraisal)、态度(attitude)和情绪(emotion)。这里的实体可以是产品、服务、组织机构、个人、事件和各种话题。除了sentiment analysis之外，在学术界还有很多类似的术语，包括观点挖掘(opinion mining)、观点分析(opinion analysis)、观点抽取(opinion extraction)、情感挖掘(sentiment mining)、主(客)观分析(subjectivity analysis)、情绪分析(affect analysis)、情感分析(emotion analysis)和评论挖掘(review mining)等等。注意这些词翻译成中文后很难区分了，所以最好看对应的英文术语，当然这些英文术语的区别也会细微，后文会介绍它们的区别。这么多术语的原因之一是因为它是一个比较新的领域，很多不同领域的研究者都开始研究这个问题，因此没有形成统一的术语。除了NLP社区，数据挖掘(data minin)和信息检索(information retrieval)等很多其它领域的研究者也都在研究这个问题。</p><p>下面我们来介绍一下sentiment和opinion的细微区别，同时形成统一的术语体系。根据Merriam-Webster词典，sentiment是态度(attitude)、想法(thought)和情绪感觉(feeling)激发出来的意见(judgment)。而opinion是人对某一个特点事物在大脑了形成的看法(view)、判断(judgment)。它们的区别非常细微，opinion更多关注一个人对某个事物的看法(view)而sentiment更多关注情绪和感受。比如句子”I am concerned about the current state of the economy”是sentiment，它表达了说话人对于当前经济经济状况的担忧(情感)；而”I think the economy is not doing well”表达了说话人对当前经济状况(不太好的)观点。对于的一个句子，我们的回复可能是”I share your sentiment”；而对于第二个句子的回复可能是”I agree/disagree with you”。当然这两个句子是有一定相关性的，第一个句子的负面情绪可能来源于第二个句子的判断结果——因为说话人对于当前经济状况的判断是不好的，所以可能产生担忧的情绪。通常表达观点的句子是正面(positive)或者负面(negative)的情感，但是也有一下表达观点的句子不带任何情感，比如”I think he will go to Canada next year”，这个句子只是表达了”我”对于他去加拿大的一个观点而已，并没有好坏的情感。</p><p>在业界几乎只使用情感分析(sentiment analysis)这个术语，而学术界情感分析和观点挖掘都有被使用。我们这里并不区分情感分析和观点挖掘这两个术语。我们这里用opinion表示情感(sentiment)、评估(evaluation)、评价(appraisal)、态度(attitude)等所有相关信息，比如我们把评论的对象叫做opinion target(评论目标)；而用sentiment表示这个opinion背后隐含的正面/负面情感。前面也说过，某些观点(opinion)并不带有情感，因此我们只研究带情感的观点。在讨论正面或者负面的情感时，我们通常用中立(neutral)情感来表示不带情感的句子。除了情感和观点之外，相关的词语还包括感受(affect)、情感(emotion)和情绪(mood)，后面我们会介绍它们。</p><p>表达观点和情感的句子通常是主观的(subjective)而不是客观的(objective)句子，因为客观的句子通常都是描述事实。但是客观的句子可能会隐含观点和情感，尤其是描述一些不想要的(undesirable)事实的句子。比如”I bought the car yesterday and it broke today”和”after sleeping on the mattress for a month, a valley has formed in the middle”，昨天刚买的车就不能开、毯子一个月就有裂缝，这显然不是说话人想要的结果。情感分析也需要处理客观句子里的这种隐式的观点和情感。简单来说，情感分析需要分析文本里显示或者隐式表达的正面或者负面观点/情感，同时还需要找到对应的情感目标(opinion target)——比如地一个句子的是car而第二个句子是mattress。</p><p>在2000年之前，由于数字化的文本数据很少，情感分析很少被研究。而在2000年之后，随着数字化的文本增多以及再后来社交媒体的兴起，越来越多的研究者开始研究这个问题。除了研究单一的评论文本，一些论坛的帖子和文章的评论之间是有类似对话的上下文关系，评论者除了表达观点之外也会表达对其他评论者的赞同/反对的立场(position)。此外研究方向也逐渐扩大到对评论者的分析，比如研究怎么给评论者建档案(profile)。而且随着大家对于情感/舆情的重视，也出现了很多作弊的手段(水军)，怎么去除这些非正常的评论也逐渐变得重要，这就不仅仅是一个NLP的问题，它往往还需要分析用户的行为数据才能作出更准确的判断。</p><h3 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h3><h4 id="分析的层级"><a href="#分析的层级" class="headerlink" title="分析的层级"></a>分析的层级</h4><p>情感分析通常可以分为三个层级：文档(document)级别、句子(sentence)级别和属性(aspect)级别。下面我们简单的介绍一下这三个层级。</p><p><strong>文档级别</strong>，它把整个文档的情感分为正面或者负面。这可以看出一个二分类问题(不太可能有评论没有情感，因为写评论的目的就是要表达情感，即使是很弱的情感)，因此它也被叫做文档级别情感分类。比如对于一个商品的评论，我们可以分析整体上来看这个评论的情感是正面还是负面。它假设这个文档的所有评论句子针对的都是同一个实体。如果一个文档会点评多个实体，这个级别的分析就是有问题的。</p><p><strong>句子级别</strong>，它对文档的每个句子判定它的情感是正面的、负面的还是中立的(neutral)。和前面的文档级别不同，一些描述性的句子其实是没有任何情感的，所以这里多了一个中立的分类，它表示没有情感。这个问题和主客观分类(subjectivity classification)有一些关系——主客观分类是判断一个句子是主观的(subjective)还是客观的(objective)。通常中立的句子是客观的，而正面或者负面情感的句子是主观的。但是它们并不是完全一样的。比如”We bought the car last month and the windshield wiper has fallen off”是客观的句子，但是它描述了一个不想要(undesirable)的事情，所以它隐含了负面的情感。而句子”I think he went home after lunch”虽然是主观的，但是它没有正面或者负面的情感。</p><p><strong>属性级别</strong>，不管是文档级别的还是句子级别的分析都是不够精细的，比如句子级别的分析可以判断句子”I like the iPhone 5”的情感是正面的，但是它没有说明观点的对象(opinion target)是实体(entity) “iPhone 5”；而句子”The battery life of iPhone 5 is very long”的观点对象是实体”iPhone 5”的一个属性battery life。此外有点句子比如”Although the service is not great, I still love this restaurant”包含了两个观点——酒店的服务不行，酒店整体不错。从句子级别来看，上面的句子既有正面的又有负面的，而且正面的是放在转折(but)的子句里，所以也许我们从整体上可以判断句子的情感还是正面为主。但是从应用的角度来说，如果某个用户很关注服务，他看到这个评论后可能就不会选择这家酒店。最早属性是使用feature或者attribute这两词，但是在机器学习领域feature有特殊的含义，而attribute又是一个太宽泛的词汇，后来就使用了Aspect(方面)这个词来表示情感分析对象实体的某个具体属性。</p><p>除了按照层级分类，我们还可以把评论分析分类为普通的评论分析和比较的(comparative)评论分析。比如”Coke tastes very good”是一个普通的情感表示，它表示了说话人对实体Coke的味道。而”Coke tastes better than Pepsi”是一个比较的评论，它说明Coke的味道要比Pepsi好。</p><h4 id="基于情感词典的方法"><a href="#基于情感词典的方法" class="headerlink" title="基于情感词典的方法"></a>基于情感词典的方法</h4><p>判断情感倾向最重要的就是情感词语(sentiment word)，也叫做观点词语(opinion word)。比如”good”、”wonderful”和”amazing”是正面的情感词语，而”bad”、”poor”和”terrible”是负面的情感词语。除了词外，还有一些短语也能表达情感倾向，比如”cost an arm and a leg”(花费高昂代价)。因此构造一个情感词典来用于情感分类(规则或者把词典作为特征)是非常自然的想法。但是情感分析是一个非常复杂的问题，光参考情感词语或者短语是远远不够的。它不能解决如下的一些问题：</p><ul><li><p>一个词在不同的上下文下的情感方向(orientation)/极性(polarity)是不同的。</p><ul><li>suck这个词，通常表示负面的情绪，比如句子”This camera sucks”。但是在句子”This vacuum cleaner really sucks”里sucks是说明吸尘器很能吸，这是正面的。另外有一些词的极性依赖与修饰的名词，比如”大”没有特定的极性，说酒店房间大则是正面的，而说噪声大就是负面的。</li></ul></li><li><p>包含情感词语的句子不见得有情感倾向</p><ul><li>比如句子”Can you tell me which Sony camera is good?”和”If I can find a good camera in the shop, I will buy it.”这两个句子没有任何情感倾向。第一个句子是疑问句，一般(但不是绝对)不包含情感倾向；第二个句子good是在条件从句，所以也不表示情感。注意，并不是所有的疑问句和条件从句都没有情感，比如”Does anyone know how to repair this terrible printer?”和”If you are looking for a good car, get a Ford Focus.”都有情感。</li></ul></li><li><p>反讽和期望的句子很难处理</p><ul><li>比如”What a great car! It stopped working in two days.”和”要是房间再大一点就好了”，如果只看情感词语，great car和”房间大”都是正面的，但是实际语义恰恰相反。</li></ul></li><li><p>没有情感词语的句子也能表达情感</p><ul><li>比如”This washer uses a lot of water”没有情感词语，它是一个客观的陈述句，但是根据常识，它描述的是我们不想要的现象，因此可以推测这是一个负面的情感。</li></ul></li></ul><p>上面只是情感分析的部分困难示例，这些困难用情感词典很难解决。</p><h4 id="Debate和Comment"><a href="#Debate和Comment" class="headerlink" title="Debate和Comment"></a>Debate和Comment</h4><p>社交媒体上有两种情感文本：独立的帖子(post)，比如review和blog；在线的对话，包括debate和comment。比如论坛的帖子，大家会对某个话题进行辩论(debate)。注意：review和comment翻译成中文都是评论，但是这里用review表示单个的独立的表达观点和情感的文档，而comment表示那种对话式的评论。comment可以是对主题贴(review)的看法——赞同或者反对，也可以针对评论的对象的提问，甚至是对前面提问的回答。这里涉及多个人，可能是主题贴的作者和评论者的对话，也可能是评论者之间的对话。</p><h4 id="挖掘意图-Mining-Intention"><a href="#挖掘意图-Mining-Intention" class="headerlink" title="挖掘意图(Mining Intention)"></a>挖掘意图(Mining Intention)</h4><p>意图(Intention)是人们想要采取的行为(action)。意图和情感是两个不同的概念，但是它们也有一定的关联。比如”I am dying to see Life of Pi”，说话人想要看电影的意图非常强烈，说明它对这部电影很可能就是正面的情感。类似的，”I want to buy an iPhone 5”，想要购买某个商品可以推测他对这个商品是正面的情感。此外，某些表达意图的句子就是在表达情感，比如”我想把这个手机扔了”和”我想把手机退了”，明显就在表达非常负面的情绪。</p><h4 id="评论的Spam-Detection和评论质量评估"><a href="#评论的Spam-Detection和评论质量评估" class="headerlink" title="评论的Spam Detection和评论质量评估"></a>评论的Spam Detection和评论质量评估</h4><p>社交媒体的优点是可以匿名的自由发表言论，但是这也会让一些不法分子有可乘之机。在各种利益的驱使下，很多人会发表”假的”评论来提高某些商品的评价得分。这些人被叫做opinion spammer，而他们的行为叫做opinion spamming。为了检测这些评论和评论者，我们不仅仅需要用的文本的语义内容(比如为了刷榜的评论一般比较短，用比较空虚的句子，当然也有很专业的五毛党写的让你看不出来)，还需要使用用户的行为数据。与之相关的一个问题是评估评论的质量，它的作用是把好的评论排序在前面让用户看到，另外在排序商品的时候一般也需要更多参考质量高的评论。</p><h2 id="问题的形式化定义"><a href="#问题的形式化定义" class="headerlink" title="问题的形式化定义"></a>问题的形式化定义</h2><h3 id="观点-Opinion-的定义"><a href="#观点-Opinion-的定义" class="headerlink" title="观点(Opinion)的定义"></a>观点(Opinion)的定义</h3><p>如前面所述，情感分析主要关注表达正面或者负面的情感的观点。我们用观点(Opinion)表示非常广的概念，它包括情感(sentiment)、评价和态度以及评价的对象(opinion target)和评论者(opinion holder)。而情感(sentiment)只表示观点(opinion)的情感极性是正面还是负面的。</p><h4 id="Opinion的定义"><a href="#Opinion的定义" class="headerlink" title="Opinion的定义"></a>Opinion的定义</h4><p>我们使用下面的例子来说明Opinion的定义，为了方便引用对每个句子做了编号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">评论者：John Smith            日期：September 10, 2011</span><br><span class="line">(1) I bought a Canon G12 camera six months ago. </span><br><span class="line">(2) I simply love it. </span><br><span class="line">(3) The picture quality is amazing. </span><br><span class="line">(4) The battery life is also long. </span><br><span class="line">(5) However, my wife thinks it is too heavy for her.</span><br></pre></td></tr></table></figure><p>上面的评论对于产品Canon G12有许多评论。第2个句子对于它的整体持正面的评价。第3个句子对它的picture equality属性持正面评价。第4个句子对它的battery life属性也是正面评价。而第5个句子对于它的weight属性持负面评价。</p><p>一个观点有两个要素：对象(target)和情感(sentiment)。我们用(g,s)来表示这两个要素，其中g可以是某个实体(比如Canon G12)或者实体的某个属性(比如Canon G12的battery life)；而s表示情感极性，它的取值可以是正面的、负面的和中性的或者连续的实数值，比如Canon G12的battery life是正面的。</p><p>另外观点还包含观点的持有者(评论者)，比如第2个句子的观点持有者是”我”而第5个句子的持有者是”my wife”。</p><p>最好观点还有一个时间，这样我们可以分析大量观点随时间的变化规律。在上面的例子里，观点的(发布)时间是2011年9月10日。</p><p>因此，观点的定义是一个四元组(g, s, h, t)，其中：</p><ul><li>g是情感的对象</li><li>s是情感</li><li>h是持有者</li><li>t是时间</li></ul><p>这里需要说明一下的是观点有一个对象(target)，这有两个用处。首先对于一个包含两个对象的句子，我们可以分开处理。比如句子”Apple is doing very well in this poor economy”同时保护两个观点，如果用句子级别的情感分类是没有办法处理的。有了观点的对象，我们知道对Apple的情感是正面的，而对economy的是负面的。第二个好处是情感词语的极性有时和对象有关，比如”大”和”房间”搭配时就是正面的而与”噪声”搭配就是负面的。</p><p>这里定义的是普通的观点，对于比较性的观点需要不同的定义，后面我们再介绍。</p><h4 id="情感对象-sentiment-target"><a href="#情感对象-sentiment-target" class="headerlink" title="情感对象(sentiment target)"></a>情感对象(sentiment target)</h4><ul><li><p>情感对象</p><ul><li>情感对象(sentiment target)也叫观点对象(opinion target)，是这个观点针对的实体或者实体的某个属性。</li></ul></li></ul><p>比如前面的例子里的第3个句子，情感对象是Canon G12的picture quality属性。注意：虽然句子中没有出现Canon G12，但是它隐含指代的对象是Canon G12。</p><ul><li><p>实体(entity)</p><ul><li>一个实体e可能是一个产品、服务、主题、人、组织机构等。它可以表示为一个pair e=(T,W)，其中T是它的部件(part)的集合，而每一个部件又是一个实体(递归定义)；W是实体e的属性集合。e的部件或者子部件也可能有属性。</li></ul></li></ul><p>比如Canon G12这个特定的照相机就是一个实体。它包含picture qulity、size和weight等属性，同时它包含lens、viewfinder和battery等部件。battery也是一个实体，它包含battery life和battery weight等属性。上面的定义通过part-of关系定义了对象的树状层次结构。根节点是实体，比如Canon G12。我们评论的对象可以是某个子部件的属性，比如battery的battery life这个属性。当然我们也可以评论子部件整体，比如说battery很好。也就是说，这棵树的每一个节点(实体)和节点的属性都可以成为评论的对象。</p><h4 id="观点的情感-opinion-sentiment"><a href="#观点的情感-opinion-sentiment" class="headerlink" title="观点的情感(opinion sentiment)"></a>观点的情感(opinion sentiment)</h4><ul><li>观点的情感是某个观点表达的感受、态度、评价或者情绪。它可以表示为三元组(y, o, i)，其中<ul><li>y是情感类型(type)</li><li>o是情感的极性</li><li>i是情感的强度</li></ul></li></ul><p>情感类型可以分为理性情感和感性情感。</p><ul><li>理性(rational)情感<ul><li>理性的情感来自于理性的推理、实际的信念和实用主义的态度。它不(直接)包含强烈的个人情绪。</li></ul></li></ul><p>比如”The voice of this phone is clear.”和”This car is worth the price.”这两个句子就是理性的情感类型。</p><ul><li>感性(emotional)情感<ul><li>感性情感来自于人内心深处的心理学状态，它是对某个实体无形的和情绪的反应。</li></ul></li></ul><p>比如句子”I love the iPhone”, “I am so angry with their service people”, “This is the best car ever”和”After our team won, I cried.”就是感性的情感。感性的情感通常要比理性的情感更加强烈，对于营销来说，我们期望用户的情感能上升到感性层次，比如用户说”iPhone is good”，那他还不见得会买单，但是如果他说”I love iPhone”，那么离转化就不远了。</p><p>情感倾向(sentiment orientation)可以是正面的(positive)、负面的(negative)和中立的(neutral)。情感倾向也被叫做情感极性(polarity)和立场(valence)。</p><p>情感强度(sentiment intensity)表示情感的强烈程度。比如good要比excellent弱，而dislike要比detest弱。理论上我们可以用一个连续的实数值来表示情感的强弱，但是实际人都很难做这么细粒度的区分。因此在实际应用中，我们通常把情感强度分为5级别，比如1星到5星：</p><ul><li>5星 感性的正面情感</li><li>4星 理性的正面情感</li><li>3星 中立的情感</li><li>2星 理性的负面情感</li><li>1星 感性的负面情感</li></ul><h4 id="简化的观点定义"><a href="#简化的观点定义" class="headerlink" title="简化的观点定义"></a>简化的观点定义</h4><p>前面的观点定义关于实体的定义包含递归，使用起来过于复杂，这里我们介绍简化版本的定义。我们这里把对象简化成实体和aspect，也就是把子部件和属性都称为aspect。对于观点的情感(sentiment)，不管是正面的、负面的和中立的还是1星到5星，我们都可以用一个数值来表示，比如-1表示负面的而0表示中立的而1表示正面的。</p><p>这样我们得到简化版本的观点定义，它是一个五元组(e, a, s, h, t)，其中：</p><ul><li>e代表实体(entity)</li><li>a代表aspect，可以是实体的属性，也可以是子部件或者子部件的属性</li><li>s表示一个数值，表示不同的情感</li><li>h是观点的持有者</li><li>t是时间</li></ul><p>如果评论的对象是entity这个整体，比如”I love iPhone 5”，则entity是”iPhone 5”，而aspect是特殊的”GENERAL”。上面这样定义的情感分析叫做基于aspect的情感分析(aspected based sentiment analysis)，用首字母缩写为ABSA。</p><h4 id="观点的理由-reason-和限定词-qualifier"><a href="#观点的理由-reason-和限定词-qualifier" class="headerlink" title="观点的理由(reason)和限定词(qualifier)"></a>观点的理由(reason)和限定词(qualifier)</h4><p>除了前面的五元组，我们还可以提前观点里的更多信息。比如句子”This car is too small for a tall person”，实体是”this car”，aspect是size，sentiment是负面的，观点持有者是说话人，时间是说话的时间。除此之外，我们还可以分析得到持有这个观点的理由是”too small”，并且这个观点还有一个限制条件”for a tall person”。因此对于一个不那么高的人来说，也许这个车的size并不是负面的。</p><ul><li>观点的理由<ul><li>观点的理由是持有这个观点的理由或者解释</li></ul></li></ul><p>对于很多应用来说，知道理由是很有用的。比如”do not like the picture quality of this camera”只告诉我们照相机的拍摄质量有问题，但是”I do not like the picture quality of this camera because the pictures are quite dark.”还能告诉我们拍摄质量不好的解释(现象)是因为拍出来的照片太黑，这可以指导厂家改进产品。</p><ul><li>观点的限定词<ul><li>观点的限定词是一些限制条件，在满足这些条件下此观点才成立</li></ul></li></ul><p>比如”This car is too small for a tall person”，它说明只要对于高个来说车太小，但是并不是对所有的人来说都小。个子并不那么高的人可能不会在意这一点。并不是每个观点都有理由或者限定词，而且理由和限定词也可能和评论的主要内容出现在不同的句子里，这也会让抽取变得更加困难。比如”The picture quality of this camera is not great. Pictures of night shots are very dark.”，理由出现在第二个句子里。而”I am six feet five inches tall. This car is too small for me.”的限定词出现在地一个句子里。</p><h4 id="情感分析的目标和任务"><a href="#情感分析的目标和任务" class="headerlink" title="情感分析的目标和任务"></a>情感分析的目标和任务</h4><p>有了前面观点的定义之后，我们就可以定义情感分析的目标和任务了。给定一个文档d，情感分析的目标就是找出其中所有的观点五元组(e, a, s, h, t)。对于更复杂的场景，我们可能还需要抽取观点的理由和限定词。</p><p>第一个抽取任务就是识别五元组中的实体。这和NLP的命名实体识别(NER)有一点关系，比如产品名称等通常就是命名实体。但是观点里的实体并不都是命名实体，比如”I hate tax increase”这个观点的实体是抽象的概念”tax increase”，这不是命名实体。</p><p>识别出实体之后，我们还需要”归一化”。我们需要定义一个实体类别(entity category)，比如iphone_5(它只是一个ID)，而它的不同文字描述比如”iPhone5”，”iphone 5”和”苹果5”都是对应这个实体类别。这些不同的文字叫做实体表示(entity expression)或者entity mention(不知道咋翻译好)。</p><p>aspect也是一样，比如camera的”picture”, “image”和”photo”指得都是同一个aspect。因此我们也有aspect category和aspect expression。</p><p>aspect expression通常都是名词和名词短语，但是也可以是动词、形容词、副词等其它词类。aspect expression可以分为显式的和隐式的。</p><ul><li><p>显式的aspect expression</p><ul><li>显式的aspect expression是文本里的名词或者名词短语。比如”The picture quality of this camera is great”中，picture quality这个aspect expression是名词短语。</li></ul></li><li><p>隐式的aspect expression</p><ul><li>隐式的aspect expression通常通过形容词来隐含的表示。比如”This camera is expensive”，对应的aspect是price，这是通过形容词expensive来推断出来的。除了形容词，动词也可以隐含aspect，比如”I can install the software easily”，通过动词install可以推断出aspect是installation。此外还有更加复杂的隐式aspect expression，比如”This camera will not easily fit in my pocket”，能放到口袋里(fit in my pocket)说明它的size这个aspect；而”This restaurant closes too early”说明餐馆的下班时间这个aspect。为了理解这样的aspect，我们还需要世界知识，这是非常困难的。</li></ul></li></ul><p>下面我们定义情感分析的具体任务。</p><ul><li><p>实体抽取(entity extraction)和指代消解(resolution)</p><ul><li>识别文档d里的所有entity expression，然后根据指代是否同一个实体把它们分组起来(或者叫归一化成一个ID)。</li></ul></li><li><p>aspect抽取和指代消解</p><ul><li>和实体类似，只不过处理aspect</li></ul></li><li><p>观点持有者的抽取和指代消解</p><ul><li>抽取观点的持有者并进行指代消解</li></ul></li><li><p>时间抽取和归一化</p></li><li><p>aspect的情感分类/回归</p><ul><li>判断某个aspect的情感分类或者预测连续的情感强度</li></ul></li><li><p>生成所有的观点五元组</p></li><li><p>抽取观点的原因</p></li><li><p>抽取观点的限定词</p></li></ul><p>最后两个任务是非常困难的，而且很多观点并不包含，在实际应用中很少会处理它们。下面我们通过一个例子来说明不同的任务需要做哪些事情。我们的例子为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Review B: Posted by bigJohn     Date: September 15, 2011</span><br><span class="line">(1) I bought a Samsung camera and my friend brought a Canon camera yesterday.</span><br><span class="line">(2) In the past week, we both used the cameras a lot. </span><br><span class="line">(3) The photos from my Samy are not clear for night shots, and the battery life is short too. </span><br><span class="line">(4) My friend was very happy with his camera and loves its picture quality. </span><br><span class="line">(5) I want a camera that can take good photos. </span><br><span class="line">(6) I am going to return it tomorrow.</span><br></pre></td></tr></table></figure><p>第1个任务需要抽取entity expression Samsung和Samy，然后把它们放到一个cateory里面，而Canon是另外一个category。第2个任务需要抽取picture, photo和battery life，并且把picture和photo放到一起。而第3个任务需要抽取第3句话对应的观点的持有者是bigJohn，第4句话对于观点的持有者是bigJohn的朋友。任务4需要抽取时间为”September 15, 2011”。任务5需要识别第3句话对于Samy的photo这个aspect是负面的，battery life也是负面的；而第4个句子关于Canon整体(GENERAL这个aspect)是正面的，关于它的picture这个aspect也是正面的。</p><p>为了完成任务5，我们还需要知道句子his camera和its指代的是哪个实体。任务5应该生成如下的五元组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. (Samsung, picture_quality, negative, bigJohn, Sept-15-2011)</span><br><span class="line">2. (Samsung, battery_life, negative, bigJohn, Sept-15-2011)</span><br><span class="line">3. (Canon, GENERAL, positive, bigJohn’s_friend, Sept-15-2011)</span><br><span class="line">4. (Canon, picture_quality, positive, bigJohn’s_friend, Sept-15-2011)</span><br></pre></td></tr></table></figure><p>如果再加上任务6和7，则生成的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. (Samsung, picture_quality, negative, bigJohn, Sept-15-2011)</span><br><span class="line">    Reason for opinion: picture not clear</span><br><span class="line">    Qualifier of opinion: night shots</span><br><span class="line">2. (Samsung, battery_life, negative, bigJohn, Sept-15-2011)</span><br><span class="line">    Reason for opinion: short battery life</span><br><span class="line">    Qualifier of opinion: none</span><br><span class="line">3. (Canon, GENERAL, positive, bigJohn’s_friend, Sept-15-2011)</span><br><span class="line">    Reason for opinion: none</span><br><span class="line">    Qualifier of opinion: none</span><br><span class="line">4. (Canon, picture_quality, positive, bigJohn’s_friend, Sept-15-2011)</span><br><span class="line">    Reason for opinion: none</span><br><span class="line">    Qualifier of opinion: none</span><br></pre></td></tr></table></figure><h3 id="感受-Affect-、情感-Emotion-和情绪-Mood"><a href="#感受-Affect-、情感-Emotion-和情绪-Mood" class="headerlink" title="感受(Affect)、情感(Emotion)和情绪(Mood)"></a>感受(Affect)、情感(Emotion)和情绪(Mood)</h3><p>接下来我们讨论一下感性(emotional)情感，它涉及感受(Affect)、情感(Emotion)和情绪(Mood)。我们这里只是介绍这些概念的区别和联系，因为这些都是人的精神状态，很多时候都是通过行为和表情来表现。即使通过语言来描述自己的这些感受，也通常是非常困难的。</p><p>首先我们来看这些概念字面上的定义，这里还增加了Feeling。</p><ul><li><p>Affect</p><ul><li>感受或者情感，通常会通过面部表情和身体语言表现出来</li></ul></li><li><p>Emotion</p><ul><li></li></ul></li><li><p>Mood</p><ul><li>精神或者情感的状态</li></ul></li><li><p>Feeling</p><ul><li>意识的情感状态</li></ul></li></ul><p>从字面上很难区分这些概念，下面我们通过一些例子来体会它们的细微区别。Affect是比较基本的感受，比如在看一个恐怖电影，我们会感受到恐怖这种感觉。我们的大脑会处理这种基本的感觉，然后产生一些Emotion，比如哭泣和尖叫。因此，Emotion是Affect的表现，它通常有一个对象，比如一个人，一件事或者一个物体，它是非常强烈并且持续时间不会太长。Mood和Emotion类似，都是一种情感状态。但是它通常没有特定的对象，而且持续时间比较长，我们也甚至不会意识到它。比如开心的情绪，它不是针对某个对象。</p><p>Emotion和Mood的区别是：Emotion通常很强烈而很短暂，而Mood更加分散和持久。比如生气就是一种Emotion，我们可能会非常生气，并且对某一个人或者事生气，但是我们很难一直保持生气。生气这种Emotion可能会转变成暴躁的情绪，这种情绪可能会持续很长时间。Emotion是非常具体的，比如某个事情可能会让我们生气。而Mood是比较模糊的，我们的暴躁情绪不是针对某一件事，我们在暴躁的情绪下可能对任何事情都容易生气。</p><p>不同的心理学研究者会定义各种不同的Emotion和Mood，因为我们从计算的角度来说不太能够准确的定义它们，而且实际应用中也比较少，所以这里不再分析这些具体的Emotion和Mood了。</p><h3 id="观点-Opinion-的分类"><a href="#观点-Opinion-的分类" class="headerlink" title="观点(Opinion)的分类"></a>观点(Opinion)的分类</h3><p>观点可以从各种不同的维度来分类，下面我们讨论一些常见的分类方法，目的是了解不同观点的特点，从而为后面的算法提供一些sense。</p><h4 id="普通观点和比较观点"><a href="#普通观点和比较观点" class="headerlink" title="普通观点和比较观点"></a>普通观点和比较观点</h4><ul><li>普通观点<ul><li>我们一般讨论的观点都是普通观点，它是针对一个实体或者一个实体的属性进行描述，它有可以分为直接(direct)观点和间接(indirect)u观点两大类。</li></ul></li></ul><p>直接观点直接描述一个实体或者实体的属性，比如”The picture quality is great”这个句子直接描述”picture quality”这个属性的好坏。而间接观点通过它的后果等间接描述，比如”After injection of the drug, my joints felt worse”，这个句子并没有直接说药效，而是说它的后果造成我的关节变得更痛了来间接说明效果不好，这通常需要世界知识来判断。</p><ul><li>比较观点<ul><li>比较观点会对比两个实体，比如”Coke tastes better than Pepsi”。</li></ul></li></ul><h4 id="主观性观点和事实隐含类-Fact-Implied-观点"><a href="#主观性观点和事实隐含类-Fact-Implied-观点" class="headerlink" title="主观性观点和事实隐含类(Fact-Implied)观点"></a>主观性观点和事实隐含类(Fact-Implied)观点</h4><p>观点本身是主观的个人的看法，因此很多时候是通过主观的句子来表达观点。但是如前面介绍的，通过客观的描述一些我们想要或者不想要的事实，也能间接的表达观点，比如说车买回来没两天就坏了。</p><h4 id="第一人称观点和非第一人称观点"><a href="#第一人称观点和非第一人称观点" class="headerlink" title="第一人称观点和非第一人称观点"></a>第一人称观点和非第一人称观点</h4><p>用第一人称观点直接表达说话人的观点，而第三人称观点描述其他人的观点。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentiment analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情感分析常见数据集介绍</title>
      <link href="/2022/10/01/nlp-sentiment-analysis-dataset/"/>
      <url>/2022/10/01/nlp-sentiment-analysis-dataset/</url>
      
        <content type="html"><![CDATA[<p>本文介绍情感分析领域最常见的一些数据集。</p><h2 id="SemEval"><a href="#SemEval" class="headerlink" title="SemEval"></a>SemEval</h2><h3 id="SemEval-2014-Task-4-Aspect-Based-Sentiment-Analysis"><a href="#SemEval-2014-Task-4-Aspect-Based-Sentiment-Analysis" class="headerlink" title="SemEval-2014 Task 4: Aspect Based Sentiment Analysis"></a>SemEval-2014 Task 4: Aspect Based Sentiment Analysis</h3><p>任务的介绍主要参考了<a href="https://www.aclweb.org/anthology/S14-2004.pdf">SemEval-2014 Task 4: Aspect Based Sentiment Analysis</a>，官方网站为<a href="http://alt.qcri.org/semeval2014/task4/">SemEval-2014 Task 4</a>。</p><p>这是SemEval-2014语义评测任务的第4个任务，它又包含4个子任务。</p><h4 id="子任务1：Aspect-term-extraction"><a href="#子任务1：Aspect-term-extraction" class="headerlink" title="子任务1：Aspect term extraction"></a>子任务1：Aspect term extraction</h4><p>给定针对某个entity(比如餐馆)的一些句子，识别其中的aspect term。比如句子”The food was nothing much, but I loved the staff”，我们需要识别”food”和”staff”这两个aspect term。一个句子里可能会出现多个(或者零个)aspect term。另外aspect term可能包含多个词，比如”The hard disk is very noisy”，这里的aspect term是”hard disk”。</p><h4 id="子任务2：Aspect-term的极性分类"><a href="#子任务2：Aspect-term的极性分类" class="headerlink" title="子任务2：Aspect term的极性分类"></a>子任务2：Aspect term的极性分类</h4><p>给定一个句子和这个句子里的所有aspect term，判定每一个term的情感极性。可能的极性包括正面(positive)、负面(negative)、中性(neutral)和冲突(conflict)。比如：</p><p>“I loved their <strong>fajitas</strong>” → {fajitas: positive}<br>“I hated their <strong>fajitas</strong>, but their <strong>salads</strong> were great” → {fajitas: negative, salads: positive}<br>“The <strong>fajitas</strong> are their first plate” → {fajitas: neutral}<br>“The <strong>fajitas</strong> were great to taste, but not to see” → {fajitas: conflict}</p><p>冲突的意思是在这个句子里既有正面的评价也有负面的评价，比如上面的第四个句子。</p><h4 id="子任务3：Aspect类别-category-识别"><a href="#子任务3：Aspect类别-category-识别" class="headerlink" title="子任务3：Aspect类别(category)识别"></a>子任务3：Aspect类别(category)识别</h4><p>因为很多不同的aspect term都可以归为一类，比如fajitas和salads都是餐馆的菜品，我们希望把它们都归类到food。这个任务定义了几个类别，比如餐馆(restaurant)的数据集上定义里food, service, price, ambience, anecdotes/miscellaneous等5个类别。这个任务为：给定一个句子，识别出其中的类别(注意一个句子可能包含多个类别)。比如：</p><p>“The restaurant was too expensive”  → {<strong>price</strong>}<br>“The restaurant was expensive, but the menu was great” → {<strong>price</strong>, <strong>food</strong>}</p><p>有的读者可能回想，如果能识别aspect term，然后再判断aspect term是哪个category。这可能有一个问题，对于隐式的aspect，可能只有形容词而没有名词，比如第一个句子没有price这样的aspect term，我们需要根据形容词expensive来推测类别为price。</p><h4 id="子任务4：Aspect类别的情感分类"><a href="#子任务4：Aspect类别的情感分类" class="headerlink" title="子任务4：Aspect类别的情感分类"></a>子任务4：Aspect类别的情感分类</h4><p>给定一个句子以及句子里的一个或者多个aspect类别，输出每个类别的情感分类。和前面的term分类一样，这里的分类也是正面(positive)、负面(negative)、中性(neutral)和冲突(conflict)。比如：</p><p>“The restaurant was too expensive” → {price: negative}<br>“The restaurant was expensive, but the menu was great” → {price: negative, food: positive}</p><p>对于上面的第一个例子，输入是句子和negative与food两个类别，输出是这两个类别的极性。</p><h4 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h4><p>全部数据可以在<a href="http://alt.qcri.org/semeval2014/task4/index.php?id=data-and-tools">这里</a>下载，它包括餐馆和笔记本电脑两个数据集，其中餐馆数据集包含上面的4个子任务的标注，而笔记本电脑的数据只有前两个任务的标注数据(没有类别的标注)。</p><p>下面是餐馆的一个示例数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;sentence id=&quot;813&quot;&gt;</span><br><span class="line">          &lt;text&gt;All the appetizers and salads were fabulous, the steak was mouth watering and the pasta was delicious!!!&lt;/text&gt;</span><br><span class="line">          &lt;aspectTerms&gt;</span><br><span class="line">                    &lt;aspectTerm term=&quot;appetizers&quot; polarity=&quot;positive&quot; from=&quot;8&quot; to=&quot;18&quot;/&gt;</span><br><span class="line">                    &lt;aspectTerm term=&quot;salads&quot; polarity=&quot;positive&quot; from=&quot;23&quot; to=&quot;29&quot;/&gt;</span><br><span class="line">                    &lt;aspectTerm term=&quot;steak&quot; polarity=&quot;positive&quot; from=&quot;49&quot; to=&quot;54&quot;/&gt;</span><br><span class="line">                    &lt;aspectTerm term=&quot;pasta&quot; polarity=&quot;positive&quot; from=&quot;82&quot; to=&quot;87&quot;/&gt;</span><br><span class="line">          &lt;/aspectTerms&gt;</span><br><span class="line">          &lt;aspectCategories&gt;</span><br><span class="line">                    &lt;aspectCategory category=&quot;food&quot; polarity=&quot;positive&quot;/&gt;</span><br><span class="line">          &lt;/aspectCategories&gt;</span><br><span class="line">&lt;/sentence&gt;</span><br></pre></td></tr></table></figure><p>下面是笔记本电脑的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;sentence id=&quot;353&quot;&gt;</span><br><span class="line">          &lt;text&gt;From the build quality to the performance, everything about it has been sub-par from what I would have expected from Apple.&lt;/text&gt;</span><br><span class="line">          &lt;aspectTerms&gt;</span><br><span class="line">                    &lt;aspectTerm term=&quot;build quality&quot; polarity=&quot;negative&quot; from=&quot;9&quot; to=&quot;22&quot;/&gt;</span><br><span class="line">                    &lt;aspectTerm term=&quot;performance&quot; polarity=&quot;negative&quot; from=&quot;30&quot; to=&quot;41&quot;/&gt;</span><br><span class="line">          &lt;/aspectTerms&gt;</span><br><span class="line">&lt;/sentence&gt;</span><br></pre></td></tr></table></figure><h3 id="SemEval-2015-Task-12-Aspect-Based-Sentiment-Analysis"><a href="#SemEval-2015-Task-12-Aspect-Based-Sentiment-Analysis" class="headerlink" title="SemEval-2015 Task 12: Aspect Based Sentiment Analysis"></a>SemEval-2015 Task 12: Aspect Based Sentiment Analysis</h3><p>任务的介绍主要参考了<a href="https://www.aclweb.org/anthology/S15-2082.pdf">SemEval-2015 Task 12: Aspect Based Sentiment Analysis</a>，官方网站为<a href="http://alt.qcri.org/semeval2015/task12/">SemEval-2015 Task 12</a>。</p><p>这是SemEval-2014任务的任务假定评论的都是给定实体(餐馆或者笔记本电脑)的某个属性，但是我们也可能点评这个实体的部件，比如笔记本电脑的鼠标。前面介绍过，aspect更加通用的表示方法是一棵树。不过这里的任务还是简化里一些，认为这棵树最多两层，树根是餐馆或者笔记本电脑，我们可以点评电脑的属性(比如价格)，也可以点评部件鼠标的属性(比如鼠标的灵敏度)。此外，有一些点评aspect的句子并不见得会出现对应的名词，比如下面的文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">They sent it back with a huge crack in it and it still didn&#x27;t work; and that was the fourth time I’ve sent it to them to get fixed</span><br></pre></td></tr></table></figure><p>它点评的实体是餐馆的服务(service)，属性是服务的质量(quality)，但是文字中没有任何service或者quality相关的文字。这和前面的expensive的句子类似的。因此2015年的任务预定义里所有的Entity和属性，然后让我们识别文本中出现里哪些实体和属性的组合，也就是E#A。比如上面的句子，输出就是service#quality。另外这个任务的输入不是一个一个的句子，而是整段评论，这样我们可以利用上下文信息。当然标注和识别的粒度还是句子，只不过我们的算法可以(但大部分算法都没有)利用上下文的信息。</p><h4 id="任务1：In-domain任务"><a href="#任务1：In-domain任务" class="headerlink" title="任务1：In-domain任务"></a>任务1：In-domain任务</h4><p>给定一个完整的评论，我们需要完成如下3个子任务。</p><h5 id="Aspect类别识别"><a href="#Aspect类别识别" class="headerlink" title="Aspect类别识别"></a>Aspect类别识别</h5><p>识别评论里所有的实体(E)和属性(A)对。E和A都是预定义集合中的某一个值，比如餐馆数据集，E包含laptop, keyboard, operating system, restaurant, food, drinks等实体和performance, design, price, quality等属性。</p><p>更具体的，对于笔记本电脑数据集来说，E共用22个实体类别(比如LAPTOP, DISPLAY, CPU, MOTHERBOARD, HARD DISC, MEMORY, BATTERY等)和9个属性标签(比如GENERAL, PRICE, QUALITY, OPERATION_PERFORMANCE等)。完整的实体列表和属性标签列表可以参考<a href="http://alt.qcri.org/semeval2015/task12/data/uploads/semeval2015_absa_laptops_annotationguidelines.pdf">这里</a>，下面是一些示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)  It fires up in the morning in less than 30 seconds and I have never had any issues with it freezing. → &#123;LAPTOP#OPERATION_PERFORMANCE&#125;</span><br><span class="line">(2)  Sometimes you will be moving your finger and the pointer will not even move.  → &#123;MOUSE#OPERATION_PERFORMANCE&#125;</span><br><span class="line">(3)  The backlit keys are wonderful when you are working in the dark.  → &#123;KEYBOARD#DESIGN_FEATURES&#125;</span><br><span class="line">(4)  I dislike the quality and the placement of the speakers. &#123;MULTIMEDIA DEVICES#QUALITY&#125;, &#123;MULTIMEDIA DEVICES#DESIGN_FEATURES&#125;</span><br><span class="line">(5)  The applications are also very easy to find and maneuver.  → &#123;SOFTWARE#USABILITY&#125;</span><br><span class="line">(6)  I took it to the shop and they said it would cost too much to repair it.  → &#123;SUPPORT#PRICE&#125;</span><br><span class="line">(7)  It is extremely portable and easily connects to WIFI at the library and elsewhere. → &#123;LAPTOP#PORTABILITY&#125;, &#123;LAPTOP#CONNECTIVITY&#125;</span><br></pre></td></tr></table></figure><p>比如第一个句子是说笔记本的操作响应很快，而第二个是说鼠标的操作很不灵敏。</p><p>对于餐馆数据集来说，E有6个实体类别(RESTAURANT, FOOD, DRINKS, SERVICE, AMBIENCE, LOCATION)和5个属性标签(GENERAL, PRICES, QUALITY, STYLE_OPTIONS, MISCELLANEOUS)，详细信息可以参考<a href="http://alt.qcri.org/semeval2015/task12/data/uploads/semeval2015_absa_restaurants_annotationguidelines.pdf">这里</a>，下面是一些示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) Great for a romantic evening, but over-priced. → &#123;AMBIENCE#GENERAL&#125;, &#123;RESTAURANT#PRICES&#125;</span><br><span class="line">(2) The fajitas were delicious, but expensive. → &#123;FOOD#QUALITY&#125;, &#123;FOOD# PRICES&#125;</span><br><span class="line">(3)The exotic food is beautifully presented and is a delight in delicious combinations. → &#123;FOOD#STYLE_OPTIONS&#125;, &#123;FOOD#QUALITY&#125;</span><br><span class="line">(4) The atmosphere isn&#x27;t the greatest , but I suppose that&#x27;s how they keep the prices down. → &#123;AMBIENCE#GENERAL&#125;, &#123;RESTAURANT# PRICES&#125;</span><br><span class="line">(5) The staff is incredibly helpful and attentive. → &#123;SERVICE# GENERAL&#125;</span><br></pre></td></tr></table></figure><h5 id="Opinion-Target-Expression（OTE-识别"><a href="#Opinion-Target-Expression（OTE-识别" class="headerlink" title="Opinion Target Expression（OTE)识别"></a>Opinion Target Expression（OTE)识别</h5><p>这个任务只有餐馆数据集上有标注数据。OTE任务的输入是所有的E#A对，需要识别E#A对里实体E对应的字符串。当隐式的表达实体时用特殊的”NULL”表示，比如代词”它”这样的代词，有的文本甚至根本找不到和E相关的字符串。下面是一些例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) Great for a romantic evening, but over-priced. → &#123;AMBIENCE#GENERAL, “NULL”&#125;, &#123;RESTAURANT# PRICES, “NULL”&#125;</span><br><span class="line">(2) The fajitas were delicious, but expensive. → &#123;FOOD#QUALITY, “fajitas”&#125;, &#123;FOOD# PRICES, “fajitas”&#125;</span><br><span class="line">(3) The exotic food is beautifully presented and is a delight in delicious combinations. → &#123;FOOD#STYLE_OPTIONS, “exotic food”&#125;, &#123;FOOD# QUALITY, “exotic food”&#125;</span><br><span class="line">(4) The atmosphere isn&#x27;t the greatest , but I suppose that&#x27;s how they keep the prices down. → &#123;AMBIENCE#GENERAL, “atmosphere”&#125;, &#123;RESTAURANT# PRICES, “NULL”&#125;</span><br><span class="line">(5) The staff is incredibly helpful and attentive. → &#123;SERVICE# GENERAL, “staff”&#125;</span><br></pre></td></tr></table></figure><p>比如在第4个句子里，they指代的是餐馆，但是它不是OTE。</p><h5 id="情感分类"><a href="#情感分类" class="headerlink" title="情感分类"></a>情感分类</h5><p>给定一个句子(有上下文)和所有的E#A对，判断其情感分类，可能的分类为正面、负面和中性。这和2014年的任务有所不同。下面是一些示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1) The applications are also very easy to find and maneuver. → &#123;SOFTWARE#USABILITY,  positive&#125;</span><br><span class="line">(2) The fajitas were great to taste, but not to see”→ &#123;FOOD#QUALITY, “fajitas”, positive&#125;,  &#123;FOOD#STYLE_OPTIONS, “fajitas”, negative &#125;</span><br><span class="line">(3) We were planning to get dessert, but the waitress basically through the bill at us before we had a chance to order.  → &#123;SERVICE# GENERAL, “waitress”, negative&#125;</span><br><span class="line">(4) It does run a little warm but that is a negligible concern.  → &#123;LAPTOP#QUALITY neutral&#125;</span><br><span class="line">(5) The fajitas are nothing out of the ordinary” → &#123;FOOD#GENERAL, “fajitas”,  neutral&#125;</span><br><span class="line">(6) I bought this laptop yesterday. → &#123;&#125;</span><br><span class="line">(7) The fajitas are their first plate  → &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="任务2：Out-of-domain任务"><a href="#任务2：Out-of-domain任务" class="headerlink" title="任务2：Out-of-domain任务"></a>任务2：Out-of-domain任务</h4><p>增加里一个酒店的测试数据集(没有训练数据)，然后考察模型则不同领域的泛化能力。它的输入是E#A对和句子，要求我们输出这个E#A对的情感极性。</p><p>下面是一个完整的评论的标注数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Review id:&quot;1004293&quot;</span><br><span class="line"> Judging from previous posts this used to be a good place, but not any longer.</span><br><span class="line"> &#123;target:&quot;NULL&quot; category:&quot;RESTAURANT#GENERAL&quot; polarity:&quot;negative&quot; from:&quot;-&quot; to=&quot;-&quot;&#125;</span><br><span class="line"> We, there were four of us, arrived at noon - the place was empty - and the staff acted </span><br><span class="line"> like we were imposing on them and they were very rude.</span><br><span class="line"> &#123;target:&quot;staff&quot; category:&quot;SERVICE#GENERAL&quot; polarity:&quot;negative&quot; from:&quot;75&quot; to:&quot;80&quot;&#125;</span><br><span class="line"> They never brought us complimentary noodles, ignored repeated requests for sugar, </span><br><span class="line"> and threw our dishes on the table.</span><br><span class="line"> &#123;target:&quot;NULL&quot; category:&quot;SERVICE#GENERAL&quot; polarity:&quot;negative&quot; from:&quot;-&quot; to:&quot;-&quot;&#125;</span><br><span class="line"> The food was lousy - too sweet or too salty and the portions tiny.</span><br><span class="line"> &#123;target:&quot;food&quot; category=&quot;FOOD#QUALITY&quot; polarity=&quot;negative&quot; from:&quot;4&quot; to:&quot;8&quot;&#125;</span><br><span class="line"> &#123;target:&quot;portions&quot; category:&quot;FOOD#STYLE_OPTIONS&quot; polarity:&quot;negative&quot; from:&quot;52&quot; to:&quot;60&quot;&#125;</span><br><span class="line"> After all that, they complained to me about the small tip.</span><br><span class="line"> &#123;target:&quot;NULL&quot; category:&quot;SERVICE#GENERAL&quot; polarity:&quot;negative&quot; from:&quot;-&quot; to:&quot;-&quot;&#125;</span><br><span class="line"></span><br><span class="line"> Avoid this place!</span><br><span class="line"> &#123;target:&quot;place&quot; category:&quot;RESTAURANT#GENERAL&quot; polarity:&quot;negative&quot; from:&quot;11&quot; to:&quot;16&quot;&#125;</span><br></pre></td></tr></table></figure><p>其中from和to表示OTE字符串在句子开始和结束的下标。</p><h3 id="SemEval-2016-Task-5-Aspect-Based-Sentiment-Analysis"><a href="#SemEval-2016-Task-5-Aspect-Based-Sentiment-Analysis" class="headerlink" title="SemEval-2016 Task 5: Aspect Based Sentiment Analysis"></a>SemEval-2016 Task 5: Aspect Based Sentiment Analysis</h3><p>任务的介绍主要参考了<a href="https://www.aclweb.org/anthology/S16-1002.pdf">SemEval-2016 Task 5: Aspect Based Sentiment Analysis</a>，官方网站为<a href="http://alt.qcri.org/semeval2016/task5/">SemEval-2016 Task 5</a>。</p><p>2016年的任务延续里2015年的任务，为它增加了新的测试数据(15年的训练数据和测试数据都变成16年的训练数据)，此外它还首次加入了英语之外的多种语言，包括中文。它包括如下几个子任务：</p><h4 id="句子级别的ABSA-Aspect-Based-Sentiment-Analysis"><a href="#句子级别的ABSA-Aspect-Based-Sentiment-Analysis" class="headerlink" title="句子级别的ABSA(Aspect-Based Sentiment Analysis)"></a>句子级别的ABSA(Aspect-Based Sentiment Analysis)</h4><p>给定某个实体(笔记本电脑、餐馆或者酒店)的一篇评论的一个句子，需要确定所有观点三元组的如下内容(slot)：</p><h5 id="Aspect-Category-Detection"><a href="#Aspect-Category-Detection" class="headerlink" title="Aspect Category Detection"></a>Aspect Category Detection</h5><p>这个任务是确定文本里所有出现的E#A对，其中E来自预定义的实体类列表，A来自预定义的属性标签列表。</p><h5 id="Opinion-Target-Expression-OTE"><a href="#Opinion-Target-Expression-OTE" class="headerlink" title="Opinion Target Expression (OTE)"></a>Opinion Target Expression (OTE)</h5><p>和上年的任务一样，需要确定每个E#A对里实体对应的字符串的开始和结束下标，如果找不到则输出”NULL”。只有餐馆的数据有这个子任务。</p><h5 id="情感极性"><a href="#情感极性" class="headerlink" title="情感极性"></a>情感极性</h5><p>判断每一个E#A对的情感分类，类别包括正面、负面和中性。</p><p>上面的任务在人工标注时每次处理一个句子，但是会参考它的前后上下文的其它句子。下面是一个笔记本的评论的标注示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S1:The So called laptop Runs to Slow and I hate it! →</span><br><span class="line">&#123;LAPTOP#OPERATION_PERFORMANCE, negative&#125;, &#123;LAPTOP#GENERAL, negative&#125;</span><br><span class="line">S2:Do not buy it! → &#123;LAPTOP#GENERAL, negative&#125;</span><br><span class="line">S3:It is the worst laptop ever. → &#123;LAPTOP#GENERAL, negative&#125;</span><br></pre></td></tr></table></figure><p>下面是餐馆的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S1:I was very disappointed with this restaurant. →</span><br><span class="line">&#123;RESTAURANT#GENERAL, “restaurant”, negative, from=&quot;34&quot; to=&quot;44&quot;&#125;</span><br><span class="line">S2:I’ve asked a cart attendant for a lotus leaf wrapped rice and she replied back rice and just walked away. →&#123;SERVICE#GENERAL, “cart attendant”, negative, from=&quot;12&quot; to=&quot;26&quot;&#125;</span><br><span class="line">S3:I had to ask her three times before she finally came back with the dish I’ve requested. →</span><br><span class="line">&#123;SERVICE#GENERAL, “NULL”, negative&#125;</span><br><span class="line">S4:Food was okay, nothing great. →</span><br><span class="line">&#123;FOOD#QUALITY, “Food”, neutral, from=&quot;0&quot; to=&quot;4&quot;&#125;</span><br><span class="line">S5:Chow fun was dry; pork shu mai was more than usually greasy and had to share a table with loud and rude family. →</span><br><span class="line">&#123;FOOD#QUALITY, “Chow fun”, negative, from=&quot;0&quot; to=&quot;8&quot;&#125;,</span><br><span class="line">&#123;FOOD#QUALITY, “pork shu mai”, negative, from=&quot;18&quot; to=&quot;30&quot;&#125;,</span><br><span class="line">&#123;AMBIENCE#GENERAL, “NULL”, negative&#125;</span><br><span class="line">S6:I/we will never go back to this place again. →</span><br><span class="line">&#123;RESTAURANT#GENERAL, “place”, negative, from=&quot;32&quot; to=&quot;37&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="文本级别的ABSA"><a href="#文本级别的ABSA" class="headerlink" title="文本级别的ABSA"></a>文本级别的ABSA</h4><p>上面的句子级别的问题是模型不能参考上下文(人工标注是参考了的)，因此还有一个文本级别的ABSA任务。它的任务和前面是一样的，只不过输入是整个评论文本，下面是一些示例。</p><p>下面是整个评论文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Review id:LPT1 (Laptop)</span><br><span class="line">&quot;The So called laptop Runs to Slow and I hate it! Do not buy it! It is the worst laptop ever.&quot;</span><br></pre></td></tr></table></figure><p>期望的输出(标注)为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;LAPTOP#OPERATION_PERFORMANCE, negative&#125;</span><br><span class="line">&#123;LAPTOP#GENERAL, negative&#125;</span><br></pre></td></tr></table></figure></p><p>但是它并不能简单的把文本分成句子，然后把所有句子的结果合并起来，因为一个段落里可能有多个句子都在说同一个E#A对，如果是这样的话需要判断最主要的情感倾向，比如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Review id:RST1 (Restaurant)</span><br><span class="line">&quot;I was very disappointed with this restaurant. I’ve asked a cart attendant for a lotus leaf wrapped rice and she replied back rice and just walked away. I had to ask her three times before she finally came back with the dish I’ve requested. Food was okay, nothing great. Chow fun was dry; pork shu mai was more than usually greasy and had to share a table with loud and rude family. I/we will never go back to this place again.&quot;</span><br></pre></td></tr></table></figure><p>它的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;RESTAURANT#GENERAL, negative&#125;</span><br><span class="line">&#123;SERVICE#GENERAL, negative&#125;</span><br><span class="line">&#123;FOOD#QUALITY, negative&#125;</span><br><span class="line">&#123;AMBIENCE#GENERAL, negative&#125;</span><br></pre></td></tr></table></figure><p>它就是前面句子级别的同一段文本，关于FOOD#QUALITY有一个中性两个负面的，因此总的情感倾向是负面的。如果多个句子的情感倾向是冲突的，比如一个正面一个负面，则需要识别为冲突(conflict)。比如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Review id: RST2 (Restaurant)</span><br><span class="line">“This little place has a cute interior decor and affordable city prices. The pad seew chicken was delicious, however the pad thai was far too oily. I would just ask for no oil next time.”</span><br></pre></td></tr></table></figure><p>它的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;AMBIENCE#GENERAL, positive&#125;</span><br><span class="line">&#123;RESTAURANT#PRICES, positive&#125;</span><br><span class="line">&#123;FOOD#QUALITY, conflict&#125;</span><br><span class="line">&#123;RESTAURANT#GENERAL, positive&#125;</span><br></pre></td></tr></table></figure><p>FOOD#QUALITY既有正面的又有负面的，因此标注为冲突。</p><h4 id="Out-of-domain-ABSA"><a href="#Out-of-domain-ABSA" class="headerlink" title="Out-of-domain ABSA"></a>Out-of-domain ABSA</h4><p>这个任务的测试数据的领域没有训练数据，它考察的是模型在不同领域的泛化能力。</p><h2 id="IMDB"><a href="#IMDB" class="headerlink" title="IMDB"></a>IMDB</h2><p>电影的评论数据，二分类任务，包括25,000个训练数据和25,000个测试数据。可以在<a href="http://ai.stanford.edu/~amaas/data/sentiment/">这里</a>下载。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sentiment analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6问题集合</title>
      <link href="/2022/09/11/xv6-questions/"/>
      <url>/2022/09/11/xv6-questions/</url>
      
        <content type="html"><![CDATA[<h2 id="进程表在哪"><a href="#进程表在哪" class="headerlink" title="进程表在哪"></a>进程表在哪</h2><h2 id="进程切换的过程"><a href="#进程切换的过程" class="headerlink" title="进程切换的过程"></a>进程切换的过程</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验十一 networking</title>
      <link href="/2022/09/10/xv6-lab11/"/>
      <url>/2022/09/10/xv6-lab11/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/net.html">https://pdos.csail.mit.edu/6.S081/2020/labs/net.html</a></li></ul><p>实验的目的是为了让我们实现一个网卡驱动在数据链路层的数据收发函数，该函数的实现需要参考E1000的用户手册来完成。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><p>函数e1000_recv需要注意的地方：</p><ul><li>不需要加锁，因为该函数会一次性读取rx_ring上所有的数据，且该函数位于数据链路层，数据链路层还不涉及进程的概念。在读取完数据之后，该函数会调用net_rx函数，将数据送给上层应用。</li><li>关于index的理解，在recv函数中，寄存器里保存的index是上次已经被处理过的位置，因此，拿到寄存器里的值后，需要加一移动至下个位置。且本次的数据被送至上层应用之后，会对其mbuf进行清理并申请新的mbuf用于保存下次接收的数据。</li></ul></li></ul><ul><li><p>函数e1000_transmit需要注意的地方：</p><ul><li>该相关寄存器中保存的index值为本次需要处理的数据索引，因此，本次处理完之后，需要对该值加一并重新放入寄存器。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/e1000.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// printf(&quot;e1000 transmit\n&quot;);</span></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="comment">// First ask the E1000 for the TX ring index at which it&#x27;s expecting</span></span><br><span class="line">  <span class="comment">// the next packet, by reading the E1000_TDT control register.</span></span><br><span class="line">  uint32 index = regs[E1000_TDT];</span><br><span class="line">  <span class="comment">// Then check if the the ring is overflowing. If E1000_TXD_STAT_DD is</span></span><br><span class="line">  <span class="comment">// not set in the descriptor indexed by E1000_TDT, the E1000 hasn&#x27;t</span></span><br><span class="line">  <span class="comment">// finished the corresponding previous transmission request, so return an error.</span></span><br><span class="line">  <span class="keyword">if</span> ((tx_ring[index].status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, use mbuffree() to free the last mbuf that was transmitted</span></span><br><span class="line">  <span class="comment">// from that descriptor (if there was one).</span></span><br><span class="line">  <span class="keyword">if</span> (tx_mbufs[index]) &#123;</span><br><span class="line">    mbuffree(tx_mbufs[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// m-&gt;head points to the packet&#x27;s content in memory</span></span><br><span class="line">  tx_ring[index].addr = (uint64)(m-&gt;head);</span><br><span class="line">  <span class="comment">//  and m-&gt;len is the packet length</span></span><br><span class="line">  tx_ring[index].length = m-&gt;len;</span><br><span class="line">  <span class="comment">// Set the necessary cmd flags (look at Section 3.3 in the E1000 manual)</span></span><br><span class="line">  tx_ring[index].cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP;</span><br><span class="line">  <span class="comment">// and stash away a pointer to the mbuf for later freeing.</span></span><br><span class="line">  tx_mbufs[index] = m;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update the ring position by adding one to E1000_TDT modulo TX_RING_SIZE.</span></span><br><span class="line">  regs[E1000_TDT] = (index + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// printf(&quot;e2000 receive\n&quot;);</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// First ask the E1000 for the ring index at which the next waiting</span></span><br><span class="line">    <span class="comment">// received packet (if any) is located, by fetching the E1000_RDT</span></span><br><span class="line">    <span class="comment">// control register and adding one modulo RX_RING_SIZE.</span></span><br><span class="line">    uint32 index = regs[E1000_RDT];</span><br><span class="line">    index = (index + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then check if a new packet is available by checking for the</span></span><br><span class="line">    <span class="comment">// E1000_RXD_STAT_DD bit in the status portion of the descriptor.</span></span><br><span class="line">    <span class="comment">// If not, stop.</span></span><br><span class="line">    <span class="keyword">if</span> ((rx_ring[index].status &amp; E1000_RXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the mbuf&#x27;s m-&gt;len to the length reported in the descriptor.</span></span><br><span class="line">    rx_mbufs[index]-&gt;len = rx_ring[index].length;</span><br><span class="line">    <span class="comment">// rx_mbufs[index]-&gt;head = (char*)rx_ring[index].addr;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deliver the mbuf to the network stack using net_rx()</span></span><br><span class="line">    net_rx(rx_mbufs[index]);</span><br><span class="line">    <span class="comment">// Then allocate a new mbuf using mbufalloc() to replace the one just</span></span><br><span class="line">    <span class="comment">// given to net_rx().</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>* <span class="title">buf</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">    rx_mbufs[index] = buf;</span><br><span class="line">    <span class="comment">// Program its data pointer (m-&gt;head) into the descriptor.</span></span><br><span class="line">    rx_ring[index].addr = (uint64)buf-&gt;head;</span><br><span class="line">    <span class="comment">// Clear the descriptor&#x27;s status bits to zero</span></span><br><span class="line">    rx_ring[index].status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, update the E1000_RDT register to be the index of the</span></span><br><span class="line">    <span class="comment">// last ring descriptor processed.</span></span><br><span class="line">    regs[E1000_RDT] = index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件nettest.c的dns函数，将8.8.8.8改为114.114.114.114；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/nettest.c</span></span><br><span class="line">dst = (<span class="number">114</span> &lt;&lt; <span class="number">24</span>) | (<span class="number">114</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">114</span> &lt;&lt; <span class="number">8</span>) | (<span class="number">114</span> &lt;&lt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h2 id="make-grade"><a href="#make-grade" class="headerlink" title="make grade"></a>make grade</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (net)&gt; ./grade-lab-net</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">== Test running nettests == (4.2s) </span><br><span class="line">== Test   nettest: ping == </span><br><span class="line">  nettest: ping: OK </span><br><span class="line">== Test   nettest: single process == </span><br><span class="line">  nettest: single process: OK </span><br><span class="line">== Test   nettest: multi-process == </span><br><span class="line">  nettest: multi-process: OK </span><br><span class="line">== Test   nettest: DNS == </span><br><span class="line">  nettest: DNS: OK </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 100/100</span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/e1000.c b/kernel/e1000.c</span><br><span class="line">index 70a2adf..9260f09 100644</span><br><span class="line">--- a/kernel/e1000.c</span><br><span class="line">+++ b/kernel/e1000.c</span><br><span class="line">@@ -91,7 +91,7 @@ e1000_init(uint32 *xregs)</span><br><span class="line">   regs[E1000_RADV] = 0; // interrupt after every packet (no timer)</span><br><span class="line">   regs[E1000_IMS] = (1 &lt;&lt; <span class="string">7); // RXDW -- Receiver Descriptor Write Back</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">-</span></span><br><span class="line"><span class="string">+/*</span></span><br><span class="line"><span class="string"> int</span></span><br><span class="line"><span class="string"> e1000_transmit(struct mbuf *m)</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string">@@ -116,6 +116,96 @@ e1000_recv(void)</span></span><br><span class="line"><span class="string">   // Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line"><span class="string">   //</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">+*/</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+int</span></span><br><span class="line"><span class="string">+e1000_transmit(struct mbuf *m)</span></span><br><span class="line"><span class="string">+&#123;</span></span><br><span class="line"><span class="string">+  //</span></span><br><span class="line"><span class="string">+  // Your code here.</span></span><br><span class="line"><span class="string">+  //</span></span><br><span class="line"><span class="string">+  // the mbuf contains an ethernet frame; program it into</span></span><br><span class="line"><span class="string">+  // the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line"><span class="string">+  // a pointer so that it can be freed after sending.</span></span><br><span class="line"><span class="string">+  //</span></span><br><span class="line"><span class="string">+  // printf(&quot;e1000 transmit\n&quot;);</span></span><br><span class="line"><span class="string">+  acquire(&amp;e1000_lock);</span></span><br><span class="line"><span class="string">+  // First ask the E1000 for the TX ring index at which it&#x27;s expecting</span></span><br><span class="line"><span class="string">+  // the next packet, by reading the E1000_TDT control register.</span></span><br><span class="line"><span class="string">+  uint32 index = regs[E1000_TDT];</span></span><br><span class="line"><span class="string">+  // Then check if the the ring is overflowing. If E1000_TXD_STAT_DD is</span></span><br><span class="line"><span class="string">+  // not set in the descriptor indexed by E1000_TDT, the E1000 hasn&#x27;t</span></span><br><span class="line"><span class="string">+  // finished the corresponding previous transmission request, so return an error.</span></span><br><span class="line"><span class="string">+  if ((tx_ring[index].status &amp; E1000_TXD_STAT_DD) == 0) &#123;</span></span><br><span class="line"><span class="string">+    release(&amp;e1000_lock);</span></span><br><span class="line"><span class="string">+    return -1;</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  // Otherwise, use mbuffree() to free the last mbuf that was transmitted</span></span><br><span class="line"><span class="string">+  // from that descriptor (if there was one).</span></span><br><span class="line"><span class="string">+  if (tx_mbufs[index]) &#123;</span></span><br><span class="line"><span class="string">+    mbuffree(tx_mbufs[index]);</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  // m-&gt;head points to the packet&#x27;s content in memory</span></span><br><span class="line"><span class="string">+  tx_ring[index].addr = (uint64)(m-&gt;head);</span></span><br><span class="line"><span class="string">+  //  and m-&gt;len is the packet length</span></span><br><span class="line"><span class="string">+  tx_ring[index].length = m-&gt;len;</span></span><br><span class="line"><span class="string">+  // Set the necessary cmd flags (look at Section 3.3 in the E1000 manual)</span></span><br><span class="line"><span class="string">+  tx_ring[index].cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP;</span></span><br><span class="line"><span class="string">+  // and stash away a pointer to the mbuf for later freeing.</span></span><br><span class="line"><span class="string">+  tx_mbufs[index] = m;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  // update the ring position by adding one to E1000_TDT modulo TX_RING_SIZE.</span></span><br><span class="line"><span class="string">+  regs[E1000_TDT] = (index + 1) % TX_RING_SIZE;</span></span><br><span class="line"><span class="string">+  release(&amp;e1000_lock);</span></span><br><span class="line"><span class="string">+  return 0;</span></span><br><span class="line"><span class="string">+&#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+static void</span></span><br><span class="line"><span class="string">+e1000_recv(void)</span></span><br><span class="line"><span class="string">+&#123;</span></span><br><span class="line"><span class="string">+  //</span></span><br><span class="line"><span class="string">+  // Your code here.</span></span><br><span class="line"><span class="string">+  //</span></span><br><span class="line"><span class="string">+  // Check for packets that have arrived from the e1000</span></span><br><span class="line"><span class="string">+  // Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line"><span class="string">+  //</span></span><br><span class="line"><span class="string">+  // printf(&quot;e2000 receive\n&quot;);</span></span><br><span class="line"><span class="string">+  for (;;) &#123;</span></span><br><span class="line"><span class="string">+    // First ask the E1000 for the ring index at which the next waiting</span></span><br><span class="line"><span class="string">+    // received packet (if any) is located, by fetching the E1000_RDT</span></span><br><span class="line"><span class="string">+    // control register and adding one modulo RX_RING_SIZE.</span></span><br><span class="line"><span class="string">+    uint32 index = regs[E1000_RDT];</span></span><br><span class="line"><span class="string">+    index = (index + 1) % RX_RING_SIZE;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+    // Then check if a new packet is available by checking for the</span></span><br><span class="line"><span class="string">+    // E1000_RXD_STAT_DD bit in the status portion of the descriptor.</span></span><br><span class="line"><span class="string">+    // If not, stop.</span></span><br><span class="line"><span class="string">+    if ((rx_ring[index].status &amp; E1000_RXD_STAT_DD) == 0) &#123;</span></span><br><span class="line"><span class="string">+      return;</span></span><br><span class="line"><span class="string">+    &#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+    // update the mbuf&#x27;s m-&gt;len to the length reported in the descriptor.</span></span><br><span class="line"><span class="string">+    rx_mbufs[index]-&gt;len = rx_ring[index].length;</span></span><br><span class="line"><span class="string">+    // rx_mbufs[index]-&gt;head = (char*)rx_ring[index].addr;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+    // Deliver the mbuf to the network stack using net_rx()</span></span><br><span class="line"><span class="string">+    net_rx(rx_mbufs[index]);</span></span><br><span class="line"><span class="string">+    // Then allocate a new mbuf using mbufalloc() to replace the one just</span></span><br><span class="line"><span class="string">+    // given to net_rx().</span></span><br><span class="line"><span class="string">+    struct mbuf* buf = mbufalloc(0);</span></span><br><span class="line"><span class="string">+    rx_mbufs[index] = buf;</span></span><br><span class="line"><span class="string">+    // Program its data pointer (m-&gt;head) into the descriptor.</span></span><br><span class="line"><span class="string">+    rx_ring[index].addr = (uint64)buf-&gt;head;</span></span><br><span class="line"><span class="string">+    // Clear the descriptor&#x27;s status bits to zero</span></span><br><span class="line"><span class="string">+    rx_ring[index].status = 0;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+    // Finally, update the E1000_RDT register to be the index of the</span></span><br><span class="line"><span class="string">+    // last ring descriptor processed.</span></span><br><span class="line"><span class="string">+    regs[E1000_RDT] = index;</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> void</span></span><br><span class="line"><span class="string"> e1000_intr(void)</span></span><br><span class="line"><span class="string">diff --git a/packets.pcap b/packets.pcap</span></span><br><span class="line"><span class="string">index 82d353e..505fd0d 100644</span></span><br><span class="line"><span class="string">Binary files a/packets.pcap and b/packets.pcap differ</span></span><br><span class="line"><span class="string">diff --git a/time.txt b/time.txt</span></span><br><span class="line"><span class="string">new file mode 100644</span></span><br><span class="line"><span class="string">index 0000000..f599e28</span></span><br><span class="line"><span class="string">--- /dev/null</span></span><br><span class="line"><span class="string">+++ b/time.txt</span></span><br><span class="line"><span class="string">@@ -0,0 +1 @@</span></span><br><span class="line"><span class="string">+10</span></span><br><span class="line"><span class="string">diff --git a/user/nettests.c b/user/nettests.c</span></span><br><span class="line"><span class="string">index edf46ef..6f297b3 100644</span></span><br><span class="line"><span class="string">--- a/user/nettests.c</span></span><br><span class="line"><span class="string">+++ b/user/nettests.c</span></span><br><span class="line"><span class="string">@@ -198,7</span> +198,9 @@ dns()</span><br><span class="line">   memset(ibuf, 0, N);</span><br><span class="line">   </span><br><span class="line">   // 8.8.8.8: google<span class="string">&#x27;s name server</span></span><br><span class="line"><span class="string">-  dst = (8 &lt;&lt; 24) | (8 &lt;&lt; 16) | (8 &lt;&lt; 8) | (8 &lt;&lt; 0);</span></span><br><span class="line"><span class="string">+  // dst = (8 &lt;&lt; 24) | (8 &lt;&lt; 16) | (8 &lt;&lt; 8) | (8 &lt;&lt; 0);</span></span><br><span class="line"><span class="string">+  // 114.114.114.114: 电信联通移动全国通用DNS</span></span><br><span class="line"><span class="string">+  dst = (114 &lt;&lt; 24) | (114 &lt;&lt; 16) | (114 &lt;&lt; 8) | (114 &lt;&lt; 0);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">   if((fd = connect(dst, 10000, 53)) &lt; 0)&#123;</span></span><br><span class="line"><span class="string">     fprintf(2, &quot;ping: connect() failed\n&quot;);</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验十 mmap</title>
      <link href="/2022/09/09/xv6-lab10/"/>
      <url>/2022/09/09/xv6-lab10/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/mmap.html">https://pdos.csail.mit.edu/6.S081/2020/labs/mmap.html</a></li></ul><p>本次实验只需实现简化版的 <code>mmap</code>和<code>munmap</code></p><ul><li>保证 <code>addr</code> 和 <code>offset</code> 都为 0，也即：在虚拟空间中找足够大的连续页面，将 fd 对应文件的前 length 字节存储在里面。</li><li><code>flags</code> 只需考虑 <code>MAP_SHARED</code> 和 <code>MAP_PRIVATE</code>；<code>prot</code> 只需考虑 <code>PROT_WRITE</code> 和 <code>PROT_READ</code>。</li><li>允许不同进程把同一个 <code>MAP_SHARED</code> 的文件映射到不同的物理页面上。</li><li><code>munmap</code> 释放的范围保证是一段 <code>mmap</code> 了的空间的开头一段、或结尾一段、或全部，不会从中间挖一个洞出来。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure><h2 id="定义每个进程的VMA（虚拟内存区域）"><a href="#定义每个进程的VMA（虚拟内存区域）" class="headerlink" title="定义每个进程的VMA（虚拟内存区域）"></a>定义每个进程的VMA（虚拟内存区域）</h2><p>首先设计一个数据结构 VMA，记录 mmap 分配的虚拟内存空间，包括地址、长度、权限等等信息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/pro.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> shared;</span><br><span class="line">  <span class="type">int</span> perm;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filept</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">nxt</span>;</span></span><br><span class="line">  <span class="type">int</span> valid;</span><br><span class="line">  uint64 vmstart, vmend;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vmalist</span>;</span>      <span class="comment">// linklist of vma</span></span><br><span class="line">  uint64 curmax;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里，我并没有直接记录 mmap 输入的变量，而是做了一些转换方便后续操作：</p><ul><li>shared 为 1 表示 MAP_SHARED，为 0 表示 MAP_PRIVATE</li><li>perm 指示 pte 的权限，即 PTE_W 或 PTE_R 或二者都有，根据 prot 设置</li><li>filept 是指向文件的指针，指向当前进程打开的描述符为 fd 的文件</li><li>valid 指示该 VMA 是否正在被某进程使用中</li><li>vmstart 和 vmend 是根据 addr 和 length 计算出来的与一页对齐的 vma 地址范围，因为我们分配内存空间一定是按页分配的</li><li>每一个进程的 PCB 中记录它用到的所有 VMA——我用了一个链表，所以有一个 nxt 指针字段</li></ul><p>如何确定VMA的开始和结束地址呢？<br>从高地址处向低地址找这样的“不用区域”，为此在每个 PCB 里记录一下已分配区域的最低地址 curmax，下次就从 curmax 继续往下分配。</p><p>开一个 VMA 全局数组（16 个即可），当某进程执行 mmap 系统调用时就从该数组中找一个 valid 无效的 VMA 分配给该进程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/param.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVMA         16 <span class="comment">// maximum number of VMAs</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> <span class="title">vmas</span>[<span class="title">NVMA</span>];</span></span><br><span class="line">&#125; vmatable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">      p-&gt;kstack = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">      p-&gt;curmax = MAXVA - <span class="number">2</span> * PGSIZE; <span class="comment">// init curmax for vma</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmainit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;vmatable.lock, <span class="string">&quot;vmatable&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> VMA*</span><br><span class="line"><span class="title function_">allocvma</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;vmatable.lock);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(vmatable.vmas[i].valid)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    vmatable.vmas[i].valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;vmatable.lock);</span><br><span class="line">  <span class="keyword">if</span>(i == NVMA) panic(<span class="string">&quot;allocvma&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> vmatable.vmas + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">deallocvma</span><span class="params">(<span class="keyword">struct</span> VMA *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;vmatable.lock);</span><br><span class="line">  vma-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  release(&amp;vmatable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line">......</span><br><span class="line"><span class="type">void</span>            <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmainit</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"><span class="keyword">struct</span> VMA*     <span class="title function_">allocvma</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">deallocvma</span><span class="params">(<span class="keyword">struct</span> VMA *)</span>; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/main.c</span></span><br><span class="line">...</span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    vmainit();       <span class="comment">// vma table</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>给多个进程分配 vma 显然是需要上锁的操作，我懒得麻烦就直接上全局锁了。</p><h2 id="sys-mmap-的实现"><a href="#sys-mmap-的实现" class="headerlink" title="sys_mmap 的实现"></a>sys_mmap 的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line">......</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><figure class="highlight pl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// user/usys.pl</span><br><span class="line">......</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;munmap&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mmap   22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_munmap 23</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">......</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_mmap]    sys_mmap,</span><br><span class="line">[SYS_munmap]  sys_munmap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">......</span><br><span class="line">$U/_zombie\</span><br><span class="line">$U/_mmaptest\</span><br></pre></td></tr></table></figure><p>首先分配一个 vma，按照上文所述含义填充 vma 的各个字段，注意要增加文件的 reference count，然后把这个 vma 加到进程的 vma 链表里面。mmap 是 lazy allocation 的，所以我们这时候无需 kalloc 物理内存，只需返回起始地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length, prot, flags, fd, offset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> ||</span><br><span class="line">     argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span> ||</span><br><span class="line">     argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> ||</span><br><span class="line">     argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> ||</span><br><span class="line">     argint(<span class="number">4</span>, &amp;fd) &lt; <span class="number">0</span> ||</span><br><span class="line">     argint(<span class="number">5</span>, &amp;offset) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(addr != <span class="number">0</span>) panic(<span class="string">&quot;sys_mmap&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(offset != <span class="number">0</span>) panic(<span class="string">&quot;sys_mmap&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">  <span class="keyword">if</span>((prot &amp; PROT_READ) &amp;&amp; !f-&gt;readable)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED) &amp;&amp; !f-&gt;writable)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// alloc a vma</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vma</span> =</span> allocvma();</span><br><span class="line">  <span class="keyword">if</span>(!vma)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// fill in vma</span></span><br><span class="line">  vma-&gt;perm = ((prot &amp; PROT_READ) ? PTE_R : <span class="number">0</span>) |</span><br><span class="line">              ((prot &amp; PROT_WRITE) ? PTE_W : <span class="number">0</span>);</span><br><span class="line">  vma-&gt;shared = (flags &amp; MAP_SHARED) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  vma-&gt;filept = f;</span><br><span class="line">  filedup(f);</span><br><span class="line">  <span class="comment">// add vma to process&#x27;s linklist</span></span><br><span class="line">  vma-&gt;nxt = p-&gt;vmalist;</span><br><span class="line">  p-&gt;vmalist = vma;</span><br><span class="line">  <span class="comment">// find an unused region in the process&#x27;s address space in which to map the file</span></span><br><span class="line">  uint64 vmaddr = PGROUNDDOWN(p-&gt;curmax - length);</span><br><span class="line">  <span class="keyword">if</span>(vmaddr % PGSIZE != <span class="number">0</span>)  panic(<span class="string">&quot;sys_mmap&quot;</span>);</span><br><span class="line">  vma-&gt;vmstart = vmaddr;</span><br><span class="line">  vma-&gt;vmend = p-&gt;curmax;</span><br><span class="line">  p-&gt;curmax = vmaddr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vmaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前所述，mmap 是 lazy allocation 的，所以我们在 usertrap 里处理 page fault：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 cause = r_scause();</span><br><span class="line">    <span class="keyword">if</span>(cause == <span class="number">13</span> || cause == <span class="number">15</span>)&#123;</span><br><span class="line">      <span class="comment">// page fault</span></span><br><span class="line">      uint64 stval = r_stval();</span><br><span class="line">      <span class="keyword">if</span>(mmaplazy(stval, cause) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> brk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">brk:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>stval 就是产生 page fault 的地址，我们不需要读入整个文件，只需要申请并映射 stval 所在的那一页并读入这一页对应的文件数据即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mmaplazy</span><span class="params">(uint64 va, uint64 cause)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// find the corresponding vma</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(vma = p-&gt;vmalist; vma; vma = vma-&gt;nxt)</span><br><span class="line">    <span class="keyword">if</span>(vma-&gt;valid &amp;&amp; vma-&gt;vmstart &lt;= va &amp;&amp; va &lt; vma-&gt;vmend)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span>(!vma)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(cause == <span class="number">13</span> &amp;&amp; !(vma-&gt;perm &amp; PTE_R)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(cause == <span class="number">15</span> &amp;&amp; !(vma-&gt;perm &amp; PTE_W)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// allocate physical memory and map pte</span></span><br><span class="line">  <span class="type">char</span> *mem = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(mem == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  uint64 vaalign = PGROUNDDOWN(va);</span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, vaalign, PGSIZE, (uint64)mem, vma-&gt;perm|PTE_U|PTE_X) != <span class="number">0</span>)&#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// read content of file into allocated memory</span></span><br><span class="line">  mmapfileread(vma-&gt;filept, <span class="number">0</span>, (uint64)mem, vaalign - vma-&gt;vmstart, PGSIZE);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmapfileread</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span>&#123; </span><br><span class="line">  ilock(f-&gt;ip);</span><br><span class="line">  <span class="type">int</span> ret = readi(f-&gt;ip, user_dst, dst, off, n);</span><br><span class="line">  iunlock(f-&gt;ip);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="type">int</span>             <span class="title function_">mmapfileread</span><span class="params">(<span class="keyword">struct</span> file*, <span class="type">int</span>, uint64, uint, uint)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">mmaplazy</span><span class="params">(uint64, uint64)</span>; </span><br></pre></td></tr></table></figure><p>这里特别说明文件开始读的偏移位置 off 和读的长度 n 是怎么计算的，如图所示：<br><img src="xv6-lab10-1.png" alt=""><br>蓝色 va 是发生 pagefault 的地方，因此灰色页就是我们要读的页。绿色线段是文件占的大小，它一定从 vmstart 开始。从图上能直观的看出，我们要读的文件偏移量就是 vaalign-vmstart，又由于读一页，所以 n 就是 PGSIZE。</p><h2 id="munmap-的实现"><a href="#munmap-的实现" class="headerlink" title="munmap 的实现"></a>munmap 的实现</h2><ul><li>找到包含释放空间的 vma</li><li>如果 vma 是 shared 的，则把现在的内容写回文件</li><li>解除页表的映射</li><li>分情况更新 vma：如果释放的只是 vma 区域的一部分，则更新 vma 的 vmstart 和 vmend；如果释放了整个 vma 区域，则把它从链表里拿出来、释放（valid 置零）、减少文件 reference count。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find the VMA for the address range</span></span><br><span class="line">  uint64 st = PGROUNDDOWN(addr);</span><br><span class="line">  uint64 ed = PGROUNDUP(addr + length);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vma</span> =</span> <span class="number">0</span>, *pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(vma = p-&gt;vmalist; vma; vma = vma-&gt;nxt)&#123;</span><br><span class="line">    <span class="keyword">if</span>(vma-&gt;valid &amp;&amp; vma-&gt;vmstart &lt;= st &amp;&amp; ed &lt;= vma-&gt;vmend)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    pre = vma;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!vma)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write back if needed</span></span><br><span class="line">  <span class="keyword">if</span>(vma-&gt;shared &amp;&amp; (vma-&gt;perm | PTE_W))</span><br><span class="line">    mmapfilewrite(vma-&gt;filept, st, ed - st);</span><br><span class="line">  <span class="comment">// unmap specified pages</span></span><br><span class="line">  <span class="keyword">for</span>(uint64 i = st; i &lt; ed; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(walkaddr(p-&gt;pagetable, i))&#123;</span><br><span class="line">      <span class="comment">// need to check because vma is allocated lazily</span></span><br><span class="line">      uvmunmap(p-&gt;pagetable, i, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// update info in vma</span></span><br><span class="line">  <span class="keyword">if</span>(vma-&gt;vmstart == st &amp;&amp; ed &lt; vma-&gt;vmend)</span><br><span class="line">    vma-&gt;vmstart = PGROUNDDOWN(addr + length);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(vma-&gt;vmstart &lt; st &amp;&amp; ed == vma-&gt;vmend)</span><br><span class="line">    vma-&gt;vmend = PGROUNDUP(addr);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(vma-&gt;vmstart == st &amp;&amp; ed == vma-&gt;vmend)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="number">0</span>)  p-&gt;vmalist = vma-&gt;nxt;</span><br><span class="line">    <span class="keyword">else</span>  pre-&gt;nxt = vma-&gt;nxt, vma-&gt;nxt = <span class="number">0</span>;</span><br><span class="line">    fileclose(vma-&gt;filept);</span><br><span class="line">    deallocvma(vma);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mmapfilewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, uint n)</span>&#123;</span><br><span class="line">  <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">    <span class="type">int</span> n1 = n - i;</span><br><span class="line">    <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">      n1 = max;</span><br><span class="line"></span><br><span class="line">    begin_op();</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="type">int</span> r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, i, n1);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    end_op();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">      <span class="comment">// error from writei</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i += r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，解除页表映射前一定先 walk 一下，因为我们是 lazy allocation，释放空间里的页面不一定全部都已经建立了映射。</p><p>还有一个点，如果释放区域是 vma 开头或者结尾区域，那怎么调整 vmstart 或 vmend 呢？看图说话：<br><img src="xv6-lab10-2.png" alt=""><br>理论上来说，释放了 vma 一部分后，这部分空间可以拿出来再次分配（垃圾回收），或者可以进行内存紧缩。我并没有实现它们，这是可以继续改进的一点。</p><p>最后，在 exit 中释放掉该进程的所有 vma，要干的事和 munmap 差不多：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vma</span> =</span> <span class="number">0</span>, *nxtvma = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(vma = p-&gt;vmalist; vma; vma = nxtvma)&#123;</span><br><span class="line">    nxtvma = vma-&gt;nxt;</span><br><span class="line">    <span class="keyword">for</span>(uint64 i = vma-&gt;vmstart; i &lt; vma-&gt;vmend; i += PGSIZE)</span><br><span class="line">      <span class="keyword">if</span>(walkaddr(p-&gt;pagetable, i))</span><br><span class="line">        uvmunmap(p-&gt;pagetable, i, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    vma-&gt;nxt = <span class="number">0</span>;</span><br><span class="line">    fileclose(vma-&gt;filept);</span><br><span class="line">    deallocvma(vma);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;vmalist = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以及在 fork 的时候把 vma 给到子进程，要干的事和 mmap 差不多：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">vma</span> =</span> <span class="number">0</span>, *pre = <span class="number">0</span>;</span><br><span class="line">  np-&gt;vmalist = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(vma = p-&gt;vmalist; vma; vma = vma-&gt;nxt)&#123;</span><br><span class="line">    <span class="comment">// alloc a vma</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">newvma</span> =</span> allocvma();</span><br><span class="line">    <span class="comment">// fill in newvma</span></span><br><span class="line">    newvma-&gt;shared = vma-&gt;shared;</span><br><span class="line">    newvma-&gt;perm = vma-&gt;perm;</span><br><span class="line">    newvma-&gt;filept = vma-&gt;filept;</span><br><span class="line">    newvma-&gt;vmstart = vma-&gt;vmstart;</span><br><span class="line">    newvma-&gt;vmend = vma-&gt;vmend;</span><br><span class="line">    filedup(vma-&gt;filept);</span><br><span class="line">    <span class="comment">// add newvma to np&#x27;s linklist</span></span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="number">0</span>)  np-&gt;vmalist = newvma;</span><br><span class="line">    <span class="keyword">else</span>  pre-&gt;nxt = newvma, newvma-&gt;nxt = <span class="number">0</span>;</span><br><span class="line">    pre = newvma;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="make-grade"><a href="#make-grade" class="headerlink" title="make grade"></a>make grade</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (mmap)&gt; ./grade-lab-mmap</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">== Test running mmaptest == (6.1s) </span><br><span class="line">== Test   mmaptest: mmap f == </span><br><span class="line">  mmaptest: mmap f: OK </span><br><span class="line">== Test   mmaptest: mmap private == </span><br><span class="line">  mmaptest: mmap private: OK </span><br><span class="line">== Test   mmaptest: mmap read-only == </span><br><span class="line">  mmaptest: mmap read-only: OK </span><br><span class="line">== Test   mmaptest: mmap <span class="built_in">read</span>/write == </span><br><span class="line">  mmaptest: mmap <span class="built_in">read</span>/write: OK </span><br><span class="line">== Test   mmaptest: mmap dirty == </span><br><span class="line">  mmaptest: mmap dirty: OK </span><br><span class="line">== Test   mmaptest: not-mapped unmap == </span><br><span class="line">  mmaptest: not-mapped unmap: OK </span><br><span class="line">== Test   mmaptest: two files == </span><br><span class="line">  mmaptest: two files: OK </span><br><span class="line">== Test   mmaptest: fork_test == </span><br><span class="line">  mmaptest: fork_test: OK </span><br><span class="line">== Test usertests == usertests: OK (445.9s) </span><br><span class="line">    (Old xv6.out.usertests failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 140/140</span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index d8509b1..31803d4 100644</span><br><span class="line">--- a/Makefile</span><br><span class="line">+++ b/Makefile</span><br><span class="line">@@ -175,6 +175,7 @@ UPROGS=\</span><br><span class="line"> <span class="variable">$U</span>/_grind\</span><br><span class="line"> <span class="variable">$U</span>/_wc\</span><br><span class="line"> <span class="variable">$U</span>/_zombie\</span><br><span class="line">+<span class="variable">$U</span>/_mmaptest\</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">diff --git a/grade-lab-mmap b/grade-lab-mmap</span><br><span class="line">index f1a67bb..9313312 100755</span><br><span class="line">--- a/grade-lab-mmap</span><br><span class="line">+++ b/grade-lab-mmap</span><br><span class="line">@@ -47,7 +47,7 @@ def test_mmaptest_fork_test():</span><br><span class="line"> def test_usertests():</span><br><span class="line">     r.run_qemu(shell_script([</span><br><span class="line">         <span class="string">&#x27;usertests&#x27;</span></span><br><span class="line">-    ]), <span class="built_in">timeout</span>=300)</span><br><span class="line">+    ]), <span class="built_in">timeout</span>=1000)</span><br><span class="line">     r.match(<span class="string">&#x27;^ALL TESTS PASSED$&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> @<span class="built_in">test</span>(1, <span class="string">&quot;time&quot;</span>)</span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index 41098f4..51f05dd 100644</span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ -33,6 +33,8 @@ void            fileinit(void);</span><br><span class="line"> int             fileread(struct file*, uint64, int n);</span><br><span class="line"> int             filestat(struct file*, uint64 addr);</span><br><span class="line"> int             filewrite(struct file*, uint64, int n);</span><br><span class="line">+int             mmapfileread(struct file*, int, uint64, uint, uint);</span><br><span class="line">+int             mmapfilewrite(struct file*, uint64, uint);</span><br><span class="line"> </span><br><span class="line"> // fs.c</span><br><span class="line"> void            fsinit(int);</span><br><span class="line">@@ -105,6 +107,10 @@ void            yield(void);</span><br><span class="line"> int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);</span><br><span class="line"> int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);</span><br><span class="line"> void            procdump(void);</span><br><span class="line">+void            vmainit(void); </span><br><span class="line">+struct VMA*     allocvma(void);</span><br><span class="line">+void            deallocvma(struct VMA *);</span><br><span class="line">+int             mmaplazy(uint64, uint64); </span><br><span class="line"> </span><br><span class="line"> // swtch.S</span><br><span class="line"> void            swtch(struct context*, struct context*);</span><br><span class="line">diff --git a/kernel/file.c b/kernel/file.c</span><br><span class="line">index 25fa226..6a6d5ef 100644</span><br><span class="line">--- a/kernel/file.c</span><br><span class="line">+++ b/kernel/file.c</span><br><span class="line">@@ -180,3 +180,35 @@ filewrite(struct file *f, uint64 addr, int n)</span><br><span class="line">   <span class="built_in">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">+int </span><br><span class="line">+mmapfileread(struct file *f, int user_dst, uint64 dst, uint off, uint n)&#123; </span><br><span class="line">+  ilock(f-&gt;ip);</span><br><span class="line">+  int ret = readi(f-&gt;ip, user_dst, dst, off, n);</span><br><span class="line">+  iunlock(f-&gt;ip);</span><br><span class="line">+  <span class="built_in">return</span> ret;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+int </span><br><span class="line">+mmapfilewrite(struct file *f, uint64 addr, uint n)&#123;</span><br><span class="line">+  int max = ((MAXOPBLOCKS-1-1-2) / 2) * BSIZE;</span><br><span class="line">+  int i = 0;</span><br><span class="line">+  <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">+    int n1 = n - i;</span><br><span class="line">+    <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">+      n1 = max;</span><br><span class="line">+</span><br><span class="line">+    begin_op();</span><br><span class="line">+    ilock(f-&gt;ip);</span><br><span class="line">+    int r = writei(f-&gt;ip, 1, addr + i, i, n1);</span><br><span class="line">+    iunlock(f-&gt;ip);</span><br><span class="line">+    end_op();</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span>(r != n1)&#123;</span><br><span class="line">+      // error from writei</span><br><span class="line">+      <span class="built_in">break</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+    i += r;</span><br><span class="line">+  &#125;</span><br><span class="line">+  int ret = (i == n ? n : -1);</span><br><span class="line">+  <span class="built_in">return</span> ret;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/main.c b/kernel/main.c</span><br><span class="line">index 5d7ad49..e4e7013 100644</span><br><span class="line">--- a/kernel/main.c</span><br><span class="line">+++ b/kernel/main.c</span><br><span class="line">@@ -27,6 +27,7 @@ main()</span><br><span class="line">     binit();         // buffer cache</span><br><span class="line">     iinit();         // inode cache</span><br><span class="line">     fileinit();      // file table</span><br><span class="line">+    vmainit();       // vma table</span><br><span class="line">     virtio_disk_init(); // emulated hard disk</span><br><span class="line">     userinit();      // first user process</span><br><span class="line">     __sync_synchronize();</span><br><span class="line">diff --git a/kernel/param.h b/kernel/param.h</span><br><span class="line">index b5fdcb2..b51db5c 100644</span><br><span class="line">--- a/kernel/param.h</span><br><span class="line">+++ b/kernel/param.h</span><br><span class="line">@@ -11,3 +11,4 @@</span><br><span class="line"> <span class="comment">#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache</span></span><br><span class="line"> <span class="comment">#define FSSIZE       1000  // size of file system in blocks</span></span><br><span class="line"> <span class="comment">#define MAXPATH      128   // maximum file path name</span></span><br><span class="line">+<span class="comment">#define NVMA         16  // maximum number of VMAs</span></span><br><span class="line">diff --git a/kernel/proc.c b/kernel/proc.c</span><br><span class="line">index ba1a9e3..8626dab 100644</span><br><span class="line">--- a/kernel/proc.c</span><br><span class="line">+++ b/kernel/proc.c</span><br><span class="line">@@ -12,6 +12,11 @@ struct proc proc[NPROC];</span><br><span class="line"> </span><br><span class="line"> struct proc *initproc;</span><br><span class="line"> </span><br><span class="line">+struct &#123;</span><br><span class="line">+  struct spinlock lock;</span><br><span class="line">+  struct VMA vmas[NVMA];</span><br><span class="line">+&#125; vmatable;</span><br><span class="line">+</span><br><span class="line"> int nextpid = 1;</span><br><span class="line"> struct spinlock pid_lock;</span><br><span class="line"> </span><br><span class="line">@@ -48,6 +53,7 @@ procinit(void)</span><br><span class="line">   <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">       initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">       p-&gt;kstack = KSTACK((int) (p - proc));</span><br><span class="line">+      p-&gt;curmax = MAXVA - 2 * PGSIZE; // init curmax <span class="keyword">for</span> vma</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">@@ -300,6 +306,24 @@ fork(void)</span><br><span class="line"> </span><br><span class="line">   pid = np-&gt;pid;</span><br><span class="line"> </span><br><span class="line">+  struct VMA *vma = 0, *pre = 0;</span><br><span class="line">+  np-&gt;vmalist = 0;</span><br><span class="line">+  <span class="keyword">for</span>(vma = p-&gt;vmalist; vma; vma = vma-&gt;nxt)&#123;</span><br><span class="line">+    // alloc a vma</span><br><span class="line">+    struct VMA *newvma = allocvma();</span><br><span class="line">+    // fill <span class="keyword">in</span> newvma</span><br><span class="line">+    newvma-&gt;shared = vma-&gt;shared;</span><br><span class="line">+    newvma-&gt;perm = vma-&gt;perm;</span><br><span class="line">+    newvma-&gt;filept = vma-&gt;filept;</span><br><span class="line">+    newvma-&gt;vmstart = vma-&gt;vmstart;</span><br><span class="line">+    newvma-&gt;vmend = vma-&gt;vmend;</span><br><span class="line">+    filedup(vma-&gt;filept);</span><br><span class="line">+    // add newvma to np<span class="string">&#x27;s linklist</span></span><br><span class="line"><span class="string">+    if(pre == 0)  np-&gt;vmalist = newvma;</span></span><br><span class="line"><span class="string">+    else  pre-&gt;nxt = newvma, newvma-&gt;nxt = 0;</span></span><br><span class="line"><span class="string">+    pre = newvma;</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+  </span></span><br><span class="line"><span class="string">   np-&gt;state = RUNNABLE;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">   release(&amp;np-&gt;lock);</span></span><br><span class="line"><span class="string">@@ -344,6 +368,18 @@ exit(int status)</span></span><br><span class="line"><span class="string">   if(p == initproc)</span></span><br><span class="line"><span class="string">     panic(&quot;init exiting&quot;);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">+  struct VMA *vma = 0, *nxtvma = 0;</span></span><br><span class="line"><span class="string">+  for(vma = p-&gt;vmalist; vma; vma = nxtvma)&#123;</span></span><br><span class="line"><span class="string">+    nxtvma = vma-&gt;nxt;</span></span><br><span class="line"><span class="string">+    for(uint64 i = vma-&gt;vmstart; i &lt; vma-&gt;vmend; i += PGSIZE)</span></span><br><span class="line"><span class="string">+      if(walkaddr(p-&gt;pagetable, i))</span></span><br><span class="line"><span class="string">+        uvmunmap(p-&gt;pagetable, i, 1, 1);</span></span><br><span class="line"><span class="string">+    vma-&gt;nxt = 0;</span></span><br><span class="line"><span class="string">+    fileclose(vma-&gt;filept);</span></span><br><span class="line"><span class="string">+    deallocvma(vma);</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+  p-&gt;vmalist = 0;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">   // Close all open files.</span></span><br><span class="line"><span class="string">   for(int fd = 0; fd &lt; NOFILE; fd++)&#123;</span></span><br><span class="line"><span class="string">     if(p-&gt;ofile[fd])&#123;</span></span><br><span class="line"><span class="string">@@ -701,3 +737,59 @@ procdump(void)</span></span><br><span class="line"><span class="string">     printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+void</span></span><br><span class="line"><span class="string">+vmainit(void)</span></span><br><span class="line"><span class="string">+&#123;</span></span><br><span class="line"><span class="string">+  initlock(&amp;vmatable.lock, &quot;vmatable&quot;);</span></span><br><span class="line"><span class="string">+&#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+struct VMA*</span></span><br><span class="line"><span class="string">+allocvma(void)</span></span><br><span class="line"><span class="string">+&#123;</span></span><br><span class="line"><span class="string">+  acquire(&amp;vmatable.lock);</span></span><br><span class="line"><span class="string">+  int i;</span></span><br><span class="line"><span class="string">+  for(i = 0; i &lt; NVMA; i++)&#123;</span></span><br><span class="line"><span class="string">+    if(vmatable.vmas[i].valid)</span></span><br><span class="line"><span class="string">+      continue;</span></span><br><span class="line"><span class="string">+    vmatable.vmas[i].valid = 1;</span></span><br><span class="line"><span class="string">+    break;</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+  release(&amp;vmatable.lock);</span></span><br><span class="line"><span class="string">+  if(i == NVMA) panic(&quot;allocvma&quot;);</span></span><br><span class="line"><span class="string">+  return vmatable.vmas + i;</span></span><br><span class="line"><span class="string">+&#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+void</span></span><br><span class="line"><span class="string">+deallocvma(struct VMA *vma)</span></span><br><span class="line"><span class="string">+&#123;</span></span><br><span class="line"><span class="string">+  acquire(&amp;vmatable.lock);</span></span><br><span class="line"><span class="string">+  vma-&gt;valid = 0;</span></span><br><span class="line"><span class="string">+  release(&amp;vmatable.lock);</span></span><br><span class="line"><span class="string">+&#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+int</span></span><br><span class="line"><span class="string">+mmaplazy(uint64 va, uint64 cause)</span></span><br><span class="line"><span class="string">+&#123;</span></span><br><span class="line"><span class="string">+  struct proc *p = myproc();</span></span><br><span class="line"><span class="string">+  // find the corresponding vma</span></span><br><span class="line"><span class="string">+  struct VMA *vma = 0;</span></span><br><span class="line"><span class="string">+  for(vma = p-&gt;vmalist; vma; vma = vma-&gt;nxt)</span></span><br><span class="line"><span class="string">+    if(vma-&gt;valid &amp;&amp; vma-&gt;vmstart &lt;= va &amp;&amp; va &lt; vma-&gt;vmend)</span></span><br><span class="line"><span class="string">+      break;</span></span><br><span class="line"><span class="string">+  if(!vma)  return -1;</span></span><br><span class="line"><span class="string">+  if(cause == 13 &amp;&amp; !(vma-&gt;perm &amp; PTE_R)) return -1;</span></span><br><span class="line"><span class="string">+  if(cause == 15 &amp;&amp; !(vma-&gt;perm &amp; PTE_W)) return -1;</span></span><br><span class="line"><span class="string">+  // allocate physical memory and map pte</span></span><br><span class="line"><span class="string">+  char *mem = kalloc();</span></span><br><span class="line"><span class="string">+  if(mem == 0)  return -1;</span></span><br><span class="line"><span class="string">+  memset(mem, 0, PGSIZE);</span></span><br><span class="line"><span class="string">+  uint64 vaalign = PGROUNDDOWN(va);</span></span><br><span class="line"><span class="string">+  if(mappages(p-&gt;pagetable, vaalign, PGSIZE, (uint64)mem, vma-&gt;perm|PTE_U|PTE_X) != 0)&#123;</span></span><br><span class="line"><span class="string">+    kfree(mem);</span></span><br><span class="line"><span class="string">+    return -1;</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+  // read content of file into allocated memory</span></span><br><span class="line"><span class="string">+  mmapfileread(vma-&gt;filept, 0, (uint64)mem, vaalign - vma-&gt;vmstart, PGSIZE);</span></span><br><span class="line"><span class="string">+  return 0;</span></span><br><span class="line"><span class="string">+&#125;</span></span><br><span class="line"><span class="string">diff --git a/kernel/proc.h b/kernel/proc.h</span></span><br><span class="line"><span class="string">index 9c16ea7..a61a9fe 100644</span></span><br><span class="line"><span class="string">--- a/kernel/proc.h</span></span><br><span class="line"><span class="string">+++ b/kernel/proc.h</span></span><br><span class="line"><span class="string">@@ -82,6 +82,15 @@ struct trapframe &#123;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> enum procstate &#123; UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">+struct VMA &#123;</span></span><br><span class="line"><span class="string">+  int shared;</span></span><br><span class="line"><span class="string">+  int perm;</span></span><br><span class="line"><span class="string">+  struct file *filept;</span></span><br><span class="line"><span class="string">+  struct VMA *nxt;</span></span><br><span class="line"><span class="string">+  int valid;</span></span><br><span class="line"><span class="string">+  uint64 vmstart, vmend;</span></span><br><span class="line"><span class="string">+&#125;;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string"> // Per-process state</span></span><br><span class="line"><span class="string"> struct proc &#123;</span></span><br><span class="line"><span class="string">   struct spinlock lock;</span></span><br><span class="line"><span class="string">@@ -103,4 +112,7 @@ struct proc &#123;</span></span><br><span class="line"><span class="string">   struct file *ofile[NOFILE];  // Open files</span></span><br><span class="line"><span class="string">   struct inode *cwd;           // Current directory</span></span><br><span class="line"><span class="string">   char name[16];               // Process name (debugging)</span></span><br><span class="line"><span class="string">+  </span></span><br><span class="line"><span class="string">+  struct VMA *vmalist;         // linklist of vma</span></span><br><span class="line"><span class="string">+  uint64 curmax;</span></span><br><span class="line"><span class="string"> &#125;;</span></span><br><span class="line"><span class="string">diff --git a/kernel/syscall.c b/kernel/syscall.c</span></span><br><span class="line"><span class="string">index c1b3670..7320633 100644</span></span><br><span class="line"><span class="string">--- a/kernel/syscall.c</span></span><br><span class="line"><span class="string">+++ b/kernel/syscall.c</span></span><br><span class="line"><span class="string">@@ -104,6 +104,8 @@ extern uint64 sys_unlink(void);</span></span><br><span class="line"><span class="string"> extern uint64 sys_wait(void);</span></span><br><span class="line"><span class="string"> extern uint64 sys_write(void);</span></span><br><span class="line"><span class="string"> extern uint64 sys_uptime(void);</span></span><br><span class="line"><span class="string">+extern uint64 sys_mmap(void);</span></span><br><span class="line"><span class="string">+extern uint64 sys_munmap(void);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> static uint64 (*syscalls[])(void) = &#123;</span></span><br><span class="line"><span class="string"> [SYS_fork]    sys_fork,</span></span><br><span class="line"><span class="string">@@ -127,6 +129,8 @@ static uint64 (*syscalls[])(void) = &#123;</span></span><br><span class="line"><span class="string"> [SYS_link]    sys_link,</span></span><br><span class="line"><span class="string"> [SYS_mkdir]   sys_mkdir,</span></span><br><span class="line"><span class="string"> [SYS_close]   sys_close,</span></span><br><span class="line"><span class="string">+[SYS_mmap]    sys_mmap,</span></span><br><span class="line"><span class="string">+[SYS_munmap]  sys_munmap,</span></span><br><span class="line"><span class="string"> &#125;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> void</span></span><br><span class="line"><span class="string">diff --git a/kernel/syscall.h b/kernel/syscall.h</span></span><br><span class="line"><span class="string">index bc5f356..e7b18d6 100644</span></span><br><span class="line"><span class="string">--- a/kernel/syscall.h</span></span><br><span class="line"><span class="string">+++ b/kernel/syscall.h</span></span><br><span class="line"><span class="string">@@ -20,3 +20,5 @@</span></span><br><span class="line"><span class="string"> #define SYS_link   19</span></span><br><span class="line"><span class="string"> #define SYS_mkdir  20</span></span><br><span class="line"><span class="string"> #define SYS_close  21</span></span><br><span class="line"><span class="string">+#define SYS_mmap   22</span></span><br><span class="line"><span class="string">+#define SYS_munmap 23</span></span><br><span class="line"><span class="string">diff --git a/kernel/sysfile.c b/kernel/sysfile.c</span></span><br><span class="line"><span class="string">index 5dc453b..ef72c9a 100644</span></span><br><span class="line"><span class="string">--- a/kernel/sysfile.c</span></span><br><span class="line"><span class="string">+++ b/kernel/sysfile.c</span></span><br><span class="line"><span class="string">@@ -484,3 +484,95 @@ sys_pipe(void)</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   return 0;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+uint64</span></span><br><span class="line"><span class="string">+sys_mmap(void)</span></span><br><span class="line"><span class="string">+&#123;</span></span><br><span class="line"><span class="string">+  uint64 addr;</span></span><br><span class="line"><span class="string">+  int length, prot, flags, fd, offset;</span></span><br><span class="line"><span class="string">+  struct proc *p = myproc();</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  if(argaddr(0, &amp;addr) &lt; 0 ||</span></span><br><span class="line"><span class="string">+     argint(1, &amp;length) &lt; 0 ||</span></span><br><span class="line"><span class="string">+     argint(2, &amp;prot) &lt; 0 ||</span></span><br><span class="line"><span class="string">+     argint(3, &amp;flags) &lt; 0 ||</span></span><br><span class="line"><span class="string">+     argint(4, &amp;fd) &lt; 0 ||</span></span><br><span class="line"><span class="string">+     argint(5, &amp;offset) &lt; 0)</span></span><br><span class="line"><span class="string">+    return -1;</span></span><br><span class="line"><span class="string">+  if(addr != 0) panic(&quot;sys_mmap&quot;);</span></span><br><span class="line"><span class="string">+  if(offset != 0) panic(&quot;sys_mmap&quot;);</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  struct file *f = p-&gt;ofile[fd];</span></span><br><span class="line"><span class="string">+  if((prot &amp; PROT_READ) &amp;&amp; !f-&gt;readable)</span></span><br><span class="line"><span class="string">+    return -1;</span></span><br><span class="line"><span class="string">+  if((prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_SHARED) &amp;&amp; !f-&gt;writable)</span></span><br><span class="line"><span class="string">+    return -1;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  // alloc a vma</span></span><br><span class="line"><span class="string">+  struct VMA *vma = allocvma();</span></span><br><span class="line"><span class="string">+  if(!vma)  return -1;</span></span><br><span class="line"><span class="string">+  // fill in vma</span></span><br><span class="line"><span class="string">+  vma-&gt;perm = ((prot &amp; PROT_READ) ? PTE_R : 0) |</span></span><br><span class="line"><span class="string">+              ((prot &amp; PROT_WRITE) ? PTE_W : 0);</span></span><br><span class="line"><span class="string">+  vma-&gt;shared = (flags &amp; MAP_SHARED) ? 1 : 0;</span></span><br><span class="line"><span class="string">+  vma-&gt;filept = f;</span></span><br><span class="line"><span class="string">+  filedup(f);</span></span><br><span class="line"><span class="string">+  // add vma to process&#x27;</span>s linklist</span><br><span class="line">+  vma-&gt;nxt = p-&gt;vmalist;</span><br><span class="line">+  p-&gt;vmalist = vma;</span><br><span class="line">+  // find an unused region <span class="keyword">in</span> the process<span class="string">&#x27;s address space in which to map the file</span></span><br><span class="line"><span class="string">+  uint64 vmaddr = PGROUNDDOWN(p-&gt;curmax - length);</span></span><br><span class="line"><span class="string">+  if(vmaddr % PGSIZE != 0)  panic(&quot;sys_mmap&quot;);</span></span><br><span class="line"><span class="string">+  vma-&gt;vmstart = vmaddr;</span></span><br><span class="line"><span class="string">+  vma-&gt;vmend = p-&gt;curmax;</span></span><br><span class="line"><span class="string">+  p-&gt;curmax = vmaddr;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  return vmaddr;</span></span><br><span class="line"><span class="string">+&#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+uint64</span></span><br><span class="line"><span class="string">+sys_munmap(void)</span></span><br><span class="line"><span class="string">+&#123;</span></span><br><span class="line"><span class="string">+  uint64 addr;</span></span><br><span class="line"><span class="string">+  int length;</span></span><br><span class="line"><span class="string">+  struct proc *p = myproc();</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  if(argaddr(0, &amp;addr) &lt; 0 || argint(1, &amp;length) &lt; 0)</span></span><br><span class="line"><span class="string">+    return -1;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  // find the VMA for the address range</span></span><br><span class="line"><span class="string">+  uint64 st = PGROUNDDOWN(addr);</span></span><br><span class="line"><span class="string">+  uint64 ed = PGROUNDUP(addr + length);</span></span><br><span class="line"><span class="string">+  struct VMA *vma = 0, *pre = 0;</span></span><br><span class="line"><span class="string">+  for(vma = p-&gt;vmalist; vma; vma = vma-&gt;nxt)&#123;</span></span><br><span class="line"><span class="string">+    if(vma-&gt;valid &amp;&amp; vma-&gt;vmstart &lt;= st &amp;&amp; ed &lt;= vma-&gt;vmend)</span></span><br><span class="line"><span class="string">+      break;</span></span><br><span class="line"><span class="string">+    pre = vma;</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+  if(!vma)  return -1;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  // write back if needed</span></span><br><span class="line"><span class="string">+  if(vma-&gt;shared &amp;&amp; (vma-&gt;perm | PTE_W))</span></span><br><span class="line"><span class="string">+    mmapfilewrite(vma-&gt;filept, st, ed - st);</span></span><br><span class="line"><span class="string">+  // unmap specified pages</span></span><br><span class="line"><span class="string">+  for(uint64 i = st; i &lt; ed; i += PGSIZE)&#123;</span></span><br><span class="line"><span class="string">+    if(walkaddr(p-&gt;pagetable, i))&#123;</span></span><br><span class="line"><span class="string">+      // need to check because vma is allocated lazily</span></span><br><span class="line"><span class="string">+      uvmunmap(p-&gt;pagetable, i, 1, 1);</span></span><br><span class="line"><span class="string">+    &#125;</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+  // update info in vma</span></span><br><span class="line"><span class="string">+  if(vma-&gt;vmstart == st &amp;&amp; ed &lt; vma-&gt;vmend)</span></span><br><span class="line"><span class="string">+    vma-&gt;vmstart = PGROUNDDOWN(addr + length);</span></span><br><span class="line"><span class="string">+  else if(vma-&gt;vmstart &lt; st &amp;&amp; ed == vma-&gt;vmend)</span></span><br><span class="line"><span class="string">+    vma-&gt;vmend = PGROUNDUP(addr);</span></span><br><span class="line"><span class="string">+  else if(vma-&gt;vmstart == st &amp;&amp; ed == vma-&gt;vmend)&#123;</span></span><br><span class="line"><span class="string">+    if(pre == 0)  p-&gt;vmalist = vma-&gt;nxt;</span></span><br><span class="line"><span class="string">+    else  pre-&gt;nxt = vma-&gt;nxt, vma-&gt;nxt = 0;</span></span><br><span class="line"><span class="string">+    fileclose(vma-&gt;filept);</span></span><br><span class="line"><span class="string">+    deallocvma(vma);</span></span><br><span class="line"><span class="string">+  &#125;</span></span><br><span class="line"><span class="string">+  else ;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+  return 0;</span></span><br><span class="line"><span class="string">+&#125;</span></span><br><span class="line"><span class="string">diff --git a/kernel/trap.c b/kernel/trap.c</span></span><br><span class="line"><span class="string">index a63249e..5afde8b 100644</span></span><br><span class="line"><span class="string">--- a/kernel/trap.c</span></span><br><span class="line"><span class="string">+++ b/kernel/trap.c</span></span><br><span class="line"><span class="string">@@ -68,11 +68,21 @@ usertrap(void)</span></span><br><span class="line"><span class="string">   &#125; else if((which_dev = devintr()) != 0)&#123;</span></span><br><span class="line"><span class="string">     // ok</span></span><br><span class="line"><span class="string">   &#125; else &#123;</span></span><br><span class="line"><span class="string">+  </span></span><br><span class="line"><span class="string">+    uint64 cause = r_scause();</span></span><br><span class="line"><span class="string">+    if(cause == 13 || cause == 15)&#123;</span></span><br><span class="line"><span class="string">+      // page fault</span></span><br><span class="line"><span class="string">+      uint64 stval = r_stval();</span></span><br><span class="line"><span class="string">+      if(mmaplazy(stval, cause) == 0)</span></span><br><span class="line"><span class="string">+        goto brk;</span></span><br><span class="line"><span class="string">+    &#125;</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">     printf(&quot;usertrap(): unexpected scause %p pid=%d\n&quot;, r_scause(), p-&gt;pid);</span></span><br><span class="line"><span class="string">     printf(&quot;            sepc=%p stval=%p\n&quot;, r_sepc(), r_stval());</span></span><br><span class="line"><span class="string">     p-&gt;killed = 1;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">+brk:</span></span><br><span class="line"><span class="string">   if(p-&gt;killed)</span></span><br><span class="line"><span class="string">     exit(-1);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">diff --git a/time.txt b/time.txt</span></span><br><span class="line"><span class="string">new file mode 100644</span></span><br><span class="line"><span class="string">index 0000000..f599e28</span></span><br><span class="line"><span class="string">--- /dev/null</span></span><br><span class="line"><span class="string">+++ b/time.txt</span></span><br><span class="line"><span class="string">@@ -0,0 +1 @@</span></span><br><span class="line"><span class="string">+10</span></span><br><span class="line"><span class="string">diff --git a/user/user.h b/user/user.h</span></span><br><span class="line"><span class="string">index b71ecda..753b59a 100644</span></span><br><span class="line"><span class="string">--- a/user/user.h</span></span><br><span class="line"><span class="string">+++ b/user/user.h</span></span><br><span class="line"><span class="string">@@ -23,6 +23,8 @@ int getpid(void);</span></span><br><span class="line"><span class="string"> char* sbrk(int);</span></span><br><span class="line"><span class="string"> int sleep(int);</span></span><br><span class="line"><span class="string"> int uptime(void);</span></span><br><span class="line"><span class="string">+void *mmap(void *, int, int, int, int, int);</span></span><br><span class="line"><span class="string">+int munmap(void *, int);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> // ulib.c</span></span><br><span class="line"><span class="string"> int stat(const char*, struct stat*);</span></span><br><span class="line"><span class="string">diff --git a/user/usys.pl b/user/usys.pl</span></span><br><span class="line"><span class="string">index 01e426e..d23b9cc 100755</span></span><br><span class="line"><span class="string">--- a/user/usys.pl</span></span><br><span class="line"><span class="string">+++ b/user/usys.pl</span></span><br><span class="line"><span class="string">@@ -36,3 +36,5 @@ entry(&quot;getpid&quot;);</span></span><br><span class="line"><span class="string"> entry(&quot;sbrk&quot;);</span></span><br><span class="line"><span class="string"> entry(&quot;sleep&quot;);</span></span><br><span class="line"><span class="string"> entry(&quot;uptime&quot;);</span></span><br><span class="line"><span class="string">+entry(&quot;mmap&quot;);</span></span><br><span class="line"><span class="string">+entry(&quot;munmap&quot;);</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验九 file system</title>
      <link href="/2022/09/08/xv6-lab9/"/>
      <url>/2022/09/08/xv6-lab9/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/fs.html">https://pdos.csail.mit.edu/6.S081/2020/labs/fs.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验八 locks</title>
      <link href="/2022/09/07/xv6-lab8/"/>
      <url>/2022/09/07/xv6-lab8/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html">https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html</a></li></ul><p>这次实验中我们将重新设计 xv6 的内存分配和磁盘块缓存机制以提高它们的并行性。并行性的性能可以由锁争用的次数反应出来——差的并行代码会导致高锁争用。</p><h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h2><p>任务：原本的 kalloc.c 导致高锁争用的原因是 xv6 只维护了一个空闲页面链表，该链表有一个锁。为了减少锁争用，我们可以给每一个 CPU 维护一个空闲页面链表，这样不同 CPU 就可以并行地内存分配和释放，因为它们之间相互独立。但是，当一个 CPU 的空闲页面被分配完之后，它需要从其他的 CPU 的空闲页面链表中窃取一部分空闲页面。窃取过程可能导致锁争用，但是不会很频繁。</p><p>我们的任务就是实现每一个 CPU 一个空闲链表，且在链表为空时窃取页面。所有锁的名字必须以 kmem 开头。kalloctest 检测是否减少了锁争用，usertests sbrkmuch 检测是否仍然能够分配所有内存。</p><p>首先把原来的一个 kmem 结构体改成一个数组 kmems，使每个 CPU 有一个对应的空闲页面链表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmems[NCPU];</span><br></pre></td></tr></table></figure></p><p>然后每个 CPU 分别初始化，这里我偷了个懒，先给 0 号 CPU 分配所有内存，其他 CPU 不分配。由于一个 CPU 没有空闲页面时会去其他 CPU 处窃取，所以我希望足够长时间之后，页面能够大致平均分配开（这其实是一个数学问题……有时间可以研究一下……）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)&#123;</span><br><span class="line">    initlock(&amp;kmems[i].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    freerange(i == <span class="number">0</span> ? end : (<span class="type">void</span>*)PHYSTOP, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*initlock(&amp;kmem.lock, &quot;kmem&quot;);</span></span><br><span class="line"><span class="comment">  freerange(end, (void*)PHYSTOP);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kalloc 从当前 CPU 空闲页面链表中取一个页面，如果不存在则窃取（steal）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  ...</span><br><span class="line">  push_off(); <span class="type">int</span> ci = cpuid(); pop_off();</span><br><span class="line">  acquire(&amp;kmems[ci].lock);</span><br><span class="line">  r = kmems[ci].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmems[ci].freelist = r-&gt;next;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// Steal from other CPU when freelist is empty.</span></span><br><span class="line">    r = steal(ci);</span><br><span class="line">  release(&amp;kmems[ci].lock);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>窃取我实现的很暴力，逐一检查各个 CPU 是否有空闲页面，有就窃取过来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="keyword">struct</span> run *</span><br><span class="line"><span class="title function_">steal</span><span class="params">(<span class="type">int</span> ci)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == ci) <span class="keyword">continue</span>;</span><br><span class="line">    acquire(&amp;kmems[i].lock);</span><br><span class="line">    <span class="keyword">if</span>((r = kmems[i].freelist))&#123;</span><br><span class="line">      kmems[i].freelist = r-&gt;next;</span><br><span class="line">      release(&amp;kmems[i].lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmems[i].lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><p>xv6 在 bio.c 中实现了磁盘块的缓存机制，它是一个双向链表，每个元素是一个缓存块。一个缓存块（struct buf, kernel/buf.h）不仅包含数据，还包含有效位 valid、脏位 disk、设备号、磁盘块号、被引用次数等信息。<code>整个双向链表由一个自旋锁保护，每个缓存块都由一个睡眠锁保护。</code></p><p>任务：由于整个缓存双向链表由一个自旋锁保护，所以多个进程反复读不同文件时会产生高锁争用。我们要更改缓存机制以减少锁争用。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验七 Multithreading</title>
      <link href="/2022/09/06/xv6-lab7/"/>
      <url>/2022/09/06/xv6-lab7/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/thread.html">https://pdos.csail.mit.edu/6.S081/2020/labs/thread.html</a></li></ul><h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><p>任务：在用户层面实现线程切换机制。</p><p>我们需要补充完整 user/uthread.c 中的 thread_create() 和 thread_schedule()，以及 user/uthread_switch.S 中的 thread_switch。两个目标：</p><ul><li>当 thread_scheduler() 第一次跑某一线程时，该线程在自己的栈上执行传入的函数；</li><li>thread_switch 保存切换走的线程的寄存器，恢复要切换的线程的寄存器，并返回到线程上一次切走的位置。</li></ul><p>定义要保存的上下文</p><blockquote><p>寄存器被分为两种类型——caller-save 和 callee-save，顾名思义，前者要求调用者保存和恢复相关寄存器，而后者要求被调用者保存和恢复相关寄存器，<br>也就是说，从调用者的角度看，caller-save 寄存器在调用前后可能发生变化，而 callee-save 寄存器不会变化 。因此，切换时我们只需要保存和恢复 callee-save 寄存器。<br>除了 callee-save 寄存器需要保存和恢复以外，栈指针 sp 和返回地址 ra 也需要保存和恢复，它们构成了上述 context 结构体的内容。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/uthread/c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>  <span class="comment">// thread context</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考 kernel/swtch.S，完成uthread_switch.S的上下文切换汇编<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">         * save the old thread&#x27;s registers,</span><br><span class="line">         * restore the new thread&#x27;s registers.</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">        /* YOUR CODE HERE */</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        sd s2, 32(a0)</span><br><span class="line">        sd s3, 40(a0)</span><br><span class="line">        sd s4, 48(a0)</span><br><span class="line">        sd s5, 56(a0)</span><br><span class="line">        sd s6, 64(a0)</span><br><span class="line">        sd s7, 72(a0)</span><br><span class="line">        sd s8, 80(a0)</span><br><span class="line">        sd s9, 88(a0)</span><br><span class="line">        sd s10, 96(a0)</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        ld s2, 32(a1)</span><br><span class="line">        ld s3, 40(a1)</span><br><span class="line">        ld s4, 48(a1)</span><br><span class="line">        ld s5, 56(a1)</span><br><span class="line">        ld s6, 64(a1)</span><br><span class="line">        ld s7, 72(a1)</span><br><span class="line">        ld s8, 80(a1)</span><br><span class="line">        ld s9, 88(a1)</span><br><span class="line">        ld s10, 96(a1)</span><br><span class="line">        ld s11, 104(a1)</span><br><span class="line">        </span><br><span class="line">        ret    /* return to ra */</span><br></pre></td></tr></table></figure></p><ul><li>在 thread_schedule() 中调用 uthread_switch 并把旧的线程上下文 &amp;t-&gt;context 和新的线程上下文 &amp;next_thread-&gt;context 作为参数传入；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/uthread.c</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>, *<span class="title">next_thread</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find another runnable thread. */</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br><span class="line">  t = current_thread + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">      t = all_thread;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">      next_thread = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next_thread == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread_schedule: no runnable threads\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;next_thread-&gt;context);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后，在 thread_create() 中把传入的函数指针给到线程上下文的 ra——这样当这个线程被调度执行时就可以执行指定函数了；同时把栈指针给到线程上下文的 sp——<strong>注意，栈空间是按地址从大到小增长的，</strong>所以我们给的应该是 stack 数组的末尾指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/uthread.c</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">// xyf</span></span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><p>任务：在一台多核 Linux 或 MacOS 上使用 UNIX pthread 线程库写多线程的并行程序。</p><p>MIT 提供了一个代码 notxv6/ph.c，它开给定数量个线程，每个线程向 hash 表里面加许多 key（put 操作），然后从 hash 表里取出 key（get 操作），同时记录 put、get 的用时，以及缺失的 key——本来应该在 hash 表里，但是 get 不到。发生缺失的原因是 ph.c 没有在多线程时加锁，我们的任务就是把锁给加上。</p><p>相关接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;            <span class="comment">// declare a lock</span></span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// initialize the lock</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);     <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure></p><p>给每个 hash 桶加一个锁，put 和 get 的时候先加锁，再操作，最后解锁就搞定了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notxv6/ph.c</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock[NBUCKET];</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">init_locks</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">    assert(pthread_mutex_init(lock+i, <span class="literal">NULL</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  assert(pthread_mutex_lock(lock+i) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(pthread_mutex_unlock(lock+i) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> entry*</span><br><span class="line"><span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  assert(pthread_mutex_lock(lock+i) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(pthread_mutex_unlock(lock+i) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  nthread = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  tha = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * nthread);</span><br><span class="line">  srandom(<span class="number">0</span>);</span><br><span class="line">  assert(NKEYS % nthread == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NKEYS; i++) &#123;</span><br><span class="line">    keys[i] = random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize locks</span></span><br><span class="line">  init_locks();</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p>任务：实现一个 barrier——执行到这里的线程必须等待，直到所有线程都执行到了这个地方。<br>和上一个任务一样，notxv6/barrier.c 已经写了一个不对的 barrier，它开给定数量个线程，每个线程做一个循环，循环的某处调用了 barrier()。我们期望所有线程都调用了 barrier() 之后才能继续执行。</p><p>相关接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notxv6/barrier.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  assert(pthread_mutex_lock(&amp;bstate.barrier_mutex) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(++bstate.nthread == nthread)&#123;</span><br><span class="line">    assert(pthread_cond_broadcast(&amp;bstate.barrier_cond) == <span class="number">0</span>);</span><br><span class="line">    bstate.round++;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    assert(pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  assert(pthread_mutex_unlock(&amp;bstate.barrier_mutex) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/answers-thread.txt b/answers-thread.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..2b0e77f</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/answers-thread.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+blablablablabla</span><br><span class="line">diff --git a/notxv6/barrier.c b/notxv6/barrier.c</span><br><span class="line">index 12793e8..0588d62 100644</span><br><span class="line">--- a/notxv6/barrier.c</span><br><span class="line">+++ b/notxv6/barrier.c</span><br><span class="line">@@ -30,7 +30,19 @@ barrier()</span><br><span class="line">   // Block until all threads have called barrier() and</span><br><span class="line">   // <span class="keyword">then</span> increment bstate.round.</span><br><span class="line">   //</span><br><span class="line">+  assert(pthread_mutex_lock(&amp;bstate.barrier_mutex) == 0);</span><br><span class="line">   </span><br><span class="line">+  <span class="keyword">if</span>(++bstate.nthread == nthread)&#123;</span><br><span class="line">+    // wake up every thread sleeping on “bstate.barrier_cond”</span><br><span class="line">+    assert(pthread_cond_broadcast(&amp;bstate.barrier_cond) == 0);</span><br><span class="line">+    bstate.round++;</span><br><span class="line">+    bstate.nthread = 0;</span><br><span class="line">+  &#125;</span><br><span class="line">+  <span class="keyword">else</span></span><br><span class="line">+    // go to <span class="built_in">sleep</span> on “bstate.barrier_cond”, releasing lock mutex, acquiring upon wake up</span><br><span class="line">+    assert(pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex) == 0);</span><br><span class="line">+  </span><br><span class="line">+  assert(pthread_mutex_unlock(&amp;bstate.barrier_mutex) == 0);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> static void *</span><br><span class="line">diff --git a/notxv6/ph.c b/notxv6/ph.c</span><br><span class="line">index 6df1500..a21c1c4 100644</span><br><span class="line">--- a/notxv6/ph.c</span><br><span class="line">+++ b/notxv6/ph.c</span><br><span class="line">@@ -17,6 +17,15 @@ struct entry *table[NBUCKET];</span><br><span class="line"> int keys[NKEYS];</span><br><span class="line"> int nthread = 1;</span><br><span class="line"> </span><br><span class="line">+// 给每个 <span class="built_in">hash</span> 桶初始化一个锁</span><br><span class="line">+pthread_mutex_t lock[NBUCKET];</span><br><span class="line">+void</span><br><span class="line">+init_locks()</span><br><span class="line">+&#123;</span><br><span class="line">+  <span class="keyword">for</span>(int i = 0; i &lt; NBUCKET; i++)</span><br><span class="line">+    assert(pthread_mutex_init(lock+i, NULL) == 0);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> double</span><br><span class="line"> <span class="function"><span class="title">now</span></span>()</span><br><span class="line"> &#123;</span><br><span class="line">@@ -40,6 +49,8 @@ void put(int key, int value)</span><br><span class="line"> &#123;</span><br><span class="line">   int i = key % NBUCKET;</span><br><span class="line"> </span><br><span class="line">+  assert(pthread_mutex_lock(lock+i) == 0);</span><br><span class="line">+  </span><br><span class="line">   // is the key already present?</span><br><span class="line">   struct entry *e = 0;</span><br><span class="line">   <span class="keyword">for</span> (e = table[i]; e != 0; e = e-&gt;next) &#123;</span><br><span class="line">@@ -53,6 +64,8 @@ void put(int key, int value)</span><br><span class="line">     // the new is new.</span><br><span class="line">     insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">   &#125;</span><br><span class="line">+  </span><br><span class="line">+  assert(pthread_mutex_unlock(lock+i) == 0);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> static struct entry*</span><br><span class="line">@@ -60,12 +73,15 @@ get(int key)</span><br><span class="line"> &#123;</span><br><span class="line">   int i = key % NBUCKET;</span><br><span class="line"> </span><br><span class="line">-</span><br><span class="line">+  assert(pthread_mutex_lock(lock+i) == 0);</span><br><span class="line">+  </span><br><span class="line">   struct entry *e = 0;</span><br><span class="line">   <span class="keyword">for</span> (e = table[i]; e != 0; e = e-&gt;next) &#123;</span><br><span class="line">     <span class="keyword">if</span> (e-&gt;key == key) <span class="built_in">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">+  assert(pthread_mutex_unlock(lock+i) == 0);</span><br><span class="line">+  </span><br><span class="line">   <span class="built_in">return</span> e;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">@@ -115,6 +131,9 @@ main(int argc, char *argv[])</span><br><span class="line">     keys[i] = random();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">+  // initialize locks</span><br><span class="line">+  init_locks();</span><br><span class="line">+  </span><br><span class="line">   //</span><br><span class="line">   // first the puts</span><br><span class="line">   //</span><br><span class="line">diff --git a/time.txt b/time.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..f599e28</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/time.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+10</span><br><span class="line">diff --git a/user/uthread.c b/user/uthread.c</span><br><span class="line">index 8e46826..29b3592 100644</span><br><span class="line">--- a/user/uthread.c</span><br><span class="line">+++ b/user/uthread.c</span><br><span class="line">@@ -10,16 +10,34 @@</span><br><span class="line"> <span class="comment">#define STACK_SIZE  8192</span></span><br><span class="line"> <span class="comment">#define MAX_THREAD  4</span></span><br><span class="line"> </span><br><span class="line">+struct context &#123;</span><br><span class="line">+  uint64 ra;  // <span class="built_in">return</span> addr</span><br><span class="line">+  uint64 sp;  // stack pointer</span><br><span class="line">+</span><br><span class="line">+  // callee-saved</span><br><span class="line">+  uint64 s0;</span><br><span class="line">+  uint64 s1;</span><br><span class="line">+  uint64 s2;</span><br><span class="line">+  uint64 s3;</span><br><span class="line">+  uint64 s4;</span><br><span class="line">+  uint64 s5;</span><br><span class="line">+  uint64 s6;</span><br><span class="line">+  uint64 s7;</span><br><span class="line">+  uint64 s8;</span><br><span class="line">+  uint64 s9;</span><br><span class="line">+  uint64 s10;</span><br><span class="line">+  uint64 s11;</span><br><span class="line">+&#125;;</span><br><span class="line"> </span><br><span class="line"> struct thread &#123;</span><br><span class="line">   char       stack[STACK_SIZE]; /* the thread<span class="string">&#x27;s stack */</span></span><br><span class="line"><span class="string">   int        state;             /* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line"><span class="string">-</span></span><br><span class="line"><span class="string">+  struct context context;       // thread context</span></span><br><span class="line"><span class="string"> &#125;;</span></span><br><span class="line"><span class="string"> struct thread all_thread[MAX_THREAD];</span></span><br><span class="line"><span class="string"> struct thread *current_thread;</span></span><br><span class="line"><span class="string"> extern void thread_switch(uint64, uint64);</span></span><br><span class="line"><span class="string">-              </span></span><br><span class="line"><span class="string">+ </span></span><br><span class="line"><span class="string"> void </span></span><br><span class="line"><span class="string"> thread_init(void)</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string">@@ -63,6 +81,7 @@ thread_schedule(void)</span></span><br><span class="line"><span class="string">      * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="string">      * thread_switch(??, ??);</span></span><br><span class="line"><span class="string">      */</span></span><br><span class="line"><span class="string">+    thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;next_thread-&gt;context);</span></span><br><span class="line"><span class="string">   &#125; else</span></span><br><span class="line"><span class="string">     next_thread = 0;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">@@ -77,6 +96,9 @@ thread_create(void (*func)())</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   t-&gt;state = RUNNABLE;</span></span><br><span class="line"><span class="string">   // YOUR CODE HERE</span></span><br><span class="line"><span class="string">+  t-&gt;context.ra = (uint64)func;</span></span><br><span class="line"><span class="string">+  // 栈空间是按地址从大到小增长的</span></span><br><span class="line"><span class="string">+  t-&gt;context.sp = (uint64)t-&gt;stack + STACK_SIZE - 1;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> void </span></span><br><span class="line"><span class="string">diff --git a/user/uthread_switch.S b/user/uthread_switch.S</span></span><br><span class="line"><span class="string">index 5defb12..70f2547 100644</span></span><br><span class="line"><span class="string">--- a/user/uthread_switch.S</span></span><br><span class="line"><span class="string">+++ b/user/uthread_switch.S</span></span><br><span class="line"><span class="string">@@ -8,4 +8,36 @@</span></span><br><span class="line"><span class="string"> .globl thread_switch</span></span><br><span class="line"><span class="string"> thread_switch:</span></span><br><span class="line"><span class="string"> /* YOUR CODE HERE */</span></span><br><span class="line"><span class="string">+        sd ra, 0(a0)</span></span><br><span class="line"><span class="string">+        sd sp, 8(a0)</span></span><br><span class="line"><span class="string">+        sd s0, 16(a0)</span></span><br><span class="line"><span class="string">+        sd s1, 24(a0)</span></span><br><span class="line"><span class="string">+        sd s2, 32(a0)</span></span><br><span class="line"><span class="string">+        sd s3, 40(a0)</span></span><br><span class="line"><span class="string">+        sd s4, 48(a0)</span></span><br><span class="line"><span class="string">+        sd s5, 56(a0)</span></span><br><span class="line"><span class="string">+        sd s6, 64(a0)</span></span><br><span class="line"><span class="string">+        sd s7, 72(a0)</span></span><br><span class="line"><span class="string">+        sd s8, 80(a0)</span></span><br><span class="line"><span class="string">+        sd s9, 88(a0)</span></span><br><span class="line"><span class="string">+        sd s10, 96(a0)</span></span><br><span class="line"><span class="string">+        sd s11, 104(a0)</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+        ld ra, 0(a1)</span></span><br><span class="line"><span class="string">+        ld sp, 8(a1)</span></span><br><span class="line"><span class="string">+        ld s0, 16(a1)</span></span><br><span class="line"><span class="string">+        ld s1, 24(a1)</span></span><br><span class="line"><span class="string">+        ld s2, 32(a1)</span></span><br><span class="line"><span class="string">+        ld s3, 40(a1)</span></span><br><span class="line"><span class="string">+        ld s4, 48(a1)</span></span><br><span class="line"><span class="string">+        ld s5, 56(a1)</span></span><br><span class="line"><span class="string">+        ld s6, 64(a1)</span></span><br><span class="line"><span class="string">+        ld s7, 72(a1)</span></span><br><span class="line"><span class="string">+        ld s8, 80(a1)</span></span><br><span class="line"><span class="string">+        ld s9, 88(a1)</span></span><br><span class="line"><span class="string">+        ld s10, 96(a1)</span></span><br><span class="line"><span class="string">+        ld s11, 104(a1)</span></span><br><span class="line"><span class="string">+        </span></span><br><span class="line"><span class="string"> ret    /* return to ra */</span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">+</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验五 lazy page allocation</title>
      <link href="/2022/09/05/xv6-lab5/"/>
      <url>/2022/09/05/xv6-lab5/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-traps-Trap"><a href="#Lab-traps-Trap" class="headerlink" title="Lab traps: Trap"></a>Lab traps: Trap</h1><ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/lazy.html">https://pdos.csail.mit.edu/6.S081/2020/labs/lazy.html</a></li></ul><p>许多 OS 都会为用户的堆内存实现懒分配——在用户程序用 sbrk() 申请更多的空间时，不真正开辟物理内存，而是把要用的用户虚拟地址在页表中设为 invalid，等到确实用到了这个虚拟地址，CPU 产生缺页错误，这时内核再分配物理内存。</p><h2 id="Eliminate-allocation-from-sbrk-easy"><a href="#Eliminate-allocation-from-sbrk-easy" class="headerlink" title="Eliminate allocation from sbrk() (easy)"></a>Eliminate allocation from sbrk() (easy)</h2><p>任务：在 sys_sbrk (kernel/sysproc.c) 中修改 xv6 原本的 sbrk(n) 系统调用的实现。原本的 sbrk(n) 会让用户空间增长 n 个字节，返回新分配虚拟空间的首地址（即原用户空间大小）。新的 sbrk(n) 应该只给 myproc()-&gt;sz 加上 n，返回原用户空间大小，但是并没有实际开辟物理内存，不再调用 growproc()。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  myproc()-&gt;sz += n;  <span class="comment">// 懒分配</span></span><br><span class="line"><span class="comment">//  if(growproc(n) &lt; 0)</span></span><br><span class="line"><span class="comment">//    return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在编译 xv6，输入 <code>echo hi</code>，则会出错：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hi</span><br><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x00000000000012ac stval=0x0000000000004008</span><br><span class="line">panic: uvmunmap: not mapped</span><br></pre></td></tr></table></figure></p><h2 id="Lazy-allocation-moderate"><a href="#Lazy-allocation-moderate" class="headerlink" title="Lazy allocation (moderate)"></a>Lazy allocation (moderate)</h2><p>任务：改变 trap.c 的代码以回应用户空间的缺页错误，即新开辟一页的物理内存空间，返回用户空间继续执行。</p><p>我们首先在 usertrap 中处理缺页错误。缺页错误的代码是 13 或 15，当发生缺页错误时，判断是否是懒分配引起的（引起错误的地址在 p-&gt;sz 内），如果是，则用 kalloc 新开辟一页物理空间，并在页表中加上缺页的地址所在页面这一项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 cause = r_scause();</span><br><span class="line">    <span class="keyword">if</span>(cause == <span class="number">13</span> || cause == <span class="number">15</span>)&#123;</span><br><span class="line">      <span class="comment">// page fault</span></span><br><span class="line">      uint64 stval = r_stval();</span><br><span class="line">      <span class="keyword">if</span>(stval &lt; p-&gt;sz)&#123;</span><br><span class="line">        <span class="comment">// need lazy allocation</span></span><br><span class="line">        <span class="type">char</span> *mem = kalloc();</span><br><span class="line">        <span class="keyword">if</span>(mem)&#123;</span><br><span class="line">          <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">          <span class="keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(stval), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">            kfree(mem);</span><br><span class="line">            uvmunmap(p-&gt;pagetable, PGROUNDDOWN(stval), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">goto</span> brk;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">brk:</span><br></pre></td></tr></table></figure></p><p>我们还需要更改 uvmunmap 的内容，这是因为加入懒分配之后，uvmunmap 可能会被要求解除本就不存在的映射、或者去找还没有创建的 pte。在原本的写法中这样会 panic，因此，我们要把 panic 改掉：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在我们已经能正常执行 <code>echo hi</code> 了。</p><h2 id="Lazytests-and-Usertests-moderate"><a href="#Lazytests-and-Usertests-moderate" class="headerlink" title="Lazytests and Usertests (moderate)"></a>Lazytests and Usertests (moderate)</h2><p>任务：通过 Lazytests 和 Usertests。</p><p>完成上一小节的任务后，我们的代码其实并不完善，还需要处理下列问题：</p><ol><li>处理负的 sbrk() 参数</li><li>如果导致缺页错误的虚拟地址高于任何 sbrk() 分配的内存地址，则杀死进程</li><li>在 fork() 中正确处理父进程到子进程的内存复制</li><li>处理以下情况：一个进程给系统调用（如 read / write）传入了一个合法的地址，但是地址的内存还没有分配</li><li>正确处理超出内存的情况：如果 kalloc() 在缺页错误处理中失败了，则杀死进程</li><li>处理缺页错误中访问用户栈之下的非法空间</li></ol><p>对于第 1 点，只需要参照 growproc 原本的写法，如果 n &lt; 0，则调用 uvmdealloc 回收空间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    p-&gt;sz += n;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    p-&gt;sz = uvmdealloc(p-&gt;pagetable, addr, addr+n);</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于第 2、5、6 点，只需要在上一小节的基础上加一点判断和 killed 设置即可，为了方便，这次把处理代码写成一个函数（kernel/proc.c 中）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// Handle page fault with lazy allocation</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">lazy_allocate</span><span class="params">(uint64 va)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">char</span> *mem = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    uvmunmap(p-&gt;pagetable, PGROUNDDOWN(va), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在kernel/defs.h添加声明</p><p>于是乎，在 usertrap 中我们只需要调用 lazy_allocate：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 cause = r_scause();</span><br><span class="line">    <span class="keyword">if</span>(cause == <span class="number">13</span> || cause == <span class="number">15</span>)&#123;</span><br><span class="line">      <span class="comment">// page fault</span></span><br><span class="line">      uint64 stval = r_stval();</span><br><span class="line">      <span class="keyword">if</span>(lazy_allocate(stval) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> brk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">brk:</span><br></pre></td></tr></table></figure></p><p>对于第 3 点，我们查看 fork 的代码，发现内存复制是调用 uvmcopy 实现的，所以只需要像改 uvmunmap 一般改 uvmcopy 即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于第 4 点，系统调用的时候 RISC-V 硬件不会引发缺页错误，因此操作系统必须处理这种情况。我们知道，那些参数包含地址的系统调用都会执行 argaddr() 函数，所以我们先找到它（kernel/syscall.c）。理论上，在这里处理缺页是可行的，但是我们把目光向上移，就会发现注释说：argaddr() 不检查是否合法，因为 copyin/copyout 会检查。好吧，那我们就去看看 copyin/copyout 是怎么检查的呗。看了一圈下来，我们可以发现，它们会调用 walkaddr()，如果 walkaddr 返回 0，那么就返回错误代码 -1。所以，<strong>本质上是 walkaddr() 在检查是否合法！</strong>Okay，定位了问题所在，我们只需要用上刚刚写的 lazy_allocate() 函数，略微修改 walkaddr() 即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy_allocate(va) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>make grade结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (lazy)&gt; ./grade-lab-lazy</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">== Test running lazytests == (11.1s) </span><br><span class="line">== Test   lazy: map == </span><br><span class="line">  lazy: map: OK </span><br><span class="line">== Test   lazy: unmap == </span><br><span class="line">  lazy: unmap: OK </span><br><span class="line">== Test usertests == (433.9s) </span><br><span class="line">== Test   usertests: pgbug == </span><br><span class="line">  usertests: pgbug: OK </span><br><span class="line">== Test   usertests: sbrkbugs == </span><br><span class="line">  usertests: sbrkbugs: OK </span><br><span class="line">== Test   usertests: argptest == </span><br><span class="line">  usertests: argptest: OK </span><br><span class="line">== Test   usertests: sbrkmuch == </span><br><span class="line">  usertests: sbrkmuch: OK </span><br><span class="line">== Test   usertests: sbrkfail == </span><br><span class="line">  usertests: sbrkfail: OK </span><br><span class="line">== Test   usertests: sbrkarg == </span><br><span class="line">  usertests: sbrkarg: OK </span><br><span class="line">== Test   usertests: stacktest == </span><br><span class="line">  usertests: stacktest: OK </span><br><span class="line">== Test   usertests: execout == </span><br><span class="line">  usertests: execout: OK </span><br><span class="line">== Test   usertests: copyin == </span><br><span class="line">  usertests: copyin: OK </span><br><span class="line">== Test   usertests: copyout == </span><br><span class="line">  usertests: copyout: OK </span><br><span class="line">== Test   usertests: copyinstr1 == </span><br><span class="line">  usertests: copyinstr1: OK </span><br><span class="line">== Test   usertests: copyinstr2 == </span><br><span class="line">  usertests: copyinstr2: OK </span><br><span class="line">== Test   usertests: copyinstr3 == </span><br><span class="line">  usertests: copyinstr3: OK </span><br><span class="line">== Test   usertests: rwsbrk == </span><br><span class="line">  usertests: rwsbrk: OK </span><br><span class="line">== Test   usertests: truncate1 == </span><br><span class="line">  usertests: truncate1: OK </span><br><span class="line">== Test   usertests: truncate2 == </span><br><span class="line">  usertests: truncate2: OK </span><br><span class="line">== Test   usertests: truncate3 == </span><br><span class="line">  usertests: truncate3: OK </span><br><span class="line">== Test   usertests: reparent2 == </span><br><span class="line">  usertests: reparent2: OK </span><br><span class="line">== Test   usertests: badarg == </span><br><span class="line">  usertests: badarg: OK </span><br><span class="line">== Test   usertests: reparent == </span><br><span class="line">  usertests: reparent: OK </span><br><span class="line">== Test   usertests: twochildren == </span><br><span class="line">  usertests: twochildren: OK </span><br><span class="line">== Test   usertests: forkfork == </span><br><span class="line">  usertests: forkfork: OK </span><br><span class="line">== Test   usertests: forkforkfork == </span><br><span class="line">  usertests: forkforkfork: OK </span><br><span class="line">== Test   usertests: createdelete == </span><br><span class="line">  usertests: createdelete: OK </span><br><span class="line">== Test   usertests: linkunlink == </span><br><span class="line">  usertests: linkunlink: OK </span><br><span class="line">== Test   usertests: linktest == </span><br><span class="line">  usertests: linktest: OK </span><br><span class="line">== Test   usertests: unlinkread == </span><br><span class="line">  usertests: unlinkread: OK </span><br><span class="line">== Test   usertests: concreate == </span><br><span class="line">  usertests: concreate: OK </span><br><span class="line">== Test   usertests: subdir == </span><br><span class="line">  usertests: subdir: OK </span><br><span class="line">== Test   usertests: fourfiles == </span><br><span class="line">  usertests: fourfiles: OK </span><br><span class="line">== Test   usertests: sharedfd == </span><br><span class="line">  usertests: sharedfd: OK </span><br><span class="line">== Test   usertests: exectest == </span><br><span class="line">  usertests: exectest: OK </span><br><span class="line">== Test   usertests: bigargtest == </span><br><span class="line">  usertests: bigargtest: OK </span><br><span class="line">== Test   usertests: bigwrite == </span><br><span class="line">  usertests: bigwrite: OK </span><br><span class="line">== Test   usertests: bsstest == </span><br><span class="line">  usertests: bsstest: OK </span><br><span class="line">== Test   usertests: sbrkbasic == </span><br><span class="line">  usertests: sbrkbasic: OK </span><br><span class="line">== Test   usertests: kernmem == </span><br><span class="line">  usertests: kernmem: OK </span><br><span class="line">== Test   usertests: validatetest == </span><br><span class="line">  usertests: validatetest: OK </span><br><span class="line">== Test   usertests: opentest == </span><br><span class="line">  usertests: opentest: OK </span><br><span class="line">== Test   usertests: writetest == </span><br><span class="line">  usertests: writetest: OK </span><br><span class="line">== Test   usertests: writebig == </span><br><span class="line">  usertests: writebig: OK </span><br><span class="line">== Test   usertests: createtest == </span><br><span class="line">  usertests: createtest: OK </span><br><span class="line">== Test   usertests: openiput == </span><br><span class="line">  usertests: openiput: OK </span><br><span class="line">== Test   usertests: exitiput == </span><br><span class="line">  usertests: exitiput: OK </span><br><span class="line">== Test   usertests: iput == </span><br><span class="line">  usertests: iput: OK </span><br><span class="line">== Test   usertests: mem == </span><br><span class="line">  usertests: mem: OK </span><br><span class="line">== Test   usertests: pipe1 == </span><br><span class="line">  usertests: pipe1: OK </span><br><span class="line">== Test   usertests: preempt == </span><br><span class="line">  usertests: preempt: OK </span><br><span class="line">== Test   usertests: exitwait == </span><br><span class="line">  usertests: exitwait: OK </span><br><span class="line">== Test   usertests: rmdot == </span><br><span class="line">  usertests: rmdot: OK </span><br><span class="line">== Test   usertests: fourteen == </span><br><span class="line">  usertests: fourteen: OK </span><br><span class="line">== Test   usertests: bigfile == </span><br><span class="line">  usertests: bigfile: OK </span><br><span class="line">== Test   usertests: dirfile == </span><br><span class="line">  usertests: dirfile: OK </span><br><span class="line">== Test   usertests: iref == </span><br><span class="line">  usertests: iref: OK </span><br><span class="line">== Test   usertests: forktest == </span><br><span class="line">  usertests: forktest: OK </span><br><span class="line">== Test time == </span><br><span class="line">time: FAIL </span><br><span class="line">    time.txt does not contain a single <span class="built_in">integer</span> (number of hours spent on the lab)</span><br><span class="line">Score: 118/119</span><br></pre></td></tr></table></figure></p><h2 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/grade-lab-lazy b/grade-lab-lazy</span><br><span class="line">index 06bde03..7455602 100755</span><br><span class="line">--- a/grade-lab-lazy</span><br><span class="line">+++ b/grade-lab-lazy</span><br><span class="line">@@ -23,7 +23,7 @@ def test_memtest():</span><br><span class="line"> def test_usertests():</span><br><span class="line">     r.run_qemu(shell_script([</span><br><span class="line">         &#x27;usertests&#x27;</span><br><span class="line">-    ]), timeout=300)</span><br><span class="line">+    ]), timeout=600)</span><br><span class="line"> </span><br><span class="line"> def usertest_check(testcase, nextcase, output):</span><br><span class="line">     if not re.search(r&#x27;\ntest &#123;&#125;: [\s\S]*OK\ntest &#123;&#125;&#x27;.format(testcase, nextcase), output):</span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index 4b9bbc0..04140f6 100644</span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ -104,6 +104,7 @@ void            yield(void);</span><br><span class="line"> int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);</span><br><span class="line"> int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);</span><br><span class="line"> void            procdump(void);</span><br><span class="line">+int             lazy_allocate(uint64);</span><br><span class="line"> </span><br><span class="line"> // swtch.S</span><br><span class="line"> void            swtch(struct context*, struct context*);</span><br><span class="line">diff --git a/kernel/proc.c b/kernel/proc.c</span><br><span class="line">index ebbf5a2..de492bd 100644</span><br><span class="line">--- a/kernel/proc.c</span><br><span class="line">+++ b/kernel/proc.c</span><br><span class="line">@@ -694,3 +694,21 @@ procdump(void)</span><br><span class="line">     printf(&quot;\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+// Handle page fault with lazy allocation</span><br><span class="line">+int</span><br><span class="line">+lazy_allocate(uint64 va)&#123;</span><br><span class="line">+  struct proc *p = myproc();</span><br><span class="line">+  if(va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp)</span><br><span class="line">+    return -1;</span><br><span class="line">+  char *mem = kalloc();</span><br><span class="line">+  if(mem == 0)</span><br><span class="line">+    return -1;</span><br><span class="line">+  memset(mem, 0, PGSIZE);</span><br><span class="line">+  if(mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0)&#123;</span><br><span class="line">+    kfree(mem);</span><br><span class="line">+    uvmunmap(p-&gt;pagetable, PGROUNDDOWN(va), 1, 1);</span><br><span class="line">+    return -1;</span><br><span class="line">+  &#125;</span><br><span class="line">+  return 0;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span><br><span class="line">index e8bcda9..31fa244 100644</span><br><span class="line">--- a/kernel/sysproc.c</span><br><span class="line">+++ b/kernel/sysproc.c</span><br><span class="line">@@ -46,9 +46,12 @@ sys_sbrk(void)</span><br><span class="line"> </span><br><span class="line">   if(argint(0, &amp;n) &lt; 0)</span><br><span class="line">     return -1;</span><br><span class="line">-  addr = myproc()-&gt;sz;</span><br><span class="line">-  if(growproc(n) &lt; 0)</span><br><span class="line">-    return -1;</span><br><span class="line">+  struct proc *p = myproc();</span><br><span class="line">+  addr = p-&gt;sz;</span><br><span class="line">+  if(n &gt; 0)</span><br><span class="line">+    p-&gt;sz += n; // lazy allocation</span><br><span class="line">+  else</span><br><span class="line">+p-&gt;sz = uvmdealloc(p-&gt;pagetable, addr, addr+n);</span><br><span class="line">   return addr;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/trap.c b/kernel/trap.c</span><br><span class="line">index a63249e..e726913 100644</span><br><span class="line">--- a/kernel/trap.c</span><br><span class="line">+++ b/kernel/trap.c</span><br><span class="line">@@ -68,11 +68,18 @@ usertrap(void)</span><br><span class="line">   &#125; else if((which_dev = devintr()) != 0)&#123;</span><br><span class="line">     // ok</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">+uint64 cause = r_scause();</span><br><span class="line">+if(cause == 13 || cause == 15) &#123;</span><br><span class="line">+  // page fault</span><br><span class="line">+  uint64 stval = r_stval();</span><br><span class="line">+  if(lazy_allocate(stval) == 0)</span><br><span class="line">+    goto brk;</span><br><span class="line">+&#125;</span><br><span class="line">     printf(&quot;usertrap(): unexpected scause %p pid=%d\n&quot;, r_scause(), p-&gt;pid);</span><br><span class="line">     printf(&quot;            sepc=%p stval=%p\n&quot;, r_sepc(), r_stval());</span><br><span class="line">     p-&gt;killed = 1;</span><br><span class="line">   &#125;</span><br><span class="line">-</span><br><span class="line">+brk:</span><br><span class="line">   if(p-&gt;killed)</span><br><span class="line">     exit(-1);</span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/vm.c b/kernel/vm.c</span><br><span class="line">index bccb405..c159529 100644</span><br><span class="line">--- a/kernel/vm.c</span><br><span class="line">+++ b/kernel/vm.c</span><br><span class="line">@@ -101,10 +101,11 @@ walkaddr(pagetable_t pagetable, uint64 va)</span><br><span class="line">     return 0;</span><br><span class="line"> </span><br><span class="line">   pte = walk(pagetable, va, 0);</span><br><span class="line">-  if(pte == 0)</span><br><span class="line">-    return 0;</span><br><span class="line">-  if((*pte &amp; PTE_V) == 0)</span><br><span class="line">-    return 0;</span><br><span class="line">+  if(pte == 0 || (*pte &amp; PTE_V) == 0) &#123;</span><br><span class="line">+    if(lazy_allocate(va) != 0)</span><br><span class="line">+      return 0;</span><br><span class="line">+pte = walk(pagetable, va, 0);</span><br><span class="line">+  &#125;</span><br><span class="line">   if((*pte &amp; PTE_U) == 0)</span><br><span class="line">     return 0;</span><br><span class="line">   pa = PTE2PA(*pte);</span><br><span class="line">@@ -181,9 +182,9 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)</span><br><span class="line"> </span><br><span class="line">   for(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">     if((pte = walk(pagetable, a, 0)) == 0)</span><br><span class="line">-      panic(&quot;uvmunmap: walk&quot;);</span><br><span class="line">+      continue; // panic(&quot;uvmunmap: walk&quot;);</span><br><span class="line">     if((*pte &amp; PTE_V) == 0)</span><br><span class="line">-      panic(&quot;uvmunmap: not mapped&quot;);</span><br><span class="line">+      continue; // panic(&quot;uvmunmap: not mapped&quot;);</span><br><span class="line">     if(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">       panic(&quot;uvmunmap: not a leaf&quot;);</span><br><span class="line">     if(do_free)&#123;</span><br><span class="line">@@ -315,9 +316,9 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</span><br><span class="line"> </span><br><span class="line">   for(i = 0; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">     if((pte = walk(old, i, 0)) == 0)</span><br><span class="line">-      panic(&quot;uvmcopy: pte should exist&quot;);</span><br><span class="line">+      continue; // panic(&quot;uvmcopy: pte should exist&quot;);</span><br><span class="line">     if((*pte &amp; PTE_V) == 0)</span><br><span class="line">-      panic(&quot;uvmcopy: page not present&quot;);</span><br><span class="line">+      continue; // panic(&quot;uvmcopy: page not present&quot;);</span><br><span class="line">     pa = PTE2PA(*pte);</span><br><span class="line">     flags = PTE_FLAGS(*pte);</span><br><span class="line">     if((mem = kalloc()) == 0)</span><br><span class="line">diff --git a/time.txt b/time.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..4ae1932</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/time.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+10h10h10h10h10h10h10h10h10h10h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验六 Copy-on-Write Fork</title>
      <link href="/2022/09/05/xv6-lab6/"/>
      <url>/2022/09/05/xv6-lab6/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/cow.html">https://pdos.csail.mit.edu/6.S081/2020/labs/cow.html</a></li></ul><p>在 xv6 系统中，fork() 系统调用会复制父进程的所有用户空间内存给子进程（正如我们在 pgtbl 实验中看到过的那样）。可是，如果父进程很大，复制过程会消耗很长的时间。更糟糕的是，这可能是无用功，例如 fork() 后子进程紧接着 exec()，那么刚复制下来的内存根本不会用到。另一方面，如果父子进程都要用到这块内存，那么复制又是必须的。</p><p>写时复制（Copy-on-Write）是一种计算机程序设计领域的优化策略。它的核心思想是，如果有多个呼叫者同时请求相同资源（如内存或磁盘上的数据存储），他们会共享相同的指针指向该资源，直到某个呼叫者试图修改资源内容时，系统才会真正复制一份专用副本给该呼叫者使用。这种技术通常用于文件系统、进程管理和虚拟内存等方面。</p><p>COW fork() 只给子进程创建一个页表，其 PTE 指向父进程的物理页，然后给父子进程的 PTE 全部打上<code>不可写</code>的标记。于是，当父子进程之一试图写这些页面时会产生 page fault，内核的 page fault 处理程序检测到这种情况后，给产生异常的那个进程分配一个新的页面，把原页面复制过去，修改 PTE 并打上<code>可写</code>的标记。处理程序返回之后，进程就能继续正常执行了。<br>COW fork() 让释放物理页面变得很 tricky，因为一个物理页面可能被多个进程的页表同时指向，因此只当最后一个指针撤去后才能释放。</p><h2 id="Implement-copy-on-write"><a href="#Implement-copy-on-write" class="headerlink" title="Implement copy-on-write"></a>Implement copy-on-write</h2><p>RISC-V 的 PTE 有 10 个标志位，其中第 8、9 位是为用户保留的，因此我用第 8 位作为 PTE_COW 标志，表示该 PTE 是否需要 copy-on-write：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="comment">// copy-on-write</span></span></span><br></pre></td></tr></table></figure></p><p>我们查看 fork() 的代码，发现页表复制是由 uvmcopy() 实现的，因此我们需要改的地方其实是 uvmcopy()。（我顺便查了一下还有没有其他函数调用了 uvmcopy()，结果惊奇地发现只有 fork() 调用了它）我们将开辟内存并复制内容的代码注释掉，改为直接向原空间建立映射，并把 PTE_W 置零，把 PTE_COW 置一<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// kernel/proc.c</span><br><span class="line">// Create a new process, copying the parent.</span><br><span class="line">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="line">int</span><br><span class="line">fork(void)</span><br><span class="line">&#123;</span><br><span class="line">  int i, pid;</span><br><span class="line">  struct proc *np;</span><br><span class="line">  struct proc *p = myproc();</span><br><span class="line"></span><br><span class="line">  // Allocate process.</span><br><span class="line">  if((np = allocproc()) == 0)&#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Copy user memory from parent to child.</span><br><span class="line">  if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">  // copy saved user registers.</span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  // Cause fork to return 0 in the child.</span><br><span class="line">  np-&gt;trapframe-&gt;a0 = 0;</span><br><span class="line"></span><br><span class="line">  // increment reference counts on open file descriptors.</span><br><span class="line">  for(i = 0; i &lt; NOFILE; i++)</span><br><span class="line">    if(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">//char *mem;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// xyf</span></span><br><span class="line">    flags = (flags | PTE_COW) &amp; (~PTE_W);</span><br><span class="line">    *pte = PA2PTE(pa) | flags;</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    update_refcount(pa, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if((mem = kalloc()) == 0)</span></span><br><span class="line"><span class="comment">      goto err;</span></span><br><span class="line"><span class="comment">    memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line"><span class="comment">    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)&#123;</span></span><br><span class="line"><span class="comment">      kfree(mem);</span></span><br><span class="line"><span class="comment">      goto err;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update_refcount(pa, 1) 的作用后文叙述。</p><p>现在，对于某个带有 PTE_COW 标记的 PTE 指向的页面，我们写它时会引起 page fault——因为它的 PTE_W 被置零了。和上一个实验（lazy allocation）一样，这个 page fault 在 usertrap() 中处理。当写页面发生异常时，scause 寄存器的值会被置为 15，stval 寄存器会存储导致异常的地址，所以我们根据这两个寄存器处理 copy-on-write：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// check cow</span></span><br><span class="line">    uint64 cause = r_scause();</span><br><span class="line">    <span class="keyword">if</span>(cause == <span class="number">15</span>)&#123;</span><br><span class="line">      <span class="comment">// page fault</span></span><br><span class="line">      uint64 stval = r_stval();</span><br><span class="line">      <span class="keyword">if</span>(handle_cow(p-&gt;pagetable, stval, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> brk; <span class="comment">// copy-on-write success</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">brk:</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 handle_cow() 函数处理 copy-on-write：它先解析虚拟地址，如果发现其 PTE 的 PTE_COW 被置位了，则开辟新的空间，并将 PTE 指向这个新的空间，同时把 PTE_W 置一、PTE_COW 置零。这样，当我们返回用户空间时，用户进程就能正常执行了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// Check if virtual address refers to a cow page and handle it.</span></span><br><span class="line"><span class="comment">// Store the physical address of the newly allocated page in parameter newpa.</span></span><br><span class="line"><span class="comment">// Return: -1 something wrong</span></span><br><span class="line"><span class="comment">//          0 copy-on-write success</span></span><br><span class="line"><span class="comment">//          1 no need to copy-on-write</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">handle_cow</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 *newpa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(*pte &amp; PTE_COW)&#123;</span><br><span class="line">    <span class="comment">// copy-on-write</span></span><br><span class="line">    uint flags = (PTE_FLAGS(*pte) &amp; (~PTE_COW)) | PTE_W;</span><br><span class="line">    uint64 pa = PTE2PA(*pte);</span><br><span class="line">    <span class="type">char</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    memmove(mem, (<span class="type">char</span> *)pa, PGSIZE);</span><br><span class="line">    *pte = PA2PTE((uint64)mem) | flags;</span><br><span class="line">    kfree((<span class="type">void</span> *)pa);</span><br><span class="line">    <span class="keyword">if</span>(newpa) *newpa = (uint64)mem;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了方便，我传入了一个指针以保存新的物理地址，待会儿会用到。<br>同时在kernel/defs.h声明</p><p>copy-on-write 之后，原来的页面怎么办呢？在上面的代码中，我调用了 kfree 试图将其释放。但正如前文所述，只有当所有进程都不用一个页面时才能将其释放，所以我们需要开一个计数数组，对每一个页面统计有多少个进程指向了它。那一共有多少个页面呢？之前做第三个实验（page tables）的时候我们学习了，xv6（内核进程会用到）的内核空间是从 KERNBASE 到 PHYSTOP 的一段，所以一共有 (PHYSTOP-KERNBASE)/PGSIZE 页，并且物理地址 pa 在第 (pa-KERNBASE)/PGSIZE 页中，我们以此作为计数数组下标即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx(x) (((uint64)(x)-KERNBASE)/PGSIZE)</span></span><br><span class="line"><span class="type">int</span> refcount[idx(PHYSTOP)];</span><br></pre></td></tr></table></figure></p><p>每次 kalloc() 时，设置当前计数为 1；kfree 时，计数自减，如果减到了零，才释放内存：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  <span class="comment">// Free only when the last reference goes away.</span></span><br><span class="line">  <span class="keyword">if</span>((uint64)pa &gt;= KERNBASE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(refcount[idx(pa)] &lt;= <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kfree: refcount&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(--refcount[idx(pa)]) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    refcount[idx(r)] = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是，kinit() 初始化是调用 kfree() 实现的，所以为了把计数数组初始化为零，可以在 freerange 中把所有页的计数置为 1，这样调用一次 kfree()，就能把计数置零、加入 kmem.freelist：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    refcount[idx(p)] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了让 kalloc.c 之外的函数方便地对 refcount 操作，我写了一个更新函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="comment">// Update refcount</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">update_refcount</span><span class="params">(uint64 pa, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>((pa % PGSIZE) != <span class="number">0</span> || pa &lt; KERNBASE || pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;update_refcount&quot;</span>);</span><br><span class="line">  refcount[idx(pa)] += val;</span><br><span class="line">  <span class="keyword">if</span>(refcount[idx(pa)] &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;update_refcount: less than 0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上文 uvmcopy 就调用了它使得计数加一。<br>在kernel/defs.h添加声明</p><p>最后，我们还需要改 copyout，也用 handle_cow 函数即可，这里我设置的第三个参数就发挥了作用，当然不设置这个参数，之后 walkaddr 一下也行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(handle_cow(pagetable, va0, &amp;pa0) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="make-grade"><a href="#make-grade" class="headerlink" title="make grade"></a>make grade</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">== Test running cowtest == </span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(26.1s) </span><br><span class="line">== Test   simple == </span><br><span class="line">  simple: OK </span><br><span class="line">== Test   three == </span><br><span class="line">  three: OK </span><br><span class="line">== Test   file == </span><br><span class="line">  file: OK </span><br><span class="line">== Test usertests == </span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(364.4s) </span><br><span class="line">    (Old xv6.out.usertests failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test   usertests: copyin == </span><br><span class="line">  usertests: copyin: OK </span><br><span class="line">== Test   usertests: copyout == </span><br><span class="line">  usertests: copyout: OK </span><br><span class="line">== Test   usertests: all tests == </span><br><span class="line">  usertests: all tests: OK </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 110/110</span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/grade-lab-cow b/grade-lab-cow</span><br><span class="line">index 8eff3b7..0d19e6d 100755</span><br><span class="line">--- a/grade-lab-cow</span><br><span class="line">+++ b/grade-lab-cow</span><br><span class="line">@@ -29,7 +29,7 @@ def test_file():</span><br><span class="line"> def test_usertests():</span><br><span class="line">     r.run_qemu(shell_script([</span><br><span class="line">         <span class="string">&#x27;usertests&#x27;</span></span><br><span class="line">-    ]), <span class="built_in">timeout</span>=300)</span><br><span class="line">+    ]), <span class="built_in">timeout</span>=1000)</span><br><span class="line">     r.match(<span class="string">&#x27;^ALL TESTS PASSED$&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> def usertest_check(testcase, nextcase, output):</span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index 4b9bbc0..4e8e7bc 100644</span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);</span><br><span class="line"> void*           kalloc(void);</span><br><span class="line"> void            kfree(void *);</span><br><span class="line"> void            kinit(void);</span><br><span class="line">+void            update_refcount(uint64, int);</span><br><span class="line"> </span><br><span class="line"> // log.c</span><br><span class="line"> void            initlog(int, struct superblock*);</span><br><span class="line">@@ -171,6 +172,7 @@ uint64          walkaddr(pagetable_t, uint64);</span><br><span class="line"> int             copyout(pagetable_t, uint64, char *, uint64);</span><br><span class="line"> int             copyin(pagetable_t, char *, uint64, uint64);</span><br><span class="line"> int             copyinstr(pagetable_t, char *, uint64, uint64);</span><br><span class="line">+int             handle_cow(pagetable_t, uint64, uint64 *);</span><br><span class="line"> </span><br><span class="line"> // plic.c</span><br><span class="line"> void            plicinit(void);</span><br><span class="line">diff --git a/kernel/kalloc.c b/kernel/kalloc.c</span><br><span class="line">index fa6a0ac..8ecec14 100644</span><br><span class="line">--- a/kernel/kalloc.c</span><br><span class="line">+++ b/kernel/kalloc.c</span><br><span class="line">@@ -23,6 +23,9 @@ struct &#123;</span><br><span class="line">   struct run *freelist;</span><br><span class="line"> &#125; kmem;</span><br><span class="line"> </span><br><span class="line">+<span class="comment">#define idx(x) (((uint64)(x)-KERNBASE)/PGSIZE)</span></span><br><span class="line">+int refcount[idx(PHYSTOP)];</span><br><span class="line">+</span><br><span class="line"> void</span><br><span class="line"> <span class="function"><span class="title">kinit</span></span>()</span><br><span class="line"> &#123;</span><br><span class="line">@@ -35,8 +38,10 @@ freerange(void *pa_start, void *pa_end)</span><br><span class="line"> &#123;</span><br><span class="line">   char *p;</span><br><span class="line">   p = (char*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">-  <span class="keyword">for</span>(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE)</span><br><span class="line">+  <span class="keyword">for</span>(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">+    refcount[idx(p)] = 1;</span><br><span class="line">     kfree(p);</span><br><span class="line">+  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // Free the page of physical memory pointed at by v,</span><br><span class="line">@@ -50,7 +55,14 @@ kfree(void *pa)</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">     panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">-</span><br><span class="line">+  </span><br><span class="line">+  // Free only when the last reference goes away.</span><br><span class="line">+  <span class="keyword">if</span>((uint64)pa &gt;= KERNBASE)&#123;</span><br><span class="line">+    <span class="keyword">if</span>(refcount[idx(pa)] &lt;= 0)</span><br><span class="line">+      panic(<span class="string">&quot;kfree: refcount&quot;</span>);</span><br><span class="line">+    <span class="keyword">if</span>(--refcount[idx(pa)]) <span class="built_in">return</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+  </span><br><span class="line">   // Fill with junk to catch dangling refs.</span><br><span class="line">   memset(pa, 1, PGSIZE);</span><br><span class="line"> </span><br><span class="line">@@ -78,5 +90,20 @@ kalloc(void)</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>(r)</span><br><span class="line">     memset((char*)r, 5, PGSIZE); // fill with junk</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span>(r)</span><br><span class="line">+    refcount[idx(r)] = 1;</span><br><span class="line">+ </span><br><span class="line">   <span class="built_in">return</span> (void*)r;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+// Update refcount</span><br><span class="line">+void</span><br><span class="line">+update_refcount(uint64 pa, int val)</span><br><span class="line">+&#123;</span><br><span class="line">+  <span class="keyword">if</span>((pa % PGSIZE) != 0 || pa &lt; KERNBASE || pa &gt;= PHYSTOP)</span><br><span class="line">+    panic(<span class="string">&quot;update_refcount&quot;</span>);</span><br><span class="line">+  refcount[idx(pa)] += val;</span><br><span class="line">+  <span class="keyword">if</span>(refcount[idx(pa)] &lt; 0)</span><br><span class="line">+    panic(<span class="string">&quot;update_refcount: less than 0&quot;</span>);</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/riscv.h b/kernel/riscv.h</span><br><span class="line">index 0aec003..8a0ca5f 100644</span><br><span class="line">--- a/kernel/riscv.h</span><br><span class="line">+++ b/kernel/riscv.h</span><br><span class="line">@@ -331,6 +331,7 @@ sfence_vma()</span><br><span class="line"> <span class="comment">#define PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"> <span class="comment">#define PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"> <span class="comment">#define PTE_U (1L &lt;&lt; 4) // 1 -&gt; user can access</span></span><br><span class="line">+<span class="comment">#define PTE_COW (1L &lt;&lt; 8)  // used in copy-on-write</span></span><br><span class="line"> </span><br><span class="line"> // <span class="built_in">shift</span> a physical address to the right place <span class="keyword">for</span> a PTE.</span><br><span class="line"> <span class="comment">#define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line">diff --git a/kernel/trap.c b/kernel/trap.c</span><br><span class="line">index a63249e..b0bf1bb 100644</span><br><span class="line">--- a/kernel/trap.c</span><br><span class="line">+++ b/kernel/trap.c</span><br><span class="line">@@ -68,11 +68,21 @@ usertrap(void)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != 0)&#123;</span><br><span class="line">     // ok</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+    // check cow</span><br><span class="line">+    uint64 cause = r_scause();</span><br><span class="line">+    <span class="keyword">if</span>(cause == 15)&#123;</span><br><span class="line">+      // page fault</span><br><span class="line">+      uint64 stval = r_stval();</span><br><span class="line">+      <span class="keyword">if</span>(handle_cow(p-&gt;pagetable, stval, 0) == 0)</span><br><span class="line">+        goto brk;</span><br><span class="line">+    &#125;</span><br><span class="line">+    </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">     p-&gt;killed = 1;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">+brk:</span><br><span class="line">   <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">     <span class="built_in">exit</span>(-1);</span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/vm.c b/kernel/vm.c</span><br><span class="line">index bccb405..88c444d 100644</span><br><span class="line">--- a/kernel/vm.c</span><br><span class="line">+++ b/kernel/vm.c</span><br><span class="line">@@ -311,7 +311,7 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</span><br><span class="line">   pte_t *pte;</span><br><span class="line">   uint64 pa, i;</span><br><span class="line">   uint flags;</span><br><span class="line">-  char *mem;</span><br><span class="line">+  //char *mem;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span>(i = 0; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">     <span class="keyword">if</span>((pte = walk(old, i, 0)) == 0)</span><br><span class="line">@@ -320,6 +320,13 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</span><br><span class="line">       panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">     pa = PTE2PA(*pte);</span><br><span class="line">     flags = PTE_FLAGS(*pte);</span><br><span class="line">+</span><br><span class="line">+    flags = (flags | PTE_COW) &amp; (~PTE_W);</span><br><span class="line">+    *pte = PA2PTE(pa) | flags;</span><br><span class="line">+    <span class="keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != 0)</span><br><span class="line">+      goto err;</span><br><span class="line">+    update_refcount(pa, 1);</span><br><span class="line">+/*</span><br><span class="line">     <span class="keyword">if</span>((mem = kalloc()) == 0)</span><br><span class="line">       goto err;</span><br><span class="line">     memmove(mem, (char*)pa, PGSIZE);</span><br><span class="line">@@ -327,6 +334,7 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</span><br><span class="line">       kfree(mem);</span><br><span class="line">       goto err;</span><br><span class="line">     &#125;</span><br><span class="line">+*/</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line"> </span><br><span class="line">@@ -361,6 +369,10 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</span><br><span class="line">     pa0 = walkaddr(pagetable, va0);</span><br><span class="line">     <span class="keyword">if</span>(pa0 == 0)</span><br><span class="line">       <span class="built_in">return</span> -1;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span>(handle_cow(pagetable, va0, &amp;pa0) == -1)</span><br><span class="line">+      <span class="built_in">return</span> -1;</span><br><span class="line">+</span><br><span class="line">     n = PGSIZE - (dstva - va0);</span><br><span class="line">     <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">       n = len;</span><br><span class="line">@@ -440,3 +452,28 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)</span><br><span class="line">     <span class="built_in">return</span> -1;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+// Check <span class="keyword">if</span> virtual address refers to a cow page and handle it.</span><br><span class="line">+// Store the physical address of the newly allocated page <span class="keyword">in</span> parameter newpa.</span><br><span class="line">+// Return: -1 something wrong</span><br><span class="line">+//          0 copy-on-write success</span><br><span class="line">+//          1 no need to copy-on-write</span><br><span class="line">+int</span><br><span class="line">+handle_cow(pagetable_t pagetable, uint64 va, uint64 *newpa)</span><br><span class="line">+&#123;</span><br><span class="line">+  pte_t *pte = walk(pagetable, va, 0);</span><br><span class="line">+  <span class="keyword">if</span>(pte == 0)  <span class="built_in">return</span> -1;</span><br><span class="line">+  <span class="keyword">if</span>(*pte &amp; PTE_COW)&#123;</span><br><span class="line">+    // copy-on-write</span><br><span class="line">+    uint flags = (PTE_FLAGS(*pte) &amp; (~PTE_COW)) | PTE_W;</span><br><span class="line">+    uint64 pa = PTE2PA(*pte);</span><br><span class="line">+    char *mem = kalloc();</span><br><span class="line">+    <span class="keyword">if</span>(mem == 0)  <span class="built_in">return</span> -1;</span><br><span class="line">+    memmove(mem, (char *)pa, PGSIZE);</span><br><span class="line">+    *pte = PA2PTE((uint64)mem) | flags;</span><br><span class="line">+    kfree((void *)pa);</span><br><span class="line">+    <span class="keyword">if</span>(newpa) *newpa = (uint64)mem;</span><br><span class="line">+    <span class="built_in">return</span> 0;</span><br><span class="line">+  &#125;</span><br><span class="line">+  <span class="built_in">return</span> 1;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/time.txt b/time.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..f599e28</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/time.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验4 Traps</title>
      <link href="/2022/09/04/xv6-lab4/"/>
      <url>/2022/09/04/xv6-lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-traps-Trap"><a href="#Lab-traps-Trap" class="headerlink" title="Lab traps: Trap"></a>Lab traps: Trap</h1><ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/traps.html">https://pdos.csail.mit.edu/6.S081/2020/labs/traps.html</a></li></ul><h2 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h2><p>阅读 call.asm，以及 RISC-V 指令集教程，回答问题。（学习 RISC-V 汇编）<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Q: 哪些寄存器存储了函数调用的参数？举个例子，main 调用 printf 的时候，13 被存在了哪个寄存器中？</span><br><span class="line">A: a0-a7; a2;</span><br><span class="line"></span><br><span class="line">Q: main 中调用函数 f 对应的汇编代码在哪？对 g 的调用呢？ (提示：编译器有可能会内链(inline)一些函数)</span><br><span class="line">A: 没有这样的代码。 g(x) 被内链到 f(x) 中，然后 f(x) 又被进一步内链到 main() 中</span><br><span class="line"></span><br><span class="line">Q: printf 函数所在的地址是？</span><br><span class="line">A: 0x0000000000000628, main 中使用 pc 相对寻址来计算得到这个地址。</span><br><span class="line"></span><br><span class="line">Q: 在 main 中 jalr 跳转到 printf 之后，ra 的值是什么？</span><br><span class="line">A: 0x0000000000000038, jalr 指令的下一条汇编指令的地址。</span><br><span class="line"></span><br><span class="line">Q: 运行下面的代码</span><br><span class="line"></span><br><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);      </span><br><span class="line"></span><br><span class="line">输出是什么？</span><br><span class="line">如果 RISC-V 是大端序的，要实现同样的效果，需要将 i 设置为什么？需要将 57616 修改为别的值吗？</span><br><span class="line">A: &quot;He110 World&quot;; 0x726c6400; 不需要，57616 的十六进制是 110，无论端序（十六进制和内存中的表示不是同个概念）</span><br><span class="line"></span><br><span class="line">Q: 在下面的代码中，&#x27;y=&#x27; 之后会答应什么？ (note: 答案不是一个具体的值) 为什么?</span><br><span class="line"></span><br><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br><span class="line"></span><br><span class="line">A: 输出的是一个受调用前的代码影响的“随机”的值。因为 printf 尝试读的参数数量比提供的参数数量多。</span><br><span class="line">第二个参数 `3` 通过 a1 传递，而第三个参数对应的寄存器 a2 在调用前不会被设置为任何具体的值，而是会</span><br><span class="line">包含调用发生前的任何已经在里面的值。</span><br></pre></td></tr></table></figure></p><h2 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (moderate)</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>backtrace功能: 打印出调用栈，用于调试</p><p><img src="/img/xv6-lab4-backtrace.png" alt="the layout of stack frames"></p><ul><li>栈的生长方向是从高地址到低地址</li><li>栈帧中从高到低第一个 8 字节 fp-8 是 return address，也就是当前调用层应该返回到的地址。</li><li>栈帧中从高到低第二个 8 字节 fp-16 是 previous address，指向上一层栈帧的 fp 开始地址。</li><li>剩下的为保存的寄存器、局部变量等。一个栈帧的大小不固定，但是至少 16 字节。</li><li>在 xv6 中，使用一个页来存储栈，如果 fp 已经到达栈页的上界，则说明已经到达栈底。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在 <code>defs.h</code> 中添加声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defs.h</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">printf</span><span class="params">(<span class="type">char</span>*, ...)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">panic</span><span class="params">(<span class="type">char</span>*)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">printfinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p><p>在 <code>riscv.h</code> 中添加获取当前 fp（frame pointer）寄存器的方法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x))</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>printf.c</code>实现backtrace函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  uint64 high = PGROUNDUP(fp), low = PGROUNDDOWN(fp);</span><br><span class="line">  <span class="keyword">while</span>(fp&gt;=low &amp;&amp; fp&lt;high) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,  *((uint64*)(fp - <span class="number">8</span>)));  <span class="comment">// return address</span></span><br><span class="line">    fp = *((uint64*)(fp - <span class="number">16</span>));                 <span class="comment">// previous fp</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>sysproc.c</code> 的 <code>sys_sleep</code> 的开头调用一次 backtrace()<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  backtrace(); <span class="comment">// print stack backtrace.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ bttest</span><br><span class="line">0x0000000080002ccc</span><br><span class="line">0x0000000080002ba6</span><br><span class="line">0x0000000080002890</span><br><span class="line">$ QEMU: Terminated</span><br><span class="line">grand@Lubuntu ~/xv6-labs-2020 (traps)&gt; addr2line -e kernel/kernel</span><br><span class="line">0x0000000080002ccc</span><br><span class="line">0x0000000080002ba6</span><br><span class="line">0x0000000080002890</span><br><span class="line">Ctrl-D</span><br><span class="line">/home/grand/xv6-labs-2020/kernel/sysproc.c:63</span><br><span class="line">/home/grand/xv6-labs-2020/kernel/syscall.c:140</span><br><span class="line">/home/grand/xv6-labs-2020/kernel/trap.c:76</span><br></pre></td></tr></table></figure><h2 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (hard)</h2><p>任务：给 xv6 加一个功能——在进程使用CPU时间时定期发出警告。这对于限制 CPU 密集型（计算密集型）进程的占用时间，或对于在计算过程中有其他定期动作的进程可能很有用。更广泛的说，我们将实现一个用户级中断/异常的处理程序。</p><p>我们需要添加一个 sigalarm(interval, handler) 系统调用。如果一个应用调用了 sigalarm(n, fn)，则该应用每耗时 n 个 ticks，内核应该使之调用 fn，fn 返回后该应用继续执行。如果一个应用调用 sigalarm(0, 0)，内核应该停止产生 alarm calls。</p><h3 id="test0-invoke-handler"><a href="#test0-invoke-handler" class="headerlink" title="test0: invoke handler"></a>test0: invoke handler</h3><h4 id="添加声明"><a href="#添加声明" class="headerlink" title="添加声明"></a>添加声明</h4><ul><li>在<code>Makefile</code>的<code>UPROGS</code>的最后添加<code>$U/_alarmtest\</code></li><li><code>user/user.h</code>中的系统调用函数声明<code>int sigalarm(int ticks, void(*handler)());</code>，<code>int sigreturn(void);</code></li><li><code>user/usys.pl</code>中添加<code>entry(&quot;sigalarm&quot;);</code>和<code>entry(&quot;sigreturn&quot;);</code></li><li><code>kernel/syscall.h</code>添加系统函数编号<code>#define SYS_sigalarm 22</code>和<code>#define SYS_sigreturn 23</code></li><li><code>kernel/syscall.c</code>添加内核态函数声明，如下所示<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">...</span><br><span class="line">[SYS_sigalarm] sys_sigalarm,</span><br><span class="line">[SYS_sigreturn] sys_sigreturn,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>test0是实现一部分的sys_sigalarm，因此为了使得可以编译运行，先将sys_sigreturn(void)的返回值设为0<br>在kernel/sysproc.c里面，添加如下代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来是关于如何实现发出alarm</p><ul><li>首先，在struct proc（in kernel/proc.h）中添加一下进程的【属性】：总 ticks 数、处理程序指针、剩余 ticks 数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ticks;                   <span class="comment">// Ticks between two alarms. </span></span><br><span class="line">  uint64 handler;              <span class="comment">// Alarm handler.</span></span><br><span class="line">  <span class="type">int</span> remain_ticks;            <span class="comment">// Remaining ticks after last alarm.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>在 allocproc (kernel/proc.c) 中初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize for alarm.</span></span><br><span class="line">  p-&gt;ticks = p-&gt;remain_ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在kernel/sysproc.c实现系统调用sys_sigalarm</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  p-&gt;ticks = ticks;</span><br><span class="line">  p-&gt;handler = handler;</span><br><span class="line">  p-&gt;remain_ticks = ticks;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每一个 tick 过后硬件都会产生计时器中断（timer interrupt），所以我们在 kernel/trap.c 中 if(which_dev == 2) 语句下处理它，把 p-&gt;trapframe-&gt;epc 改成处理程序地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks == <span class="number">0</span>)</span><br><span class="line">      yield();</span><br><span class="line">    p-&gt;remain_ticks--;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;remain_ticks == <span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;remain_ticks = p-&gt;ticks;</span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="test1-test2-resume-interrupted-code"><a href="#test1-test2-resume-interrupted-code" class="headerlink" title="test1/test2(): resume interrupted code"></a>test1/test2(): resume interrupted code</h3><h4 id="完善sigalarm"><a href="#完善sigalarm" class="headerlink" title="完善sigalarm"></a>完善sigalarm</h4><ul><li><p>在struct proc（in kernel/proc.h）中添加一个【属性】用来保存栈帧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="type">int</span> ticks;                   <span class="comment">// Ticks between two alarms. </span></span><br><span class="line">  uint64 handler;              <span class="comment">// Alarm handler.</span></span><br><span class="line">  <span class="type">int</span> remain_ticks;            <span class="comment">// Remaining ticks after last alarm.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">save_trapframe</span>;</span> <span class="comment">// Save trapframe page when handling alarm.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 allocproc (kernel/proc.c) 中初始化 栈帧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize for alarm.</span></span><br><span class="line">  p-&gt;ticks = p-&gt;remain_ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;save_trapframe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 kernel/trap.c 中 if(which_dev == 2) 语句处 保存栈帧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;ticks == <span class="number">0</span>)</span><br><span class="line">    yield();</span><br><span class="line">  p-&gt;remain_ticks--;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;remain_ticks == <span class="number">0</span> &amp;&amp; p-&gt;save_trapframe == <span class="number">0</span>)&#123;</span><br><span class="line">    p-&gt;remain_ticks = p-&gt;ticks;</span><br><span class="line">    p-&gt;save_trapframe = (<span class="keyword">struct</span> trapframe *)kalloc();</span><br><span class="line">    memmove(p-&gt;save_trapframe, p-&gt;trapframe, PGSIZE);</span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;handler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现sys-sigreturn，还原-栈帧"><a href="#实现sys-sigreturn，还原-栈帧" class="headerlink" title="实现sys_sigreturn，还原 栈帧"></a>实现sys_sigreturn，还原 栈帧</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;save_trapframe)&#123;</span><br><span class="line">    memmove(p-&gt;trapframe, p-&gt;save_trapframe, PGSIZE);</span><br><span class="line">    kfree(p-&gt;save_trapframe);</span><br><span class="line">    p-&gt;save_trapframe = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (traps)&gt; ./grade-lab-traps</span><br><span class="line"></span><br><span class="line">== Test answers-traps.txt == answers-traps.txt: FAIL </span><br><span class="line">    Cannot <span class="built_in">read</span> answers-traps.txt</span><br><span class="line">== Test backtrace <span class="built_in">test</span> == backtrace <span class="built_in">test</span>: OK (5.1s) </span><br><span class="line">== Test running alarmtest == (8.3s) </span><br><span class="line">== Test   alarmtest: test0 == </span><br><span class="line">  alarmtest: test0: OK </span><br><span class="line">== Test   alarmtest: test1 == </span><br><span class="line">  alarmtest: test1: OK </span><br><span class="line">== Test   alarmtest: test2 == </span><br><span class="line">  alarmtest: test2: OK </span><br><span class="line">== Test usertests == usertests: OK (198.8s) </span><br><span class="line">== Test time == </span><br><span class="line">time: FAIL </span><br><span class="line">    Cannot <span class="built_in">read</span> time.txt</span><br><span class="line">Score: 79/85</span><br></pre></td></tr></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>如果只是修改了文件，没有任何git操作，想要撤销、还原文件</p><ul><li>用暂存区的文件替换工作区的文件：<ul><li>全部文件：<code>git checkout .</code></li><li>指定文件：<code>git checkout -- [file]</code></li></ul></li></ul><p>如果修改了文件，并且<code>git add</code>，没有<code>git commit</code></p><ul><li>git log —oneline  // 可以省略，oneline 一条提交信息用一行展示</li><li>git reset HEAD    //  回退到当前版本</li><li>git checkout — [file]</li></ul><p>如果修改了文件，<code>git add, git commit</code></p><ul><li>git log —oneline // 可以省略</li><li>git reset HEAD^ // 回退到上一个版本，HEAD^^：上上版本，HEAD~数字：回退到数字个版本</li><li>git checkout — [file] </li></ul><h2 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index 1fa367e..a74296b 100644</span><br><span class="line">--- a/Makefile</span><br><span class="line">+++ b/Makefile</span><br><span class="line">@@ -175,6 +175,7 @@ UPROGS=\</span><br><span class="line"> <span class="variable">$U</span>/_grind\</span><br><span class="line"> <span class="variable">$U</span>/_wc\</span><br><span class="line"> <span class="variable">$U</span>/_zombie\</span><br><span class="line">+<span class="variable">$U</span>/_alarmtest\</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index 4b9bbc0..137c786 100644</span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ -80,6 +80,7 @@ int             pipewrite(struct pipe*, uint64, int);</span><br><span class="line"> void            <span class="built_in">printf</span>(char*, ...);</span><br><span class="line"> void            panic(char*) __attribute__((noreturn));</span><br><span class="line"> void            printfinit(void);</span><br><span class="line">+void            backtrace(void);</span><br><span class="line"> </span><br><span class="line"> // proc.c</span><br><span class="line"> int             cpuid(void);</span><br><span class="line">diff --git a/kernel/printf.c b/kernel/printf.c</span><br><span class="line">index e1347de..b3219b0 100644</span><br><span class="line">--- a/kernel/printf.c</span><br><span class="line">+++ b/kernel/printf.c</span><br><span class="line">@@ -132,3 +132,14 @@ printfinit(void)</span><br><span class="line">   initlock(&amp;pr.lock, <span class="string">&quot;pr&quot;</span>);</span><br><span class="line">   pr.locking = 1;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+void</span><br><span class="line">+backtrace(void)</span><br><span class="line">+&#123;</span><br><span class="line">+  uint64 fp = r_fp();</span><br><span class="line">+  uint64 high = PGROUNDUP(fp), low = PGROUNDDOWN(fp);</span><br><span class="line">+  <span class="keyword">while</span>(fp &gt;= low &amp;&amp; fp &lt; high) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,  *((uint64*)(fp - 8)));  // <span class="built_in">return</span> address</span><br><span class="line">+    fp = *((uint64*)(fp - 16));             // previous fp</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/proc.c b/kernel/proc.c</span><br><span class="line">index dab1e1d..cebdcbe 100644</span><br><span class="line">--- a/kernel/proc.c</span><br><span class="line">+++ b/kernel/proc.c</span><br><span class="line">@@ -127,6 +127,11 @@ found:</span><br><span class="line">   p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">   p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"> </span><br><span class="line">+  // initlize tick ans handler <span class="keyword">for</span> alarm</span><br><span class="line">+  p-&gt;ticks = p-&gt;remain_ticks = 0;</span><br><span class="line">+  p-&gt;handler = 0;</span><br><span class="line">+  p-&gt;save_trapframe = 0;</span><br><span class="line">+</span><br><span class="line">   <span class="built_in">return</span> p;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/proc.h b/kernel/proc.h</span><br><span class="line">index 9c16ea7..0afc5ef 100644</span><br><span class="line">--- a/kernel/proc.h</span><br><span class="line">+++ b/kernel/proc.h</span><br><span class="line">@@ -103,4 +103,9 @@ struct proc &#123;</span><br><span class="line">   struct file *ofile[NOFILE];  // Open files</span><br><span class="line">   struct inode *cwd;           // Current directory</span><br><span class="line">   char name[16];               // Process name (debugging)</span><br><span class="line">-&#125;;</span><br><span class="line">+</span><br><span class="line">+  int ticks;                   // Ticks between two alarms.</span><br><span class="line">+  uint64 handler;              // Alarm handler.</span><br><span class="line">+  int remain_ticks;            // Remaining ticks after last alarm.</span><br><span class="line">+  struct trapframe *save_trapframe; // Save trapframe page when handling alarm.</span><br><span class="line">+ &#125;;</span><br><span class="line">diff --git a/kernel/riscv.h b/kernel/riscv.h</span><br><span class="line">index 0aec003..927d9ee 100644</span><br><span class="line">--- a/kernel/riscv.h</span><br><span class="line">+++ b/kernel/riscv.h</span><br><span class="line">@@ -1,3 +1,12 @@</span><br><span class="line">+// 获取当前 fp（frame pointer）寄存器</span><br><span class="line">+static inline uint64</span><br><span class="line">+r_fp()</span><br><span class="line">+&#123;</span><br><span class="line">+  uint64 x;</span><br><span class="line">+  asm volatile(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) );</span><br><span class="line">+  <span class="built_in">return</span> x;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> // <span class="built_in">which</span> hart (core) is this?</span><br><span class="line"> static inline uint64</span><br><span class="line"> r_mhartid()</span><br><span class="line">diff --git a/kernel/syscall.c b/kernel/syscall.c</span><br><span class="line">index c1b3670..24bfccd 100644</span><br><span class="line">--- a/kernel/syscall.c</span><br><span class="line">+++ b/kernel/syscall.c</span><br><span class="line">@@ -104,6 +104,8 @@ extern uint64 sys_unlink(void);</span><br><span class="line"> extern uint64 sys_wait(void);</span><br><span class="line"> extern uint64 sys_write(void);</span><br><span class="line"> extern uint64 sys_uptime(void);</span><br><span class="line">+extern uint64 sys_sigalarm(void);</span><br><span class="line">+extern uint64 sys_sigreturn(void);</span><br><span class="line"> </span><br><span class="line"> static uint64 (*syscalls[])(void) = &#123;</span><br><span class="line"> [SYS_fork]    sys_fork,</span><br><span class="line">@@ -127,6 +129,8 @@ static uint64 (*syscalls[])(void) = &#123;</span><br><span class="line"> [SYS_link]    sys_link,</span><br><span class="line"> [SYS_mkdir]   sys_mkdir,</span><br><span class="line"> [SYS_close]   sys_close,</span><br><span class="line">+[SYS_sigalarm] sys_sigalarm,</span><br><span class="line">+[SYS_sigreturn] sys_sigreturn,</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> void</span><br><span class="line">diff --git a/kernel/syscall.h b/kernel/syscall.h</span><br><span class="line">index bc5f356..67ca3a4 100644</span><br><span class="line">--- a/kernel/syscall.h</span><br><span class="line">+++ b/kernel/syscall.h</span><br><span class="line">@@ -20,3 +20,5 @@</span><br><span class="line"> <span class="comment">#define SYS_link   19</span></span><br><span class="line"> <span class="comment">#define SYS_mkdir  20</span></span><br><span class="line"> <span class="comment">#define SYS_close  21</span></span><br><span class="line">+<span class="comment">#define SYS_sigalarm 22</span></span><br><span class="line">+<span class="comment">#define SYS_sigreturn 23</span></span><br><span class="line">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span><br><span class="line">index e8bcda9..f349ea9 100644</span><br><span class="line">--- a/kernel/sysproc.c</span><br><span class="line">+++ b/kernel/sysproc.c</span><br><span class="line">@@ -58,6 +58,8 @@ sys_sleep(void)</span><br><span class="line">   int n;</span><br><span class="line">   uint ticks0;</span><br><span class="line"> </span><br><span class="line">+  backtrace(); // <span class="built_in">print</span> stack backtrace.</span><br><span class="line">+</span><br><span class="line">   <span class="keyword">if</span>(argint(0, &amp;n) &lt; 0)</span><br><span class="line">     <span class="built_in">return</span> -1;</span><br><span class="line">   acquire(&amp;tickslock);</span><br><span class="line">@@ -95,3 +97,36 @@ sys_uptime(void)</span><br><span class="line">   release(&amp;tickslock);</span><br><span class="line">   <span class="built_in">return</span> xticks;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+uint64</span><br><span class="line">+sys_sigalarm(void)</span><br><span class="line">+&#123;</span><br><span class="line">+  int ticks;</span><br><span class="line">+  uint64 handler;</span><br><span class="line">+  struct proc *p = myproc();</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span>(argint(0, &amp;ticks) &lt; 0)</span><br><span class="line">+    <span class="built_in">return</span> -1;</span><br><span class="line">+  <span class="keyword">if</span>(argaddr(1, &amp;handler) &lt; 0)</span><br><span class="line">+    <span class="built_in">return</span> -1;</span><br><span class="line">+  acquire(&amp;p-&gt;lock);</span><br><span class="line">+  p-&gt;ticks = ticks;</span><br><span class="line">+  p-&gt;handler = handler;</span><br><span class="line">+  p-&gt;remain_ticks = ticks;</span><br><span class="line">+  release(&amp;p-&gt;lock);</span><br><span class="line">+  <span class="built_in">return</span> 0;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+uint64</span><br><span class="line">+sys_sigreturn(void)</span><br><span class="line">+&#123;</span><br><span class="line">+  struct proc *p = myproc();</span><br><span class="line">+  acquire(&amp;p-&gt;lock);</span><br><span class="line">+  <span class="keyword">if</span>(p-&gt;save_trapframe)&#123;</span><br><span class="line">+    memmove(p-&gt;trapframe, p-&gt;save_trapframe, PGSIZE);</span><br><span class="line">+    kfree(p-&gt;save_trapframe);</span><br><span class="line">+    p-&gt;save_trapframe = 0;</span><br><span class="line">+  &#125;</span><br><span class="line">+  release(&amp;p-&gt;lock);</span><br><span class="line">+  <span class="built_in">return</span> 0;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/trap.c b/kernel/trap.c</span><br><span class="line">index a63249e..d1900fd 100644</span><br><span class="line">--- a/kernel/trap.c</span><br><span class="line">+++ b/kernel/trap.c</span><br><span class="line">@@ -77,9 +77,18 @@ usertrap(void)</span><br><span class="line">     <span class="built_in">exit</span>(-1);</span><br><span class="line"> </span><br><span class="line">   // give up the CPU <span class="keyword">if</span> this is a timer interrupt.</span><br><span class="line">-  <span class="keyword">if</span>(which_dev == 2)</span><br><span class="line">-    yield();</span><br><span class="line">-</span><br><span class="line">+  <span class="keyword">if</span>(which_dev == 2) &#123;</span><br><span class="line">+    <span class="keyword">if</span>(p-&gt;ticks == 0)</span><br><span class="line">+      yield();</span><br><span class="line">+</span><br><span class="line">+    p-&gt;remain_ticks--;</span><br><span class="line">+    <span class="keyword">if</span>(p-&gt;remain_ticks == 0 &amp;&amp; p-&gt;save_trapframe == 0)&#123;</span><br><span class="line">+      p-&gt;remain_ticks = p-&gt;ticks;</span><br><span class="line">+      p-&gt;save_trapframe = (struct trapframe *)kalloc();</span><br><span class="line">+      memmove(p-&gt;save_trapframe, p-&gt;trapframe, PGSIZE);</span><br><span class="line">+      p-&gt;trapframe-&gt;epc = p-&gt;handler;</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">   usertrapret();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">diff --git a/user/user.h b/user/user.h</span><br><span class="line">index b71ecda..675a192 100644</span><br><span class="line">--- a/user/user.h</span><br><span class="line">+++ b/user/user.h</span><br><span class="line">@@ -24,6 +24,9 @@ char* sbrk(int);</span><br><span class="line"> int <span class="built_in">sleep</span>(int);</span><br><span class="line"> int <span class="built_in">uptime</span>(void);</span><br><span class="line"> </span><br><span class="line">+int sigalarm(int ticks, void (*handler)());</span><br><span class="line">+int sigreturn(void);</span><br><span class="line">+</span><br><span class="line"> // ulib.c</span><br><span class="line"> int <span class="built_in">stat</span>(const char*, struct <span class="built_in">stat</span>*);</span><br><span class="line"> char* strcpy(char*, const char*);</span><br><span class="line">diff --git a/user/usys.pl b/user/usys.pl</span><br><span class="line">index 01e426e..fa548b0 100755</span><br><span class="line">--- a/user/usys.pl</span><br><span class="line">+++ b/user/usys.pl</span><br><span class="line">@@ -36,3 +36,5 @@ entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">+entry(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line">+entry(<span class="string">&quot;sigreturn&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验3 page tables</title>
      <link href="/2022/09/03/xv6-lab3/"/>
      <url>/2022/09/03/xv6-lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-pgtbl-Page-tables"><a href="#Lab-pgtbl-Page-tables" class="headerlink" title="Lab pgtbl: Page tables"></a>Lab pgtbl: Page tables</h1><ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html">https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html</a></li></ul><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>本小节参考freewalk的代码，实现RISC-V三级页表翻译，打印页表的内容。</p><p>在<code>kernel/defs.h</code>声明<code>void vmprint(pagetable_t);</code></p><p>在<code>kernel/exec.c</code>的<code>return argc;</code>之前添加<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>) &#123;</span><br><span class="line">vmprint(p-&gt;pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么，在os启动的时候，会打印页表的内容。</p><p>参考<code>kernel/vm.c</code>中<code>freewalk(pagetable_t pagetable)</code>函数访问页表的方式递归输出页表信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://kilogrand.github.io/2022/08/31/xv6-Chapter-3/">RISC-V的页表</a><br><img src="/img/Figure-3.2.jpg" alt="Figure-3.2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vmprint辅助函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line">_vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i) &#123; <span class="comment">// 每一页都包含 512 个 PTE，用于指向下一个页表或物理地址</span></span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V)) &#123; <span class="comment">// PTE_V 表示 PTE 是否有效</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; level; ++j) &#123; <span class="comment">// 根据现在是L2、L1、L0 (level: 1,2,3)来打印，形成树形结构</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      uint64 child = PTE2PA(pte); <span class="comment">// 通过pte映射下一级页表的物理地址</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      <span class="comment">// 判断是否在最后一级页表，若不是，则递归</span></span><br><span class="line">      <span class="comment">// 只有在页表的最后一级，才可进行读、写、执行</span></span><br><span class="line">      <span class="keyword">if</span> ((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)</span><br><span class="line">        _vmprint((<span class="type">pagetable_t</span>)child, level + <span class="number">1</span>);  <span class="comment">// 层级加1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印页表的内容</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h2><blockquote><p>当前，xv6的内核态只有一个直接映射到物理内存的page table，并且这个页表没有用户态进程的地址信息。<br>因此用户态向内核态传递地址时，先在用户态将虚拟地址转为物理地址，然后把物理地址通过寄存器传递给内核。</p><p>在lab2中，我们在结构体<code>struct proc</code>添加了一个成员变量<code>int mast</code>，实现<code>sys_trace</code>；<br>在本小节中，我们在结构体<code>struct proc</code>添加一个成员变量<code>kernel_pagetable</code>，<br>为每个进程添加一个内核态的页表，然后在该进程进入到内核前，<br>将该进程的kernel page table的物理地址写入SATP寄存器(Supervisor Address Translation and Protection Register)，即使用该进程的内核态页表，<br>这样就可以实现<strong>在内核态直接翻译虚拟地址的功能</strong>。</p></blockquote><hr><h3 id="一个内核页表的创建"><a href="#一个内核页表的创建" class="headerlink" title="一个内核页表的创建"></a>一个内核页表的创建</h3><ul><li>在<code>kernel/proc.h</code>中的<code>struct proc</code>添加新成员变量<code>pagetable_t kernel_pagetable</code>。</li><li>首先查看kernel/vm.c中的kvminit函数。该函数通过kalloc为内核创建一个空的页表，然后通过kvmmap完成直接映射操作。</li><li>现在要为每个新进程生成一个内核页表，所以需要参考kvminit重新实现一个为进程生成内核页表的版本</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the kernel&#x27;s page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pagetable_t</span> kernel_pagetable;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext[];  <span class="comment">// kernel.ld sets this to end of kernel code.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> trampoline[]; <span class="comment">// trampoline.S</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create a direct-map page table for the kernel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  kvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ukvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;ukvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 申请一个页表空间</span></span><br><span class="line">  <span class="type">pagetable_t</span> proc_kernel_pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="keyword">if</span> (proc_kernel_pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(proc_kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="comment">// 与vminint内容上保持一致</span></span><br><span class="line">  ukvmmap(proc_kernel_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> proc_kernel_pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在<code>kernel/defs.h</code>里面添加这两个函数的声明。</p><h3 id="为每个新进程生成一个内核页表"><a href="#为每个新进程生成一个内核页表" class="headerlink" title="为每个新进程生成一个内核页表"></a>为每个新进程生成一个内核页表</h3><blockquote><p>确保每个进程的内核页表都有该进程的内核栈的映射。<br>在未修改的xv6中，所有内核栈都在procinit中设置。<br>你需要将部分或全部功能移至allocproc。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c void procinit(void)</span></span><br><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">  <span class="comment">// 删除以下部分，将内核栈的空间申请和映射放在创建进程时</span></span><br><span class="line">  <span class="comment">//     // Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">  <span class="comment">//     // Map it high in memory, followed by an invalid</span></span><br><span class="line">  <span class="comment">//     // guard page.</span></span><br><span class="line">  <span class="comment">//     char *pa = kalloc();</span></span><br><span class="line">  <span class="comment">//     if(pa == 0)</span></span><br><span class="line">  <span class="comment">//       panic(&quot;kalloc&quot;);</span></span><br><span class="line">  <span class="comment">//     uint64 va = KSTACK((int) (p - proc));</span></span><br><span class="line">  <span class="comment">//     kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span></span><br><span class="line">  <span class="comment">//     p-&gt;kstack = va;</span></span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建进程时，为进程分配独立的内核页表</span></span><br><span class="line">  p-&gt;kernel_pagetable = proc_kvminit();</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kernel_pagetable == <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化当前内核页表的内核栈</span></span><br><span class="line">  <span class="type">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span> (pa == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">  <span class="comment">// 将内核栈映射到用户内核页表固定的部分</span></span><br><span class="line">  uint64 va = KSTACK((<span class="type">int</span>)<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 添加kernel stack的映射到用户的kernel pagetable中</span></span><br><span class="line">  ukvmmap(p-&gt;kernel_pagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="切换进程时能够切换内核页表"><a href="#切换进程时能够切换内核页表" class="headerlink" title="切换进程时能够切换内核页表"></a>切换进程时能够切换内核页表</h3><blockquote><p>修改scheduler()以便将进程的内核页表加载到内核的satp寄存器中(请参阅kvminithart以获得灵感)。<br>在调用w_satp()之后不要忘记调用sfence_vma()。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在切换任务前，将用户内核页表替换到stap寄存器中</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;kernel_pagetable));</span><br><span class="line">        <span class="comment">// 清除快表缓存</span></span><br><span class="line">        sfence_vma();</span><br><span class="line">        <span class="comment">// 调度，执行进程</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        <span class="comment">// 该进程执行结束后，将SATP寄存器的值设置为全局内核页表地址</span></span><br><span class="line">        kvminithart();</span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁进程时释放内核页表"><a href="#销毁进程时释放内核页表" class="headerlink" title="销毁进程时释放内核页表"></a>销毁进程时释放内核页表</h3><blockquote><p>在freeproc中释放进程的内核页表。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删除内核栈</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kstack) &#123;</span><br><span class="line">    <span class="comment">// 通过页表地址， kstack虚拟地址 找到最后一级的页表项</span></span><br><span class="line">    <span class="type">pte_t</span>* pte = walk(p-&gt;kernel_pagetable, p-&gt;kstack, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;freeproc : kstack&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除页表项对应的物理地址</span></span><br><span class="line">    kfree((<span class="type">void</span>*)PTE2PA(*pte));</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除kernel pagetable</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kernel_pagetable) </span><br><span class="line">    proc_freekernelpagetable(p-&gt;kernel_pagetable);  </span><br><span class="line">  p-&gt;kernel_pagetable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">proc_freekernelpagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> ((pte &amp; PTE_V)) &#123;</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        proc_freekernelpagetable((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要将 <code>walk</code> 函数的定义添加到 <code>kernel/defs.h</code> 中，否则无法直接引用。</p><h3 id="获取进程内核页表"><a href="#获取进程内核页表" class="headerlink" title="获取进程内核页表"></a>获取进程内核页表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmpa</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//注释掉</span></span><br><span class="line">  <span class="comment">//pte = walk(kernel_pagetable, va, 0);</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  pte = walk(p-&gt;kernel_pagetable, va, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在vm.c中添加头文件，因为使用了结构体proc。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify copyin/copyinstr</h2><p>这个任务的目的就是在用户进程内核页表中添加用户页表映射的副本。</p><hr><p>1.将<code>vm.c</code>中<code>copyin</code>的内容替换为对<code>copyin_new</code>的调用，将<code>vm.c</code>中<code>copyinstr</code>的内容替换为对<code>copyinstr_new</code>的调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后，将<code>copyin_new</code>和<code>copyinstr_new</code>的声明添加到<code>kernel/defs.h</code>中</p><hr><p>2.在<code>kernel/vm.c</code>中添加<code>kvmcopy</code>和<code>kvmdealloc</code>函数，<br>用户页表的变化同步到用户进程内核页表中，需要实现映射和缩减两个操作。<br>注意权限，需要把<code>PTE_U</code>去掉，因为CPU在<code>suprivisor模式</code>时不能访问设置<code>PTE_U</code>的页。<br>同时，不要释放物理内存，拷贝映射关系即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// 将 src 页表的一部分页映射关系拷贝到 dst 页表中。</span></span><br><span class="line"><span class="comment">// 只拷贝页表项，不拷贝实际的物理页内存。</span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回 -1</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kvmcopy</span><span class="params">(<span class="type">pagetable_t</span> src, <span class="type">pagetable_t</span> dst, uint64 start, uint64 end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PGROUNDUP: 对齐页边界，防止 remap</span></span><br><span class="line">  <span class="keyword">for</span>(i = PGROUNDUP(start); i &lt; end; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(src, i, <span class="number">0</span>)) == <span class="number">0</span>) <span class="comment">// 找到虚拟地址的最后一级页表项</span></span><br><span class="line">      panic(<span class="string">&quot;kvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)<span class="comment">// 判断页表项是否有效</span></span><br><span class="line">      panic(<span class="string">&quot;kvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte); <span class="comment">// 将页表项转换为物理地址页起始位置</span></span><br><span class="line">    <span class="comment">// `&amp; ~PTE_U` 表示将该页的权限设置为非用户页</span></span><br><span class="line">    <span class="comment">// 必须设置该权限，RISC-V 中内核是无法直接访问用户页的。</span></span><br><span class="line">    flags = PTE_FLAGS(*pte) &amp; ~PTE_U;</span><br><span class="line">    <span class="comment">// 将pa这一页的PTEs映射到dst上同样的虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(dst, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 清除已经映射的部分，但不释放内存</span></span><br><span class="line">      uvmunmap(dst, <span class="number">0</span>, i / PGSIZE, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 uvmdealloc 功能类似，将程序内存从 oldsz 缩减到 newsz。</span></span><br><span class="line"><span class="comment">// 但区别在于不释放实际内存</span></span><br><span class="line"><span class="comment">// 用于内核页表内程序内存映射与用户页表程序内存映射之间的同步</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmdealloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">    <span class="comment">// 如果存在多余的页需要释放</span></span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将函数声明在defs.h中。</p><hr><p>3.修改<code>fork()</code>、<code>exec()</code>和<code>growproc()</code></p><p>把fork出来的子进程的用户pagetable复制给kernel_pagetable。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child. </span></span><br><span class="line">  <span class="comment">// 将新进程的用户页表映射拷贝一份到新进程的内核页表中</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span> ||</span><br><span class="line">     kvmcopy(np-&gt;pagetable, np-&gt;kernel_pagetable, <span class="number">0</span>, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在映射之前要先检测程序大小是否超过PLIC，防止remap。<br>同时，映射前要先清除[0，PLIC]中原本的内容，再将要执行的程序映射到[0，PLIC]中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/exec.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// 添加检测，防止程序大小超过 PLIC</span></span><br><span class="line">    <span class="keyword">if</span>(sz1 &gt;= PLIC) &#123;</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除内核页表中对程序内存的旧映射，然后重新建立映射。</span></span><br><span class="line">  uvmunmap(p-&gt;kernel_pagetable, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  kvmcopy(pagetable, p-&gt;kernel_pagetable, <span class="number">0</span>, sz);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>sysproc.c</code>中的<code>sys_sbrk()</code>中可以发现，执行内存相关的函数为<code>growproc()</code>，所以我们对<code>growproc()</code>进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 newsz;</span><br><span class="line">    <span class="keyword">if</span>((newsz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内核页表中的映射同步扩大</span></span><br><span class="line">    <span class="keyword">if</span>(kvmcopy(p-&gt;pagetable, p-&gt;kernel_pagetable, sz, n) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// uvmdealloc(p-&gt;pagetable, newsz, sz);</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sz = newsz;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// 内核页表中的映射同步缩小</span></span><br><span class="line">    sz = kvmdealloc(p-&gt;kernel_pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在userinit的内核页表中包含第一个进程的用户页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  kvmcopy(p-&gt;pagetable, p-&gt;kernel_pagetable, <span class="number">0</span>, p-&gt;sz); <span class="comment">// 同步程序内存映射到进程内核页表中</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>用户页表在用户内核页表中的映射范围为[0，PLIC]，但是从xv6 book中可以看到，<br>全局内核页表的定义中在[0，PLIC]之间存在一个CLINT核心本地中断，<br>CLINT仅在内核启动时使用，所以用户进程内核页表中无需再存在CLINT，<br>所以我们将<code>proc_kvminit()</code>中CLINT映射的部分注释掉，防止再映射用户页表时出现remap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_kvminit</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 申请一个页表空间</span></span><br><span class="line">  <span class="type">pagetable_t</span> proc_kernel_pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="keyword">if</span> (proc_kernel_pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(proc_kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="comment">// 与vminint内容上保持一致</span></span><br><span class="line">  ukvmmap(proc_kernel_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// 用户进程内核页表无需在映射CLINT，将空间留出映射用户页表</span></span><br><span class="line">  <span class="comment">// ukvmmap(proc_kernel_pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);</span></span><br><span class="line">  ukvmmap(proc_kernel_pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kernel_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> proc_kernel_pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h2><blockquote><p>缺少页表映射可能会导致内核遇到页面错误。<br>它将打印一个包含sepc=0x00000000XXXXXXXX的错误。<br>你可以通过在kernel/kernel.asm中搜索XXXXXXXX来找出故障发生的位置。</p></blockquote><hr><p>如果出现<code>== Test usertests == Timeout! (300.2s)</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (pgtbl)&gt; python3 grade-lab-pgtbl</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">== Test pte printout == pte printout: OK (3.1s) </span><br><span class="line">== Test answers-pgtbl.txt == answers-pgtbl.txt: FAIL </span><br><span class="line">    answers-pgtbl.txt does not seem to contain enough text</span><br><span class="line">== Test count copyin == count copyin: OK (2.2s) </span><br><span class="line">== Test usertests == Timeout! (300.2s) </span><br><span class="line">== Test   usertests: copyin == </span><br><span class="line">  usertests: copyin: OK </span><br><span class="line">== Test   usertests: copyinstr1 == </span><br><span class="line">  usertests: copyinstr1: OK </span><br><span class="line">== Test   usertests: copyinstr2 == </span><br><span class="line">  usertests: copyinstr2: OK </span><br><span class="line">== Test   usertests: copyinstr3 == </span><br><span class="line">  usertests: copyinstr3: OK </span><br><span class="line">== Test   usertests: sbrkmuch == </span><br><span class="line">  usertests: sbrkmuch: OK </span><br><span class="line">== Test   usertests: all tests == </span><br><span class="line">  usertests: all tests: FAIL </span><br><span class="line">    ...</span><br><span class="line">         <span class="built_in">test</span> bigfile: OK</span><br><span class="line">         <span class="built_in">test</span> dirfile: OK</span><br><span class="line">         <span class="built_in">test</span> iref: OK</span><br><span class="line">         <span class="built_in">test</span> forktest: OK</span><br><span class="line">         <span class="built_in">test</span> bigdir: qemu-system-riscv64: terminating on signal 15 from pid 17227 (make)</span><br><span class="line">    MISSING <span class="string">&#x27;^ALL TESTS PASSED$&#x27;</span></span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 41/66</span><br></pre></td></tr></table></figure><br>就去修改grade-lab-pgtbl，把timeout往大改，毕竟在虚拟机运行会比较慢<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@test(<span class="params"><span class="number">0</span>, <span class="string">&quot;usertests&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_usertests</span>():</span><br><span class="line">    r.run_qemu(shell_script([</span><br><span class="line">        <span class="string">&#x27;usertests&#x27;</span></span><br><span class="line">    ]), timeout=<span class="number">600</span>) <span class="comment"># 把时间改长，300s-&gt;600s</span></span><br></pre></td></tr></table></figure></p><h2 id="实验评分"><a href="#实验评分" class="headerlink" title="实验评分"></a>实验评分</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (pgtbl)&gt; python3 grade-lab-pgtbl</span><br><span class="line"></span><br><span class="line">== Test pte printout == pte printout: OK (4.1s) </span><br><span class="line">== Test answers-pgtbl.txt == answers-pgtbl.txt: FAIL </span><br><span class="line">    answers-pgtbl.txt does not seem to contain enough text</span><br><span class="line">== Test count copyin == count copyin: OK (2.4s) </span><br><span class="line">== Test usertests == (284.1s) </span><br><span class="line">== Test   usertests: copyin == </span><br><span class="line">  usertests: copyin: OK </span><br><span class="line">== Test   usertests: copyinstr1 == </span><br><span class="line">  usertests: copyinstr1: OK </span><br><span class="line">== Test   usertests: copyinstr2 == </span><br><span class="line">  usertests: copyinstr2: OK </span><br><span class="line">== Test   usertests: copyinstr3 == </span><br><span class="line">  usertests: copyinstr3: OK </span><br><span class="line">== Test   usertests: sbrkmuch == </span><br><span class="line">  usertests: sbrkmuch: OK </span><br><span class="line">== Test   usertests: all tests == </span><br><span class="line">  usertests: all tests: OK </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 61/66</span><br></pre></td></tr></table></figure><h2 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (pgtbl)&gt; git diff origin/pgtbl pgtbl --<span class="built_in">stat</span></span><br><span class="line"> answers-pgtbl.txt |   0</span><br><span class="line"> grade-lab-pgtbl   |   2 +-</span><br><span class="line"> kernel/defs.h     |  13 ++++++++++++</span><br><span class="line"> kernel/exec.c     |  14 ++++++++++++-</span><br><span class="line"> kernel/proc.c     |  86 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----</span><br><span class="line"> kernel/proc.h     |   1 +</span><br><span class="line"> kernel/vm.c       | 122 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-</span><br><span class="line"> time.txt          |   1 +</span><br><span class="line"> 8 files changed, 232 insertions(+), 7 deletions(-)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/answers-pgtbl.txt b/answers-pgtbl.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br><span class="line">diff --git a/grade-lab-pgtbl b/grade-lab-pgtbl</span><br><span class="line">index 2b0b49d..bf5a47e 100755</span><br><span class="line">--- a/grade-lab-pgtbl</span><br><span class="line">+++ b/grade-lab-pgtbl</span><br><span class="line">@@ -62,7 +62,7 @@ def test_count():</span><br><span class="line"> def test_usertests():</span><br><span class="line">     r.run_qemu(shell_script([</span><br><span class="line">         &#x27;usertests&#x27;</span><br><span class="line">-    ]), timeout=300)</span><br><span class="line">+    ]), timeout=600) # 把时间改长，300s-&gt;600s</span><br><span class="line"> </span><br><span class="line"> def usertest_check(testcase, nextcase, output):</span><br><span class="line">     if not re.search(r&#x27;\ntest &#123;&#125;: [\s\S]*OK\ntest &#123;&#125;&#x27;.format(testcase, nextcase), output):</span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index a73b4f7..4996b44 100644</span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ -108,6 +108,7 @@ void            yield(void);</span><br><span class="line"> int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);</span><br><span class="line"> int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);</span><br><span class="line"> void            procdump(void);</span><br><span class="line">+void            proc_freekernelpagetable(pagetable_t);</span><br><span class="line"> </span><br><span class="line"> // swtch.S</span><br><span class="line"> void            swtch(struct context*, struct context*);</span><br><span class="line">@@ -167,17 +168,25 @@ pagetable_t     uvmcreate(void);</span><br><span class="line"> void            uvminit(pagetable_t, uchar *, uint);</span><br><span class="line"> uint64          uvmalloc(pagetable_t, uint64, uint64);</span><br><span class="line"> uint64          uvmdealloc(pagetable_t, uint64, uint64);</span><br><span class="line">+</span><br><span class="line"> #ifdef SOL_COW</span><br><span class="line"> #else</span><br><span class="line"> int             uvmcopy(pagetable_t, pagetable_t, uint64);</span><br><span class="line"> #endif</span><br><span class="line">+</span><br><span class="line"> void            uvmfree(pagetable_t, uint64);</span><br><span class="line"> void            uvmunmap(pagetable_t, uint64, uint64, int);</span><br><span class="line"> void            uvmclear(pagetable_t, uint64);</span><br><span class="line">+pte_t*          walk(pagetable_t, uint64, int);</span><br><span class="line"> uint64          walkaddr(pagetable_t, uint64);</span><br><span class="line"> int             copyout(pagetable_t, uint64, char *, uint64);</span><br><span class="line"> int             copyin(pagetable_t, char *, uint64, uint64);</span><br><span class="line"> int             copyinstr(pagetable_t, char *, uint64, uint64);</span><br><span class="line">+void            vmprint(pagetable_t);</span><br><span class="line">+void            ukvmmap(pagetable_t, uint64, uint64, uint64, int);</span><br><span class="line">+pagetable_t     proc_kvminit(void);</span><br><span class="line">+int             kvmcopy(pagetable_t, pagetable_t, uint64, uint64);</span><br><span class="line">+uint64          kvmdealloc(pagetable_t, uint64, uint64);</span><br><span class="line"> </span><br><span class="line"> // plic.c</span><br><span class="line"> void            plicinit(void);</span><br><span class="line">@@ -202,6 +211,10 @@ void            statsinc(void);</span><br><span class="line"> // sprintf.c</span><br><span class="line"> int             snprintf(char*, int, char*, ...);</span><br><span class="line"> </span><br><span class="line">+// vmcopyin.c</span><br><span class="line">+int             copyin_new(pagetable_t, char*, uint64, uint64);</span><br><span class="line">+int             copyinstr_new(pagetable_t, char*, uint64, uint64);</span><br><span class="line">+</span><br><span class="line"> #ifdef LAB_NET</span><br><span class="line"> // pci.c</span><br><span class="line"> void            pci_init();</span><br><span class="line">diff --git a/kernel/exec.c b/kernel/exec.c</span><br><span class="line">index 0e8762f..7577797 100644</span><br><span class="line">--- a/kernel/exec.c</span><br><span class="line">+++ b/kernel/exec.c</span><br><span class="line">@@ -51,6 +51,11 @@ exec(char *path, char **argv)</span><br><span class="line">     uint64 sz1;</span><br><span class="line">     if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0)</span><br><span class="line">       goto bad;</span><br><span class="line">+    // 添加检测，防止程序大小超过 PLIC</span><br><span class="line">+    if(sz1 &gt;= PLIC) &#123;</span><br><span class="line">+      goto bad;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">     sz = sz1;</span><br><span class="line">     if(ph.vaddr % PGSIZE != 0)</span><br><span class="line">       goto bad;</span><br><span class="line">@@ -107,7 +112,11 @@ exec(char *path, char **argv)</span><br><span class="line">     if(*s == &#x27;/&#x27;)</span><br><span class="line">       last = s+1;</span><br><span class="line">   safestrcpy(p-&gt;name, last, sizeof(p-&gt;name));</span><br><span class="line">-    </span><br><span class="line">+</span><br><span class="line">+  // 清除内核页表中对程序内存的旧映射，然后重新建立映射。</span><br><span class="line">+  uvmunmap(p-&gt;kernel_pagetable, 0, PGROUNDUP(oldsz)/PGSIZE, 0);</span><br><span class="line">+  kvmcopy(pagetable, p-&gt;kernel_pagetable, 0, sz);</span><br><span class="line">+</span><br><span class="line">   // Commit to the user image.</span><br><span class="line">   oldpagetable = p-&gt;pagetable;</span><br><span class="line">   p-&gt;pagetable = pagetable;</span><br><span class="line">@@ -116,6 +125,9 @@ exec(char *path, char **argv)</span><br><span class="line">   p-&gt;trapframe-&gt;sp = sp; // initial stack pointer</span><br><span class="line">   proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"> </span><br><span class="line">+  // print a page table</span><br><span class="line">+  if(p-&gt;pid == 1) vmprint(p-&gt;pagetable);</span><br><span class="line">+</span><br><span class="line">   return argc; // this ends up in a0, the first argument to main(argc, argv)</span><br><span class="line"> </span><br><span class="line">  bad:</span><br><span class="line">diff --git a/kernel/proc.c b/kernel/proc.c</span><br><span class="line">index dab1e1d..d8c0333 100644</span><br><span class="line">--- a/kernel/proc.c</span><br><span class="line">+++ b/kernel/proc.c</span><br><span class="line">@@ -30,7 +30,7 @@ procinit(void)</span><br><span class="line">   initlock(&amp;pid_lock, &quot;nextpid&quot;);</span><br><span class="line">   for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">       initlock(&amp;p-&gt;lock, &quot;proc&quot;);</span><br><span class="line">-</span><br><span class="line">+/*    // move to allocproc</span><br><span class="line">       // Allocate a page for the process&#x27;s kernel stack.</span><br><span class="line">       // Map it high in memory, followed by an invalid</span><br><span class="line">       // guard page.</span><br><span class="line">@@ -40,6 +40,7 @@ procinit(void)</span><br><span class="line">       uint64 va = KSTACK((int) (p - proc));</span><br><span class="line">       kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">       p-&gt;kstack = va;</span><br><span class="line">+*/</span><br><span class="line">   &#125;</span><br><span class="line">   kvminithart();</span><br><span class="line"> &#125;</span><br><span class="line">@@ -121,6 +122,25 @@ found:</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">+  // An empty user kernel page table</span><br><span class="line">+  p-&gt;kernel_pagetable = proc_kvminit();</span><br><span class="line">+  if (p-&gt;kernel_pagetable == 0) &#123;</span><br><span class="line">+    freeproc(p);</span><br><span class="line">+    release(&amp;p-&gt;lock);</span><br><span class="line">+    return 0;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  // Allocate a page for the process&#x27;s kernel stack.</span><br><span class="line">+  // Map it high in memory, followed by an invalid</span><br><span class="line">+  // guard page.</span><br><span class="line">+  char *pa = kalloc();</span><br><span class="line">+  if(pa == 0)</span><br><span class="line">+    panic(&quot;kalloc&quot;);</span><br><span class="line">+  uint64 va = KSTACK((int) (p - proc));</span><br><span class="line">+  // kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">+  ukvmmap(p-&gt;kernel_pagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">+  p-&gt;kstack = va;</span><br><span class="line">+</span><br><span class="line">   // Set up new context to start executing at forkret,</span><br><span class="line">   // which returns to user space.</span><br><span class="line">   memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));</span><br><span class="line">@@ -139,9 +159,27 @@ freeproc(struct proc *p)</span><br><span class="line">   if(p-&gt;trapframe)</span><br><span class="line">     kfree((void*)p-&gt;trapframe);</span><br><span class="line">   p-&gt;trapframe = 0;</span><br><span class="line">+</span><br><span class="line">+  // 删除内核栈</span><br><span class="line">+  if(p-&gt;kstack) &#123;</span><br><span class="line">+    // 通过页表地址， kstack虚拟地址 找到最后一级的页表项</span><br><span class="line">+    pte_t* pte = walk(p-&gt;kernel_pagetable, p-&gt;kstack, 0);</span><br><span class="line">+    if (pte == 0)</span><br><span class="line">+      panic(&quot;freeproc : kstack&quot;);</span><br><span class="line">+    // 删除页表项对应的物理地址</span><br><span class="line">+    kfree((void*)PTE2PA(*pte));</span><br><span class="line">+  &#125;</span><br><span class="line">+  p-&gt;kstack = 0;</span><br><span class="line">+</span><br><span class="line">   if(p-&gt;pagetable)</span><br><span class="line">     proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">   p-&gt;pagetable = 0;</span><br><span class="line">+</span><br><span class="line">+  // 删除kernel pagetable</span><br><span class="line">+  if(p-&gt;kernel_pagetable) </span><br><span class="line">+    proc_freekernelpagetable(p-&gt;kernel_pagetable);</span><br><span class="line">+  p-&gt;kernel_pagetable = 0;</span><br><span class="line">+</span><br><span class="line">   p-&gt;sz = 0;</span><br><span class="line">   p-&gt;pid = 0;</span><br><span class="line">   p-&gt;parent = 0;</span><br><span class="line">@@ -195,6 +233,23 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)</span><br><span class="line">   uvmfree(pagetable, sz);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">+// Free a process&#x27;s kernel page tabel</span><br><span class="line">+void </span><br><span class="line">+proc_freekernelpagetable(pagetable_t pagetable)</span><br><span class="line">+&#123;</span><br><span class="line">+  for(int i = 0; i &lt; 512; i++) &#123;</span><br><span class="line">+    pte_t pte = pagetable[i];</span><br><span class="line">+    if(pte &amp; PTE_V) &#123;</span><br><span class="line">+      pagetable[i] = 0;</span><br><span class="line">+      if((pte &amp; (PTE_R | PTE_W | PTE_X)) == 0) &#123;</span><br><span class="line">+        uint64 child = PTE2PA(pte);</span><br><span class="line">+        proc_freekernelpagetable((pagetable_t)child);</span><br><span class="line">+      &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+  kfree((void*)pagetable);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> // a user program that calls exec(&quot;/init&quot;)</span><br><span class="line"> // od -t xC initcode</span><br><span class="line"> uchar initcode[] = &#123;</span><br><span class="line">@@ -220,6 +275,8 @@ userinit(void)</span><br><span class="line">   // and data into it.</span><br><span class="line">   uvminit(p-&gt;pagetable, initcode, sizeof(initcode));</span><br><span class="line">   p-&gt;sz = PGSIZE;</span><br><span class="line">+  // 同步程序内存映射到进程内核页表中</span><br><span class="line">+  kvmcopy(p-&gt;pagetable, p-&gt;kernel_pagetable, 0, p-&gt;sz);</span><br><span class="line"> </span><br><span class="line">   // prepare for the very first &quot;return&quot; from kernel to user.</span><br><span class="line">   p-&gt;trapframe-&gt;epc = 0;      // user program counter</span><br><span class="line">@@ -242,12 +299,23 @@ growproc(int n)</span><br><span class="line">   struct proc *p = myproc();</span><br><span class="line"> </span><br><span class="line">   sz = p-&gt;sz;</span><br><span class="line">-  if(n &gt; 0)&#123;</span><br><span class="line">+  if(n &gt; 0) &#123;</span><br><span class="line">+    if(PGROUNDDOWN(sz + n) &gt;= PLIC)</span><br><span class="line">+      return -1;</span><br><span class="line">+</span><br><span class="line">     if((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == 0) &#123;</span><br><span class="line">       return -1;</span><br><span class="line">     &#125;</span><br><span class="line">-  &#125; else if(n &lt; 0)&#123;</span><br><span class="line">+</span><br><span class="line">+    // 内核页表中的映射同步扩大</span><br><span class="line">+    if(kvmcopy(p-&gt;pagetable, p-&gt;kernel_pagetable, p-&gt;sz, sz) == -1) &#123;</span><br><span class="line">+      return -1;</span><br><span class="line">+    &#125;</span><br><span class="line">+    </span><br><span class="line">+  &#125; else if(n &lt; 0) &#123;</span><br><span class="line">     sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">+    // 内核页表中的映射同步缩小</span><br><span class="line">+    kvmdealloc(p-&gt;kernel_pagetable, p-&gt;sz, p-&gt;sz + n);</span><br><span class="line">   &#125;</span><br><span class="line">   p-&gt;sz = sz;</span><br><span class="line">   return 0;</span><br><span class="line">@@ -268,7 +336,8 @@ fork(void)</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // Copy user memory from parent to child.</span><br><span class="line">-  if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0)&#123;</span><br><span class="line">+  if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0 ||</span><br><span class="line">+     kvmcopy(np-&gt;pagetable, np-&gt;kernel_pagetable, 0, p-&gt;sz) &lt; 0) &#123;</span><br><span class="line">     freeproc(np);</span><br><span class="line">     release(&amp;np-&gt;lock);</span><br><span class="line">     return -1;</span><br><span class="line">@@ -473,8 +542,17 @@ scheduler(void)</span><br><span class="line">         // before jumping back to us.</span><br><span class="line">         p-&gt;state = RUNNING;</span><br><span class="line">         c-&gt;proc = p;</span><br><span class="line">+</span><br><span class="line">+        // 在切换任务前，将用户内核页表替换到stap寄存器中</span><br><span class="line">+        w_satp(MAKE_SATP(p-&gt;kernel_pagetable));</span><br><span class="line">+        // 清除快表缓存</span><br><span class="line">+        sfence_vma();</span><br><span class="line">+</span><br><span class="line">         swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"> </span><br><span class="line">+        // 该进程执行结束后，将SATP寄存器的值设置为全局内核页表地址</span><br><span class="line">+        kvminithart();</span><br><span class="line">+</span><br><span class="line">         // Process is done running for now.</span><br><span class="line">         // It should have changed its p-&gt;state before coming back.</span><br><span class="line">         c-&gt;proc = 0;</span><br><span class="line">diff --git a/kernel/proc.h b/kernel/proc.h</span><br><span class="line">index 9c16ea7..2cdd693 100644</span><br><span class="line">--- a/kernel/proc.h</span><br><span class="line">+++ b/kernel/proc.h</span><br><span class="line">@@ -98,6 +98,7 @@ struct proc &#123;</span><br><span class="line">   uint64 kstack;               // Virtual address of kernel stack</span><br><span class="line">   uint64 sz;                   // Size of process memory (bytes)</span><br><span class="line">   pagetable_t pagetable;       // User page table</span><br><span class="line">+  pagetable_t kernel_pagetable;// kernel page tabel of each process</span><br><span class="line">   struct trapframe *trapframe; // data page for trampoline.S</span><br><span class="line">   struct context context;      // swtch() here to run process</span><br><span class="line">   struct file *ofile[NOFILE];  // Open files</span><br><span class="line">diff --git a/kernel/vm.c b/kernel/vm.c</span><br><span class="line">index bccb405..3e95042 100644</span><br><span class="line">--- a/kernel/vm.c</span><br><span class="line">+++ b/kernel/vm.c</span><br><span class="line">@@ -5,6 +5,8 @@</span><br><span class="line"> #include &quot;riscv.h&quot;</span><br><span class="line"> #include &quot;defs.h&quot;</span><br><span class="line"> #include &quot;fs.h&quot;</span><br><span class="line">+#include &quot;spinlock.h&quot;</span><br><span class="line">+#include &quot;proc.h&quot;</span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line">  * the kernel&#x27;s page table.</span><br><span class="line">@@ -132,7 +134,10 @@ kvmpa(uint64 va)</span><br><span class="line">   pte_t *pte;</span><br><span class="line">   uint64 pa;</span><br><span class="line">   </span><br><span class="line">-  pte = walk(kernel_pagetable, va, 0);</span><br><span class="line">+  // pte = walk(kernel_pagetable, va, 0);</span><br><span class="line">+  // 使用用户进程自己的内核页表地址来翻译虚拟地址</span><br><span class="line">+  pte = walk(myproc()-&gt;kernel_pagetable, va, 0);</span><br><span class="line">+</span><br><span class="line">   if(pte == 0)</span><br><span class="line">     panic(&quot;kvmpa&quot;);</span><br><span class="line">   if((*pte &amp; PTE_V) == 0)</span><br><span class="line">@@ -379,6 +384,7 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</span><br><span class="line"> int</span><br><span class="line"> copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)</span><br><span class="line"> &#123;</span><br><span class="line">+/*</span><br><span class="line">   uint64 n, va0, pa0;</span><br><span class="line"> </span><br><span class="line">   while(len &gt; 0)&#123;</span><br><span class="line">@@ -396,6 +402,8 @@ copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)</span><br><span class="line">     srcva = va0 + PGSIZE;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">+*/</span><br><span class="line">+  return copyin_new(pagetable, dst, srcva, len);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // Copy a null-terminated string from user to kernel.</span><br><span class="line">@@ -405,6 +413,7 @@ copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)</span><br><span class="line"> int</span><br><span class="line"> copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)</span><br><span class="line"> &#123;</span><br><span class="line">+/*</span><br><span class="line">   uint64 n, va0, pa0;</span><br><span class="line">   int got_null = 0;</span><br><span class="line"> </span><br><span class="line">@@ -439,4 +448,115 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return -1;</span><br><span class="line">   &#125;</span><br><span class="line">+*/</span><br><span class="line">+  return copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+// vmprint辅助函数</span><br><span class="line">+static void</span><br><span class="line">+_vmprint(pagetable_t pagetable, int level)</span><br><span class="line">+&#123;</span><br><span class="line">+  for (int i = 0; i &lt; 512; ++i) &#123;</span><br><span class="line">+    pte_t pte = pagetable[i];</span><br><span class="line">+</span><br><span class="line">+    if ((pte &amp; PTE_V)) &#123;</span><br><span class="line">+      for (int j = 0; j &lt; level; ++j) &#123;</span><br><span class="line">+        if (j == 0) printf(&quot;..&quot;);</span><br><span class="line">+        else printf(&quot; ..&quot;);</span><br><span class="line">+      &#125;</span><br><span class="line">+</span><br><span class="line">+      uint64 child = PTE2PA(pte); // 通过pte映射下一级页表的物理地址</span><br><span class="line">+      printf(&quot;%d: pte %p pa %p\n&quot;, i, pte, child);</span><br><span class="line">+      // 查看flag是否被设置，若被设置，则为最低一层</span><br><span class="line">+      // 只有在页表的最后一级，才可进行读、写、执行</span><br><span class="line">+      if ((pte &amp; (PTE_R | PTE_W | PTE_X)) == 0)</span><br><span class="line">+        _vmprint((pagetable_t)child, level + 1);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+// Print a page table</span><br><span class="line">+void</span><br><span class="line">+vmprint(pagetable_t pagetable)</span><br><span class="line">+&#123;</span><br><span class="line">+  printf(&quot;page table %p\n&quot;, pagetable);</span><br><span class="line">+  _vmprint(pagetable, 1);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+// map to the process&#x27;s kernel page table</span><br><span class="line">+void</span><br><span class="line">+ukvmmap(pagetable_t pagetable, uint64 va, uint64 pa, uint64 sz, int perm)</span><br><span class="line">+&#123;</span><br><span class="line">+  if(mappages(pagetable, va, sz, pa, perm) != 0)</span><br><span class="line">+    panic(&quot;ukvmmap&quot;);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+// init the kernel page tabel of user process</span><br><span class="line">+pagetable_t</span><br><span class="line">+proc_kvminit()</span><br><span class="line">+&#123;</span><br><span class="line">+  // 申请一个页表空间</span><br><span class="line">+  pagetable_t proc_kernel_pagetable = (pagetable_t) kalloc();</span><br><span class="line">+  if (proc_kernel_pagetable == 0)</span><br><span class="line">+    return 0;</span><br><span class="line">+  memset(proc_kernel_pagetable, 0, PGSIZE);</span><br><span class="line">+  // 与vminint内容上保持一致</span><br><span class="line">+  ukvmmap(proc_kernel_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">+  ukvmmap(proc_kernel_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">+  // 用户进程内核页表无需在映射CLINT，将空间留出映射用户页表</span><br><span class="line">+  // ukvmmap(proc_kernel_pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);</span><br><span class="line">+  ukvmmap(proc_kernel_pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W);</span><br><span class="line">+  ukvmmap(proc_kernel_pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">+  ukvmmap(proc_kernel_pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">+  ukvmmap(proc_kernel_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">+  return proc_kernel_pagetable;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+// 将 src 页表的一部分页映射关系拷贝到 dst 页表中。</span><br><span class="line">+// 只拷贝页表项，不拷贝实际的物理页内存。</span><br><span class="line">+// 成功返回0，失败返回 -1</span><br><span class="line">+int</span><br><span class="line">+kvmcopy(pagetable_t src, pagetable_t dst, uint64 start, uint64 end)</span><br><span class="line">+&#123;</span><br><span class="line">+  pte_t *pte;</span><br><span class="line">+</span><br><span class="line">+  // PGROUNDUP: 对齐页边界，防止 remap</span><br><span class="line">+  for(uint64 i = PGROUNDUP(start); i &lt; end; i += PGSIZE) &#123;</span><br><span class="line">+    if((pte = walk(src, i, 0)) == 0) // 找到虚拟地址的最后一级页表项</span><br><span class="line">+      panic(&quot;kvmcopy: pte should exist&quot;);</span><br><span class="line">+    if((*pte &amp; PTE_V) == 0)      // 判断页表项是否有效</span><br><span class="line">+      panic(&quot;kvmcopy: page not present&quot;);</span><br><span class="line">+</span><br><span class="line">+    // 将页表项转换为物理地址页起始位置</span><br><span class="line">+    uint64 pa = PTE2PA(*pte);</span><br><span class="line">+    // `&amp; ~PTE_U` 表示将该页的权限设置为非用户页</span><br><span class="line">+    // 必须设置该权限，RISC-V 中内核是无法直接访问用户页的。</span><br><span class="line">+    uint flags = PTE_FLAGS(*pte) &amp; ~PTE_U;</span><br><span class="line">+    // 将pa这一页的PTEs映射到dst上同样的虚拟地址</span><br><span class="line">+    if(mappages(dst, i, PGSIZE, pa, flags) != 0) &#123;</span><br><span class="line">+      // 清除已经映射的部分，但不释放内存</span><br><span class="line">+      uvmunmap(dst, 0, i / PGSIZE, 0);</span><br><span class="line">+      return -1;</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+  return 0;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+// 与 uvmdealloc 功能类似，将程序内存从 oldsz 缩减到 newsz。但区别在于不释放实际内存</span><br><span class="line">+// 用于内核页表内程序内存映射与用户页表程序内存映射之间的同步</span><br><span class="line">+uint64</span><br><span class="line">+kvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)</span><br><span class="line">+&#123;</span><br><span class="line">+  if(newsz &gt;= oldsz)</span><br><span class="line">+    return oldsz;</span><br><span class="line">+</span><br><span class="line">+  if(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">+    // 如果存在多余的页需要释放</span><br><span class="line">+    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">+    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 0);</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  return newsz;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">diff --git a/time.txt b/time.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..a45fd52</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/time.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+24</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验2 system calls</title>
      <link href="/2022/09/02/xv6-lab2/"/>
      <url>/2022/09/02/xv6-lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-syscall-System-calls"><a href="#Lab-syscall-System-calls" class="headerlink" title="Lab syscall: System calls"></a>Lab syscall: System calls</h1><ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html">https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html</a></li></ul><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>在上一个实验，我们学习了怎么使用系统调用来写用户程序，这次实验，我们来实现如何写一个系统调用。</p><p>中文版实验手册</p><ul><li><a href="http://hitsz-cslab.gitee.io/os-labs/lab2/part1/">操作系统（2022秋季） | 哈工大（深圳）</a></li><li><a href="http://hitsz-cslab.gitee.io/os-labs/lab2/part5/">GDB调试系统调用</a></li></ul><blockquote><p>一个简单的从用户到内核空间的调试方法¶<br>有同学可能问，能不能跳过汇编代码，直接打打断点到C代码呢？答案是可以的。下面还是以ls中的fstat系统调用为例，介绍一个较为简单的调试步骤：<br>Step1： 先在终端输入“make qemu-gdb”。<br>接着，按下F5， 或者 点击左侧按钮运行与调试，并点击左上角绿色三角（Attach to gdb)。<br>再点击“运行”，让xv6正常运行，直到出现“$”，表示已经进入shell中。<br>Step2： 在调试控制台，输入“interrupt”。<br>Step3： 在kernel/trap.c:128处打断点，继续点击“运行”。<br>Step4： 在xv6的shell中输入ls，以启动ls程序；程序停留在kernel/trap.c:128处。<br>Step5： 接下来，我们需要在调试窗口左下角删除原有的内核态断点，并通过调试控制台，加载ls的调试符号。在其中输入file user/_ls。<br>Step6： 打开user/ls.c文件，找到main()函数，在第78行打上断点。点击“运行”。<br>Step7： 在ls.c第38行打上断点，点击“运行”，让程序停留在执行fstat系统调用的地方。<br>Step8： 在调试控制台，输入file kernel/kernel，加载kernel的调试符号。<br>Step9： 在syscall.c文件中第138行syscall();打上断点，点击“运行”，让程序停留在syscall()函数。<br>Step10： 接下来，你就可以根据需要来调试你想要分析的代码吧。</p></blockquote><p>小技巧：使用在指定文件命令查找给定的关键词</p><ul><li>fish终端<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (syscall)&gt; grep fork (find kernel/ -name &quot;*.h&quot;)</span><br><span class="line">kernel/defs.h:int             fork(void);</span><br><span class="line">kernel/syscall.h:#define SYS_fork    1</span><br></pre></td></tr></table></figure></li><li>bash终端<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (syscall)&gt; grep fork $(find kernel/ -name <span class="string">&quot;*.h&quot;</span>)</span><br><span class="line">kernel/defs.h:int             fork(void);</span><br><span class="line">kernel/syscall.h:<span class="comment">#define SYS_fork    1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><p>先来分析一下user/trace.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> *nargv[MAXARG]; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">3</span> || (argv[<span class="number">1</span>][<span class="number">0</span>] &lt; <span class="string">&#x27;0&#x27;</span> || argv[<span class="number">1</span>][<span class="number">0</span>] &gt; <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trace(atoi(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>) &#123;  <span class="comment">// 系统调用trace，设置mask值为argv[1]</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++) &#123; <span class="comment">// 提取command</span></span><br><span class="line">    nargv[i<span class="number">-2</span>] = argv[i];</span><br><span class="line">  &#125;</span><br><span class="line">  exec(nargv[<span class="number">0</span>], nargv); <span class="comment">// exec command</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果执行<code>trace 32 grep hello README</code>，那么trace.c先执行系统调用<code>trace(32)</code>来设置当前程序的mask为32，再通过系统调用exec执行<code>grep hello README</code></p><h3 id="为了让gcc编译trace-c"><a href="#为了让gcc编译trace-c" class="headerlink" title="为了让gcc编译trace.c"></a>为了让gcc编译trace.c</h3><p>在Makefile 的UPROGS的最后添加$U/_trace\<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">    ......</span><br><span class="line">    $U/_trace\</span><br></pre></td></tr></table></figure></p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>我们发现在user/user.h中有系统调用的函数声明，所以我们也添加一个系统调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>**)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">char</span>*, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;  <span class="comment">// add a new system call trace</span></span><br></pre></td></tr></table></figure></p><h3 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h3><p>user/usys.pl是用来生成系统调用的汇编代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print &quot;.global $name\n&quot;;</span><br><span class="line">    print &quot;$&#123;name&#125;:\n&quot;;</span><br><span class="line">    print &quot; li a7, SYS_$&#123;name&#125;\n&quot;;   // 将系统调用号放入a7寄存器</span><br><span class="line">    print &quot; ecall\n&quot;;                         // 调用ecall，触发软中断，进入内核</span><br><span class="line">    print &quot; ret\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这里perl语言自动生成汇编语言usys.S，是用户态系统调用接口，可以看到首先把系统调用号压入a7寄存器，然后就直接ecall进入系统内核。<br>而我们刚才syscall那个函数就把a7寄存器的数字读出来调用对应的函数，所以这里就是系统调用用户态和内核态的切换接口。</p></blockquote><p><code>添加entry(&quot;trace&quot;);</code>以系统调用函数trace为例，事实上是要调用时把SYS_trace（trace的系统调用编号）压入到寄存器a7当中，然后调用ecall进入kernel。</p><p>生成的usys.S如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"># generated by usys.pl - do not edit</span><br><span class="line">#include &quot;kernel/syscall.h&quot;</span><br><span class="line">.global fork</span><br><span class="line">fork:</span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global exit</span><br><span class="line">exit:</span><br><span class="line"> li a7, SYS_exit</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global wait</span><br><span class="line">wait:</span><br><span class="line"> li a7, SYS_wait</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global pipe</span><br><span class="line">pipe:</span><br><span class="line"> li a7, SYS_pipe</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global read</span><br><span class="line">read:</span><br><span class="line"> li a7, SYS_read</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global close</span><br><span class="line">close:</span><br><span class="line"> li a7, SYS_close</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global kill</span><br><span class="line">kill:</span><br><span class="line"> li a7, SYS_kill</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global exec</span><br><span class="line">exec:</span><br><span class="line"> li a7, SYS_exec</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global open</span><br><span class="line">open:</span><br><span class="line"> li a7, SYS_open</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global mknod</span><br><span class="line">mknod:</span><br><span class="line"> li a7, SYS_mknod</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global unlink</span><br><span class="line">unlink:</span><br><span class="line"> li a7, SYS_unlink</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global fstat</span><br><span class="line">fstat:</span><br><span class="line"> li a7, SYS_fstat</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global link</span><br><span class="line">link:</span><br><span class="line"> li a7, SYS_link</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global mkdir</span><br><span class="line">mkdir:</span><br><span class="line"> li a7, SYS_mkdir</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global chdir</span><br><span class="line">chdir:</span><br><span class="line"> li a7, SYS_chdir</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global dup</span><br><span class="line">dup:</span><br><span class="line"> li a7, SYS_dup</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global getpid</span><br><span class="line">getpid:</span><br><span class="line"> li a7, SYS_getpid</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sbrk</span><br><span class="line">sbrk:</span><br><span class="line"> li a7, SYS_sbrk</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sleep</span><br><span class="line">sleep:</span><br><span class="line"> li a7, SYS_sleep</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global uptime</span><br><span class="line">uptime:</span><br><span class="line"> li a7, SYS_uptime</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global trace</span><br><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure></p><h3 id="添加系统调用号"><a href="#添加系统调用号" class="headerlink" title="添加系统调用号"></a>添加系统调用号</h3><p>kernel/syscall.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure></p><h3 id="实现系统调用"><a href="#实现系统调用" class="headerlink" title="实现系统调用"></a>实现系统调用</h3><p>添加<code>系统调用编号对应的系统调用函数名</code>到<code>函数指针数组</code>，添加<code>内核态的系统函数调用声明</code>，实现<code>内核态系统调用</code>。</p><p>1.kernel/syscall.c，函数指针数组<code>static uint64 (*syscalls[])(void)</code>加上：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">...</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">[SYS_sysinfo] sys_sysinfo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>该表的功能是：<code>根据系统调用编号，找到并调用对应的函数</code></p><hr><p>2.kernel/syscall.c，给内核态的系统调用sys_trace加上声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p><hr><p>3.实现sys_trace</p><p>kernel/proc.h的struct proc中添加成员变量mask表示trace掩码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="type">int</span> mask;  <span class="comment">// using in trace</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>kernel/sysproc.c中，定义sys_trace内核函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)   <span class="comment">// int trace(int)的形参保存在寄存器a0中，mask = a0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    myproc()-&gt;mask = mask;  <span class="comment">// 设置当前进程的mask</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>argint这个函数调用了argraw函数，这个函数会去读寄存器a0到a5<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kernel/proc.c中，修改fork函数，使得在子进程继承父进程的mask<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line">  np-&gt;mask=p-&gt;mask; <span class="comment">// 子进程继承父进程的mask</span></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kernel/syscall.c中，修改syscall函数，在系统调用返回后判断trace掩码并输出信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> syscallsname[] =  <span class="comment">// 系统调用号对应的系统名称</span></span><br><span class="line">&#123;</span><br><span class="line">     [SYS_fork]   <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">     [SYS_exit]   <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">     [SYS_wait]   <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">     [SYS_pipe]   <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">     [SYS_read]   <span class="string">&quot;read&quot;</span>,</span><br><span class="line">     [SYS_kill]   <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">     [SYS_exec]   <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">     [SYS_fstat]  <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">     [SYS_chdir]  <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">     [SYS_dup]    <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">     [SYS_getpid] <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">     [SYS_sbrk]   <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">     [SYS_sleep]  <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">     [SYS_uptime] <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">     [SYS_open]   <span class="string">&quot;open&quot;</span>,</span><br><span class="line">     [SYS_write]  <span class="string">&quot;write&quot;</span>,</span><br><span class="line">     [SYS_mknod]  <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">     [SYS_unlink] <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">     [SYS_link]   <span class="string">&quot;link&quot;</span>,</span><br><span class="line">     [SYS_mkdir]  <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">     [SYS_close]  <span class="string">&quot;close&quot;</span>,</span><br><span class="line">     [SYS_trace]  <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">     [SYS_sysinfo] <span class="string">&quot;sysinfo&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mask&gt;&gt;num &amp; <span class="number">1</span>) &#123;  <span class="comment">//  如果当前的系统调用是trace掩码对应的系统调用，输出信息。</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscallsname[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (syscall)&gt; grep sysinfo (find kernel/ -name &quot;*.h&quot;)</span><br><span class="line">kernel/sysinfo.h:struct sysinfo &#123;</span><br><span class="line">grand@Lubuntu ~/xv6-labs-2020 (syscall)&gt; cat kernel/sysinfo.h </span><br><span class="line">struct sysinfo &#123;</span><br><span class="line">  uint64 freemem;   // amount of free memory (bytes)</span><br><span class="line">  uint64 nproc;     // number of process</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这里，我们可以知道struct sysinfo用来记录系统信息，即空闲内存和进程数）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br></pre></td></tr></table></figure><br>这个数组就保存着所有的进程，所以只要遍历这个数组判断状态就好了，<br>判断状态就是在proc结构体中的enum procstate state;</p><p>查看sysinfotest.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/sysinfo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *info)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (sysinfo(info) &lt; <span class="number">0</span>) &#123;  <span class="comment">// call the syscall &quot;sysinfo&quot;, get the system infomation</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: sysinfo failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// use sbrk() to count how many free physical memory pages there are.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">countfree</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sz0 = (uint64)sbrk(<span class="number">0</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((uint64)sbrk(PGSIZE) == <span class="number">0xffffffffffffffff</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">  <span class="keyword">if</span> (info.freemem != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: there is no free mem, but sysinfo.freemem=%d\n&quot;</span>,</span><br><span class="line">      info.freemem);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sbrk(-((uint64)sbrk(<span class="number">0</span>) - sz0));</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">testmem</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 n = countfree();</span><br><span class="line">  </span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (info.freemem!= n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: free mem %d (bytes) instead of %d\n&quot;</span>, info.freemem, n);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((uint64)sbrk(PGSIZE) == <span class="number">0xffffffffffffffff</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sbrk failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (info.freemem != n-PGSIZE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: free mem %d (bytes) instead of %d\n&quot;</span>, n-PGSIZE, info.freemem);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((uint64)sbrk(-PGSIZE) == <span class="number">0xffffffffffffffff</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sbrk failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (info.freemem != n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: free mem %d (bytes) instead of %d\n&quot;</span>, n, info.freemem);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">testcall</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (sysinfo(&amp;info) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: sysinfo failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sysinfo((<span class="keyword">struct</span> sysinfo *) <span class="number">0xeaeb0b5b00002f5e</span>) !=  <span class="number">0xffffffffffffffff</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FAIL: sysinfo succeeded with bad argument\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testproc</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 nproc;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  </span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">  nproc = info.nproc;</span><br><span class="line"></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: fork failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    sinfo(&amp;info);</span><br><span class="line">    <span class="keyword">if</span>(info.nproc != nproc+<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: FAIL nproc is %d instead of %d\n&quot;</span>, info.nproc, nproc+<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wait(&amp;status);</span><br><span class="line">  sinfo(&amp;info);</span><br><span class="line">  <span class="keyword">if</span>(info.nproc != nproc) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: FAIL nproc is %d instead of %d\n&quot;</span>, info.nproc, nproc);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: start\n&quot;</span>);</span><br><span class="line">  testcall();</span><br><span class="line">  testmem();</span><br><span class="line">  testproc();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sysinfotest: OK\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="添加声明"><a href="#添加声明" class="headerlink" title="添加声明"></a>添加声明</h3><ul><li>在<code>Makefile</code>的<code>UPROGS</code>的最后添加<code>$U/_sysinfo\</code></li><li><code>user/user.h</code>中的系统调用函数声明<code>int sysinfo(struct sysinfo*);</code>和结构体声明<code>struct sysinfo</code></li><li><code>user/usys.pl</code>中添加<code>entry(&quot;sysinfo&quot;);</code></li><li><code>kernel/syscall.h</code>添加系统函数编号<code>#define SYS_sysinfo 23</code></li><li><code>kernel/syscall.c</code>添加内核态函数声明，如下所示<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">...</span><br><span class="line">[SYS_sysinfo] sys_sysinfo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> syscallsname[] =</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">[SYS_sysinfo] <span class="string">&quot;sysinfo&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现内核函数"><a href="#实现内核函数" class="headerlink" title="实现内核函数"></a>实现内核函数</h3><p>kernel/kalloc.c添加get_freemem函数的定义，获取当前空闲内存字节数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">get_freemem</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    uint64 cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> cnt * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kernel/proc.c中添加函数get_nproc的定义，获取当前空闲进程数量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">get_nproc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    uint64 cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kernel/defs.h添加函数get_freemem与get_nproc声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line">uint64      <span class="title function_">get_freemem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// proc.c</span></span><br><span class="line">uint64      <span class="title function_">get_nproc</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></p><p>kernel/sysproc.c添加sys_sysinfo内核函数定义，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line">uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>=</span>myproc();</span><br><span class="line">    info.freemem=get_freemem();</span><br><span class="line">    info.nproc=get_nproc();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span>*)&amp;info, <span class="keyword">sizeof</span>(info))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考 kernel/sysfile.c/sys_fstat 和 kernel/file.c/filestat 使用 copyput() 将内核数据传输到用户态。<br><code>copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</code><br>把在内核地址src开始的len大小的数据拷贝到用户进程pagetable的虚地址dstva处，<br>所以sysinfo实现里先用argaddr读进来我们要保存的在用户态的数据sysinfo的指针地址，<br>然后再把从内核里得到的sysinfo开始的内容以sizeof(sysinfo)大小的的数据复制到这个指针上，<br>其实就是同一个数据结构，所以这样直接复制过去就可以了。</p><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (syscall) [1]&gt; python3 ./grade-lab-syscall</span><br><span class="line">make: &#x27;kernel/kernel&#x27; is up to date.</span><br><span class="line">== Test trace 32 grep == trace 32 grep: OK (2.7s) </span><br><span class="line">== Test trace all grep == trace all grep: OK (1.9s) </span><br><span class="line">== Test trace nothing == trace nothing: OK (2.0s) </span><br><span class="line">== Test trace children == trace children: OK (18.5s) </span><br><span class="line">== Test sysinfotest == sysinfotest: OK (5.3s) </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 35/35</span><br></pre></td></tr></table></figure><h2 id="对比git修改内容"><a href="#对比git修改内容" class="headerlink" title="对比git修改内容"></a>对比git修改内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (syscall)&gt; git diff origin/syscall syscall --stat</span><br><span class="line"> Makefile         |  2 ++</span><br><span class="line"> kernel/defs.h    |  2 ++</span><br><span class="line"> kernel/kalloc.c  | 16 ++++++++++++++++</span><br><span class="line"> kernel/proc.c    | 14 ++++++++++++++</span><br><span class="line"> kernel/proc.h    |  1 +</span><br><span class="line"> kernel/syscall.c | 35 +++++++++++++++++++++++++++++++++++</span><br><span class="line"> kernel/syscall.h |  2 ++</span><br><span class="line"> kernel/sysproc.c | 33 +++++++++++++++++++++++++++++++++</span><br><span class="line"> time.txt         |  1 +</span><br><span class="line"> user/trace.c     |  8 ++++----</span><br><span class="line"> user/user.h      |  3 +++</span><br><span class="line"> user/usys.pl     |  2 ++</span><br><span class="line"> 12 files changed, 115 insertions(+), 4 deletions(-)</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index f0beb51..15ab2e8 100644</span><br><span class="line">--- a/Makefile</span><br><span class="line">+++ b/Makefile</span><br><span class="line">@@ -149,6 +149,8 @@ UPROGS=\</span><br><span class="line"> $U/_grind\</span><br><span class="line"> $U/_wc\</span><br><span class="line"> $U/_zombie\</span><br><span class="line">+$U/_trace\</span><br><span class="line">+$U/_sysinfotest\</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index 4b9bbc0..8c6e633 100644</span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);</span><br><span class="line"> void*           kalloc(void);</span><br><span class="line"> void            kfree(void *);</span><br><span class="line"> void            kinit(void);</span><br><span class="line">+uint64          get_freemem(void);</span><br><span class="line"> </span><br><span class="line"> // log.c</span><br><span class="line"> void            initlog(int, struct superblock*);</span><br><span class="line">@@ -104,6 +105,7 @@ void            yield(void);</span><br><span class="line"> int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);</span><br><span class="line"> int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);</span><br><span class="line"> void            procdump(void);</span><br><span class="line">+uint64          get_nproc(void);</span><br><span class="line"> </span><br><span class="line"> // swtch.S</span><br><span class="line"> void            swtch(struct context*, struct context*);</span><br><span class="line">diff --git a/kernel/kalloc.c b/kernel/kalloc.c</span><br><span class="line">index fa6a0ac..079331c 100644</span><br><span class="line">--- a/kernel/kalloc.c</span><br><span class="line">+++ b/kernel/kalloc.c</span><br><span class="line">@@ -80,3 +80,19 @@ kalloc(void)</span><br><span class="line">     memset((char*)r, 5, PGSIZE); // fill with junk</span><br><span class="line">   return (void*)r;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+// return the size of free memory</span><br><span class="line">+uint64</span><br><span class="line">+get_freemem(void)</span><br><span class="line">+&#123;</span><br><span class="line">+  acquire(&amp;kmem.lock);</span><br><span class="line">+  struct run *r = kmem.freelist;</span><br><span class="line">+  uint64 cnt = 0;</span><br><span class="line">+  while(r)</span><br><span class="line">+  &#123;</span><br><span class="line">+    cnt++;</span><br><span class="line">+    r = r-&gt;next;</span><br><span class="line">+  &#125;</span><br><span class="line">+  release(&amp;kmem.lock);</span><br><span class="line">+  return cnt * PGSIZE;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/proc.c b/kernel/proc.c</span><br><span class="line">index 6afafa1..8377978 100644</span><br><span class="line">--- a/kernel/proc.c</span><br><span class="line">+++ b/kernel/proc.c</span><br><span class="line">@@ -294,6 +294,9 @@ fork(void)</span><br><span class="line">   pid = np-&gt;pid;</span><br><span class="line"> </span><br><span class="line">   np-&gt;state = RUNNABLE;</span><br><span class="line">+  </span><br><span class="line">+  // copy the trace mask from the parent to the child process</span><br><span class="line">+  np-&gt;mask = p-&gt;mask;</span><br><span class="line"> </span><br><span class="line">   release(&amp;np-&gt;lock);</span><br><span class="line"> </span><br><span class="line">@@ -693,3 +696,14 @@ procdump(void)</span><br><span class="line">     printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+// return the number of unused processes</span><br><span class="line">+uint64</span><br><span class="line">+get_nproc(void)</span><br><span class="line">+&#123;</span><br><span class="line">+  struct proc *p;</span><br><span class="line">+  uint64 cnt = 0;</span><br><span class="line">+  for (p = proc; p &lt; &amp;proc[NPROC]; p++)</span><br><span class="line">+     if (p-&gt;state != UNUSED) cnt++;</span><br><span class="line">+  return cnt;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/proc.h b/kernel/proc.h</span><br><span class="line">index 9c16ea7..4e582b4 100644</span><br><span class="line">--- a/kernel/proc.h</span><br><span class="line">+++ b/kernel/proc.h</span><br><span class="line">@@ -103,4 +103,5 @@ struct proc &#123;</span><br><span class="line">   struct file *ofile[NOFILE];  // Open files</span><br><span class="line">   struct inode *cwd;           // Current directory</span><br><span class="line">   char name[16];               // Process name (debugging)</span><br><span class="line">+  int mask;                    // whose bits specify which system calls to trace</span><br><span class="line"> &#125;;</span><br><span class="line">diff --git a/kernel/syscall.c b/kernel/syscall.c</span><br><span class="line">index c1b3670..8854960 100644</span><br><span class="line">--- a/kernel/syscall.c</span><br><span class="line">+++ b/kernel/syscall.c</span><br><span class="line">@@ -104,6 +104,8 @@ extern uint64 sys_unlink(void);</span><br><span class="line"> extern uint64 sys_wait(void);</span><br><span class="line"> extern uint64 sys_write(void);</span><br><span class="line"> extern uint64 sys_uptime(void);</span><br><span class="line">+extern uint64 sys_trace(void);</span><br><span class="line">+extern uint64 sys_sysinfo(void);</span><br><span class="line"> </span><br><span class="line"> static uint64 (*syscalls[])(void) = &#123;</span><br><span class="line"> [SYS_fork]    sys_fork,</span><br><span class="line">@@ -127,6 +129,34 @@ static uint64 (*syscalls[])(void) = &#123;</span><br><span class="line"> [SYS_link]    sys_link,</span><br><span class="line"> [SYS_mkdir]   sys_mkdir,</span><br><span class="line"> [SYS_close]   sys_close,</span><br><span class="line">+[SYS_trace]   sys_trace,</span><br><span class="line">+[SYS_sysinfo] sys_sysinfo,</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+static const char *const syscallsname[] = &#123;</span><br><span class="line">+[SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">+[SYS_exit]    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">+[SYS_wait]    <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">+[SYS_pipe]    <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">+[SYS_read]    <span class="string">&quot;read&quot;</span>,</span><br><span class="line">+[SYS_kill]    <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">+[SYS_exec]    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">+[SYS_fstat]   <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">+[SYS_chdir]   <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">+[SYS_dup]     <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">+[SYS_getpid]  <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">+[SYS_sbrk]    <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">+[SYS_sleep]   <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">+[SYS_uptime]  <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">+[SYS_open]    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">+[SYS_write]   <span class="string">&quot;write&quot;</span>,</span><br><span class="line">+[SYS_mknod]   <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">+[SYS_unlink]  <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">+[SYS_link]    <span class="string">&quot;link&quot;</span>,</span><br><span class="line">+[SYS_mkdir]   <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">+[SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">+[SYS_trace]   <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">+[SYS_sysinfo] <span class="string">&quot;sysinfo&quot;</span>,</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> void</span><br><span class="line">@@ -138,6 +168,11 @@ syscall(void)</span><br><span class="line">   num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">   if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">     p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">+// print the trace output</span><br><span class="line">+if (p-&gt;mask &gt;&gt; num &amp; 1) &#123;</span><br><span class="line">+printf(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,</span><br><span class="line">+p-&gt;pid, syscallsname[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">+    &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     printf(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">             p-&gt;pid, p-&gt;name, num);</span><br><span class="line">diff --git a/kernel/syscall.h b/kernel/syscall.h</span><br><span class="line">index bc5f356..0dfedc7 100644</span><br><span class="line">--- a/kernel/syscall.h</span><br><span class="line">+++ b/kernel/syscall.h</span><br><span class="line">@@ -20,3 +20,5 @@</span><br><span class="line"> <span class="comment">#define SYS_link   19</span></span><br><span class="line"> <span class="comment">#define SYS_mkdir  20</span></span><br><span class="line"> <span class="comment">#define SYS_close  21</span></span><br><span class="line">+<span class="comment">#define SYS_trace  22</span></span><br><span class="line">+<span class="comment">#define SYS_sysinfo 23</span></span><br><span class="line">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span><br><span class="line">index e8bcda9..f6bc9ac 100644</span><br><span class="line">--- a/kernel/sysproc.c</span><br><span class="line">+++ b/kernel/sysproc.c</span><br><span class="line">@@ -6,6 +6,7 @@</span><br><span class="line"> <span class="comment">#include &quot;memlayout.h&quot;</span></span><br><span class="line"> <span class="comment">#include &quot;spinlock.h&quot;</span></span><br><span class="line"> <span class="comment">#include &quot;proc.h&quot;</span></span><br><span class="line">+<span class="comment">#include &quot;sysinfo.h&quot;</span></span><br><span class="line"> </span><br><span class="line"> uint64</span><br><span class="line"> sys_exit(void)</span><br><span class="line">@@ -95,3 +96,35 @@ sys_uptime(void)</span><br><span class="line">   release(&amp;tickslock);</span><br><span class="line">   return xticks;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+uint64</span><br><span class="line">+sys_trace(void)</span><br><span class="line">+&#123;</span><br><span class="line">+  int mask;</span><br><span class="line">+  if (argint(0, &amp;mask) &lt; 0)</span><br><span class="line">+  &#123;</span><br><span class="line">+    return -1;</span><br><span class="line">+  &#125;</span><br><span class="line">+  myproc()-&gt;mask = mask;</span><br><span class="line">+  return 0;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+uint64</span><br><span class="line">+sys_sysinfo(void)</span><br><span class="line">+&#123;</span><br><span class="line">+  uint64 addr;</span><br><span class="line">+  if (argaddr(0, &amp;addr) &lt; 0)</span><br><span class="line">+  &#123;</span><br><span class="line">+        return -1;</span><br><span class="line">+  &#125;</span><br><span class="line">+  struct sysinfo info;</span><br><span class="line">+  struct proc *p = myproc();</span><br><span class="line">+  info.freemem = get_freemem();</span><br><span class="line">+  info.nproc = get_nproc();</span><br><span class="line">+ </span><br><span class="line">+  if(copyout(p-&gt;pagetable, addr, (char*)&amp;info, sizeof(info))) &#123;</span><br><span class="line">+    return -1;</span><br><span class="line">+  &#125;</span><br><span class="line">+  return 0;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">diff --git a/time.txt b/time.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..7ed6ff8</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/time.txt</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+5</span><br><span class="line">diff --git a/user/trace.c b/user/trace.c</span><br><span class="line">index dd77760..7de5bb6 100644</span><br><span class="line">--- a/user/trace.c</span><br><span class="line">+++ b/user/trace.c</span><br><span class="line">@@ -7,21 +7,21 @@ int</span><br><span class="line"> main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line">   int i;</span><br><span class="line">-  char *nargv[MAXARG];</span><br><span class="line">+  char *nargv[MAXARG]; </span><br><span class="line"> </span><br><span class="line">   if(argc &lt; 3 || (argv[1][0] &lt; &#x27;0&#x27; || argv[1][0] &gt; &#x27;9&#x27;))&#123;</span><br><span class="line">     fprintf(2, <span class="string">&quot;Usage: %s mask command\n&quot;</span>, argv[0]);</span><br><span class="line">     exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">-  if (trace(atoi(argv[1])) &lt; 0) &#123;</span><br><span class="line">+  if (trace(atoi(argv[1])) &lt; 0) &#123;  // 系统调用trace，设置mask值为argv[1]</span><br><span class="line">     fprintf(2, <span class="string">&quot;%s: trace failed\n&quot;</span>, argv[0]);</span><br><span class="line">     exit(1);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">-  for(i = 2; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;</span><br><span class="line">+  for(i = 2; i &lt; argc &amp;&amp; i &lt; MAXARG; i++) &#123; // 提取command</span><br><span class="line">     nargv[i-2] = argv[i];</span><br><span class="line">   &#125;</span><br><span class="line">-  exec(nargv[0], nargv);</span><br><span class="line">+  exec(nargv[0], nargv); // exec command</span><br><span class="line">   exit(0);</span><br><span class="line"> &#125;</span><br><span class="line">diff --git a/user/user.h b/user/user.h</span><br><span class="line">index b71ecda..6ba24e6 100644</span><br><span class="line">--- a/user/user.h</span><br><span class="line">+++ b/user/user.h</span><br><span class="line">@@ -1,5 +1,6 @@</span><br><span class="line"> struct stat;</span><br><span class="line"> struct rtcdate;</span><br><span class="line">+struct sysinfo;</span><br><span class="line"> </span><br><span class="line"> // system calls</span><br><span class="line"> int fork(void);</span><br><span class="line">@@ -23,6 +24,8 @@ int getpid(void);</span><br><span class="line"> char* sbrk(int);</span><br><span class="line"> int sleep(int);</span><br><span class="line"> int uptime(void);</span><br><span class="line">+int trace(int);</span><br><span class="line">+int sysinfo(struct sysinfo*);</span><br><span class="line"> </span><br><span class="line"> // ulib.c</span><br><span class="line"> int stat(const char*, struct stat*);</span><br><span class="line">diff --git a/user/usys.pl b/user/usys.pl</span><br><span class="line">index 01e426e..bc109fd 100755</span><br><span class="line">--- a/user/usys.pl</span><br><span class="line">+++ b/user/usys.pl</span><br><span class="line">@@ -36,3 +36,5 @@ entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">+entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line">+entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 实验1 Unix Utilities</title>
      <link href="/2022/09/01/xv6-lab1/"/>
      <url>/2022/09/01/xv6-lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab-util-Uinx-utilities"><a href="#Lab-util-Uinx-utilities" class="headerlink" title="Lab util: Uinx utilities"></a>Lab util: Uinx utilities</h1><ul><li><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a></li><li><a href="https://pdos.csail.mit.edu/6.828/2020/labs/util.html">https://pdos.csail.mit.edu/6.828/2020/labs/util.html</a></li></ul><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>在 UPROGS 项中最后一行添加 $U/_sleep\<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br><span class="line">$U/_sleep\</span><br></pre></td></tr></table></figure></p><p>sleep.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;(nothing happens for a little while)\n&quot;</span>);</span><br><span class="line">sleep(atoi((<span class="type">const</span> <span class="type">char</span>*) argv[<span class="number">1</span>])); <span class="comment">// convert ascii to integer and use system call sleep</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage:sleep number...\n&quot;</span>);  <span class="comment">// put the error masssage to the file descriptor 2</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// terminate the process, </span></span><br><span class="line">    <span class="comment">// status = 1: indicates failure, and reported to wait() </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>通过<code>fork</code>、<code>pipe</code>和<code>getpid</code>系统调用，来实现pingpong</p><ul><li>fork在父进程中的返回值是pid，在子进程中的返回值是0</li><li>pipe初始化的管道，其数组的第一个元素是读端，第二个元素是写端</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在 UPROGS 项中最后一行添加 $U/_pingpong\</p><p>pingpong.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p1[<span class="number">2</span>]; <span class="comment">// parent -&gt; child</span></span><br><span class="line"><span class="type">int</span> p2[<span class="number">2</span>]; <span class="comment">// child -&gt; parent</span></span><br><span class="line"><span class="type">char</span> buffer[] = &#123;<span class="string">&#x27;x&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(buffer);</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: pingpong\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pipe(p1);</span><br><span class="line">pipe(p2);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123; <span class="comment">// child</span></span><br><span class="line">close(p1[<span class="number">1</span>]);</span><br><span class="line">close(p2[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(read(p1[<span class="number">0</span>], buffer, length) == <span class="number">1</span>)&#123;  <span class="comment">// child receives the byte</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">write(p2[<span class="number">1</span>], buffer, length);     <span class="comment">// child sends the byte to child</span></span><br><span class="line">close(p2[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(p2[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  <span class="comment">// parent</span></span><br><span class="line">close(p1[<span class="number">0</span>]);</span><br><span class="line">close(p2[<span class="number">1</span>]);</span><br><span class="line">write(p1[<span class="number">1</span>], buffer,  length); <span class="comment">// parent sends a byte to the child</span></span><br><span class="line">close(p1[<span class="number">1</span>]);</span><br><span class="line">wait((<span class="type">int</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(read(p2[<span class="number">0</span>], buffer, length) == <span class="number">1</span>)&#123;  <span class="comment">// parent receives the byte</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/img/xv6-lab1-primes.png" alt="进程链"></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>在 UPROGS 项中最后一行添加 $U/_primes\</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">close_pipe</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">primes</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n, p, len;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the frist number from previous prime </span></span><br><span class="line"><span class="keyword">if</span> ((len = read(<span class="number">0</span>, &amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// print first number to console</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, n);</span><br><span class="line">  </span><br><span class="line">pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">dup(fd[<span class="number">0</span>]);  <span class="comment">// link the std i/o 0 to fd[0] </span></span><br><span class="line">close_pipe(fd);</span><br><span class="line">primes();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;      <span class="comment">// parent process</span></span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">dup(fd[<span class="number">1</span>]); <span class="comment">// link the std i/o 1 to fd[1]</span></span><br><span class="line">close_pipe(fd); </span><br><span class="line"><span class="keyword">while</span> ((len = read(<span class="number">0</span>, &amp;p, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &gt; <span class="number">0</span> &amp;&amp; p &gt; <span class="number">0</span>) &#123;  <span class="comment">// read the number from the prime</span></span><br><span class="line"><span class="keyword">if</span> (p % n != <span class="number">0</span>) &#123;</span><br><span class="line"> write(<span class="number">1</span>, &amp;p, <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// filter the number</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">wait((<span class="type">int</span> *)<span class="number">0</span>);   </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">  </span><br><span class="line">pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// child process</span></span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">dup(fd[<span class="number">0</span>]);  <span class="comment">// link the std i/o 0 to the fd[0]</span></span><br><span class="line">close_pipe(fd);</span><br><span class="line"> primes();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">dup(fd[<span class="number">1</span>]);  <span class="comment">// link the std i/o 1 to the fd[1]</span></span><br><span class="line">close_pipe(fd);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">write(<span class="number">1</span>, &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">wait((<span class="type">int</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>在 UPROGS 项中最后一行添加 $U/_find\</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span>  <span class="comment">// 将路径格式化为文件名</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find first character after last slash. 从字符串末尾开始遍历，直到遇到&#x27;/&#x27;或者到字符串的头部为止</span></span><br><span class="line"><span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--) ;</span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return blank-padded name.</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)  <span class="comment">// 字符串太长了</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">memmove(buf, p, <span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *file)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 路径不存在</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;   <span class="comment">// 获取不了该路径的状态</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line"><span class="keyword">case</span> T_FILE:  <span class="comment">// 如果这是一个文件</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(fmtname(path), file) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> T_DIR: <span class="comment">// 如果这是一个目录</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf))&#123;  <span class="comment">// 路径太长，缓冲区装不下</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path); </span><br><span class="line">p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">*p++ = <span class="string">&#x27;/&#x27;</span>;  <span class="comment">// 在路径末尾添加&#x27;/&#x27;</span></span><br><span class="line"><span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;  <span class="comment">// 从该路径读取出文件名或者目录名</span></span><br><span class="line"><span class="keyword">if</span>(de.inum == <span class="number">0</span> || de.inum == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">memmove(p, de.name, DIRSIZ);  <span class="comment">// 在路径后面添加文件名or目录</span></span><br><span class="line">p[DIRSIZ] = <span class="number">0</span>;      <span class="comment">// the end of string is &#x27;\0&#x27;</span></span><br><span class="line">find(buf, file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find &lt;path&gt; &lt;file&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>在 UPROGS 项中最后一行添加 $U/_xargs\</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *arguments[MAXARG];</span><br><span class="line"><span class="type">char</span> buff[<span class="number">255</span>];</span><br><span class="line"><span class="type">char</span> *p = buff, *q = buff;</span><br><span class="line"><span class="type">int</span> i, offset;</span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: xargc &lt;command&gt;...\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++)&#123;  <span class="comment">// get the command which is behind the &quot;xargs&quot;</span></span><br><span class="line">  arguments[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">&#125;</span><br><span class="line">i = i - <span class="number">1</span>;</span><br><span class="line">offset = i;  <span class="comment">// backup</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(read(<span class="number">0</span>, p, <span class="number">1</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(*p == <span class="string">&#x27;\n&#x27;</span>)&#123;  <span class="comment">// meet the &#x27;\n&#x27; and execute it with arguments</span></span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    arguments[i] = q;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    exec(arguments[<span class="number">0</span>], arguments);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    wait((<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">    p = buff;</span><br><span class="line">    q = p;</span><br><span class="line">    i = offset;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="string">&#x27; &#x27;</span> || *p == <span class="string">&#x27;\t&#x27;</span>)&#123;  <span class="comment">// meet the &#x27; &#x27; or &#x27;\t&#x27;, find an argument</span></span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    arguments[i] = q;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    p = p + <span class="number">1</span>;</span><br><span class="line">    q = p; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    p = p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="git查看修改记录"><a href="#git查看修改记录" class="headerlink" title="git查看修改记录"></a>git查看修改记录</h2><p>查看文件的变化<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu:~/xv6-labs-2020$ git diff origin/util util --stat</span><br><span class="line"> Makefile        |   5 +++++</span><br><span class="line"> gradelib.pyc    | Bin 0 -&gt; 22972 bytes</span><br><span class="line"> user/find.c     |  84 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> user/pingpong.c |  40 ++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> user/primes.c   |  67 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> user/sleep.c    |  17 +++++++++++++++++</span><br><span class="line"> user/xargs.c    |  47 +++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> 7 files changed, 260 insertions(+)</span><br></pre></td></tr></table></figure></p><hr><p>查看具体修改内容<code>git diff origin/util util</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index 0fbaf7c..b2addd4 100644</span><br><span class="line">--- a/Makefile</span><br><span class="line">+++ b/Makefile</span><br><span class="line">@@ -149,6 +149,11 @@ UPROGS=\</span><br><span class="line"> $U/_grind\</span><br><span class="line"> $U/_wc\</span><br><span class="line"> $U/_zombie\</span><br><span class="line">+$U/_sleep\</span><br><span class="line">+$U/_pingpong\</span><br><span class="line">+$U/_find\</span><br><span class="line">+$U/_xargs\</span><br><span class="line">+$U/_primes\</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> ifeq ($(LAB),syscall)</span><br><span class="line">diff --git a/gradelib.pyc b/gradelib.pyc</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..634a0f3</span><br><span class="line">Binary files /dev/null and b/gradelib.pyc differ</span><br><span class="line">diff --git a/user/find.c b/user/find.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..8070f86</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/find.c</span><br><span class="line">@@ -0,0 +1,84 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;kernel/stat.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+#include &quot;kernel/fs.h&quot;</span><br><span class="line">+</span><br><span class="line">+char*</span><br><span class="line">+fmtname(char *path)  // 将路径格式化为文件名</span><br><span class="line">+&#123;</span><br><span class="line">+  static char buf[DIRSIZ+1];</span><br><span class="line">+  char *p;</span><br><span class="line">+</span><br><span class="line">+  // Find first character after last slash. 从字符串末尾开始遍历，直到遇到&#x27;/&#x27;或者到字符串的头部为止</span><br><span class="line">+  for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != &#x27;/&#x27;; p--) ;</span><br><span class="line">+  p++;</span><br><span class="line">+</span><br><span class="line">+  // Return blank-padded name.</span><br><span class="line">+  if(strlen(p) &gt;= DIRSIZ)  // 字符串太长了</span><br><span class="line">+    return p;</span><br><span class="line">+  memmove(buf, p, strlen(p)+1);</span><br><span class="line">+  return buf;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+void</span><br><span class="line">+find(char *path, char *file)</span><br><span class="line">+&#123;</span><br><span class="line">+  char buf[512], *p;</span><br><span class="line">+  int fd;</span><br><span class="line">+  struct dirent de;</span><br><span class="line">+  struct stat st;</span><br><span class="line">+</span><br><span class="line">+  if((fd = open(path, 0)) &lt; 0)&#123;  // 路径不存在</span><br><span class="line">+    fprintf(2, &quot;find: cannot open %s\n&quot;, path);</span><br><span class="line">+    return;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  if(fstat(fd, &amp;st) &lt; 0)&#123;   // 获取不了该路径的状态</span><br><span class="line">+    fprintf(2, &quot;find: cannot stat %s\n&quot;, path);</span><br><span class="line">+    close(fd);</span><br><span class="line">+    return;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  switch(st.type)&#123;</span><br><span class="line">+  case T_FILE:  // 如果这是一个文件</span><br><span class="line">+    if(strcmp(fmtname(path), file) == 0)&#123;</span><br><span class="line">+printf(&quot;%s\n&quot;, path);</span><br><span class="line">+&#125;</span><br><span class="line">+    break;</span><br><span class="line">+</span><br><span class="line">+  case T_DIR: // 如果这是一个目录</span><br><span class="line">+    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;  // 路径太长，缓冲区装不下</span><br><span class="line">+      printf(&quot;find: path too long\n&quot;);</span><br><span class="line">+      break;</span><br><span class="line">+    &#125;</span><br><span class="line">+    strcpy(buf, path); </span><br><span class="line">+    p = buf+strlen(buf);</span><br><span class="line">+    *p++ = &#x27;/&#x27;;  // 在路径末尾添加&#x27;/&#x27;</span><br><span class="line">+    while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123;  // 从该路径读取出文件名或者目录名</span><br><span class="line">+      if(de.inum == 0 || de.inum == 1)</span><br><span class="line">+        continue;</span><br><span class="line">+      if (strcmp(de.name, &quot;.&quot;) == 0 || strcmp(de.name, &quot;..&quot;) == 0)</span><br><span class="line">+        continue;</span><br><span class="line">+      memmove(p, de.name, DIRSIZ);  // 在路径后面添加文件名or目录</span><br><span class="line">+      p[DIRSIZ] = 0;      // the end of string is &#x27;\0&#x27;</span><br><span class="line">+      find(buf, file);</span><br><span class="line">+    &#125;</span><br><span class="line">+    break;</span><br><span class="line">+</span><br><span class="line">+  default:</span><br><span class="line">+    break;</span><br><span class="line">+  &#125;</span><br><span class="line">+  close(fd);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(int argc, char *argv[])</span><br><span class="line">+&#123;</span><br><span class="line">+if(argc != 3)&#123;</span><br><span class="line">+fprintf(2, &quot;Usage: find &lt;path&gt; &lt;file&gt;\n&quot;);</span><br><span class="line">+exit(1);</span><br><span class="line">+&#125;</span><br><span class="line">+find(argv[1], argv[2]);</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/user/pingpong.c b/user/pingpong.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..caecc4b</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/pingpong.c</span><br><span class="line">@@ -0,0 +1,40 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;kernel/stat.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(int argc, char *argv[])</span><br><span class="line">+&#123;</span><br><span class="line">+int p1[2]; // parent -&gt; child</span><br><span class="line">+int p2[2]; // child -&gt; parent</span><br><span class="line">+    char buffer[] = &#123;&#x27;x&#x27;&#125;;</span><br><span class="line">+    int length = sizeof(buffer);</span><br><span class="line">+if(argc != 1)&#123;</span><br><span class="line">+fprintf(2, &quot;Usage: pingpong\n&quot;);</span><br><span class="line">+exit(1);</span><br><span class="line">+&#125;</span><br><span class="line">+pipe(p1);</span><br><span class="line">+pipe(p2);</span><br><span class="line">+if(fork() == 0)&#123; // child</span><br><span class="line">+close(p1[1]);</span><br><span class="line">+close(p2[0]);</span><br><span class="line">+if(read(p1[0], buffer, length) == 1)&#123;  // child receives the byte</span><br><span class="line">+printf(&quot;%d: received ping\n&quot;, getpid());</span><br><span class="line">+write(p2[1], buffer, length);     // child sends the byte to child</span><br><span class="line">+close(p2[1]);</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">+close(p2[1]);</span><br><span class="line">+exit(1);</span><br><span class="line">+&#125;else&#123;  // parent</span><br><span class="line">+close(p1[0]);</span><br><span class="line">+close(p2[1]);</span><br><span class="line">+write(p1[1], buffer,  length); // parent sends a byte to the child</span><br><span class="line">+close(p1[1]);</span><br><span class="line">+wait((int *)0);</span><br><span class="line">+if(read(p2[0], buffer, length) == 1)&#123;  // parent receives the byte</span><br><span class="line">+printf(&quot;%d: received pong\n&quot;, getpid());</span><br><span class="line">+&#125;</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/user/primes.c b/user/primes.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..6f9180e</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/primes.c</span><br><span class="line">@@ -0,0 +1,67 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+</span><br><span class="line">+void</span><br><span class="line">+close_pipe(int *p) &#123;</span><br><span class="line">+  close(p[0]);</span><br><span class="line">+  close(p[1]);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+void</span><br><span class="line">+primes() &#123;</span><br><span class="line">+  int n, p, len;</span><br><span class="line">+  int fd[2];</span><br><span class="line">+</span><br><span class="line">+  // read the frist number from previous prime </span><br><span class="line">+  if ((len = read(0, &amp;n, sizeof(int))) &lt;= 0 || n &lt;= 0) &#123;</span><br><span class="line">+    close(1);</span><br><span class="line">+    exit(0);</span><br><span class="line">+  &#125;</span><br><span class="line">+  </span><br><span class="line">+  // print first number to console</span><br><span class="line">+  printf(&quot;prime %d\n&quot;, n);</span><br><span class="line">+  </span><br><span class="line">+  pipe(fd);</span><br><span class="line">+  if (fork() == 0) &#123; // child process</span><br><span class="line">+    close(0);</span><br><span class="line">+    dup(fd[0]);  // link the std i/o 0 to fd[0] </span><br><span class="line">+    close_pipe(fd);</span><br><span class="line">+    primes();</span><br><span class="line">+  &#125; else &#123;      // parent process</span><br><span class="line">+    close(1);</span><br><span class="line">+    dup(fd[1]); // link the std i/o 1 to fd[1]</span><br><span class="line">+    close_pipe(fd); </span><br><span class="line">+    while ((len = read(0, &amp;p, sizeof(int))) &gt; 0 &amp;&amp; p &gt; 0) &#123;  // read the number from the prime</span><br><span class="line">+      if (p % n != 0) &#123;</span><br><span class="line">+        write(1, &amp;p, sizeof(int));  // filter the number</span><br><span class="line">+      &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+    close(1);</span><br><span class="line">+    wait((int *)0);   </span><br><span class="line">+  &#125; </span><br><span class="line">+  exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(void) &#123;</span><br><span class="line">+  int i;</span><br><span class="line">+  int fd[2];</span><br><span class="line">+  </span><br><span class="line">+  pipe(fd);</span><br><span class="line">+  if (fork() == 0) &#123;  // child process</span><br><span class="line">+    close(0);</span><br><span class="line">+    dup(fd[0]);  // link the std i/o 0 to the fd[0]</span><br><span class="line">+    close_pipe(fd);</span><br><span class="line">+    primes();</span><br><span class="line">+  &#125; else &#123;</span><br><span class="line">+    close(1);</span><br><span class="line">+    dup(fd[1]);  // link the std i/o 1 to the fd[1]</span><br><span class="line">+    close_pipe(fd);</span><br><span class="line">+    for (i = 2; i &lt;= 35; i++) &#123;</span><br><span class="line">+      write(1, &amp;i, sizeof(int));</span><br><span class="line">+    &#125;</span><br><span class="line">+    close(1);</span><br><span class="line">+    wait((int *)0);</span><br><span class="line">+  &#125;</span><br><span class="line">+  exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/user/sleep.c b/user/sleep.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..1c4d51d</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/sleep.c</span><br><span class="line">@@ -0,0 +1,17 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;kernel/stat.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(int argc, char *argv[])</span><br><span class="line">+&#123;</span><br><span class="line">+if(argc == 2)&#123;</span><br><span class="line">+sleep(atoi((const char*) argv[1])); // convert ascii to integer and use system call sleep</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br><span class="line">+else&#123;</span><br><span class="line">+fprintf(2, &quot;Usage:sleep number...\n&quot;);  // put the error masssage to the file descriptor 2</span><br><span class="line">+exit(1); // terminate the process, </span><br><span class="line">+//status = 1: indicates failure, and reported to wait() </span><br><span class="line">+&#125;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/user/xargs.c b/user/xargs.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..1423af7</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/user/xargs.c</span><br><span class="line">@@ -0,0 +1,47 @@</span><br><span class="line">+#include &quot;kernel/types.h&quot;</span><br><span class="line">+#include &quot;user/user.h&quot;</span><br><span class="line">+#include &quot;kernel/param.h&quot;</span><br><span class="line">+</span><br><span class="line">+int</span><br><span class="line">+main(int argc, char *argv[])</span><br><span class="line">+&#123;</span><br><span class="line">+char *arguments[MAXARG];</span><br><span class="line">+char buff[255];</span><br><span class="line">+char *p = buff, *q = buff;</span><br><span class="line">+int i, offset;</span><br><span class="line">+if(argc &lt;= 1)&#123;</span><br><span class="line">+fprintf(2, &quot;Usage: xargc &lt;command&gt;...\n&quot;);</span><br><span class="line">+exit(1);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+for(i = 1; i &lt; argc; i++)&#123;  // get the command which is behind the &quot;xargs&quot;</span><br><span class="line">+        arguments[i-1] = argv[i];</span><br><span class="line">+    &#125;</span><br><span class="line">+    i = i - 1;</span><br><span class="line">+    offset = i;  // backup</span><br><span class="line">+    </span><br><span class="line">+    while(read(0, p, 1))&#123;</span><br><span class="line">+    if(*p == &#x27;\n&#x27;)&#123;  // meet the &#x27;\n&#x27; and execute it with arguments</span><br><span class="line">+    *p = &#x27;\0&#x27;;</span><br><span class="line">+    arguments[i] = q;</span><br><span class="line">+    if(fork() == 0)&#123;</span><br><span class="line">+    exec(arguments[0], arguments);</span><br><span class="line">+    exit(0);</span><br><span class="line">+    &#125;else&#123;</span><br><span class="line">+    wait((int*)0);</span><br><span class="line">+    p = buff;</span><br><span class="line">+    q = p;</span><br><span class="line">+    i = offset;</span><br><span class="line">+    &#125;</span><br><span class="line">+    &#125;else if(*p == &#x27; &#x27; || *p == &#x27;\t&#x27;)&#123;  // meet the &#x27; &#x27; or &#x27;\t&#x27;, find an argument</span><br><span class="line">+    *p = &#x27;\0&#x27;;</span><br><span class="line">+    arguments[i] = q;</span><br><span class="line">+    i = i + 1;</span><br><span class="line">+    p = p + 1;</span><br><span class="line">+    q = p; </span><br><span class="line">+    &#125;else&#123;</span><br><span class="line">+    p = p + 1;</span><br><span class="line">+    &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+exit(0);</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6调试用户程序</title>
      <link href="/2022/08/31/xv6-debug-userprogram/"/>
      <url>/2022/08/31/xv6-debug-userprogram/</url>
      
        <content type="html"><![CDATA[<p>本文介绍使用vscode来调试用户程序。</p><h2 id="vscode远程连接虚拟机上的Linux"><a href="#vscode远程连接虚拟机上的Linux" class="headerlink" title="vscode远程连接虚拟机上的Linux"></a>vscode远程连接虚拟机上的Linux</h2><ol><li>安装Remote-SSH，同时，虚拟机上的Linux系统也要安装并启动openssh-server</li><li>利用Remote-SSH远程连接虚拟机上的Linux</li><li>在虚拟机上安装插件<code>C/C++</code>和<code>Native Debug</code></li></ol><h2 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h2><p>在.vscode新建<code>launch.json</code>和<code>c_cpp_properties.json</code></p><p>把.gdbinit.tmpl-riscv中<code>target remote 127.0.0.1:26000</code>注释<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set confirm off</span><br><span class="line">set architecture riscv:rv64</span><br><span class="line">#target remote 127.0.0.1:26000</span><br><span class="line">symbol-file kernel/kernel</span><br><span class="line">set disassemble-next-line auto</span><br></pre></td></tr></table></figure></p><p>根据<code>target remote 127.0.0.1:26000</code>来设置launch.json的<code>target</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// launch.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;attach&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Attach to gdbserver&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;executable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;/kernel/kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gdbpath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb-multiarch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;remote&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:26000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><p>为了在vscode上代码跳转，<br>在Ubuntu上安装bear，接着<code>make clean</code>，然后<code>bear make qemu</code>生成<code>compile_commands.json</code>。<br>把<code>compile_commands.json</code>移动到<code>.vscode</code>里面。<br>之后如果修改源代码的话，同样也要<code>bear make qemu</code>重新生成<code>compile_commands.json</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// c_cpp_properties.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Linux&quot;,</span><br><span class="line">            // make clean; bear make qemu</span><br><span class="line">            &quot;compileCommands&quot;: &quot;$&#123;workspaceFolder&#125;/.vscode/compile_commands.json&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="调试用户程序ls"><a href="#调试用户程序ls" class="headerlink" title="调试用户程序ls"></a>调试用户程序ls</h2><ol><li>在下方命令行输入<code>make qemu-gdb</code>。qemu会自动启动，gdb开始等待接入。</li><li>按下F5， 或者 点击左侧按钮运行与调试，并点击左上角绿色三角（Attach to gdbserver)。<br>如果不想开启多核心，可以在运行make qemu-gdb时使用CPUS=1，以单核模式启动，即输入命令变为make qemu-gdb CPUS=1。</li></ol><p><code>每次调试完成，务必使用红色按钮 断开 GDB调试，并在命令行中 Ctrl-A, X以停止qemu。</code></p><ol><li>我们知道，在进入Trampoline切换前最后一行C代码位于<code>kernel/trap.c:128</code>处，我们将断点打在此处，继续点击“运行”。</li><li>在xv6的shell中输入ls，以启动ls程序；程序停留在<code>kernel/trap.c:128</code>处。</li><li>接下来，我们需要确认对应xv6的用户程序入口点，我们有两种方法可以确认应用程序的入口点：<ul><li>通过readelf确认应用程序入口点，<code>readelf -h user/_ls</code>，可见其中显示Entry point address: 0x27a，应用程序入口点位于0x27a处。我们前往调试控制台，在其中输入<code>b *0x27a</code>，即将断点置于ls程序入口处。</li><li>在VSCode上直接打开该应用程序ls的源代码，找打main()函数，并在main()函数里打上断点。</li></ul></li><li>接下来，我们需要在调试窗口左下角删除原有的内核态断点，并通过调试控制台，加载ls的调试符号。在其中输入<code>file user/_ls</code>。</li><li>点击“运行”。可以看到已经进入了ls.c的main函数中。</li></ol><p>更多详细内容请参考：<a href="http://hitsz-cslab.gitee.io/os-labs/remote_env_gdb/#444">http://hitsz-cslab.gitee.io/os-labs/remote_env_gdb/#444</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6系统启动过程</title>
      <link href="/2022/08/31/xv6-OS-setup/"/>
      <url>/2022/08/31/xv6-OS-setup/</url>
      
        <content type="html"><![CDATA[<h2 id="启动qemu和gdb"><a href="#启动qemu和gdb" class="headerlink" title="启动qemu和gdb"></a>启动qemu和gdb</h2><p>一个终端（设定一个CPU，方便调试）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (dev)&gt; make qemu-gdb CPUS=1</span><br><span class="line">*** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26000</span><br></pre></td></tr></table></figure></p><p>另一个终端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (dev)&gt; gdb-multiarch kernel/kernel</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.                                                                                   </span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from kernel/kernel...</span><br><span class="line">The target architecture is assumed to be riscv:rv64</span><br><span class="line">0x0000000000001000 <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure><br>在gdb终端上查看源代码和汇编<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout <span class="built_in">split</span></span><br></pre></td></tr></table></figure></p><p><img src="/img/xv6-OS-setup1.png" alt=""></p><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><ul><li>在entry加一个断点<ul><li>b _entry</li></ul></li><li>可以单步调试也可以Continue<ul><li>si</li><li>c</li></ul></li></ul><p><img src="/img/xv6-OS-setup2.png" alt=""></p><p>kernel/entry.S<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        # qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each CPU to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure></p><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><ul><li>focus src</li><li>在main加一个断点<ul><li>b main</li></ul></li><li>可以单步调试也可以continue<ul><li>s</li><li>c</li></ul></li></ul><p><img src="/img/xv6-OS-setup3.png" alt=""></p><p>kernel/start.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timerinit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.S needs one stack per CPU.</span></span><br><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br><span class="line"></span><br><span class="line"><span class="comment">// scratch area for timer interrupt, one per CPU.</span></span><br><span class="line">uint64 mscratch0[NCPU * <span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// assembly code in kernelvec.S for machine-mode timer interrupt.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">timervec</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up to receive timer interrupts in machine mode,</span></span><br><span class="line"><span class="comment">// which arrive at timervec in kernelvec.S,</span></span><br><span class="line"><span class="comment">// which turns them into software interrupts for</span></span><br><span class="line"><span class="comment">// devintr() in trap.c.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timerinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// each CPU has a separate source of timer interrupts.</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask the CLINT for a timer interrupt.</span></span><br><span class="line">  <span class="type">int</span> interval = <span class="number">1000000</span>; <span class="comment">// cycles; about 1/10th second in qemu.</span></span><br><span class="line">  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare information in scratch[] for timervec.</span></span><br><span class="line">  <span class="comment">// scratch[0..3] : space for timervec to save registers.</span></span><br><span class="line">  <span class="comment">// scratch[4] : address of CLINT MTIMECMP register.</span></span><br><span class="line">  <span class="comment">// scratch[5] : desired interval (in cycles) between timer interrupts.</span></span><br><span class="line">  uint64 *scratch = &amp;mscratch0[<span class="number">32</span> * id];</span><br><span class="line">  scratch[<span class="number">4</span>] = CLINT_MTIMECMP(id);</span><br><span class="line">  scratch[<span class="number">5</span>] = interval;</span><br><span class="line">  w_mscratch((uint64)scratch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the machine-mode trap handler.</span></span><br><span class="line">  w_mtvec((uint64)timervec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode interrupts.</span></span><br><span class="line">  w_mstatus(r_mstatus() | MSTATUS_MIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable machine-mode timer interrupts.</span></span><br><span class="line">  w_mie(r_mie() | MIE_MTIE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><ul><li>在userinit打一个断点<ul><li>b userinit</li></ul></li><li>单步调试或者continue<ul><li>s</li><li>c</li></ul></li></ul><p><img src="/img/xv6-OS-setup4.png" alt=""></p><p>kernel/main.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> started = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode cache</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="第一个进程的初始化"><a href="#第一个进程的初始化" class="headerlink" title="第一个进程的初始化"></a>第一个进程的初始化</h2><ul><li>在scheduler打一个断点<ul><li>b scheduler</li></ul></li><li>单步调试或者continue<ul><li>s</li><li>c</li></ul></li></ul><p>kernel/proc.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a user program that calls exec(&quot;/init&quot;)</span></span><br><span class="line"><span class="comment">// od -t xC initcode</span></span><br><span class="line">uchar initcode[] = &#123;</span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x13</span>, <span class="number">0x05</span>, <span class="number">0x45</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x97</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x93</span>, <span class="number">0x85</span>, <span class="number">0x35</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xef</span>, <span class="number">0xf0</span>, <span class="number">0x9f</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x69</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>initcode是二进制代码的形式，对应initcode.S中的代码，作用是执行系统调用<code>exec(&quot;\init&quot;, argv)</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure></p><h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><ul><li>在syscall打一个断点<ul><li>b syscall</li></ul></li><li>单步调试或者continue<ul><li>s</li><li>c</li></ul></li></ul><p>kernel/pro.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ul><li>在sys_exec打一个断点<ul><li>b sys_exec</li></ul></li><li>单步调试或者continue<ul><li>s</li><li>c</li></ul></li></ul><p>kernel/syscall.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="comment">// 执行系统调用</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在exec打一个断点<ul><li>b exec</li></ul></li><li>单步调试或者continue<ul><li>s</li><li>c</li></ul></li></ul><p>kernel/sysfile.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH], *argv[MAXARG];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  uint64 uargv, uarg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, path, MAXPATH) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;uargv) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(argv));</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= NELEM(argv))&#123;</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fetchaddr(uargv+<span class="keyword">sizeof</span>(uint64)*i, (uint64*)&amp;uarg) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(uarg == <span class="number">0</span>)&#123;</span><br><span class="line">      argv[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[i] = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(argv[i] == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(fetchstr(uarg, argv[i], PGSIZE) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = exec(path, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NELEM(argv) &amp;&amp; argv[i] != <span class="number">0</span>; i++)</span><br><span class="line">    kfree(argv[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NELEM(argv) &amp;&amp; argv[i] != <span class="number">0</span>; i++)</span><br><span class="line">    kfree(argv[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG+<span class="number">1</span>], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  sp = sz;</span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试第一个进程"><a href="#调试第一个进程" class="headerlink" title="调试第一个进程"></a>调试第一个进程</h2><p>首先退出qemu和gdb，查看init程序的入口地址（Entry point address）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (dev)&gt; readelf -h user/_init </span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)</span></span><br><span class="line"><span class="string">  Machine:                           RISC-V</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          22672 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x5, RVC, double-float ABI</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         2</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         18</span></span><br><span class="line"><span class="string">  Section header string table index: 17</span></span><br></pre></td></tr></table></figure><ul><li>重新启动qemu和gdb，在入口地址加一个断点，<code>b *0x0</code>；</li><li>接着，continue，<code>c</code>；</li><li>然后加载kernel的调试符号，<code>file user/_init</code>；</li><li>查看源代码，<code>layout src</code>；</li><li>调试，<code>n</code>。</li></ul><p><img src="/img/xv6-OS-setup5.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6调试</title>
      <link href="/2022/08/31/xv6-debug/"/>
      <url>/2022/08/31/xv6-debug/</url>
      
        <content type="html"><![CDATA[<h2 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure><h2 id="理解框架代码的编译"><a href="#理解框架代码的编译" class="headerlink" title="理解框架代码的编译"></a>理解框架代码的编译</h2><ul><li>输出到vim中<ul><li><code>make nB | vim -</code></li></ul></li><li>在 Vim 里做一些你舒适的文本处理<ul><li><code>:%s/^/\r</code> 在命令之间插入空行</li><li><code>:%s/ /\r /g</code> 将命令的参数缩进排版</li></ul></li><li>另存为新文件<ul><li><code>:w filename</code></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br></pre></td><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc </span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/entry.o</span><br><span class="line"> kernel/entry.S</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/start.o</span><br><span class="line"> kernel/start.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/console.o</span><br><span class="line"> kernel/console.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/printf.o</span><br><span class="line"> kernel/printf.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/uart.o</span><br><span class="line"> kernel/uart.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/kalloc.o</span><br><span class="line"> kernel/kalloc.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/spinlock.o</span><br><span class="line"> kernel/spinlock.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/string.o</span><br><span class="line"> kernel/string.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/main.o</span><br><span class="line"> kernel/main.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/vm.o</span><br><span class="line"> kernel/vm.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/proc.o</span><br><span class="line"> kernel/proc.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/swtch.o</span><br><span class="line"> kernel/swtch.S</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/trampoline.o</span><br><span class="line"> kernel/trampoline.S</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/trap.o</span><br><span class="line"> kernel/trap.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/syscall.o</span><br><span class="line"> kernel/syscall.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/sysproc.o</span><br><span class="line"> kernel/sysproc.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/bio.o</span><br><span class="line"> kernel/bio.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/fs.o</span><br><span class="line"> kernel/fs.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/log.o</span><br><span class="line"> kernel/log.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/sleeplock.o</span><br><span class="line"> kernel/sleeplock.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/file.o</span><br><span class="line"> kernel/file.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/pipe.o</span><br><span class="line"> kernel/pipe.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/exec.o</span><br><span class="line"> kernel/exec.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/sysfile.o</span><br><span class="line"> kernel/sysfile.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/kernelvec.o</span><br><span class="line"> kernel/kernelvec.S</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/plic.o</span><br><span class="line"> kernel/plic.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -c</span><br><span class="line"> -o</span><br><span class="line"> kernel/virtio_disk.o</span><br><span class="line"> kernel/virtio_disk.c</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-gcc</span><br><span class="line"> -Wall</span><br><span class="line"> -Werror</span><br><span class="line"> -O</span><br><span class="line"> -fno-omit-frame-pointer</span><br><span class="line"> -ggdb</span><br><span class="line"> -DSOL_UTIL</span><br><span class="line"> -MD</span><br><span class="line"> -mcmodel=medany</span><br><span class="line"> -ffreestanding</span><br><span class="line"> -fno-common</span><br><span class="line"> -nostdlib</span><br><span class="line"> -mno-relax</span><br><span class="line"> -I.</span><br><span class="line"> -fno-stack-protector</span><br><span class="line"> -fno-pie</span><br><span class="line"> -no-pie</span><br><span class="line"> -march=rv64g</span><br><span class="line"> -nostdinc</span><br><span class="line"> -I.</span><br><span class="line"> -Ikernel</span><br><span class="line"> -c</span><br><span class="line"> user/initcode.S</span><br><span class="line"> -o</span><br><span class="line"> user/initcode.o</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-ld</span><br><span class="line"> -z</span><br><span class="line"> max-page-size=4096</span><br><span class="line"> -N</span><br><span class="line"> -e</span><br><span class="line"> start</span><br><span class="line"> -Ttext</span><br><span class="line"> 0</span><br><span class="line"> -o</span><br><span class="line"> user/initcode.out</span><br><span class="line"> user/initcode.o</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-objcopy</span><br><span class="line"> -S</span><br><span class="line"> -O</span><br><span class="line"> binary</span><br><span class="line"> user/initcode.out</span><br><span class="line"> user/initcode</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-objdump</span><br><span class="line"> -S</span><br><span class="line"> user/initcode.o</span><br><span class="line"> &gt;</span><br><span class="line"> user/initcode.asm</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-ld</span><br><span class="line"> -z</span><br><span class="line"> max-page-size=4096</span><br><span class="line"> -T</span><br><span class="line"> kernel/kernel.ld</span><br><span class="line"> -o</span><br><span class="line"> kernel/kernel</span><br><span class="line"> kernel/entry.o</span><br><span class="line"> kernel/start.o</span><br><span class="line"> kernel/console.o</span><br><span class="line"> kernel/printf.o</span><br><span class="line"> kernel/uart.o</span><br><span class="line"> kernel/kalloc.o</span><br><span class="line"> kernel/spinlock.o</span><br><span class="line"> kernel/string.o</span><br><span class="line"> kernel/main.o</span><br><span class="line"> kernel/vm.o</span><br><span class="line"> kernel/proc.o</span><br><span class="line"> kernel/swtch.o</span><br><span class="line"> kernel/trampoline.o</span><br><span class="line"> kernel/trap.o</span><br><span class="line"> kernel/syscall.o</span><br><span class="line"> kernel/sysproc.o</span><br><span class="line"> kernel/bio.o</span><br><span class="line"> kernel/fs.o</span><br><span class="line"> kernel/log.o</span><br><span class="line"> kernel/sleeplock.o</span><br><span class="line"> kernel/file.o</span><br><span class="line"> kernel/pipe.o</span><br><span class="line"> kernel/exec.o</span><br><span class="line"> kernel/sysfile.o</span><br><span class="line"> kernel/kernelvec.o</span><br><span class="line"> kernel/plic.o</span><br><span class="line"> kernel/virtio_disk.o</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-objdump</span><br><span class="line"> -S</span><br><span class="line"> kernel/kernel</span><br><span class="line"> &gt;</span><br><span class="line"> kernel/kernel.asm</span><br><span class="line"></span><br><span class="line">riscv64-linux-gnu-objdump</span><br><span class="line"> -t</span><br><span class="line"> kernel/kernel</span><br><span class="line"> |</span><br><span class="line"> sed</span><br><span class="line"> <span class="string">&#x27;1,/SYMBOL</span></span><br><span class="line"><span class="string"> TABLE/d;</span></span><br><span class="line"><span class="string"> s/</span></span><br><span class="line"><span class="string"> .*</span></span><br><span class="line"><span class="string"> /</span></span><br><span class="line"><span class="string"> /;</span></span><br><span class="line"><span class="string"> /^$/d&#x27;</span></span><br><span class="line"> &gt;</span><br><span class="line"> kernel/kernel.sym</span><br></pre></td></tr></table></figure><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>makefile中的定义的make commend<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">qemu: $K/kernel fs.img</span></span><br><span class="line"><span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">.gdbinit: .gdbinit.tmpl-riscv</span></span><br><span class="line">sed <span class="string">&quot;s/:1234/:<span class="variable">$(GDBPORT)</span>/&quot;</span> &lt; <span class="variable">$^</span> &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">qemu-gdb: $K/kernel .gdbinit fs.img</span></span><br><span class="line">@echo <span class="string">&quot;*** Now run &#x27;gdb&#x27; in another window.&quot;</span> 1&gt;&amp;2</span><br><span class="line"><span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span> -S <span class="variable">$(QEMUGDB)</span></span><br><span class="line"></span><br><span class="line"><span class="section">print-gdbport:</span></span><br><span class="line">@echo <span class="variable">$(GDBPORT)</span></span><br></pre></td></tr></table></figure></p><h3 id="终端1"><a href="#终端1" class="headerlink" title="终端1"></a>终端1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (util)&gt; make qemu-gdb</span><br><span class="line">sed <span class="string">&quot;s/:1234/:26000/&quot;</span> &lt; .gdbinit.tmpl-riscv &gt; .gdbinit</span><br><span class="line">*** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26000</span><br></pre></td></tr></table></figure><p>或者make CPUS=1 qemu-gdb，Makefile中的CPUS即qemu -smp $(CPUS)，cpu核数，设置为1时，单线程，方便调试</p><h3 id="终端2"><a href="#终端2" class="headerlink" title="终端2"></a>终端2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (util)&gt; gdb-multiarch kernel/kernel</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from kernel/kernel...</span><br><span class="line">warning: File <span class="string">&quot;/home/grand/xv6-labs-2020/.gdbinit&quot;</span> auto-loading has been declined by your `auto-load safe-path<span class="string">&#x27; set to &quot;$debugdir:$datadir/auto-load&quot;.</span></span><br><span class="line"><span class="string">To enable execution of this file add</span></span><br><span class="line"><span class="string">        add-auto-load-safe-path /home/grand/xv6-labs-2020/.gdbinit</span></span><br><span class="line"><span class="string">line to your configuration file &quot;/home/grand/.gdbinit&quot;.</span></span><br><span class="line"><span class="string">To completely disable this security protection add</span></span><br><span class="line"><span class="string">        set auto-load safe-path /</span></span><br><span class="line"><span class="string">line to your configuration file &quot;/home/grand/.gdbinit&quot;.</span></span><br><span class="line"><span class="string">For more information about this security protection see the</span></span><br><span class="line"><span class="string">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span></span><br></pre></td></tr></table></figure><p>按q回车退出，在/home/grand/.gdbinit中添加add-auto-load-safe-path /home/grand/xv6-labs-2020/.gdbinit<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (util) [1]&gt; <span class="built_in">echo</span> <span class="string">&quot;add-auto-load-safe-path /home/grand/xv6-labs-2020/.gdbinit&quot;</span> &gt;&gt; <span class="string">&quot;/home/grand/.gdbinit&quot;</span></span><br></pre></td></tr></table></figure></p><p>重新运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grand@Lubuntu ~/xv6-labs-2020 (util)&gt; gdb-multiarch kernel/kernel</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.                                                                                   </span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from kernel/kernel...</span><br><span class="line">The target architecture is assumed to be riscv:rv64</span><br><span class="line">0x0000000000001000 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><br>现在就可以去调试了，快来试试下面的命令，了解熟悉gdb的基本调试操作。</p><h2 id="gdb常用命令"><a href="#gdb常用命令" class="headerlink" title="gdb常用命令"></a>gdb常用命令</h2><p>tui界面相关的（Text User Interface commands）</p><ul><li>tui enable    启动tui界面，默认显示源码</li><li>tui disable   关闭tui界面</li><li>layout asm    启动tui界面，查看汇编代码</li><li>layout src    启动tui界面，查看源码</li><li>layout split  启动tui界面，同时查看源码和汇编</li><li>layout reg    启动tui节目，查看寄存器</li><li>focus [win]   多个窗口时，可以聚焦到某一窗口，例如focus src, focus asm, focus reg</li></ul><p>执行相关的</p><ul><li>si            执行一条汇编指令</li><li>ni            执行一条汇编指令，若是跳转指令，则执行完返回。</li><li>s             执行一行代码，进入函数，step</li><li>n             执行一行代码，不进入函数，next</li><li>c             继续运行，遇到断点暂停，continue</li><li>r             执行整个程序，遇到断点暂停，run</li><li>finish        函数结束，遇到断点暂停</li></ul><p>断点</p><ul><li>b [func]      添加断点，如b main</li><li>b [line]      添加断点，如b 17</li><li>b filename:[line/func]  添加断点，如b kernel/main.c:15</li><li>i breakpoints 查看断点的信息</li><li>d [num]       删除断点/观察点，如b 1，不填num时，删除所有的断点</li></ul><p>观察点</p><ul><li>watch [val]  设置观察点，当某个变量的值发生变化时，暂停提示</li><li>watch [expr] 设置观察点，当表达式发生变化时，暂停提示</li><li>d [num]      删除断点/观察点</li></ul><p>查看</p><ul><li>p [var]       打印某个变量</li><li>i locals      查看局部变量</li><li>i args        查看函数的入参</li><li>i frame       查看当前栈帧信息</li><li>bt/basktrace  查看所有栈帧的位置</li><li>frame [num]   查看某个栈帧的信息</li></ul><h2 id="vscode调试"><a href="#vscode调试" class="headerlink" title="vscode调试"></a>vscode调试</h2><h3 id="ssh远程链接"><a href="#ssh远程链接" class="headerlink" title="ssh远程链接"></a>ssh远程链接</h3><ul><li>在vscode安装ssh插件，在ubuntu安装openssh-server<ul><li>sudo apt install openssh-server<ul><li>出错了先按照提示安装依赖，sudo apt-get install openssh-client=1:8.2p1-4</li><li>再重新安装</li></ul></li></ul></li><li>给ubuntu添加一个网络适配器，设定为仅主机模式</li><li>在ubuntu给该网卡设定静态ip</li><li>最后在vscode登录，username@ip，输入密码</li></ul><h3 id="vscode配置教程"><a href="#vscode配置教程" class="headerlink" title="vscode配置教程"></a>vscode配置教程</h3><ul><li><a href="https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6/">https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6/</a></li><li><a href="https://zhuanlan.zhihu.com/p/501901665">https://zhuanlan.zhihu.com/p/501901665</a></li></ul><h3 id="调试手册和实验手册"><a href="#调试手册和实验手册" class="headerlink" title="调试手册和实验手册"></a>调试手册和实验手册</h3><ul><li><a href="http://hitsz-cslab.gitee.io/os-labs/remote_env_gdb/">http://hitsz-cslab.gitee.io/os-labs/remote_env_gdb/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第九章</title>
      <link href="/2022/08/31/xv6-Chapter-9/"/>
      <url>/2022/08/31/xv6-Chapter-9/</url>
      
        <content type="html"><![CDATA[<h2 id="第九章：并发"><a href="#第九章：并发" class="headerlink" title="第九章：并发"></a>第九章：并发</h2><p>要同时获得良好的的性能、并发的正确性和易于理解的代码是内核设计的一大挑战。直接使用锁是保证正确性的最佳途径，但不总是可行的。本章重点介绍了xv6不得不使用锁的例子，以及使用类似锁（但不是锁）的例子。</p><h3 id="9-1-Locking-patterns"><a href="#9-1-Locking-patterns" class="headerlink" title="9.1 Locking patterns"></a>9.1 Locking patterns</h3><p>缓存项通常是锁的一个挑战。例如，文件系统的块缓存(kernel/bio.c:26)存储了<strong>NBUF</strong>个磁盘块的副本。一个给定的磁盘块在缓存中最多只有一个副本，这一点非常重要；否则，不同的进程对同一磁盘块的不同副本进行修改时可能会发生冲突。每一个缓存的磁盘块都被存储在一个<strong>buf</strong>结构中(kernel/buf.h:1)。<strong>buf</strong>结构有一个锁字段，它确保每次只有一个进程使用一个给定的磁盘块。然而，这个锁是不够的：如果一个块根本不存在于缓存中，而两个进程想同时使用它怎么办？没有 <strong>buf</strong> (因为该块还没有被缓存)，因此没有能加锁的东西。Xv6对所有块的标识符关联一个额外的锁来处理这种情况。判断块是否被缓存的代码（e.g.  bget(kernel/bio.c:59)），或改变缓存块集合的代码，必须持有<strong>bcache.lock</strong>。当代码找到它所需要的块和<strong>buf</strong>结构后，它就可以释放<strong>bcache.lock，</strong>然后锁定特定的块，这是一种通用模式：一组一把锁，外加每个项一把锁。</p><p>通常情况下，获取锁的函数会释放那把锁。但更准确的说法是，当一个序列需要保证原子性时，会在该序列开始时获取锁，而在序列结束时释放锁。如果序列的开始和结束在不同的函数中，或者不同的线程中，或者在不同的CPU上，那么锁的获取和释放也必须是一样的。锁的功能是强制其他的使用者等待，而不是将一段数据绑定给特定的代理。一个例子是yield中的<strong>acquire</strong>(kernel/proc.c:515)，它是在调度线程中释放的，而不是在获取锁的进程中释放的。另一个例子是<strong>ilock</strong>(kernel/fs.c:289)中的<strong>acquiresleep</strong>；这段代码经常在读取磁盘时睡眠；它可能在不同的CPU上被唤醒，这意味着锁可能在不同的CPU上获取和释放。</p><p>释放一个被锁保护的且锁内嵌在其中的对象是一件很棘手的事情，因为拥有锁并不足以保证释放对象的正确性。当有其他线程在<strong>acquire</strong>中等待时，问题就会出现；释放这个对象就意味着释放内嵌的锁，而释放这个锁会导致等待线程出错。一种方式是追踪该对象有多少个引用，只有在最后一个引用消失时才会释放对象。<strong>pipeclose (kernel/pipe.c:59)</strong>就是这样的例子。<strong>pi-&gt;readopen</strong>和<strong>pi-&gt;writeopen</strong>跟踪是否有文件描述符引用该管道。</p><h3 id="9-2-Lock-like-patterns"><a href="#9-2-Lock-like-patterns" class="headerlink" title="9.2 Lock-like patterns"></a>9.2 Lock-like patterns</h3><p>在许多地方，xv6使用引用计数或标志位作为一种软锁（soft lock），以表明一个对象已被分配，不应该被释放或重用。进程的<strong>p-&gt;state</strong>依此工作，<strong>file</strong>、<strong>inode</strong>和<strong>buf</strong>结构中的引用计数也是如此。虽然在每种情况下，锁都会保护标志位或引用计数，但正是标志位或引用计数防止了对象被过早释放。  </p><p>文件系统使用结构体<strong>inode</strong>的引用计数作为一种共享锁，可以由多个进程持有，以避免代码使用普通锁时出现的死锁。例如，<strong>namex</strong>(kernel/fs.c:626)中的循环依次锁定路径上的每个目录。然而，<strong>namex</strong>必须在循环末尾释放每一个锁，因为如果它持有多个锁，那么如果路径名中包含.(即当前目录，例如，a/./b)，它可能会与自己发生死锁。它也可能因为涉及目录和..的并发查找而死锁。正如第8章所解释的那样，解决方案是让循环将目录的inode带入下一次迭代，并增加其引用计数，但不锁定。</p><p>有些数据项在不同的时候会受到不同机制的保护。它有时可能会被xv6代码的结构隐式保护，而不是通过显式的锁来防止并发访问。例如，当一个物理页是空闲的时候，它被<strong>kmem.lock（kernel/kalloc.c:24）</strong>保护。如果页面被分配作为管道(kernel/pipe.c:23)，它将被一个不同的锁(内嵌的<strong>pi-&gt;lock</strong>)保护。如果该页被重新分配给一个新进程的用户内存，它就不会受到锁的保护。相反，分配器不会将该页交给任何其他进程（直到它被释放）的事实保护了它不被并发访问。一个新进程的内存的所有权是很复杂的：首先父进程在<strong>fork</strong>中分配和操作它，然后子进程使用它，（在子进程退出后）父进程再次拥有内存，并将其传递给<strong>kfree</strong>。这里有两个需要注意的地方：第一，一个数据对象在其生命周期中的不同时刻可以用不同的方式来保护它不被并发访问；第二，保护的形式可能是隐式结构而不是显式锁。</p><p>最后一个类似于锁的例子是在调用<strong>mycpu()</strong>(kernel/proc.c:68)时需要禁用中断。禁用中断会导致调用代码对定时器中断是原子性的，而定时器中断可能会强制上下文切换，从而将进程移到不同的CPU上。</p><h3 id="9-3-No-locks-at-all"><a href="#9-3-No-locks-at-all" class="headerlink" title="9.3 No locks at all"></a>9.3 No locks at all</h3><p>xv6有几个地方是在完全没有锁的情况下共享可变数据的。一个是在<strong>spinlocks</strong>的实现中，尽管你可以把RISC-V原子指令看作是依靠硬件实现的锁。另一个是<strong>main.c</strong> (kernel/main.c:7)中的<strong>started</strong>变量，用来防止其他CPU运行，直到CPU 0完成xv6的初始化；<strong>volatile</strong>确保编译器真正生成加载和存储指令。第三个例子是proc.c(kernel.proc.c:398)(kernel/proc.c:306)中的p-&gt;parent。它的一些用法会导致死锁，但是明显不会有其他进程能够同时修改p-&gt;parent。第四个例子是p-&gt;killed。它在持有p-&gt;lock时被设置，但在检查时却并不需要锁。</p><p>Xv6包含这样的情况：一个CPU或线程写一些数据，另一个CPU或线程读数据，但没有专门的锁来保护这些数据。例如，在<strong>fork</strong>中，父进程写入子进程的用户内存页，子进程(可能在不同的CPU上)读取这些页。这些页没有锁来显式地保护。严格来说，这不是锁的问题，因为子进程在父进程写完后才开始执行。这是一个潜在的内存操作的顺序问题（见第6章），因为没有内存屏障，没有理由期望一个CPU看到另一个CPU的写入。然而，由于父进程CPU释放锁，而子进程CPU在启动时获取锁，所以在<strong>acquire</strong>和<strong>release</strong>中的内存屏障保证了子进程CPU能看到父进程CPU的写入。</p><h3 id="9-4-Parallelism"><a href="#9-4-Parallelism" class="headerlink" title="9.4 Parallelism"></a>9.4 Parallelism</h3><p>锁主要是为了正确性而抑制并行性。但是性能也很重要，所以内核设计者经常要考虑如何使用锁，来同时保证正确性和良好的并行性。虽然xv6并未对高性能进行系统地设计，但仍然值得考虑哪些xv6操作可以并行执行，哪些操作可能在锁上发生冲突。</p><p>xv6中的管道是一个并行性相当好的例子。每个管道都有自己的锁，因此不同的进程可以在不同的CPU上并行读写不同的管道。然而，对于一个给定的管道，writer和reader必须等待对方释放锁，他们不能同时读/写同一个管道。还有一种情况是，从一个空管道读（或向一个满管道写）必须阻塞，但这不是锁的方案导致的问题。</p><p>上下文切换是一个更复杂的例子。两个在各自CPU上执行的内核线程，可以同时调用<strong>yield</strong>、<strong>sched</strong>和<strong>swtch</strong>，并且这些调用能并行执行。这两个线程各自持有一个锁，但是不同的锁，所以它们不必等待对方。一旦进入<strong>scheduler</strong>，两个CPU在遍历进程表寻找一个RUNNABLE的进程的时候，却可能会发生锁冲突。也就是说，xv6在上下文切换的过程中，很可能会从多个CPU中获得性能上的好处，但可能没有那么多。</p><p>另一个例子是在不同的CPU上从不同的进程并发调用<strong>fork</strong>。这些调用可能需要互相等待<strong>pid_lock</strong>和<strong>kmem.lock</strong>，以及在进程表中搜索一个<strong>UNUSED</strong>进程所需的进程锁。另一方面，两个正在fork的进程可以完全并行地复制用户内存页和格式化页表页。</p><p>上述每个例子中的锁方案在某些情况下都牺牲了并行性能。在每一种情况下，都有可能通过更复杂的设计获得更多的并行性。这是否值得取决于细节：相关操作被调用的频率、代码在锁竞争的情况下所花费的时间、有多少CPU可能同时运行冲突的操作、是否代码的其他部分才是性能瓶颈。很难猜测一个给定的锁方案是否会导致性能问题，或者一个新的设计是否有明显的改进，所以往往需要在现实的工作负载上进行测量。</p><h3 id="9-5-Exercises"><a href="#9-5-Exercises" class="headerlink" title="9.5 Exercises"></a>9.5 Exercises</h3><ol><li><p>修改xv6管道的实现，允许对同一管道的读和写在不同内核上并行进行。</p></li><li><p>修改xv6 <strong>scheduler()</strong>，以减少不同内核同时寻找可运行进程时的锁竞争。</p></li><li><p>消除<strong>fork</strong>中一些串行执行的代码。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第八章</title>
      <link href="/2022/08/31/xv6-Chapter-8/"/>
      <url>/2022/08/31/xv6-Chapter-8/</url>
      
        <content type="html"><![CDATA[<h2 id="第八章：文件系统"><a href="#第八章：文件系统" class="headerlink" title="第八章：文件系统"></a>第八章：文件系统</h2><p>文件系统的目的是组织和存储数据。文件系统通常支持用户和应用程序之间的数据共享，以及支持持久性，以便数据在重启后仍然可用。</p><p>xv6文件系统提供了类Unix的文件、目录和路径名（见第1章），并将其数据存储在virtio磁盘上以实现持久化（见第4章）。该文件系统解决了几个挑战：</p><ul><li><p>文件系统需要磁盘上的数据结构来表示命名目录和文件的树，记录保存每个文件内容的块的身份，并记录磁盘上哪些区域是空闲的。</p></li><li><p>文件系统必须支持崩溃恢复。也就是说，如果发生崩溃（如电源故障），文件系统必须在重新启动后仍能正常工作。风险在于，崩溃可能会中断更新序列，并在磁盘上留下不一致的数据结构（例如，一个块既在文件中使用，又被标记为空闲）。</p></li><li><p>不同的进程可能并发在文件系统上运行，所以文件系统代码必须协调维护每一个临界区。</p></li><li><p>访问磁盘的速度比访问内存的速度要慢几个数量级，所以文件系统必须在内存维护一个缓冲区，用于缓存常用块。</p></li></ul><p>本章剩下的部分将解释xv6如何解决这些问题。</p><h3 id="8-1-Overview"><a href="#8-1-Overview" class="headerlink" title="8.1 Overview"></a>8.1 Overview</h3><p><img src="/img/Figure-8.1.png" alt="Figure-8.1"></p><p>xv6文件系统的实现分为七层，如图8.1所示。disk层在virtio磁盘上读写块。Buffer cache缓存磁盘块，并同步访问它们，确保一个块只能同时被内核中的一个进程访问。日志层允许上层通过事务更新多个磁盘块，并确保在崩溃时，磁盘块是原子更新的（即全部更新或不更新）。inode层将一个文件都表示为一个<strong>inode</strong>，每个文件包含一个唯一的i-number和一些存放文件数据的块。目录层将实现了一种特殊的<strong>inode</strong>，被称为目录，其包含一个目录项序列，每个目录项由文件名称和i-number组成。路径名层提供了层次化的路径名，如/<strong>usr/rtm/xv6/fs.c</strong>，可以用递归查找解析他们。文件描述符层用文件系统接口抽象了许多Unix资源（如管道、设备、文件等），使程序员的生产力得到大大的提高。</p><p><img src="/img/Figure-8.2.png" alt="Figure-8.2"></p><p> 文件系统必须安排好磁盘存储inode和内容块的位置。为此，xv6将磁盘分为几个部分，如图8.2所示。文件系统不使用块0（它存放boot sector）。第1块称为<strong><em>superblock</em></strong>，它包含了文件系统的元数据（以块为单位的文件系统大小、数据块的数量、inode的数量和日志中的块数）。从块2开始存放着日志。日志之后是inodes，每个块会包含多个inode。在这些块之后是<strong><em>位图块(bitmap)</em></strong>，记录哪些数据块在使用。其余的块是数据块，每个数据块要么在bitmap块中标记为空闲，要么持有文件或目录的内容。超级块由一个单独的程序<strong>mkfs</strong>写入，它建立了一个初始文件系统。</p><p>本章的其余部分将讨论每一层，从buffer缓存开始。从讨论中我们将看到如何选择合适的低层抽象，来方便更高层的设计。 </p><h3 id="8-2-Buffer-cache-layer"><a href="#8-2-Buffer-cache-layer" class="headerlink" title="8.2 Buffer cache layer"></a>8.2 Buffer cache layer</h3><p>buffer缓存有两项工作。(1)同步访问磁盘块，以确保磁盘块在内存中只有一个buffer缓存，并且一次只有一个内核线程能使用该buffer缓存；(2)缓存使用较多的块，这样它们就不需要从慢速磁盘中重新读取。代码见<strong>bio.c</strong>。</p><p>buffer缓存的主要接口包括<strong>bread</strong>和<strong>bwrite</strong>，bread返回一个在内存中可以读取和修改的块副本<strong>buf</strong>，<strong>bwrite</strong>将修改后的buffer写到磁盘上相应的块。内核线程在使用完一个buffer后，必须通过调用<strong>brelse</strong>释放它。buffer缓存为每个buffer的都设有sleep-lock，以确保每次只有一个线程使用buffer（从而使用相应的磁盘块）；<strong>bread</strong> 返回的buffer会被锁定，而<strong>brelse</strong>释放锁。</p><p>我们再来看看buffer缓存。buffer缓存有固定数量的buffer来存放磁盘块，这意味着如果文件系统需要一个尚未被缓存的块，buffer缓存必须回收一个当前存放其他块的buffer。buffer缓存为新块寻找最近使用最少的buffer（lru机制）。因为最近使用最少的buffer是最不可能被再次使用的buffer。</p><h3 id="8-3-Code-Buffer-cache"><a href="#8-3-Code-Buffer-cache" class="headerlink" title="8.3 Code: Buffer cache"></a>8.3 Code: Buffer cache</h3><p>buffer缓存是一个由buffer组成的双端链表。由函数<strong>binit</strong>用静态数组<strong>buf</strong>初始化这个链表， <strong>binit</strong>在启动时由<strong>main</strong>(kernel/main.c:27)调用。访问buffer缓存是通过链表，而不是<strong>buf</strong>数组。</p><p>buffer有两个与之相关的状态字段。字段<strong>valid</strong>表示是否包含该块的副本（是否从磁盘读取了数据）。字段<strong>disk</strong>表示缓冲区的内容已经被修改需要被重新写入磁盘。</p><p><strong>bget</strong> (kernel/bio.c:59)扫描buffer链表，寻找给定设备号和扇区号来查找缓冲区(kernel/bio.c:65-73)。如果存在，<strong>bget</strong>就会获取该buffer的sleep-lock。然后<strong>bget</strong>返回被锁定的buffer。</p><p>如果给定的扇区没有缓存的buffer，<strong>bget</strong>必须生成一个，可能会使用一个存放不同扇区的buffer，它再次扫描buffer链表，寻找没有被使用的buffer(<strong>b-&gt;refcnt = 0</strong>)；任何这样的buffer都可以使用。任何这样的buffer都可以使用。bget修改buffer元数据，记录新的设备号和扇区号，并获得其sleep-lock。请注意，<strong>b-&gt;valid = 0</strong>可以确保bread从磁盘读取块数据，而不是错误地使用buffer之前的内容。</p><p>请注意，每个磁盘扇区最多只能有一个buffer，以确保写操作对读取者可见，也因为文件系统需要使用buffer上的锁来进行同步。<strong>Bget</strong>通过从第一次循环检查块是否被缓存，第二次循环来生成一个相应的buffer（通过设置<strong>dev</strong>、<strong>blockno</strong>和<strong>refcnt</strong>），在进行这两步操作时，需要一直持有<strong>bache.lock</strong> 。持有<strong>bache.lock</strong>会保证上面两个循环在整体上是原子的。</p><p><strong>bget</strong>在<strong>bcache.lock</strong>保护的临界区之外获取buffer的sleep-lock是安全的，因为非零的<strong>b-&gt;refcnt</strong>可以防止缓冲区被重新用于不同的磁盘块。sleep-lock保护的是块的缓冲内容的读写，而bcache.lock保护被缓存块的信息。</p><p>如果所有buffer都在使用，那么太多的进程同时在执行文件相关的系统调用，bget就会<strong>panic</strong>。一个更好的处理方式可能是睡眠，直到有buffer空闲，尽管这时有可能出现死锁。</p><p>一旦<strong>bread</strong>读取了磁盘内容（如果需要的话）并将缓冲区返回给它的调用者，调用者就独占该buffer，可以读取或写入数据。如果调用者修改了buffer，它必须在释放buffer之前调用<strong>bwrite</strong>将修改后的数据写入磁盘。<strong>bwrite</strong> (kernel/bio.c:107)调用<strong>virtio_disk_rw</strong>与磁盘硬件交互。</p><p>当调用者处理完一个buffer后，必须调用<strong>brelse</strong>来释放它。(<strong>brelse</strong>这个名字是<strong>b-release</strong>的缩写，虽然很神秘，但值得学习，它起源于Unix，在BSD、Linux和Solaris中也有使用。) <strong>brelse</strong> (kernel/bio.c:117)释放sleep-lock，并将该buffer移动到链表的头部(kernel/bio.c:128-133)。移动buffer会使链表按照buffer最近使用的时间（最近释放）排序，链表中的第一个buffer是最近使用的，最后一个是最早使用的。<strong>bget</strong>中的两个循环利用了这一点，在最坏的情况下，获取已缓存buffer的扫描必须处理整个链表，由于数据局部性，先检查最近使用的缓冲区（从<strong>bcache.head</strong>开始，通过<strong>next</strong>指针）将减少扫描时间。扫描选取可使用buffer的方法是通过从后向前扫描（通过<strong>prev</strong>指针）选取最近使用最少的缓冲区。</p><h3 id="8-4-Logging-layer"><a href="#8-4-Logging-layer" class="headerlink" title="8.4 Logging layer"></a>8.4 Logging layer</h3><p>文件系统设计中最有趣的问题之一是崩溃恢复。这个问题的出现是因为许多文件系统操作涉及到对磁盘的多次写入，如果只执行了部分写操作，然后发生崩溃可能会使磁盘上的文件系统处于不一致的状态。例如，假设在文件截断（将文件的长度设置为零并释放其内容块）时发生崩溃。根据磁盘写入的顺序，可能会留下一个引用空闲内容块的inode，也可能会留下一个已分配但没有被引用的内容块。</p><p>后面的这种情况相对来说好一点，但是如果一个inode指向被释放的块，很可能在重启后造成严重的问题。重启后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向了同一个块。如果xv6支持多用户，这种情况可能是一个安全问题，因为旧文件的所有者能够读写新文件，即使该文件被另一个用户所拥有。</p><p>Xv6通过简单的日志系统来解决文件系统操作过程中崩溃带来的问题。xv6的系统调用不直接写磁盘上的文件系统数据结构。相反，它将写入的数据记录在磁盘上的日志中。一旦系统调用记录了全部的写入数据，它就会在磁盘上写一个特殊的提交记录，表明该日志包含了一个完整的操作。这时，系统调用就会将日志中的写入数据写到磁盘上相应的位置。在执行完成后，系统调用将磁盘上的日志清除。</p><p>如果系统崩溃并重启，文件系统会在启动过程中恢复自己。如果日志被标记为包含一个完整的操作，那么恢复代码就会将写入的内容复制到它们在磁盘文件系统中的相应位置。如果日志未被标记为包含完整的操作，则恢复代码将忽略并清除该日志。</p><p>为什么xv6的日志系统可以解决文件系统操作过程中的崩溃问题？如果崩溃发生在操作提交之前，那么磁盘上的日志将不会被标记为完成，恢复代码将忽略它，磁盘的状态就像操作根本没有开始一样。如果崩溃发生在操作提交之后，那么恢复代码会重新执行写操作，可能会重复执行之前的写操作。不管是哪种情况，日志都会使写与崩溃为原子的，即恢复后，所有操作的写入内容，要么都在磁盘上，要么都不在。</p><h3 id="8-5-Log-design"><a href="#8-5-Log-design" class="headerlink" title="8.5 Log design"></a>8.5 Log design</h3><p>日志贮存在一个固定位置，由<strong><em>superblock</em></strong>指定。它由一个header块组成，后面是一连串的更新块副本（日志块）。header块包含一个扇区号数组，其中的每个扇区号都对应一个日志块<a href="#ftn1">[1]</a>，header还包含日志块的数量。磁盘上header块中的数量要么为零，表示日志中没有事务，要么为非零，表示日志中包含一个完整的提交事务，并有指定数量的日志块。Xv6在事务提交时会修改 header块，将日志块复制到文件系统后，会将数量设为零。因此，一个事务中途的崩溃将导致日志header块中的计数为零；提交后的崩溃的计数为非零。</p><p>为了应对崩溃，每个系统调用都包含一个原子写序列。为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写操作累积到一个事务中。因此，一次提交可能涉及多个完整系统调用的写入。为了避免一个系统调用被分裂到不同的事务中，只有在没有文件系统相关的系统调用正在进行时，日志系统才会提交。</p><p>将几个事务一起提交的方法被称为组提交（group commit）。组提交可以减少磁盘操作的次数，因为它将提交的固定成本分摊在了多个操作上。组提交可以让文件系统同时执行更多的并发写，也可以让磁盘在一次磁盘轮转中把它们全部写入。Xv6的virtio驱动不支持这种批处理，但xv6的文件系统实现了这种方式。</p><p>Xv6在磁盘上划出固定的空间来存放日志。在一个事务中，系统调用所写的块总数必须适应这个空间的大小。这将导致两个后果：</p><p>1、系统调用写入的日志大小必须小于日志空间的大小。这对大多数系统调用来说都不是问题，但有两个系统调用可能会写很多块，<strong>write</strong>和<strong>unlink</strong>。大文件的write可能会写很多数据块和bitmap块，以及一个inode块；取消链接一个大文件可能会写很多bitmap块和一个inode。Xv6的<strong>write</strong>系统调用将大的写操作分解成多个小的写操作，以适应在日志空间的大小，而<strong>unlink</strong>不会引起问题，因为xv6文件系统只使用一个位图块。</p><p>2、日志空间有限的另一个后果是，日志系统只会在确定了系统调用的写操作可以适应剩余日志空间之后，才会开始执行该系统调用。</p><h3 id="8-6-Code-logging"><a href="#8-6-Code-logging" class="headerlink" title="8.6 Code: logging"></a>8.6 Code: logging</h3><p>系统调用中一般用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure><p><strong>begin_op</strong>(kernel/log.c:126)会一直等到日志系统没有commiting，并且有足够的日志空间来容纳这次调用的写。<strong>log.outstanding</strong>统计当前系统调用的数量，可以通过<strong>log.outstanding</strong>乘以<strong>MAXOPBLOCKS</strong>来计算已使用的日志空间。自增<strong>log.outstanding</strong>既能预留空间，又能防止该系统调用期间进行提交。该代码假设每次系统调用最多写入<strong>MAXOPBLOCKS</strong>个块。</p><p>​    <strong>log_write</strong> (kernel/log.c:214) 是<strong>bwrite</strong>的代理。它将扇区号记录在内存中，在磁盘上的日志中使用一个槽，并自增<strong>buffer.refcnt</strong>防止该<strong>buffer</strong>被重用。在提交之前，块必须留在缓存中，即该缓存的副本是修改的唯一记录；在提交之后才能将其写入磁盘上的位置；该次修改必须对其他读可见。 注意，当一个块在一个事务中被多次写入时，他们在日志中的槽是相同的。这种优化通常被称为<strong><em>absorption</em></strong>(吸收)。例如，在一个事务中，包含多个文件的多个inode的磁盘块被写多次，这是常见的情况。通过将几次磁盘写<strong><em>吸收</em></strong>为一次，文件系统可以节省日志空间，并且可以获得更好的性能，因为只有一份磁盘块的副本必须写入磁盘。</p><p><strong>end_op</strong> (kernel/log.c:146)首先递减<strong>log.outstanding</strong>。如果计数为零，则通过调用<strong>commit()</strong>来提交当前事务。</p><p><strong>Commit</strong>分为四个阶段：</p><p>1、<strong>write_log</strong>()(kernel/log.c:178)将事务中修改的每个块从buffer缓存中复制到磁盘上的日志槽中。</p><p>2、 <strong>write_head</strong>()(kernel/log.c:102)将header块写到磁盘上，就表明已提交，为提交点，写完日志后的崩溃，会导致在重启后重新执行日志。</p><p>3、<strong>install_trans</strong>(kernel/log.c:69)从日志中读取每个块，并将其写到文件系统中对应的位置。</p><p>4、最后修改日志块计数为0，并写入日志空间的header部分。这必须在下一个事务开始之前修改，这样崩溃就不会导致重启后的恢复使用这次的header和下次的日志块。</p><p><strong>recover_from_log</strong> (kernel/log.c:116) 是在 <strong>initlog</strong> (kernel/log.c:55) 中调用的，而 <strong>initlog</strong> 是在第一个用户进程运行 (kernel/proc.c:539) 之前, 由 <strong>fsinit</strong>(kernel/fs.c:42) 调用的。它读取日志头，如果日志头显示日志中包含一个已提交的事务，则会像<strong>end_op</strong>那样执行日志。</p><p>一个使用了日志的例子是filewrite (kernel/file.c:135)。这个事务看起来像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">ilock(f-&gt;ip);</span><br><span class="line">r = writei(f-&gt;ip, ...);</span><br><span class="line">iunlock(f-&gt;ip);</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure><p>这段代码被包裹在一个循环中，它将大的写分解成每次只有几个扇区的单独事务，以避免溢出日志空间。调用 <strong>writei</strong> 写入许多块作为这个事务的一部分：文件的 inode，一个或多个bitmap块，以及一些数据块。</p><h3 id="8-7-Code-Block-allocator"><a href="#8-7-Code-Block-allocator" class="headerlink" title="8.7 Code: Block allocator"></a>8.7 Code: Block allocator</h3><p>文件和目录存储在磁盘块中，必须从空闲池中分配，xv6的块分配器在磁盘上维护一个bitmap，每个块对应一个位。0表示对应的块是空闲的，1表示正在使用中。程序mkfs设置引导扇区、超级块、日志块、inode块和位图块对应的位。</p><p>块分配器提供了两个函数：<strong>balloc</strong>申请一个新的磁盘块，<strong>bfree</strong>释放一个块。<strong>balloc</strong> (kernel/fs.c:71)会有一个循环遍历每一个块，从块 0 开始，直到 <strong>sb.size</strong>，即文件系统中的块数。它寻找一个位为0的空闲块。如果 <strong>balloc</strong> 找到了这样一个块，它就会更新bitmap并返回该块。为了提高效率，这个循环被分成两部分。外循环读取bitmap的一个块，内循环检查块中的所有BPB位。如果两个进程同时试图分配一个块，可能会发生竞争，但buffer缓存只允许块同时被一个进程访问，这就避免了这种情况的发生。</p><p><strong>Bfree</strong> (kernel/fs.c:90) 找到相应的bitmap块并清除相应的位。<strong>bread</strong>和<strong>brelse</strong>暗含的独占性避免了显式锁定。</p><p>与本章其余部分描述的大部分代码一样，<strong>balloc</strong>和<strong>bfree</strong>必须在事务中被调用。</p><h3 id="8-8-Inode-layer"><a href="#8-8-Inode-layer" class="headerlink" title="8.8 Inode layer"></a>8.8 Inode layer</h3><p>术语inode有两种相关的含义。1、指的是磁盘上的数据结构，其中包含了文件的大小和数据块号的列表；2、指的是内存中的inode，它包含了磁盘上inode的副本以及内核中需要的其他信息。</p><p>磁盘上的inode被放置磁盘的一个连续区域。每一个inode的大小都是一样的，所以，给定一个数字n，很容易找到磁盘上的第n个inode。事实上，这个数字n，被称为inode号或i-number，在实现中就是通过这个识别inode的。</p><p>结构体<strong>dinode</strong>(kernel/fs.h:32)定义了磁盘上的inode。<strong>type</strong>字段区分了文件、目录和特殊文件（设备）。type为0表示该inode是空闲的。<strong>nlink</strong>字段统计引用这个inode的目录项的数量，当引用数为0时就释放磁盘上的inode及其数据块。<strong>size</strong>字段记录了文件中内容的字节数。<strong>addrs</strong>数组记录了持有文件内容的磁盘块的块号。</p><p>内核将在使用的inode保存在内存中；结构体<strong>inode</strong> (kernel/file.h:17)是磁盘<strong>dinode</strong>的拷贝。内核只在有指针指向inode才会储存。<strong>ref</strong>字段为指向inode的指针的数量，如果引用数量减少到零，内核就会从内存中丢弃这个inode。<strong>iget</strong>和<strong>iput</strong>函数引用和释放inode，并修改引用计数。指向inode的指针可以来自文件描述符，当前工作目录，以及短暂的内核代码，如<strong>exec</strong>。</p><p>在xv6的inode代码中，有四种锁或类似锁的机制。<strong>icache.lock</strong>保证了一个inode在缓存只有一个副本，以及缓存inode的<strong>ref</strong>字段计数正确。每个内存中的inode都有一个包含sleep-lock的锁字段，它保证了可以独占访问inode的其他字段（如文件长度）以及inode的文件或目录内容块的。一个inode的<strong>ref</strong>如果大于0，则会使系统将该inode保留在缓存中，而不会重用该inode。最后，每个inode都包含一个<strong>nlink</strong>字段(在磁盘上，缓存时会复制到内存中)，该字段统计链接该inode的目录项的数量；如果一个inode的链接数大于零，xv6不会释放它。</p><p>在xv6的inode代码中，有四种锁或类似锁的机制。<strong>icache.lock</strong>保证了一个inode在缓存只有一个副本，以及缓存inode的<strong>ref</strong>字段计数正确。每个内存中的inode都有一个包含sleep-lock的锁字段，它保证了可以独占访问inode的其他字段（如文件长度）以及inode的文件或目录内容块的。一个inode的<strong>ref</strong>如果大于0，则会使系统将该inode保留在缓存中，而不会重用该缓存buffer。最后，每个inode都包含一个<strong>nlink</strong>字段(在磁盘上，如果是缓存，则复制在内存中)，该字段统计引用文件的目录项的数量；只有当inode的链接数为零时，xv6才会释放它。</p><p><strong>iget()</strong>返回的<strong>inode</strong>指针在调用iput()之前都是有效的；inode不会被删除，指针所引用的内存也不会被另一个inode重新使用。<strong>iget()</strong>提供了对inode的非独占性访问，因此可以有许多指针指向同一个inode。文件系统代码中的许多部分都依赖于<strong>iget()</strong>的这种行为，既是为了保持对inode的长期引用(如打开的文件和当前目录)，也是为了防止竞争，同时避免在操作多个inode的代码中出现死锁(如路径名查找)。</p><p>inode缓存只缓存被指针指向的inode。它的主要工作其实是同步多个进程的访问，缓存是次要的。如果一个inode被频繁使用，如果不被inode缓存保存，buffer缓存可能会把它保存在内存中。inode缓存是<strong><em>write-through</em></strong>的，这意味着缓存的inode被修改，就必须立即用<strong>iupdate</strong>把它写入磁盘。</p><h3 id="8-9-Code-Inodes"><a href="#8-9-Code-Inodes" class="headerlink" title="8.9 Code: Inodes"></a>8.9 Code: Inodes</h3><p>要创建一个新的inode(例如，当创建一个文件时)，xv6会调用<strong>ialloc</strong>(kernel/fs.c:196)。<strong>ialloc</strong> 类似于 <strong>balloc</strong>：它遍历磁盘上的 inode ，寻找一个被标记为空闲的inode。当它找到后，它会修改该inode的<strong>type</strong>字段来使用它，最后调用 <strong>iget</strong> (kernel/fs.c:210) 来从 inode 缓存中返回一个条目。由于一次只能有一个进程持有对<strong>bp:ialloc</strong>的引用，所以可以确保其他进程不会同时看到inode是可用的并使用它。</p><p><strong>Iget</strong> (kernel/fs.c:243) 在 inode 缓存中寻找一个带有所需设备号和 inode 号码的active条目 (ip-&gt;ref &gt; 0)。如果它找到了，它就返回一个新的对该inode的引用(kernel/fs.c:252-256)。当 <strong>iget</strong> 扫描时，它会记录第一个空槽的位置 (kernel/fs.c:257- 258)，当它需要分配一个缓存条目时，它会使用这个空槽。</p><p>在读写inode的元数据或内容之前，代码必须使用<strong>ilock</strong>锁定它。<strong>Ilock</strong>(kernel/fs.c:289)使用sleep-lock来锁定。一旦<strong>ilock</strong>锁定了inode，它就会根据自己的需要从磁盘（更有可能是buffer缓存）读取inode。函数<strong>iunlock</strong> (kernel/fs.c:317)释放睡眠锁，这会唤醒正在等待该睡眠锁的进程。</p><p><strong>Iput</strong> (kernel/fs.c:333) 通过递减引用次数 (kernel/fs.c:356) 释放指向inode的指针。如果递减后的引用数为0，inode 缓存中的 就会释放掉该inode 在inode缓存中的槽位，该槽位就可以被其他inode使用。</p><p>如果<strong>iput</strong>发现没有指针指向该inode，并且没有任何目录项链接该inode（不在任何目录中出现），那么该inode和它的数据块必须被释放。<strong>Iput</strong>调用<strong>itrunc</strong>将文件截断为零字节，释放数据块；将inode类型设置为0（未分配）；并将inode写入磁盘（kernel/fs.c:338）。</p><p><strong>iput</strong>在释放inode的锁定协议是值得我们仔细研究。一个危险是，一个并发线程可能会在<strong>ilock</strong>中等待使用这个inode(例如，读取一个文件或列出一个目录)，但它没有意识到该inode可能被释放掉了。这种情况是不会发生，因为该inode的没有被目录项链接且<strong>ip-&gt;ref</strong>为1，那么系统调用是没有这个指针的（如果有，<strong>ip-&gt;ref</strong>应该为2）。这一个引用是调用 iput 的线程所拥有的。的确，<strong>iput</strong>会在其<strong>icache.lock</strong>锁定的临界区之外检查引用数是否为1，但此时已知链接数为0，所以没有线程会尝试获取新的引用。另一个主要的危险是，并发调用<strong>ialloc</strong>可能会使<strong>iput</strong>返回一个正在被释放的inode。这种情况发生在<strong>iupdate</strong>写磁盘时<strong>ip-&gt;type=0</strong>。这种竞争是正常的，分配inode的线程会等待获取inode的睡眠锁，然后再读取或写入inode，但此时<strong>iput</strong>就结束了。</p><p><strong>iput()</strong>会写磁盘。这意味着任何使用文件系统的系统调用都会写磁盘，因为系统调用可能是最后一个对文件有引用的调用。甚至像read()这样看似只读的调用，最终也可能会调用iput()。这又意味着，即使是只读的系统调用，如果使用了文件系统，也必须用事务来包装。</p><p>崩溃发生在<strong>iput()</strong>中是相当棘手的。当文件的链接数降到零时，<strong>iput()</strong>不会立即截断一个文件，因为一些进程可能仍然在内存中持有对inode的引用：一个进程可能仍然在对文件进行读写，因为它成功地打开了inode。但是，如果崩溃发生在该文件的最后一个文件描述符释放时，那么该文件将被标记为已在磁盘上分配，但没有目录项指向它。</p><p>文件系统处理这种情况的方法有两种。简单的解决方法是，是在重启后的恢复时，文件系统会扫描整个文件系统，寻找那些被标记为已分配的文件，但没有指向它们的目录项。如果有这样的文件存在，那么就可以释放这些文件。</p><p>第二种解决方案不需要扫描文件系统。在这个解决方案中，文件系统在磁盘上（例如，在<strong><em>superblock</em></strong>中）记录链接数为0但引用数不为0的文件的inode的inumber。如果文件系统在其引用计数达到0时删除该文件 。当文件的引用数为0时，文件系统会删除该文件，同时它更新磁盘上的列表，从列表中删除该inode。恢复时，文件系统会释放列表中的任何文件。</p><p>Xv6没有实现这两种解决方案，这意味着inode可能会在磁盘上被标记分配，即使它们不再使用。这意味着随着时间的推移，xv6可能会面临磁盘空间耗尽的风险。</p><h3 id="8-10-Code-Inode-content"><a href="#8-10-Code-Inode-content" class="headerlink" title="8.10 Code: Inode content"></a>8.10 Code: Inode content</h3><p> <img src="/img/Figure-8.3.png" alt="Figure-8.3"></p><p>磁盘上的<strong>inode</strong>，即<strong>dinode</strong>结构体，包含一个size和一个块号数组（见图8.3）。<strong>inode</strong>数据可以在<strong>dinode</strong>的<strong>addrs</strong>数组中找到。开始的<strong>NDIRECT</strong>个数据块列在数组中的前<strong>NDIRECT</strong>个条目中，这些块被称为<strong><em>直接块</em></strong>。接下来的<strong>NINDIRECT</strong>个数据块并没有列在<strong>inode</strong>中，而是列在叫做<strong><em>间接块</em></strong>的数据块中。<strong>addrs</strong>数组中的最后一个条目给出了放置间接块的地址。因此，一个文件的前<strong>12</strong> <strong>kB</strong> ( <strong>NDIRECT x BSIZE</strong>)字节可以从<strong>inode</strong>中列出的块中加载，而接下来的<strong>256</strong> <strong>kB</strong> ( <strong>NINDIRECT x BSIZE</strong>)字节只能在查阅间接块后才能取出。对于磁盘这是一种不错的表示方式，但对客户机就有点复杂了。函数<strong>bmap</strong>包装了这种表示方式使得高层次的函数，如<strong>readi</strong>和<strong>writei</strong>可以更好的使用。<strong>Bmap</strong>返回inode <strong>ip</strong>的第 <strong>bn</strong>个数据块的磁盘块号。如果<strong>ip</strong>没有第<strong>bn</strong>个的数据块，<strong>bmap</strong>就会分配一个。</p><p>函数<strong>bmap</strong>(kernel/fs.c:378)从简单的情况开始：最前面的<strong>NDIRECT</strong>个块储存在inode(kernel/fs.c:383-387)中，接下来的<strong>NINDIRECT</strong>个块放置在<strong>ip-&gt;addrs[NDIRECT]</strong>指向的的<strong><em>间接块</em></strong>中。<strong>Bmap</strong>读取间接块(kernel/fs.c:394)，然后从块内的正确的位置读取一个块号(kernel/fs.c:395)。如果块号超过了<strong>NDIRECT+NINDIRECT</strong>，<strong>bmap</strong>就会<strong>panic</strong>；<strong>writei</strong>会检查并防止这种情况(kernel/fs.c:490)。</p><p><strong>Bmap</strong>根据需要分配块。<strong>ip-&gt;addrs[bn]</strong>或间接条目为0 时表示没有块。当<strong>bmap</strong>遇到0时，它会用新的块号来代替0(kernel/fs.c:384-385) (kernel/fs.c:392-393)。</p><p><strong>itrunc</strong> 释放文件的块，将inode的大小重置为零。<strong>Itrunc</strong> (kernel/fs.c:410) 首先释放<strong><em>直接块</em></strong>(kernel/fs.c:416-421)，然后释放<strong><em>间接块</em></strong>中指向的块(kernel/fs.c:426- 429)，最后释放<strong><em>间接块</em></strong>本身(kernel/fs.c:431-432)。</p><p>Bmap 使得 readi 和 writei 可以很容易地获取一个 inode 的数据。Readi (kernel/fs.c:456)首先要确定偏移量和计数没有超过文件末端。从文件超出末尾开始的读会返回一个错误(kernel/fs.c:461-462)，而从文件末尾开始或读取过程中超出末尾的读会不会返回错误，只是返回的字节数会少于请求的字节数(kernel/fs.c:463-464)。</p><p>主循环会把文件中的每一个块的数据复制到<strong>dst</strong>中(kernel/fs.c:466-474)。<strong>writei</strong> (kernel/fs.c:483)与<strong>readi</strong>相同，但有三个不同：（1）、从文件末尾开始或越过文件末尾的写入会使文件增长，但不会超过文件的最大长度(kernel/fs.c:490-491)；（2）、循环将数据复制到缓冲区而不是<strong>out</strong>(kernel/fs.c:36)；（3）、如果写使文件增长了，<strong>writi</strong>必须更新它的大小(kernel/fs.c:504-511)。</p><p><strong>readi</strong>和<strong>writei</strong>开始都会检查<strong>ip-&gt;type == T_DEV</strong>。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层中再讨论这种情况。</p><p>函数 <strong>stati</strong> (kernel/fs.c:442) 将 inode 元数据复制到 <strong>stat</strong> 结构体中，通过 <strong>stat</strong> 系统调用暴露给用户程序。</p><h3 id="8-11-Code-directory-layer"><a href="#8-11-Code-directory-layer" class="headerlink" title="8.11 Code: directory layer"></a>8.11 Code: directory layer</h3><p>目录的实现机制和文件很类似。它的<strong>inode</strong>类型是<strong>T_DIR</strong>，它的数据是一个目录项的序列。每个条目是一个结构体<strong>dirent</strong>(kernel/fs.h:56)，它包含一个名称和一个inode号。名称最多包含<strong>DIRSIZ</strong>(14)个字符，较短的名称以<strong>NULL</strong>(0)结束。inode号为0的目录项是空闲的。</p><p>函数<strong>dirlookup</strong> (kernel/fs.c:527)在一个目录中搜索一个带有给定名称的条目。如果找到了，它返回一个指向相应未上锁的inode的指针，并将<strong>*poff</strong>设置为目录中条目的字节偏移量，以便调用者想要编辑它。如果dirlookup找到一个对应名称的条目，则更新<em>poff，并返回一个通过iget获得的未被锁定的inode。Dirlookup是iget返回未锁定的inode的原因。调用者已经锁定了dp，所以如果查找的是 <strong>“.”</strong> ，当前目录的别名，在返回之前试图锁定inode，就会试图重新锁定dp而死锁。(还有更复杂的死锁情况，涉及到多个进程和”<strong>..”</strong>，父目录的别名；”<em>*.”</em></em>不是唯一的问题。) 调用者可以先解锁dp，然后再锁定ip，保证一次只持有一个锁。</p><p>函数<strong>dirlink</strong> (kernel/fs.c:554)会在当前目录dp中创建一个新的目录项，通过给定的名称和inode号。如果名称已经存在，dirlink 将返回一个错误(kernel/fs.c:560- 564)。主循环读取目录项，寻找一个未使用的条目。当它找到一个时，它会提前跳出循环 (kernel/fs.c:538-539)，并将 <strong>off</strong> 设置为该可用条目的偏移量。否则，循环结束时，将<strong>off</strong>设置为<strong>dp-&gt;size</strong>。不管是哪种方式，<strong>dirlink</strong>都会在偏移量<strong>off</strong>的位置添加一个新的条目到目录中(kernel/fs.c:574-577)。</p><h3 id="8-12-Code-Path-names"><a href="#8-12-Code-Path-names" class="headerlink" title="8.12 Code: Path names"></a>8.12 Code: Path names</h3><p>查找路径名会对每一个节点调用一次<strong>dirlookup</strong>。Namei (kernel/fs.c:661) 解析路径并返回相应的inode。函数<strong>nameiparent</strong>是<strong>namei</strong>的一个变种：它返回相应inode的父目录inode，并将最后一个元素复制到<strong>name</strong>中。这两个函数都通过调用<strong>namex</strong>来实现。</p><p><strong>Namex</strong> (kernel/fs.c:626)首先确定路径解析从哪里开始。如果路径以斜线开头，则从根目录开始解析；否则，从当前目录开始解析(kernel/fs.c:630-633)。然后它使用 <strong>skipelem</strong> 来遍历路径中的每个元素(kernel/fs.c:635)。循环的每次迭代都必须在当前inode <strong>ip</strong>中查找<strong>name</strong>。迭代的开始是锁定<strong>ip</strong>并检查它是否是一个目录。如果不是，查找就会失败(kernel/fs.c:636-640)。(锁定<strong>ip</strong>是必要的，不是因为<strong>ip-&gt;type</strong>可能会改变，而是因为在<strong>ilock</strong>运行之前，不能保证ip-&gt;type已经从磁盘载入)。如果调用的是<strong>nameiparent</strong>，而且这是最后一个路径元素，按照之前<strong>nameiparent</strong>的定义，循环应该提前停止，最后一个路径元素已经被复制到name中，所以<strong>namex</strong>只需要返回解锁的ip(kernel/fs.c:641-645)。最后，循环使用<strong>dirlookup</strong>查找路径元素，并通过设置<strong>ip</strong> = <strong>next</strong>为下一次迭代做准备(kernel/fs.c:646-651)。当循环遍历完路径元素时，它返回<strong>ip</strong>。</p><p><strong>namex</strong>可能需要很长的时间来完成：它可能会涉及几个磁盘操作，通过遍历路径名得到的目录的inode和目录块（如果它们不在buffer缓存中）。Xv6经过精心设计，如果一个内核线程对<strong>namex</strong>的调用阻塞在磁盘I/O上，另一个内核线程查找不同的路径名可以同时进行。<strong>Namex</strong>分别锁定路径中的每个目录，这样不同目录的查找就可以并行进行。</p><p>这种并发性带来了一些挑战。例如，当一个内核线程在查找一个路径名时，另一个内核线程可能正在取消链接一个目录，这会改变目录数。一个潜在的风险是，可能一个查找线程正在搜索的目录可能已经被另一个内核线程删除了，而它的块已经被另一个目录或文件重用了。</p><p>Xv6避免了这种竞争。例如，在<strong>namex</strong>中执行<strong>dirlookup</strong>时，查找线程会持有目录的锁，<strong>dirlookup</strong>返回一个使用<strong>iget</strong>获得的inode。<strong>iget</strong>会增加inode的引用次数。只有从<strong>dirlookup</strong>收到inode后，<strong>namex</strong>才会释放目录上的锁。现在另一个线程可能会从目录中取消链接inode，但xv6还不会删除inode，因为inode的引用数仍然大于零。</p><p>另一个风险是死锁。例如，当查找<strong>“. “</strong>时，next指向的inode与<strong>ip</strong>相同。在释放对<strong>ip</strong>的锁之前锁定next会导致死锁。为了避免这种死锁，<strong>namex</strong>在获得对next的锁之前就会解锁目录。这里我们再次看到为什么<strong>iget</strong>和<strong>ilock</strong>之间的分离是很重要的。</p><h3 id="8-13-File-descriptor-layer"><a href="#8-13-File-descriptor-layer" class="headerlink" title="8.13 File descriptor layer"></a>8.13 File descriptor layer</h3><p>Unix接口很酷的一点是：Unix中的大部分资源都是以文件的形式来表示的。包括控制台、管道等设备，当然还有真实的文件。文件描述符层就是实现这种统一性的一层。</p><p>Xv6给每个进程提供了自己的打开文件表，或者说文件描述符表，就像我们在第一章中看到的那样。每个打开的文件由一个结构体<strong>file</strong>(kernel/file.h:1)表示，它包装inode或管道，也包含一个I/O偏移量。每次调用<strong>open</strong>都会创建一个新的打开文件（一个新的结构体file），如果多个进程独立打开同一个文件，那么不同的<strong>file</strong>实例会有不同的I/O偏移量。另一方面，一个打开的文件（同一个结构文件）可以在一个进程的文件表中出现多次，也可以在多个进程的文件表中出现。如果一个进程使用<strong>open</strong>打开文件，然后使用<strong>dup</strong>创建别名，或者使用<strong>fork</strong>与子进程共享文件，就会出现这种情况。引用计数可以跟踪特定打开文件的引用数量。一个文件的打开方式可以为读，写，或者读写。通过<strong>readable</strong>和<strong>writable</strong>来指明。</p><p>系统中所有打开的文件都保存在一个全局文件表中，即<strong>ftable</strong>。文件表的功能有: 分配文件(<strong>filealloc</strong>)、创建重复引用(<strong>fileup</strong>)、释放引用(<strong>fileclose</strong>)、读写数据(<strong>fileeread</strong>和<strong>filewrite</strong>)。</p><p>前三个函数应该比较熟悉了,就不过多的讨论。<strong>Filealloc</strong> (kernel/file.c:30) 扫描文件表，寻找一个未引用的文件 (f-&gt;ref == 0)，并返回一个新的引用；<strong>fileup</strong> (kernel/file.c:48) 增加引用计数；<strong>fileclose</strong> (kernel/file.c:60) 减少引用计数。当一个文件的引用数达到0时，<strong>fileclose</strong>会根据类型释放底层的管道或inode。</p><p>函数<strong>filestat</strong>、<strong>fileread</strong>和<strong>filewrite</strong>实现了对文件的统计、读和写操作。Filestat(kernel/file.c:88)只允许对inodes进行操作，并调用<strong>stati</strong>。<strong>Fileread</strong>和<strong>filewrite</strong>首先检查打开模式是否允许该操作，然后再调用管道或inode的相关实现。如果文件代表一个inode，<strong>fileread</strong>和<strong>filewrite</strong>使用I/O偏移量作为本次操作的偏移量，然后前移偏移量（kernel/file.c:122- 123）（kernel/file.c:153-154）。Pipes没有偏移量的概念。回想一下inode的函数需要调用者处理锁的相关操作（kernel/file.c:94-96）（kernel/file.c:121-124）（kernel/file.c:163-166）。inode加锁附带了一个不错的作用，那就是读写偏移量是原子式更新的，这样多个进程写一个文件时，自己写的数据就不会被其他进程所覆盖，尽管他们的写入可能最终会交错进行。</p><h3 id="8-14-Code-System-calls"><a href="#8-14-Code-System-calls" class="headerlink" title="8.14 Code: System calls"></a>8.14 Code: System calls</h3><p>有了更低层提供的函数，大多数系统调用的实现都是比较简单的（见(kernel/sysfile.c)）。有几个调用值得仔细研究一下。</p><p>函数 <strong>sys_link</strong> 和 <strong>sys_unlink</strong> 可以编辑目录，创建或删除对 inodes 的引用。它们是使用事务的另一个很好的例子。<strong>Sys_link</strong> (kernel/sysfile.c:120) 首先获取它的参数，两个字符串 <strong>old</strong> 和 <strong>new</strong> (kernel/sysfile.c:125) 。假设 <strong>old</strong> 存在并且不是一个目录 (kernel/sysfile.c:129-132)，<strong>sys_link</strong> 会递增它的 <strong>ip-&gt;nlink</strong> 计数。然后 <strong>sys_link</strong> 调用 <strong>nameiparent</strong> 找到 new (kernel/sysfile.c:145) 的父目录和最终路径元素，并创建一个指向 <strong>old</strong>的 inode 的新目录项 (kernel/sysfile.c:148)。新的父目录必须存在，并且和现有的inode在同一个设备上，inode号只在同一个磁盘上有意义。如果出现这样的错误，<strong>sys_link</strong>必须返回并减少<strong>ip-&gt;nlink</strong>。</p><p>事务简化了这个函数的实现，因为它需要更新多个磁盘块，但我们不必担心做这些事情的顺序。它们要么全部成功，要么都不成功。例如，如果没有事务，在创建链接之前更新<strong>ip-&gt;nlink</strong>，会使文件系统暂时处于不安全的状态，中间的崩溃可能会造成破坏。有了事务，我们就不用担心这个问题了。</p><p><strong>Sys_link</strong>为一个现有的inode创建一个新的名字。而函数<strong>create</strong> (kernel/sysfile.c:242)为一个新的inode创建一个新的名字。它是三个文件创建相关的系统调用的综合：使用O_CREATE标志的open创建一个新的普通文件，<strong>mkdir</strong>创建一个新的目录，以及mkdev创建一个新的设备文件。和<strong>sys_link</strong>一样，<strong>create</strong>也是通过调用<strong>nameiparent</strong>来获取父目录的inode。然后调用 <strong>dirlookup</strong> 来检查名称是否已经存在 (kernel/sysfile.c:252)。如果名称存在，create的行为取决于它被用于哪个系统调用：<strong>open</strong>，<strong>mkdir</strong>，<strong>mkdev</strong>的语义不同。如果<strong>create</strong>是由<strong>open</strong>使用的 (<strong>type == T_FILE</strong>)，如果能根据该名字存在且为普通文件，那么打开就会成功，所以<strong>create</strong>也会成功 (kernel/sysfile.c:256)。否则，就会报错（kernel/sysfile.c:257-258）。如果这个名字不存在，<strong>create</strong>就会用<strong>ialloc</strong>分配一个新的inode(kernel/sysfile.c:261)。如果新的inode是一个目录，<strong>create</strong>会在该目录添加条目“.”和“..”。最后，现在数据已经被正确地初始化了，<strong>create</strong>可以把它链接到父目录中(kernel/sysfile.c:274)。和<strong>sys_link</strong>一样，create同时拥有两个inode锁：<strong>ip</strong>和<strong>dp</strong>。没有死锁的可能性，因为inode <strong>ip</strong>是新分配的：系统中没有其他进程会持有<strong>ip</strong>的锁并尝试锁住dp。。</p><p>使用<strong>create</strong>，很容易实现<strong>sys_open</strong>、<strong>sys_mkdir</strong>和<strong>sys_mknod</strong>。<strong>Sys_open</strong> (kernel/sysfile.c:287)是其中最复杂的，因为创建一个新文件只是它做的一小部分。如果<strong>open</strong>的打开模式包含为<strong>O_CREATE</strong>，它就会调用<strong>create</strong> (kernel/sysfile.c:301)。否则，它会调用 <strong>namei</strong> (kernel/sysfile.c:307)。<strong>Create</strong>会返回一个锁定的inode，但<strong>namei</strong>不会，所以<strong>sys_open</strong>必须锁定inode。这比较有一个方便的地方是目录只会以读打开，而不是写。假设inode是通过某种方式获得的，sys_open会分配一个文件和一个文件描述符(kernel/sysfile.c:325)，然后设置file相关的字段(kernel/sysfile.c:337- 94 342)。注意，没有其他进程可以访问这个部分初始化的文件，因为它只在当前进程的表中。</p><p>第7章在我们还没有文件系统之前就研究了管道的实现。函数<strong>sys_pipe</strong>通过提供创建管道对的方法将管道实现与文件系统连接起来。它的参数是一个指针，该指针指向一个长度为2的int类型数组，它将在这里记录两个新的文件描述符。然后它分配管道并装入文件描述符。</p><h3 id="8-15-Real-world"><a href="#8-15-Real-world" class="headerlink" title="8.15 Real world"></a>8.15 Real world</h3><p>实际操作系统中的buffer缓存要比xv6的复杂得多，但它有同样的两个目的：缓存和同步访问磁盘。xv6的buffer缓存和V6是一样的，使用简单的最近最少使用（LRU）抛弃策略；可以实现许多更复杂的策略，每种策略都对某些情况有好处，而对其它情况没有好处。更高效的LRU缓存不使用链表，而使用哈希表进行查找，使用堆进行LRU抛弃。现代的buffer缓存通常与虚拟内存系统集成在一起，以支持内存映射的文件。</p><p>Xv6的日志系统效率低下。提交不能与文件系统系统调用同时发生。系统会记录整个块，即使一个块中只有几个字节被改变。它执行同步的日志写入，一次写一个块，每一个块都可能需要整个磁盘旋转时间。真正的日志系统可以解决所有这些问题。</p><p>日志不是提供崩溃恢复的唯一方法。早期的文件系统在重启期间使用scavenger（例如UNIX fsck程序）来检查每个文件和目录以及块和inode空闲列表，寻找并解决不一致的地方。对于大型文件系统来说，清扫可能需要几个小时的时间，而且在某些情况下，这种方式要想获得的数据一致性，其系统调用必须是一致性的。从日志中恢复要快得多，而且在崩溃时，系统调用是原子的。</p><p>Xv6使用了与早期UNIX相同的inodes和目录的基本磁盘布局；这个方案多年来仍在使用。BSD的UFS/FFS和Linux的ext2/ext3使用基本相同的数据结构。文件系统布局中最低效的部分是目录，在每次查找过程中需要对所有磁盘块进行线性扫描。当目录只有几个磁盘块时，这是合理的，但对于有许多文件的目录来说是昂贵的。微软Windows的NTFS，Mac OS X的HFS，以及Solaris的ZFS，将目录实现为磁盘上块的平衡树。这很复杂，但可以保证目录查找的时间复杂度是对数级的。</p><p>Xv6对磁盘故障的处理很朴素：如果磁盘操作失败，xv6就会<strong>panic</strong>。这是否合理取决于硬件：如果一个操作系统位于特殊的硬件之上，这种硬件会使用冗余来掩盖故障，也许操作系统看到故障的频率很低，以至于直接<strong>panic</strong>是可以的。另一方面，使用普通磁盘的操作系统应该使用更加优雅的方式来处理异常，这样一个文件中一个块的丢失就不会影响文件系统其他部分的使用。</p><p>Xv6要求文件系统固定在单一磁盘设备上，而且大小不能改变。随着大型数据库和多媒体文件对存储要求越来越高，操作系统正在开发消除每个文件系统一个磁盘瓶颈的方法。基本的方法是将许多磁盘组合成一个逻辑磁盘。硬件解决方案（如RAID）仍然是最流行的，但目前的趋势是尽可能地在软件中实现这种逻辑。这些软件实现通常允许丰富的功能，如在运行时通过快速添加或删除磁盘来增长或缩小逻辑设备。当然，一个能够快速增长或收缩的存储层需要一个能够做到同样的文件系统：xv6使用的固定大小的inode块阵列在这样的环境中不能很好地工作。将磁盘管理与文件系统分离可能是最简洁的设计，但由于两者之间复杂的接口，使得有些系统，如Sun公司的ZFS，将两者直接结合起来。</p><p>Xv6的文件系统缺乏现代文件系统的许多其他功能，例如，它缺乏对快照和增量备份的支持。</p><p>现代Unix系统允许用与磁盘存储相同的系统调用来访问许多种类的资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如/proc。与xv6在fileread和filewrite中的if语句，这些系统通常给每个打开的文件一个函数指针表，每个代表一个操作，调用函数指针来调用该inode的实现调用。网络文件系统和用户级文件系统提供了将这些调用变成网络RPC的函数，并在返回前等待响应。</p><h3 id="8-16-Exercises"><a href="#8-16-Exercises" class="headerlink" title="8.16 Exercises"></a>8.16 Exercises</h3><ol><li><p>为什么<strong>balloc</strong>需要<strong>panic</strong>？xv6能恢复吗？</p></li><li><p>为什么<strong>ialloc</strong>需要<strong>panic</strong>？xv6能恢复吗？</p></li><li><p>为什么<strong>filealloc</strong>用完文件后不<strong>panic</strong>？为什么这种情况比较常见，而值得处理？</p></li><li><p>假设在执行<strong>sys_lin</strong>k时，另一个进程在<strong>iunlock(ip)</strong>和<strong>dirlink</strong>之间解除链接该<strong>ip</strong>对应的文件。链接会被正确创建吗？为什么？</p></li><li><p><strong>create</strong>调用了四次函数（一个<strong>ialloc</strong>，三次<strong>dirlink</strong>），它需要这些函数成功返回。如果任何一个不成功，<strong>create</strong>调用就会<strong>panic</strong>。为什么这可以接受？为什么这四个调用不能有一个失败呢？</p></li><li><p><strong>sys_chdir</strong>在<strong>iput(cp-&gt;cwd)</strong>之前调用<strong>iunlock(ip)</strong>，这可能会尝试锁定<strong>cp-&gt;cwd</strong>，但将<strong>iunlock(ip)</strong>推迟到<strong>iput</strong>之后不会造成死锁。为什么不会呢？</p></li><li><p>实现<strong>lseek</strong>系统调用。<strong>lseek</strong>还需要你修改<strong>filewrite</strong>，如果<strong>lseek</strong>设置超过<strong>f-&gt;ip-&gt;size</strong>，则在文件中用零来填补空缺。</p></li><li><p>给<strong>open</strong>增加O_TRUNC和O_APPEND，使&gt;和&gt;&gt;操作符在shell中可以使用。</p></li><li><p>修改文件系统使其支持符号链接。</p></li><li><p>修改文件系统使其支持命名管道。</p></li><li><p>修改文件系统和VM使其支持memory-map文件（内存映射文件）。</p></li></ol><hr><ol><li><a name="ftn1"></a>扇区号表明该日志块，应该写入的位置。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第七章</title>
      <link href="/2022/08/31/xv6-Chapter-7/"/>
      <url>/2022/08/31/xv6-Chapter-7/</url>
      
        <content type="html"><![CDATA[<h2 id="第七章：调度"><a href="#第七章：调度" class="headerlink" title="第七章：调度"></a>第七章：调度</h2><p>任何操作系统运行的进程数量都可能超过计算机的CPU数量，因此需要制定一个方案，在各进程之间分时共享CPU。理想情况下，这种共享对用户进程是透明的。一种常见的方法是通过将进程复用到硬件CPU上，给每个进程提供它有自己的虚拟CPU的假象。本章解释xv6如何实现这种复用。</p><h3 id="7-1-Multiplexing"><a href="#7-1-Multiplexing" class="headerlink" title="7.1 Multiplexing"></a>7.1 Multiplexing</h3><p>xv6通过在两种情况下将CPU从一个进程切换到另一个进程来实现复用。首先，xv6的<strong>sleep</strong>和<strong>wakeup</strong>机制会进行切换，这会发生在进程等待设备或管道I/O，或等待子进程退出，或在<strong>sleep</strong>系统调用中等待。其次，xv6周期性地强制切换，以应对长时间不进行sleep操作的计算进程。这种复用造成了每个进程都有自己的CPU的假象，就像xv6使用内存分配器和硬件页表造成每个进程都有自己的内存的假象一样。</p><p>实现复用会有一些挑战。首先，如何从一个进程切换到另一个进程？虽然上下文切换的想法很简单，但在XV6的实现中上下文切换却是最不透明的代码之一。第二，如何以对用户进程透明的方式进行强制切换？xv6采用标准通用的方式，用定时器中断来驱动上下文切换。第三，许多CPU可能会在进程间并发切换，需要设计一个锁来避免竞争。第四，当进程退出时，必须释放进程的内存和其他资源，但进程本身不能完全释放掉所有的资源，比如它不能在使用内核栈的同时释放自己的内核栈。第五，多核机器的每个内核必须记住它正在执行的进程，这样系统调用才能修改相应进程的内核状态。最后，<strong>sleep</strong>和<strong>wakeup</strong>允许一个进程放弃CPU，并睡眠等待某一事件，并允许另一个进程将睡眠的进程唤醒。需要注意一些竞争可能会使唤醒丢失。Xv6试图尽可能简单地解决这些问题，尽管如此，实际代码还是很棘手。</p><h3 id="7-2-Code-Context-switching"><a href="#7-2-Code-Context-switching" class="headerlink" title="7.2 Code: Context switching"></a>7.2 Code: Context switching</h3><p><img src="/img/Figure-7.1.png" alt="Figure-7.1"></p><p>图7.1概述了从一个用户进程切换到另一个用户进程所涉及的步骤：用户-内核的切换（通过系统调用或中断）到旧进程的内核线程，上下文（context）切换到当前CPU的调度器线程，上下文（context）切换到新进程的内核线程，以及trap返回到用户级进程。xv6调度器在每个CPU上有一个专门的线程(保存了寄存器和栈)，因为调度器在旧进程的内核栈上执行是不安全的：因为其他核心可能会唤醒该进程并运行它，而在两个不同的核心上使用相同的栈将是一场灾难。在本节中，我们将研究在内核线程和调度线程之间切换的机制。</p><p>从一个线程切换到另一个线程，需要保存旧线程的CPU寄存器，并恢复新线程之前保存的寄存器；栈指针和pc被保存和恢复，意味着CPU将切换栈和正在执行的代码。</p><p>函数<strong>swtch</strong>执行内核线程切换的保存和恢复。<strong>swtch</strong>并不直接知道线程，它只是保存和恢复寄存器组，称为<strong><em>上下文(context)</em></strong>。当一个进程要放弃CPU的时候，进程的内核线程会调用<strong>swtch</strong>保存自己的上下文并返回到调度器上下文。每个上下文都包含在一个结构体 <strong>context(kernel/proc.h:2)</strong>中，它本身包含在进程的结构体<strong>proc</strong>或CPU的结构体<strong>cpu</strong>中。<strong>Swtch</strong>有两个参数：<strong>struct context old</strong>和<strong>struct context new</strong>。它将当前的寄存器保存在old中，从new中加载寄存器，然后返回。</p><p>让我们跟随一个进程通过<strong>swtch</strong>进入<strong>scheduler</strong>。我们在第4章看到，在中断结束时，有一种情况是<strong>usertrap</strong>调用<strong>yield</strong>。<strong>yield</strong>又调用<strong>sched</strong>，<strong>sched</strong>调用<strong>swtch</strong>将当前上下文保存在<strong>p-&gt;context</strong>中，并切换到之前保存在<strong>cpu-&gt;scheduler</strong>中的调度器上下文（kernel/proc.c:509）。</p><p><strong>Swtch(kernel/swtch.S:3)</strong>只保存callee-saved寄存器，caller-saved寄存器由调用的C代码保存在堆栈上(如果需要)。<strong>Swtch</strong>知道<strong>struct context</strong>中每个寄存器字段的偏移量。它不保存pc。相反，<strong>swtch</strong>保存了ra寄存器<a href="#ftn1">[1]</a>，它保存了<strong>swtch</strong>应该返回的地址。现在，<strong>swtch</strong>从新的上下文中恢复寄存器，新的上下文中保存着前一次<strong>swtch</strong>所保存的寄存器值。当<strong>swtch</strong>返回时，它返回到被恢复的ra寄存器所指向的指令，也就是新线程之前调用<strong>swtch</strong>的指令。此外，它还会返回新线程的堆栈。</p><p>在我们的例子中，<strong>sched</strong>调用<strong>swtch</strong>切换到<strong>cpu-&gt;scheduler</strong>，即CPU调度器的上下文。这个上下文已经被<strong>scheduler</strong>对<strong>swtch</strong>的调用所保存(kernel/proc.c:475)。当我们跟踪的<strong>swtch</strong>返回时，它不是返回到<strong>sched</strong>而是返回到<strong>scheduler</strong>，它的栈指针指向当前CPU的调度器栈。</p><p>补充说明（不在翻译内容中）：</p><p>根据XV6的源代码，xv6中只有两处调用switch：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;scheduler);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swtch(&amp;c-&gt;scheduler, &amp;p-&gt;context);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以看出这里没有两个用户进程之间的直接切换，只有用户进程和调度器线程之间的切换</strong>：xv6中要主动让出cpu的进程都是通过调用exit/sleep/yield，间接调用sched，从而实现切换到调度器线程，再由调度器线程选出并切换到一个runnable。</p><h3 id="7-3-Code-Scheduling"><a href="#7-3-Code-Scheduling" class="headerlink" title="7.3 Code: Scheduling"></a>7.3 Code: Scheduling</h3><p>上一节研究了<strong>swtch</strong>的底层细节，现在我们把<strong>swtch</strong>作为一个给定的条件，研究从一个进程的内核线程通过调度器切换到另一个进程。调度器以CPU特殊线程（每个CPU各一个）的形式存在，线程运行<strong>scheduler</strong>函数。这个函数负责选择下一步运行哪个进程。一个想要放弃CPU的进程，必须获取自己的进程锁<strong>p-&gt;lock</strong>，释放它所持有的其他锁，更新自己的状态（<strong>p-&gt;state</strong>），然后调用<strong>sched</strong>。<strong>Yield</strong> (kernel/proc.c:515) 遵循这个规则，我们稍后要研究的<strong>sleep</strong>和<strong>exit</strong>也同样遵循这个规则。<strong>Sched</strong>对这些条件进行仔细检查(kernel/proc.c:499-504)，然后再检查这些条件的含义：既然锁被持有，就应该禁用中断。最后，<strong>sched</strong>调用<strong>swtch</strong>将当前上下文保存在p-&gt;context中，并切换到cpu-&gt;scheduler中<strong>scheduler</strong>的上下文。Swtch在<strong>scheduler</strong>堆栈上返回，<strong>scheduler</strong>继续for循环，找到一个要运行的进程，切换到它，然后循环重复。</p><p>我们刚刚看到xv6在调用<strong>swtch</strong>的过程中持有<strong>p-&gt;lock</strong>：<strong>swtch</strong>的调用者必须已经持有锁，并把锁的控制权移交给切换到的代码。这种约定对于锁来说是不寻常的；一般来说获得锁的线程也要负责释放锁，这样才容易保证正确性。对于上下文切换来说，有必要打破这个约定，因为<strong>p-&gt;lock</strong>保护了进程的状态和<strong>context</strong>字段上的<strong><em>不变量（invariant）</em></strong>，而这些不变量在<strong>swtch</strong>执行时是不正确的。如果<strong>p-&gt;lock</strong>在<strong>swtch</strong>过程中不被持有，可能会出现问题的一个情况：在<strong>yield</strong>将其状态设置为<strong>RUNNABLE</strong>之后，但在<strong>swtch</strong>切换到新的栈之前，其他CPU可能会运行这个进程。结果就是两个CPU运行在同一个栈上，这显然是错误的。</p><p>一个内核线程在<strong>sched</strong>中放弃它的CPU，并且切换到<strong>scheduler</strong>的同一个位置，而<strong>scheduler</strong>（几乎）总是切换到之前调用<strong>sched</strong>的某个内核线程。因此，如果把xv6切换线程的行号打印出来，就会观察到下面的结果：(kernel/proc.c:475)，(kernel/proc.c:509)，(kernel/proc.c:475)，(kernel/proc.c:509)，等等。在两个线程之间发生这种样式化切换的程序有时被称为<strong><em>协程（coroutine）</em></strong>；在这个例子中，<strong>sched</strong>和<strong>scheduler</strong>是彼此的<strong><em>coroutines</em></strong>。</p><p>有一种情况是调度器对<strong>swtch</strong>的调用没有以<strong>sched</strong>结束。当一个新进程第一次被调度时，它从<strong>forkret</strong>开始（kernel/proc.c:527）。<strong>forkret</strong>的存在是为了释放<strong>p-&gt;lock</strong>；否则，新进程需要从<strong>usertrapret</strong>开始。</p><p><strong>scheduler(kernel/proc.c:457)</strong>运行了一个简单的循环：找到一个可以运行进程，运行它，直到它让出CPU，一直重复。调度器在进程表上循环寻找一个可运行的进程，即p-&gt;state == RUNNABLE的进程。一旦找到这样的进程，它就会设置CPU当前进程变量c-&gt;proc指向该进程，将该进程标记为RUNNING，然后调用<strong>swtch</strong>开始运行它(kernel/proc.c:470- 475)。</p><p>你可以这样理解调度代码结构，它执行一组关于进程的不变量，并且每当这些不变量不正确时，就持有<strong>p-&gt;lock</strong>。一个不变量是，如果一个进程正在运行，那么定时中断导致的yield必须能够安全的让他让出cpu；这意味着CPU寄存器必须持有该进程的寄存器值（即<strong>swtch</strong>没有将它们移到上下文中），并且<strong>c-&gt;proc</strong>必须指向该进程。另一个不变量是，如果一个进程是<strong>RUNNABLE</strong>的，那么对于一个空闲的CPU调度器来说，运行它必须是安全的；这意味着 （1）<strong>p-&gt;context</strong>必须拥有进程的寄存器（即它们实际上并不在真实的寄存器中），（2）没有CPU在进程的内核栈上执行，（3）也没有CPU的c-&gt;proc指向该进程。请注意，当p-&gt;lock被持有时，这些属性往往不正确。</p><p>维护上述不变量是xv6经常在一个线程中获取<strong>p-&gt;lock</strong>，然后在另一个线程中释放它的原因（例如在<strong>yield</strong>中获取，在<strong>schedululer</strong>中释放）。一旦<strong>yield</strong>开始修改一个正在运行的进程的状态，使其成为<strong>RUNNABLE</strong>，锁必须一直保持，直到不变量被恢复：最早正确的释放点是在调度器（运行在自己的堆栈上）清除<strong>c-&gt;proc</strong>之后。同样，一旦调度器开始将一个<strong>RUNNABLE</strong>进程转换为<strong>RUNNING</strong>，锁就不能被释放，直到内核线程完成运行（在<strong>swtch</strong>之后，例如在<strong>yield</strong>中）。</p><p><strong>p-&gt;lock</strong>也保护其他的东西：<strong>exit</strong>和<strong>wait</strong>之间的相互作用，避免丢失唤醒的机制（见第7.5节），以及避免避免退出进程和读写其状态的其他进程之间的竞争（例如，<strong>exit</strong>系统调用查看<strong>p-&gt;pid</strong>并设置<strong>p-&gt;killed (kernel/proc.c:611)</strong>。值得思考的是，是否可以将<strong>p-&gt;lock</strong>的不同功能拆分开来，这样既清晰，也可能提高性能。</p><h3 id="7-4-Code-mycpu-and-myproc"><a href="#7-4-Code-mycpu-and-myproc" class="headerlink" title="7.4 Code: mycpu and myproc"></a>7.4 Code: mycpu and myproc</h3><p>​    Xv6经常需要一个指向当前进程<strong>proc</strong>的指针。在单核处理器上，可以用一个全局变量指向当前的<strong>proc</strong>。这在多核机器上是行不通的，因为每个核都执行不同的进程。解决这个问题的方法是利用每个核都有自己的一组寄存器的事实；我们可以使用其中的一个寄存器来帮助查找每个核的信息。</p><p>Xv6为每个CPU维护了一个<strong>cpu</strong>结构体(kernel/proc.h:22)，它记录了当前在该CPU上运行的进程(如果有的话)，为CPU的调度线程保存的寄存器，以及管理中断禁用所需的嵌套自旋锁的计数。函数<strong>mycpu</strong>(kernel/proc.c:60)返回一个指向当前CPU结构体<strong>cpu</strong>的指针。RISC-V对CPU进行编号，给每个CPU一个<strong>hartid</strong>。Xv6确保每个CPU的<strong>hartid</strong>在内核中被存储在该CPU的<strong>tp</strong>寄存器中。这使得<strong>mycpu</strong>可以使用<strong>tp</strong>对<strong>cpu</strong>结构体的数组进行索引，从而找到正确的cpu。</p><p>确保一个CPU的<strong>tp</strong>始终保持CPU的hartid是有一点复杂的。<strong>mstart</strong>在CPU启动的早期设置<strong>tp</strong>寄存器，此时CPU处于机器模式(kernel/start.c:46)。<strong>Usertrapret</strong>将<strong>tp</strong>寄存器保存在trampoline页中，因为用户进程可能会修改tp寄存器。最后，当从用户空间进入内核时，<strong>use</strong>rvec会恢复保存的tp（trapframe中的tp加载到tp寄存器）(kernel/trampoline.S:70)。编译器保证永远不使用tp寄存器。如果RISC-V允许xv6直接读取当前的hartid会更方便，但这只允许在机器模式下读取，而不允许在管理模式下读取。</p><p>cpuid和mycpu的返回值很容易错：如果定时器中断，导致线程让出CPU，然后转移到不同的CPU上，之前返回的值将不再正确。为了避免这个问题，xv6要求调用者禁用中断，只有在使用完返回的cpu结构后才启用中断。(即为了避免这个问题，调用cpuid和mycpu时，需要禁用中断)</p><p><strong>myproc</strong>(kernel/proc.c:68)函数返回当前CPU上运行的进程的<strong>proc</strong>指针。<strong>myproc</strong>禁用中断，调用<strong>mycpu</strong>，从<strong>struct</strong> <strong>cpu</strong>中获取当前进程指针(<strong>c-&gt;proc</strong>)，然后启用中断。即使启用了中断，<strong>myproc</strong>的返回值也可以安全使用：如果定时器中断将调用进程移到了另一个的CPU上，它的<strong>proc</strong>结构指针将保持不变。</p><h3 id="7-5-Sleep-and-wakeup"><a href="#7-5-Sleep-and-wakeup" class="headerlink" title="7.5 Sleep and wakeup"></a>7.5 Sleep and wakeup</h3><p>调度和锁有助于让一个进程对另一个进程的不可见，但到目前为止，我们还没有帮助进程进行交互的抽象。人们发明了许多机制来解决这个问题。Xv6使用了一种叫做睡眠和唤醒的机制，它允许一个进程睡眠并等待事件，另一个进程在该事件发生后将其唤醒。睡眠和唤醒通常被称为<strong><em>序列协调（sequence coordination）</em></strong> 或<strong><em>条件同步（conditional synchronization）</em></strong> 机制。</p><p>为了说明这一点，让我们考虑一个叫做<strong><em>信号量（semaphore）</em></strong>[4]的同步机制，它协调生产者和消费者。信号量维护一个计数并提供两个操作。V操作（针对生产者）增加计数。P操作（针对消费者）等待，直到计数非零，然后将其递减并返回。如果只有一个生产者线程和一个消费者线程，而且它们在不同的CPU上执行，编译器也没有太过激进的优化，那么这个实现是正确的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count += <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现是代价很大。如果生产者很少生产，消费者将把大部分时间花在while循环中，希望得到一个非零的计数。消费者的CPU可以通过反复<strong><em>轮询(polling)</em></strong> <strong>s-&gt;count</strong>可以找到比<strong><em>忙碌等待(busy waiting)</em></strong>更有效的工作。避免<strong><em>忙碌等待</em></strong>需要一种方法，让消费者让出CPU，只有在<strong>V</strong>增加计数后才恢复。</p><p>这里是朝着这个方向迈出的一步，虽然他不能完全解决这个问题。让我们想象一对调用，<strong>sleep</strong>和<strong>wakeup</strong>，其工作原理如下。<strong>Sleep(chan)</strong>睡眠<strong>chan</strong>上，<strong>chan</strong>可以为任意值，称为<strong><em>等待通道(wait channel)</em></strong>。<strong>Sleep</strong>使调用进程进入睡眠状态，释放CPU进行其他工作。<strong>Wakeup(chan)</strong>唤醒所有在<strong>chan</strong>上<strong>sleep</strong>的进程（如果有的话），使它们的<strong>sleep</strong>调用返回。如果没有进程在<strong>chan</strong>上等待，则<strong>wakeup</strong>不做任何事情。我们修改信号量实现，以使用<strong>sleep</strong>和<strong>wakeup</strong>（修改处用注释标注）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count += <span class="number">1</span>;</span><br><span class="line">  wakeup(s);<span class="comment">// 修改</span></span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    sleep(s);<span class="comment">// 修改</span></span><br><span class="line">  acquire(&amp;s-&gt;lock);</span><br><span class="line">  s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">  release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P现在放弃CPU而不是自旋，这是一个不错的改进。然而，事实证明，像这样设计<strong>sleep</strong>和<strong>wakeup</strong>并不是一件容易的事，因为它会遇到所谓的丢失唤醒问题。假设执行P 的<strong>s-&gt;count == 0</strong>这一行时。当P在<strong>sleep</strong>之前，V在另一个CPU上运行：它将<strong>s-&gt;count</strong>改为非零，并调用<strong>wakeup</strong>，<strong>wakeup</strong>发现没有进程在睡眠，因此什么也不做。现在P继续执行：它调用<strong>sleep</strong>并进入睡眠状态。这就造成了一个问题：P正在<strong>sleep</strong>，等待一个已经发生的V调用。除非我们运气好，生产者再次调用V，否则消费者将永远等待，即使计数是非零。</p><p>这个问题的根源在于，在错误的时刻运行的V违反了P只在<code>s-&gt;count==0</code>时休眠的不变量。保护这个不变量的一个不正确的方法是将锁获取（修改用注释标注）移动到P中，这样它对计数的检查和对sleep的调用是原子的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;s-&gt;lock);</span><br><span class="line">s-&gt;count += <span class="number">1</span>;</span><br><span class="line">wakeup(s);</span><br><span class="line">release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;s-&gt;lock);<span class="comment">// 修改</span></span><br><span class="line"><span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">sleep(s);</span><br><span class="line">s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人们可能希望这个版本的P能够避免丢失的唤醒，因为锁会阻止V在<strong>s-&gt;count == 0</strong>和sleep之间执行。它做到了这一点，但它也会死锁。P在<strong>sleep</strong>时保持着锁，所以V将永远阻塞在等待锁的过程中。</p><p>我们将通过改变<strong>sleep</strong>的接口来修正前面的方案：调用者必须将<strong><em>条件锁(condition lock)</em></strong>传递给<strong>sleep</strong>，这样在调用进程被标记为<strong><em>SLEEPING</em></strong>并在chan上等待后，它就可以释放锁。锁将强制并发的V等待直到P将自己置于<strong><em>SLEEPING</em></strong>状态，这样<strong>wakeup</strong>就会发现<strong><em>SLEEPING</em></strong>的消费者并将其唤醒。一旦消费者再次被唤醒，<strong>sleep</strong>就会重新获得锁，然后再返回。我们新的正确的睡眠/唤醒方案是可用的，如下所示（修改用注释标注）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">acquire(&amp;s-&gt;lock);</span><br><span class="line"><span class="keyword">while</span>(s-&gt;count == <span class="number">0</span>)</span><br><span class="line">sleep(s, &amp;s-&gt;lock);<span class="comment">// 修改</span></span><br><span class="line">s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P持有<strong>s-&gt;lock</strong>会阻止了V在P检查<strong>c-&gt;count</strong>和调用<strong>sleep</strong>之间试图唤醒它。但是，请注意，我们需要<strong>sleep</strong>来原子地释放<strong>s-&gt;lock</strong>并使消费者进程进入<strong><em>SLEEPING</em></strong>状态。</p><h3 id="7-6-Code-Sleep-and-wakeup"><a href="#7-6-Code-Sleep-and-wakeup" class="headerlink" title="7.6 Code: Sleep and wakeup"></a>7.6 Code: Sleep and wakeup</h3><p>让我们看看<strong>sleep (kernel/proc.c:548)</strong> 和 <strong>wakeup (kernel/proc.c:582)</strong> 的实现。其基本思想是让<strong>sleep</strong>将当前进程标记为<strong>SLEEPING</strong>，然后调用<strong>sched</strong>让出<strong>CPU</strong>；<strong>wakeup</strong>则寻找给定的<strong><em>等待通道</em></strong>上睡眠的进程，并将其标记为<strong>RUNNABLE</strong>。<strong>sleep</strong>和<strong>wakeup</strong>的调用者可以使用任何方便的数字作为<strong>channel</strong>。Xv6经常使用参与等待的内核数据结构的地址。</p><p><strong>Sleep</strong>首先获取<strong>p-&gt;lock (kernel/proc.c:559)</strong>。现在进入睡眠状态的进程同时持有<strong>p-&gt;lock</strong>和<strong>lk</strong>。在调用者(在本例中为P)中，持有<strong>lk</strong>是必要的：它保证了没有其他进程(在本例中，运行V的进程)可以调用<strong>wakeup(chan)</strong>。现在<strong>sleep</strong>持有<strong>p-&gt;lock</strong>，释放<strong>lk</strong>是安全的：其他进程可能会调用<strong>wakeup(chan)</strong>，但<strong>wakeup</strong>会等待获得<strong>p-&gt;lock</strong>，因此会等到<strong>sleep</strong>将进程状态设置为<strong>SLEEPING</strong>，使<strong>wakeup</strong>不会错过<strong>sleep</strong>的进程。</p><p>有一个复杂情况：如果<strong>lk</strong>和<strong>p-&gt;lock</strong>是同一个锁，如果<strong>sleep</strong>仍试图获取<strong>p-&gt;lock</strong>，就会和自己死锁。但是如果调用<strong>sleep</strong>的进程已经持有<strong>p-&gt;lock</strong>，那么它就不需要再做任何事情来避免错过一个并发的<strong>wakeup</strong>。这样的情况发生在，<strong>wait (kernel/proc.c:582)</strong>调用<strong>sleep</strong>并持有<strong>p-&gt;lock</strong>时。</p><p>现在<strong>sleep</strong>持有<strong>p-&gt;lock</strong>，而没有其他的锁，它可以通过记录它睡眠的<strong>channel</strong>，将进程状态设置<strong>SLEEPING</strong>，并调用<strong>sched</strong>(kernel/proc.c:564-567)来使进程进入睡眠状态。稍后我们就会明白为什么在进程被标记为<strong>SLEEPING</strong>之前，<strong>p-&gt;lock</strong>不会被释放（由调度器）。</p><p>在某些时候，一个进程将获取条件锁，设置睡眠等待的条件，并调用<strong>wakeup(chan)</strong>。重要的是，<strong>wakeup</strong>是在持有条件锁<a href="#ftn2">[2]</a>的情况下被调用的。<strong>Wakeup</strong>循环浏览进程表<strong>（kernel/proc.c:582）</strong>。它获取每个被检查的进程的<strong>p-&gt;lock</strong>，因为它可能会修改该进程的状态，也因为<strong>p-&gt;sleep</strong>确保<strong>sleep</strong>和<strong>wakeup</strong>不会相互错过。当<strong>wakeup</strong>发现一个进程处于状态为<strong>SLEEPING</strong>并有一个匹配的<strong>chan</strong>时，它就会将该进程的状态改为<strong>RUNNABLE</strong>。下一次调度器运行时，就会看到这个进程已经准备好运行了。</p><p>为什么<strong>sleep</strong>和<strong>wakeup</strong>的锁规则能保证睡眠的进程不会错过<strong>wakeup</strong>？<strong>sleep</strong>进程从检查条件之前到标记为<strong>SLEEPING</strong>之后的这段时间里，持有条件锁或它自己的<strong>p-&gt;lock</strong>或两者都持有。调用<strong>wakeup</strong>的进程在<strong>wakeup</strong>的循环中持有这两个锁。因此，唤醒者要么在消费者检查条件之前使条件为真；要么唤醒者的<strong>wakeup</strong>在消费者被标记为<strong>SLEEPING</strong>之后检查它。 无论怎样，<strong>wakeup</strong>就会看到这个睡眠的进程，并将其唤醒（除非有其他事情先将其唤醒）。</p><p>有时会出现多个进程在同一个<strong>channel</strong>上睡眠的情况；例如，有多个进程从管道中读取数据。调用一次<strong>wakeup</strong>就会把它们全部唤醒。其中一个进程将首先运行，并获得<strong>sleep</strong>参数传递的锁，（就管道而言）读取数据都会在管道中等待。其他进程会发现，尽管被唤醒了，但没有数据可读。从他们的角度来看，唤醒是“虚假的“，他们必须再次睡眠。出于这个原因，<strong>sleep</strong>总是在一个检查条件的循环中被调用。</p><p>如果两次使用<strong>sleep/wakeup</strong>不小心选择了同一个通道，也不会有害：它们会看到虚假的唤醒，上面提到的循环允许发生这种情况。<strong>sleep</strong>/<strong>wakeup</strong>的魅力很大程度上在于它既是轻量级的（不需要创建特殊的数据结构来充当睡眠通道），又提供了一层间接性（调用者不需要知道他们正在与哪个具体的进程交互）。</p><h3 id="7-7-Code-Pipes"><a href="#7-7-Code-Pipes" class="headerlink" title="7.7 Code: Pipes"></a>7.7 Code: Pipes</h3><p>一个使用<strong>sleep</strong>和<strong>wakeup</strong>来同步生产者和消费者的更复杂的例子是xv6的管道实现。我们在第1章看到了管道的接口：写入管道一端的字节被复制到内核缓冲区，然后可以从管道的另一端读取。未来的章节将研究管道如何支持文件描述符，但我们现在来看一下<strong>pipewrite</strong>和<strong>piperead</strong>的实现吧。</p><p>每个管道由一个结构体 <strong>pipe</strong>表示，它包含一个锁和一个数据缓冲区。<strong>nread</strong>和<strong>nwrite</strong>两个字段统计从缓冲区读取和写入的字节总数。缓冲区呈环形：<strong>buf[PIPESIZE-1]</strong>之后写入的下一个字节是<strong>buf[0]</strong>。计数不呈环形。这个约定使得实现可以区分满缓冲区(<strong>nwrite == nread+PIPESIZE</strong>)和空缓冲区(<strong>nwrite == nread</strong>)，但这意味着对缓冲区的索引必须使用<strong>buf[nread % PIPESIZE]</strong>，而不是使用<strong>buf[nread]</strong>(<strong>nwrite</strong>也是如此)。</p><p>假设对<strong>piperead</strong>和<strong>pipewrite</strong>的调用同时发生在两个不同的CPU上。<strong>Pipewrite</strong> <strong>(kernel/pipe.c:77)</strong>首先获取管道的锁，它保护了计数、数据和相关的不变式。然后，<strong>Piperead</strong> <strong>(kernel/pipe.c:103)</strong>也试图获取这个锁，但是不会获取成功。它在<strong>acquire(kernel/spinlock.c:22)</strong>中循环，等待锁的到来。当<strong>piperead</strong>等待时，<strong>pipewrite</strong>会循环写，依次将每个字节添加到管道中(kernel/pipe.c:95)。在这个循环中，可能会发生缓冲区被填满的情况(kernel/pipe.c:85)。在这种情况下，<strong>pipewrite</strong>调用<strong>wakeup</strong>来提醒所有睡眠中的reader有数据在缓冲区中等待，然后在<strong>&amp;pi-&gt;nwrite</strong>上<strong>sleep</strong>，等待reader从缓冲区中取出一些字节。<strong>Sleep</strong>函数内会释放<strong>pi-&gt;lock</strong>，然后<strong>pipwrite</strong>进程睡眠。</p><p>现在<strong>pi-&gt;lock</strong>可用了，<strong>piperead</strong>设法获取它并进入它的临界区：它发现<strong>pi-&gt;nread != pi-&gt;nwrite (kernel/pipe.c:110)</strong> (<strong>pipewrite</strong>进入睡眠状态是由于<strong>pi-&gt;nwrite == pi-&gt;nread+PIPESIZE (kernel/pipe.c:85)</strong>)，所以它进入for循环，将数据从管道中复制出来<strong>(kernel/pipe.c:117)</strong>，并按复制的字节数增加<strong>nread</strong>。现在又可写了，所以 <strong>piperead</strong> 在返回之前调用 <strong>wakeup (kernel/pipe.c:124)</strong> 来唤醒在睡眠的writer。<strong>Wakeup</strong>找到一个在<strong>&amp;pi-&gt;nwrite</strong>上睡眠的进程，这个进程正在运行<strong>pipewrite</strong>，但在缓冲区填满时停止了。它将该进程标记为<strong>RUNNABLE</strong>。</p><p>管道代码对reader和writer分别使用不同的睡眠<strong>channel</strong>（<strong>pi-&gt;nread</strong>和<strong>pi-&gt;nwrite</strong>）；这可能会使系统在有多个reader和writer等待同一个管道的情况下更有效率。管道代码在循环内sleep，检查sleep条件；如果有多个reader 和 writer，除了第一个被唤醒的进程外，其他进程都会看到条件仍然是假的，然后再次睡眠。</p><h3 id="7-8-Code-Wait-exit-and-kill"><a href="#7-8-Code-Wait-exit-and-kill" class="headerlink" title="7.8 Code: Wait, exit, and kill"></a>7.8 Code: Wait, exit, and kill</h3><p><strong>sleep</strong>和<strong>wakeup</strong>可以用于许多种需要等待的情况。在第1章中介绍的一个有趣的例子是，一个子进程的<strong>exit</strong>和其父进程的<strong>wait</strong>之间的交互。在子进程退出的时候，父进程可能已经在<strong>wait</strong>中睡眠了，也可能在做别的事情；在后一种情况下，后续的<strong>wait</strong>调用必须观察子进程的退出，也许是在它调用<strong>exit</strong>之后很久。xv6在<strong>wait</strong>观察到子进程退出之前，记录子进程退出的方式是让<strong>exit</strong>将调用进程设置为<strong>ZOMBIE</strong>状态，在那里停留，直到父进程的<strong>wait</strong>注意到它，将子进程的状态改为<strong>UNUSED</strong>，然后复制子进程的退出状态，并将子进程的进程ID返回给父进程。如果父进程比子进程先退出，父进程就把子进程交给<strong>init</strong>进程，而<strong>init</strong>进程则循环的调用<strong>wait</strong>；这样每个子进程都有一个“父进程”来清理。主要的实现挑战是父进程和子进程的<strong>wait</strong>和<strong>exit</strong>，以及<strong>exit</strong>和<strong>exit</strong>之间可能出现竞争和死锁的情况。</p><p><strong>Wait</strong>使用<em>调用进程</em> 的<strong>p-&gt;lock</strong>作为条件锁，以避免唤醒丢失，它在开始时获取该锁<strong>（kernel/proc.c:398）</strong>。然后它扫描进程表。如果它发现一个处于<strong>ZOMBIE</strong>状态的子进程，它释放这个子进程的资源和它的<strong>proc</strong>结构，将子进程的退出状态复制到提供给<strong>wait</strong>的地址(如果它不是0)，并返回子进程的ID。如果<strong>wait</strong>找到了子进程但没有一个退出，它调用<strong>sleep</strong>等待其中一个子进程退出<strong>(kernel/proc.c:445)</strong>，然后再次扫描。这里，在<strong>sleep</strong>中释放的条件锁是等待进程的<strong>p-&gt;lock</strong>，也就是上面提到的特殊情况。请注意，<strong>wait</strong>经常持有两个锁；它在试图获取任何子锁之前，会先获取自己的锁；因此xv6的所有锁都必须遵守相同的锁顺序（父进程的锁，然后是子进程的锁），以避免死锁。</p><p><strong>Wait</strong>会查看每个进程的<strong>np-&gt;parent</strong>来寻找它的子进程。它使用 <strong>np-&gt;parent</strong> 而不持有 <strong>np-&gt;lock</strong>，这违反了共享变量必须受锁保护的通常规则。但是<strong>np</strong>有可能是当前进程的祖先，在这种情况下，获取<strong>np-&gt;lock</strong>可能会导致死锁，因为这违反了上面提到的顺序。在这种情况下，在没有锁的情况下检查<strong>np-&gt;parent</strong>似乎是安全的；一个进程的父进程字段只有“父亲“改变，所以如果<strong>np-&gt;parent==p</strong>为真，除非当前进程改变它，否则该值就不会改变。</p><p><strong>Exit (kernel/proc.c:333)</strong>记录退出状态，释放一些资源，将所有子进程交给<strong>init</strong>进程，在父进程处于等待状态时唤醒它，将<em>调用进程</em>标记为<strong>zombie</strong>，并永久放弃CPU。最后的序列有点棘手。退出的进程必须持有父进程的锁，同时将自己状态设置为<strong>ZOMBIE</strong>并唤醒父进程，因为父进程的锁是条件锁，可以防止在等待中丢失<strong>wakeup</strong>。子进程也必须持有自己的<strong>p-&gt;lock</strong>，否则父进程可能会看到它的状态为<strong>ZOMBIE</strong>，并在它还在运行时释放它。锁的获取顺序对避免死锁很重要：因为<strong>wait</strong>在子锁之前获取父锁，所以<strong>exit</strong>必须使用相同的顺序。</p><p><strong>Exit</strong> 调用了一个专门的唤醒函数 <strong>wakeup1</strong>，它只唤醒父函数，而且只有父进程在<strong>wait</strong>中睡眠的情况下才会去唤醒它<strong>(kernel/proc.c:598)</strong>。在将自己的状态设置为<strong>ZOMBIE</strong>之前，唤醒父进程可能看起来并不正确，但这是安全的：尽管<strong>wakeup1</strong>可能会导致父进程运行，但<strong>wait</strong>中的循环不能检查子进程，直到子进程的<strong>p-&gt;lock</strong>被调度器释放为止，所以<strong>wait</strong>不能查看退出的进程，直到<strong>exit</strong>将其状态设置为<strong>ZOMBIE</strong>之后<strong>(kernel/proc.c:386)</strong>。</p><p><strong>exit</strong>允许一个进程自行终止，而<strong>kill（kernel/proc.c:611）</strong>则允许一个进程请求另一个进程终止。如果让<strong>kill</strong>直接摧毁进程，那就太复杂了，因为相应进程可能在另一个CPU上执行，也许正处于更新内核数据结构的敏感序列中。因此，kill的作用很小：它只是设置进程的<strong>p-&gt;killed</strong>，如果它在<strong>sleep</strong>，则<strong>wakeup</strong>它。最终，进程会进入或离开内核，这时如果<strong>p-&gt;killed</strong>被设置，<strong>usertrap</strong>中的代码会调用<strong>exit</strong>。如果进程在用户空间运行，它将很快通过进行系统调用或因为定时器（或其他设备）中断而进入内核。</p><p>如果进程处于睡眠状态，<strong>kill</strong>调用<strong>wakeup</strong>会使进程从睡眠中返回。这是潜在的危险，因为正在等待的条件可能不为真。然而，xv6对<strong>sleep</strong>的调用总是被包裹在一个<strong>while</strong>循环中，在<strong>sleep</strong>返回后重新检测条件。一些对<strong>sleep</strong>的调用也会在循环中检测<strong>p-&gt;killed</strong>，如果设置了<strong>p-&gt;killed</strong>，则离开当前活动。只有当这种离开是正确的时候才会这样做。例如，管道读写代码如果设置了<strong>killed</strong>标志就会返回；最终代码会返回到<strong>trap</strong>，<strong>trap</strong>会再次检查标志并退出。</p><p>一些xv6 <strong>sleep</strong>循环没有检查<strong>p-&gt;killed</strong>，因为代码处于多步骤系统调用的中间，而这个调用应该是原子的。virtio驱动<strong>(kernel/virtio_disk.c:242)</strong>就是一个例子：它没有检查<strong>p-&gt;killed</strong>，因为磁盘操作可能是一系列写操作中的一个，而这些写操作都是为了让文件系统处于一个正确的状态而需要的。一个在等待磁盘I/O时被杀死的进程不会退出，直到它完成当前的系统调用和<strong>usertrap</strong>看到<strong>killed</strong>的标志。</p><h3 id="7-9-Real-world"><a href="#7-9-Real-world" class="headerlink" title="7.9 Real world"></a>7.9 Real world</h3><p>xv6 调度器实现了一个简单的调度策略，它依次运行每个进程。这种策略被称为<strong><em>轮询调度(round robin)</em></strong>。真正的操作系统实现了更复杂的策略，例如，允许进程有优先级。这个策略是，一个可运行的高优先级进程将被调度器优先于一个可运行的低优先级进程。这些策略可能会很快变得复杂，因为经常有相互竞争的目标：例如，操作者可能还想保证公平性和高吞吐量。此外，复杂的策略可能会导致不尽人意的交互，如<strong><em>优先级倒置(priority inversion)</em></strong>和<strong><em>护航现象(convoys</em></strong>)。当低优先级和高优先级进程共享一个锁时，就会发生优先级倒置，当低优先级进程获得锁时，就会阻止高优先级进程的进展。当许多高优先级进程都在等待一个获得共享锁的低优先级进程时，就会形成一个长长的等待进程的车队；一旦护航现象形成，就会持续很长时间。为了避免这类问题，在复杂的调度器中需要额外的机制。</p><p><strong>sleep</strong>和<strong>wakeup</strong>是一种简单有效的同步方法，但还有很多其他的方法。在所有这些方法中，第一个挑战是避免我们在本章开头看到的丢失唤醒问题。最初的Unix内核的<strong>sleep</strong>只是禁用了中断，这已经足够了，因为Unix运行在单CPU系统上。因为xv6运行在多处理器上，所以它增加了一个显式的<strong>sleep</strong>锁。FreeBSD 的 <strong>msleep</strong> 采用了同样的方法。Plan 9的<strong>sleep</strong>使用了一个回调函数，它在进入睡眠前保持调度锁的情况下运行；这个函数的作用是在最后一刻检查<strong>sleep</strong>情况，以避免<strong>wakeup</strong>丢失。Linux内核的<strong>sleep</strong>使用一个显式的进程队列，称为等待队列，而不是等待通道；队列有自己的内部锁。</p><p>在<strong>wakeup</strong>过程中扫描整个进程链表，寻找相匹配的<strong>chan</strong>的进程，效率很低。一个更好的解决方案是用一个数据结构代替<strong>sleep</strong>和<strong>wakeup</strong>中的<strong>chan</strong>，该结构上存放着<strong>sleep</strong>的进程列表，比如Linux的等待队列。Plan 9的<strong>sleep</strong>和<strong>wakeup</strong>将该结构称为rendezvous point或Rendez。许多线程库将同一个结构称为条件变量；在这种情况下，sleep和wakeup的操作被称为<strong>wait</strong>和<strong>signal</strong>。所有这些机制都有相同的机制：睡眠条件被睡眠过程中原子地释放的锁保护。</p><p><strong>wakeup</strong>唤醒了所有在某个特定<strong>channel</strong>上等待的进程，可能很多进程都在等待这个特定<strong>channel</strong>。操作系统会调度所有这些进程，它们会争相检查睡眠条件。以这种方式行事的进程有时被称为<strong><em>惊群效应（thundering herd）</em></strong>，最好避免这种情况。大多数条件变量都有两个唤醒的基元：信号（signal），唤醒一个进程；广播（broadcast），唤醒所有等待的进程。</p><p>信号量通常用于同步。count通常对应于类似于管道缓冲区中可用的字节数或一个进程拥有的僵尸子进程的数量。使用显式计数作为抽象的一部分，可以避免丢失<strong>wakeup</strong>的问题：有一个显式的计数，说明已经发生的唤醒次数。该计数还避免了“虚假的”唤醒和<strong><em>惊群效应</em></strong>问题。</p><p>终止进程和清理进程在xv6中引入了很多复杂性。在大多数操作系统中，它甚至更加复杂，因为，假设被杀进程可能<strong>trap</strong>在内核中睡眠，而解除它的堆栈需要很多仔细的编程。许多操作系统使用显式的异常处理机制来解除堆栈，比如<strong>longjmp</strong><a href="#ftn3">[3]</a>。此外，还有其他一些事件可以导致一个睡眠进程被唤醒，即使它正在等待的事件还没有发生。例如，当一个Unix进程处于睡眠状态时，另一个进程可能会向它发送一个<strong>signal</strong>。在这种情况下，该进程将从中断的系统调用中返回，返回值为-1，错误代码设置为<strong>EINTR</strong>。应用程序可以检查这些值并决定做什么。Xv6不支持信号，也就不会出现这种复杂性。</p><p>Xv6对<strong>kill</strong>的支持并不完全令人满意：有些<strong>sleep</strong>循环可能应该检查<strong>p-&gt;killed</strong>。一个相关的问题是，即使是检查<strong>p-&gt;killed</strong>的<strong>sleep</strong>循环，在<strong>sleep</strong>和<strong>kill</strong>之间也会有一个竞争；<strong>kill</strong>可能会设置<strong>p-&gt;killed</strong>，并试图唤醒被杀进程，唤醒时刻发生在循环检查<strong>p-&gt;killed</strong>之后， 但在它调用<strong>sleep</strong>之前，就会发生。如果这个问题发生了，被杀进程不会注意到<strong>p-&gt;killed</strong>，直到它所等待的条件发生。这可能会晚很多（例如，当virtio驱动返回一个被杀进程正在等待的磁盘块时），也可能永远不会发生（例如，如果被杀进程正在等待来自控制台的输入，但用户没有键入任何输入）。</p><p>真正的操作系统会在常数时间内用显式的空闲列表来寻找空闲的进程，而不是在allocproc中进行线性时间的搜索；xv6为了简单起见，使用了线性扫描的方式。</p><h3 id="7-10-Exercises"><a href="#7-10-Exercises" class="headerlink" title="7.10 Exercises"></a>7.10 Exercises</h3><ol><li>Sleep必须检查lk != &amp; p-&gt;lock以避免死锁<strong>(kernel/proc.c:558-561)</strong>。假设一种特殊情况通过将</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">     acquire(&amp;p-&gt;lock);</span><br><span class="line">     release(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">release(lk);</span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br></pre></td></tr></table></figure><p>这样会破坏sleep吗，怎样破坏。</p><ol><li><p>大部分进程退出时，资源清理可以通过<strong>exit</strong>或<strong>wait</strong>来完成。事实证明，关闭打开的文件一定要在<strong>exit</strong>中进行。为什么？答案和管道有关。</p></li><li><p>在xv6中实现信号量而不使用<strong>sleep</strong>和<strong>wakeup</strong>(但可以使用<strong>spin</strong> <strong>locks</strong>)。在xv6中用信号量替换<strong>sleep</strong>和<strong>wakeup</strong>的使用。判断结果。</p></li><li><p>修正上面提到的<strong>kill</strong>和<strong>sleep</strong>之间的竞争，使得发生在被杀进程睡眠循环检查p-&gt;killed之后，在它调用sleep之前的kill会使得被杀进程放弃当前系统调用。</p></li><li><p>设计一个方案，让每一个睡眠循环都检查<strong>p-&gt;killed</strong>，这样，在<strong>virtio</strong>驱动中的进程如果被其他进程杀死，就可以从<strong>while</strong>循环中快速返回。</p></li><li><p>修改xv6，当从一个进程的内核线程切换到另一个进程时，只使用一次上下文切换，而不是先切换到调度线程，再切换到另一个进程。使用一次上下文切换，产生的线程需要自己选择下一个线程，并调用<strong>swtch</strong>。面临的挑战将是如何防止多个内核意外执行同一个线程；如何正确地进行锁定；以及如何避免死锁。</p></li><li><p>修改xv6的调度器，当没有进程可运行时，使用RISC-V <strong>WFI</strong>（等待中断）指令。尽量保证只要有可运行的进程等待运行，就不会有核心通过WFI进行暂停。</p></li><li><p>锁<strong>p-&gt;lock</strong>保护了很多不变式，当看到某段被<strong>p-&gt;lock</strong>保护的xv6代码时，可能很难弄清楚保护了那个不变式。通过将<strong>p-&gt;lock</strong>拆分成几个锁，设计一个更简洁的方案。</p></li></ol><hr><ol><li><p><a name="ftn1"></a>ra寄存器: 函数return地址。</p></li><li><p><a name="ftn2"></a>严格地说，只是在<strong>acquire</strong>之后<strong>wakeup</strong>就足够了(也就是说，可以在<strong>release</strong>之后调用<strong>wakeup</strong>)。</p></li><li><p><a name="ftn3"></a>一种异常处理方式，可以去google下。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第六章</title>
      <link href="/2022/08/31/xv6-Chapter-6/"/>
      <url>/2022/08/31/xv6-Chapter-6/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章：锁"><a href="#第六章：锁" class="headerlink" title="第六章：锁"></a>第六章：锁</h2><p>大多数内核，包括xv6，都会交错执行多个任务。一种实现交错执行任务的方式是多处理器架构：硬件系统具有多个CPU独立执行，如xv6的RISC-V。这些CPU共享物理RAM，xv6利用共享来维护所有CPU读写的数据结构。这种共享带来了一种可能性，即一个CPU读取一个数据结构，而另一个CPU正在中途更新它，甚至多个CPU同时更新同一个数据。如果不仔细设计，这种并行访问很可能产生不正确的结果或破坏数据结构。即使在单处理器上，内核也可能在多个线程之间切换CPU，导致它们的执行交错。最后，如果中断发生的时间不对，一个设备中断处理程序可能会修改与一些可中断代码相同的数据，从而破坏数据。并发一词指的是由于多处理器并行、线程切换或中断而导致多个指令流交错的情况。</p><p>内核中充满了并发访问的数据。例如，两个CPU可以同时调用<code>kalloc</code>，从而并发地从空闲内存链表的头部push。内核设计者喜欢允许大量的并发，因为它可以通过并行来提高性能，提高响应速度。然而，结果是内核设计者花了很多精力来让自己确认这些存在的并发是正确的。有很多方法可以写出正确的代码，有些方法比其他方法更简单。以并发下的正确性为目标的策略，以及支持这些策略的抽象，被称为并发控制技术。</p><p>根据不同的情况，xv6使用了很多并发控制技术，且还有更多的可能尚未被实现。本章重点介绍一种广泛使用的技术:锁（lock）。锁提供了互斥的功能，确保一次只有一个CPU可以持有一个特定的锁。如果程序员为每个共享数据项关联一个锁，并且代码在使用某项时总是持有关联的锁，那么该项每次只能由一个CPU使用。在这种情况下，我们说锁保护了数据项。虽然锁是一种简单易懂的并发控制机制，但其也带来了性能降低的缺点，因为锁将并发操作串行化了。</p><p>本章的其余部分解释了为什么xv6需要锁、xv6如何实现它们以及如何使用它们。</p><h3 id="6-1-竞争条件"><a href="#6-1-竞争条件" class="headerlink" title="6.1 竞争条件"></a>6.1 竞争条件</h3><p><img src="/img/Figure-6.1.png" alt="Figure-6.1"></p><p>作为我们为什么需要锁的一个例子，考虑两个进程在两个不同的CPU上调用<code>wait</code>，<code>wait</code>释放子进程的内存。因此，在每个CPU上，内核都会调用<code>kfree</code>来释放子进程的内存页。内核分配器维护了一个链表:<code>kalloc()</code>(kernel/kalloc.c:69)从空闲页链表中pop一页内存，<code>kfree()</code>(kernel/kalloc.c:47)将一页push空闲链表中。为了达到最好的性能，我们可能希望两个父进程的<code>kfree</code>能够并行执行，而不需要任何一个进程等待另一个进程，但是考虑到xv6的<code>kfree</code>实现，这是不正确的。</p><p>图6.1更详细地说明了这种设置：链表在两个CPU共享的内存中，CPU使用加载和存储指令操作链表。(在现实中，处理器有缓存，但在概念上，多处理器系统的行为就像有一个单一的共享内存一样)。如果没有并发请求，你可能会实现如下的链表push操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span> =</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/Figure-6.2.png" alt="Figure-6.2"></p><p>如果单独执行，这个实现是正确的。但是，如果多个副本同时执行，代码就不正确。如果两个CPU同时执行<code>push</code>，那么两个CPU可能都会执行图6.1所示的第15行，然后其中一个才执行第16行，这就会产生一个不正确的结果，如图6.2所示。这样就会出现两个list元素，将next设为list的前值。当对list的两次赋值发生在第16行时，第二次赋值将覆盖第一次赋值;第一次赋值中涉及的元素将丢失。</p><p>第16行的丢失更新是竞争条件(race condition)的一个例子。竞争条件是指同时访问一个内存位置，并且至少有一次访问是写的情况。竞争通常是一个错误的标志，要么是丢失更新(如果访问是写)，要么是读取一个不完全更新的数据结构。竞争的结果取决于所涉及的两个CPU的确切时间，以及它们的内存操作如何被内存系统排序，这可能会使竞争引起的错误难以重现和调试。例如，在调试<code>push</code>时加入<code>print</code>语句可能会改变执行的时机，足以使竞争消失。</p><p>避免竞争的通常方法是使用锁。锁确保了相互排斥，因此一次只能有一个CPU执行<code>push</code>的哪一行;这就使得上面的情况不可能发生。上面代码的正确<code>lock</code>版本只增加了几行代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span>=</span><span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locklist</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span> <span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">    release(&amp;listlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code>和<code>release</code>之间的指令序列通常被称为临界区。这里的锁保护<code>list</code>。</p><p>当我们说锁保护数据时，我们真正的意思是<strong>锁保护了一些适用于数据的不变量(invariant)的集合</strong>。不变量是数据结构的属性，这些属性在不同的操作中得到维护。通常情况下，一个操作的正确行为取决于操作开始时的不变量是否为真。操作可能会暂时违反不变量，但在结束前必须重新建立不变量。例如，在链表中，不变性是：“list指向列表中的第一个元素，并且每个元素的下一个字段指向下一个元素”。push的实现暂时违反了这一不变性：在第17行，l指向下一个链表元素list，但list还没有指向l（在第18行重新建立）。我们上面所研究的竞争条件之所以会发生，是因为第二个CPU执行了依赖于列表不变式的代码，而它们被（暂时）违反了。正确使用锁可以确保每次只有一个CPU可以对关键部分的数据结构进行操作，因此当数据结构的不变式不成立时，没有CPU会执行数据结构操作。</p><p>你可以把锁看成是把并发的关键部分序列化，使它们一次只运行一个，从而保存不变性（假设关键部分孤立地正确）。你也可以认为由同一个锁保护的关键部分是相互原子的(atomic)，因此每个关键部分只看到来自更早的关键部分的完整变化，而永远不会看到部分完成的更新。</p><p>虽然正确使用锁可以使不正确的代码变得正确，但锁限制了性能。例如，如果两个进程同时调用kfree，锁会将两个调用序列化，我们在不同的CPU上运行它们不会获得任何好处。我们说，如果多个进程同时想要同一个锁，就会发生冲突，或者说锁经历了争夺。内核设计的一个主要挑战是避免锁的争夺。Xv6在这方面做得很少，但是复杂的内核会专门组织数据结构和算法来避免锁争用。在列表的例子中，一个内核可能会维护每个CPU的空闲列表，只有当CPU的列表是空的，并且它必须从另一个CPU偷取内存时，才会接触另一个CPU的空闲列表。其他用例可能需要更复杂的设计。</p><p>锁的位置对性能也很重要。例如，在<code>push</code>中把<code>acquisition</code>移动到较早的位置也是正确的：将<code>acquisition</code>的调用移动到第13行之前是可以的。然而，这可能会降低性能，因为这样的话，对<code>malloc</code>的调用也会被序列化。下面的“使用锁”一节提供了一些关于在哪里插入<code>acquisition</code>和<code>release</code>调用的指南。</p><h3 id="6-2-代码：锁"><a href="#6-2-代码：锁" class="headerlink" title="6.2 代码：锁"></a>6.2 代码：锁</h3><p>Xv6有两种类型的锁:自旋锁(spinlock)和睡眠锁(sleeplock)。我们先说说自旋锁。Xv6将自旋锁表示为一个结构体<code>spinlock</code>(kernel/spinlock.h:2)。该结构中重要的字段是<code>locked</code>，当锁可获得时，<code>locked</code>为零，当锁被持有时，<code>locked</code>为非零。从逻辑上讲，xv6获取锁的的代码类似于:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span><span class="comment">//doesnotwork!</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>)&#123;</span><br><span class="line">lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这种实现并不能保证多处理器上的相互排斥。可能会出现这样的情况:两个CPU同时到达if语句，看到<code>lk-&gt;locked</code>为零，然后都通过设置<code>lk-&gt;locked=1</code>来抢夺锁。此时，两个不同的CPU持有锁，这就违反了互斥属性。我们需要的是让第25行和第26行作为一个原子(即不可分割)步骤来执行。</p><p>由于锁被广泛使用，多核处理器通常提供了一些原子版的指令。在RISC-V上，这条指令是<code>amoswapr,a</code>。<code>amoswap</code>读取内存地址<code>a</code>处的值，将寄存器<code>r</code>的内容写入该地址，并将其读取的值放入<code>r</code>中，也就是说，它将寄存器的内容和内存地址进行了交换。它原子地执行这个序列，使用特殊的硬件来防止任何其他CPU使用读和写之间的内存地址。</p><p>Xv6的<code>acquire</code>(kernel/spinlock.c:22使用了可移植的C库调用<code>__sync_lock_test_and_set</code>，它本质上为<code>amoswap</code>指令;返回值是<code>lk-&gt;locked</code>的旧(被交换出来的)内容。<code>acquire</code>函数循环交换，重试(旋转)直到获取了锁。每一次迭代都会将1交换到<code>lk-&gt;locked</code>中，并检查之前的值;如果之前的值为0，那么我们已经获得了锁，并且交换将<code>lk-&gt;locked</code>设置为1。如果之前的值是1，那么其他CPU持有该锁，而我们原子地将1换成<code>lk-&gt;locked</code>并没有改变它的值。</p><p>一旦锁被获取，<code>acquire</code>就会记录获取该锁的CPU，这方便调试。<code>lk-&gt;cpu</code>字段受到锁的保护，只有在持有锁的时候才能改变。</p><p>函数<code>release</code>(kernel/spinlock.c:47)与<code>acquire</code>相反:它清除<code>lk-&gt;cpu</code>字段，然后释放锁。从概念上讲，释放只需要给<code>lk-&gt;locked</code>赋值为0。C标准允许编译器用多条存储指令来实现赋值，所以C赋值对于并发代码来说可能是非原子性的。相反，<code>release</code>使用C库函数<code>__sync_lock_release</code>执行原子赋值。这个函数也是使用了RISC-V的<code>amoswap</code>指令。</p><h3 id="6-3-代码：使用锁"><a href="#6-3-代码：使用锁" class="headerlink" title="6.3 代码：使用锁"></a>6.3 代码：使用锁</h3><p>Xv6在很多地方使用锁来避免竞赛条件。如上所述，<code>kalloc</code>(kernel/kalloc.c:69)和<code>kfree</code>(kernel/kalloc.c:47)就是一个很好的例子。试着练习1和2看看如果这些函数省略了锁会发生什么事情。你可能会发现，很难触发不正确的行为，这说明很难可靠地测试代码是否没有锁定错误和竞争。xv6有一些竞争也不是不可能的。</p><p>使用锁的一个难点是决定使用多少个锁，以及每个锁应该保护哪些数据和不变量。有几个基本原则。首先，任何时候，当一个CPU可以在另一个CPU读或写变量的同时写入变量时，都应该使用锁来防止这两个操作重叠。第二，记住锁保护不变量：如果一个不变量涉及多个内存位置，通常需要用一个锁保护所有的位置，以确保不变式得到维护。</p><p>上面的规则说了什么时候需要锁，但没有说什么时候不需要锁，为了效率，不要锁太多，因为锁会降低并行性。如果并行性不重要，那么可以安排只有一个进程，而不用担心锁的问题。一个简单的内核可以在多处理器上做到这一点，它有一个单一的锁，这个锁必须在进入内核时获得，并在退出内核时释放（尽管系统调用，如管道读取或等待会带来一个问题）。许多单处理器操作系统已经被改造成使用这种方法在多处理器上运行，有时被称为”大内核锁”，但这种方法牺牲了并行性：内核中一次只能执行一个CPU。如果内核做任何繁重的计算，那么使用一组更大的更细粒度的锁，这样内核可以同时在多个CPU上执行，效率会更高。</p><p>作为粗粒度锁的一个例子，xv6的kalloc.c分配器有一个单一的空闲列表，由一个单一的锁构成。如果不同CPU上的多个进程试图同时分配页面，那么每个进程都必须通过在<code>acquire</code>中旋转来等待轮到自己。旋转会降低性能，因为这不是有用的工作。如果争夺锁浪费了相当一部分CPU时间，也许可以通过改变分配器的设计来提高性能，使其拥有多个空闲列表，每个列表都有自己的锁，从而实现真正的并行分配。（该分配器在lockinglab中会被重写——译者注）</p><p>作为细粒度锁的一个例子，xv6为每个文件都有一个单独的锁，这样操作不同文件的进程往往可以不用等待对方的锁就可以进行。如果想让进程模拟写入同一文件的不同区域，文件锁方案可以做得更细。最终，锁的粒度决定需要由性能测量以及复杂性考虑来驱动。<br>在后续的章节解释xv6的每个部分时，会提到xv6使用锁来处理并发性的例子。作为预览，图6.3列出了xv6中所有的锁。</p><p><img src="/img/Figure-6.3.png" alt="Figure-6.3"></p><h3 id="6-4-死锁和锁的顺序"><a href="#6-4-死锁和锁的顺序" class="headerlink" title="6.4 死锁和锁的顺序"></a>6.4 死锁和锁的顺序</h3><p>如果一个穿过内核的代码路径必须同时持有多个锁，那么所有的代码路径以相同的顺序获取这些锁是很重要的。如果他们不这样做，就会有死锁的风险。假设线程T1执行代码path1并获取锁A，线程T2执行代码path2并获取锁B，接下来T1会尝试获取锁B，T2会尝试获取锁A，这两次获取都会无限期地阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回。为了避免这样的死锁，所有的代码路径必须以相同的顺序获取锁。对全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分:调用者调用函数的方式必须使锁按照约定的顺序被获取。</p><p>由于sleep的工作方式(见第7章)，xv6有许多长度为2的锁序链，涉及到进程锁(<code>structproc</code>中的锁)。例如，<code>consoleintr</code>(kernel/console.c:138)是处理格式化字符的中断流程。当一个新数据到达时，任何正在等待控制台（终端，即cmd）输入的进程都应该被唤醒。为此，<code>consoleintr</code>在调用<code>wakeup</code>时持有<code>cons.lock</code>，以获取进程锁来唤醒它。因此，全局避免死锁的锁顺序包括了<code>cons.lock</code>必须在任何进程锁之前获取的规则。文件系统代码包含xv6最长的锁链。例如，创建一个文件需要同时持有目录的锁、新文件的inode的锁、磁盘块缓冲区的锁、磁盘驱动器的<code>vdisk_lock</code>和调用进程的<code>p-&gt;lock</code>。为了避免死锁，文件系统代码总是按照上一句提到的顺序获取锁。</p><p>遵守全局避免死锁的顺序可能会非常困难。有时锁的顺序与逻辑程序结构相冲突，例如，也许代码模块M1调用模块M2，但锁的顺序要求M2中的锁在M1中的锁之前被获取。有时锁的身份并不是事先知道的，也许是因为必须持有一个锁才能发现接下来要获取的锁的身份。这种情况出现在文件系统中，因为它在路径名中查找连续的组件，也出现在<code>wait</code>和<code>exit</code>的代码中，因为它们搜索进程表寻找子进程。最后，死锁的危险往往制约着人们对锁方案的细化程度，因为更多的锁往往意味着更多的死锁机会。避免死锁是内核实现的重要需求。</p><h3 id="6-5-锁与中断处理"><a href="#6-5-锁与中断处理" class="headerlink" title="6.5 锁与中断处理"></a>6.5 锁与中断处理</h3><p>一些xv6自旋锁保护的数据会被线程和中断处理程序两者使用。例如，<code>clockintr</code>定时器中断处理程序可能会在内核线程读取<code>sys_sleep</code>(kernel/sysproc.c:64)中的<code>ticks</code>的同时，递增<code>ticks</code>(kernel/trap.c:163)。锁<code>tickslock</code>将保护两次临界区。</p><p>自旋锁和中断的相互作用带来了一个潜在的危险。假设<code>sys_sleep</code>持有<code>tickslock</code>，而它的CPU接收到一个时钟中断。<code>clockintr</code>会尝试获取<code>tickslock</code>，看到它被持有，并等待它被释放。在这种情况下，<code>tickslock</code>永远不会被释放：只有<code>sys_sleep</code>可以释放它，但<code>sys_sleep</code>不会继续运行，直到<code>clockintr</code>返回。所以CPU会死锁，任何需要其他锁的代码也会冻结。</p><p>为了避免这种情况，如果一个中断处理程序使用了自旋锁，CPU决不能在启用中断的情况下持有该锁。Xv6则采用了更加保守的策略：当一个CPU获取任何锁时，xv6总是禁用该CPU上的中断。中断仍然可能发生在其他CPU上，所以一个中断程序获取锁会等待一个线程释放自旋锁，但它们不在同一个CPU上。</p><p>xv6在CPU没有持有自旋锁时重新启用中断;它必须做一点记录来应对嵌套的临界区。<code>acquire</code>调用<code>push_off</code>(kernel/spinlock.c:89)和<code>release</code>调用<code>pop_off</code>(kernel/spinlock.c:100)来跟踪当前CPU上锁的嵌套级别。当该计数达到零时，<code>pop_off</code>会恢复最外层临界区开始时的中断启用状态。<code>intr_off</code>和<code>intr_on</code>函数分别执行RISC-V指令来禁用和启用中断。</p><p>在设置<code>lk-&gt;locked</code>之前，严格调用<code>push_off</code>是很重要的(kernel/spinlock.c:28)。如果两者反过来，那么在启用中断的情况下，锁会有一个窗口(未锁到的位置)，在未禁止中断时持有锁。在这种情况下，一个时机恰到好处的时钟中断会使系统死锁。同样，释放锁后才调用<code>pop_off</code>也很重要(kernel/spinlock.c:66)。</p><h3 id="6-6-指令与存储的顺序"><a href="#6-6-指令与存储的顺序" class="headerlink" title="6.6 指令与存储的顺序"></a>6.6 指令与存储的顺序</h3><p>人们很自然地认为程序是按照源代码语句出现的顺序来执行的。然而，许多编译器和CPU为了获得更高的性能，会不按顺序执行代码。如果一条指令需要很多周期才能完成，CPU可能会提前发出该指令，以便与其他指令重叠，避免CPU停顿。例如，CPU可能会注意到在一个串行序列中，指令A和B互不依赖。CPU可能先启动指令B，这是因为它的输入在A的输入之前已经准备好了，或者是为了使A和B的执行重叠。编译器可以执行类似的重新排序，在一条语句的指令之前发出另一条语句的指令，由于它们原来的顺序。</p><p>编译器和CPU在对指令重新排序时遵循相应规则，以确保它们不会改变正确编写的串行代码的结果。然而，这些规则确实允许重排，从而改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的指令排序规则规则称为内存模型(memory model)。</p><p>例如，在这段<code>push</code>的代码中，如果编译器或CPU将第4行对应的存储移到第6行释放后的某个点，那将是一场灾难。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release(&amp;listlock);</span><br></pre></td></tr></table></figure><p>如果发生这样的重排，就会有一个指令执行的窗口。在这个窗口中，另一个CPU可以获取锁并观察更新的链表，但看到的是一个未初始化的<code>list-&gt;next</code>。</p><p>为了告诉硬件和编译器不要执行这样的re-ordering，xv6在<code>acquire</code>(kernel/spinlock.c:22)和<code>release</code>(kernel/spinlock.c:47)中都使用了<code>__sync_synchronize()</code>。<code>__sync_synchronize</code>()是一个内存屏障(memory barrier):它告诉编译器和CPU不要在越过屏障重新排列任何的内存读写操作。<code>acquire</code>和<code>release</code>中的屏障几乎在所有重要的情况下都会强制锁定顺序，因为xv6在访问共享数据的周围使用锁。第9章讨论了一些例外情况。</p><h3 id="6-7-睡眠锁"><a href="#6-7-睡眠锁" class="headerlink" title="6.7 睡眠锁"></a>6.7 睡眠锁</h3><p>有时xv6需要长时间保持一个锁。例如，文件系统（第8章）在磁盘上读写文件内容时，会保持一个文件的锁定，这些磁盘操作可能需要几十毫秒。如果另一个进程想获取一个自旋锁，那么保持那么长的时间会导致浪费，因为第二个进程在等待锁的同时会浪费CPU很长时间。自旋锁的另一个缺点是，一个进程在保留自旋锁的同时不能释放CPU并将自身转变为就绪态；我们希望做到这一点，以便在拥有自旋锁的进程等待磁盘时，其他进程可以使用CPU。在持有自旋锁时释放CPU是非法的，因为如果第二个线程再试图获取自旋锁，可能会导致死锁；由于<code>acquire</code>并不能释放CPU，第二个进程的等待可能会阻止第一个进程运行和释放锁。在持有锁的同时释放CPU也会违反在持有自旋锁时中断必须关闭的要求。因此，我们希望有一种锁，在等待获取的同时让CPU可以进行别的工作，并在锁被持有时允许释放CPU，同时开放中断。</p><p>Xv6以睡眠锁(sleeplock)的形式提供了这样的锁。<code>acquiresleep</code>(kernel/sleeplock.c:22)在等待时产生CPU，使用的技术将在第7章解释。在高层次上，睡眠锁有一个由<code>spinlock</code>保护的锁定字段，<code>acquiresleep</code>调用<code>sleep</code>原子性地让渡CPU并释放<code>spinlock</code>。结果就是，在<code>acquireleep</code>等待的时候，其他线程可以执行。</p><p>因为睡眠锁使中断处于启用状态，所以它们不能用于中断处理程序中。由于<code>acquiresleep</code>可能会释放CPU，所以睡眠锁不能在自旋锁的核心代码中使用（尽管自旋锁可以在睡眠锁的核心代码中使用）。</p><p>自旋锁最适合于短的关键部分，因为等待它们会浪费CPU时间；睡眠锁对长的操作很有效。</p><h3 id="6-8-现实世界"><a href="#6-8-现实世界" class="headerlink" title="6.8 现实世界"></a>6.8 现实世界</h3><p>尽管对并发基元和并行进行了多年的研究，但使用锁进行编程仍然具有挑战性。通常最好是将锁隐藏在更高级别的构造中，比如同步队列，尽管xv6没有这样做。如果您使用锁编程，明智的做法是使用一个试图识别竞争条件的工具，因为很容易错过一个需要锁的不变式。</p><p>大多数操作系统都支持POSIX线程（Pthreads），它允许一个用户进程在不同的CPU上有多个线程同时运行。Pthreads对用户级锁、屏障等都有支持。支持Pthreads需要操作系统的支持。例如，应该是如果一个pthread在系统调用中阻塞，同一进程的另一个pthread应该可以在该CPU上运行。又比如，如果一个pthread改变了它的进程的地址空间（比如映射或取消映射内存），内核必须安排运行同一进程线程的其他CPU更新它们的硬件页表以反映地址空间的变化。</p><p>可以在没有原子指令的情况下实现锁，但成本很高，大多数操作系统都使用原子指令。</p><p>如果许多CPU试图同时获取同一个锁，那么锁的成本会很高。如果一个CPU的本地缓存中有一个锁，而另一个CPU必须获取该锁，那么更新持有该锁的缓存行的原子指令必须将该行从一个CPU的缓存中移到另一个CPU的缓存中，并且可能使缓存行的任何其他副本无效。从另一个CPU的缓存中获取缓存单元的代价可能比从本地缓存中获取行的代价高出一个数量级。</p><p>为了避免与锁相关的代价，许多操作系统使用无锁数据结构和算法。例如，可以实现像本章开头那样的链接列表，在列表搜索过程中不需要锁，只需要一条原子指令就可以在列表中插入一个项目。不过，无锁编程比有锁编程更复杂，例如，必须担心指令和内存的重新排序问题。用锁编程已经很难了，所以xv6避免了无锁编程的额外复杂性。</p><h3 id="6-9-习题"><a href="#6-9-习题" class="headerlink" title="6.9 习题"></a>6.9 习题</h3><ol><li>删去<code>kalloc</code>(kernel/kalloc.c:69)中对acquire和release的调用。这似乎会给调用kalloc的内核代码带来问题。你觉得会发生什么？当你运行xv6时，和你想的一样吗？运行<code>usertests</code>的时候呢？如果你没有看到问题，为什么没有呢？看看你是否可以通过在kalloc的关键部分插入dummy loops来引发问题。</li><li>假设你在<code>kfree</code>中注释了锁(在恢复<code>kalloc</code>的锁之后)。现在可能出了什么问题？<code>kfree</code>中缺少锁是否比kalloc中缺少锁的危害小？</li><li>如果两个CPU同时调用<code>kalloc</code>，其中一个就要等待另一个，这对性能不利。修改<code>kalloc.c</code>，使其具有更多的并行性，这样不同CPU对<code>kalloc</code>的同时调用就可以进行，而不需要等待对方。</li><li>使用大多数操作系统都支持的POSIX线程(Pthreads)编写一个并行程序。例如，实现一个并行哈希表，并测量put/get操作的数量是否随着核心数的增加而增加。</li><li>在xv6中实现Pthreads的一个子集。即实现用户级线程库，使一个用户进程可以有1个以上的线程，并安排这些线程可以在不同的CPU上并行运行。提出一个设计，正确处理线程进行阻塞系统调用和改变其共享地址空间的问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第五章</title>
      <link href="/2022/08/31/xv6-Chapter-5/"/>
      <url>/2022/08/31/xv6-Chapter-5/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章：中断和设备驱动"><a href="#第五章：中断和设备驱动" class="headerlink" title="第五章：中断和设备驱动"></a>第五章：中断和设备驱动</h2><p><strong><em>驱动</em></strong>是操作系统中管理特定设备的代码，它有如下功能：1、配置设备相关的硬件，2、告诉设备需要怎样执行，3、处理设备产生的中断，4、与等待设备I/O的进程进行交互。驱动程序的代码写起来可能很棘手，因为驱动程序与它所管理的设备会并发。此外，驱动必须了解设备的硬件接口，但硬件接口可能是很复杂的，而且文档不够完善。</p><p>需要操作系统关注的设备通常可以被配置为产生中断，这是trap的一种类型。内核trap处理代码可以知道设备何时引发了中断，并调用驱动的中断处理程序；在xv6中，这个处理发生在<strong>devintr</strong>(kernel/trap.c:177)中。</p><p>许多设备驱动程序在两个context中执行代码：上半部分（<strong><em>top half</em></strong>）在进程的内核线程中运行，下半部分（<strong><em>bottom half</em></strong>）在中断时执行。上半部分是通过系统调用，如希望执行I/O的 read和write。这段代码可能会要求硬件开始一个操作（比如要求磁盘读取一个块）；然后代码等待操作完成。最终设备完成操作并引发一个中断。驱动程序的中断处理程序，作为<strong>下半部分</strong>，找出什么操作已经完成，如果合适的话，唤醒一个等待该操作的进程，并告诉硬件执行下一个操作。</p><h3 id="5-1-Code-Console-input"><a href="#5-1-Code-Console-input" class="headerlink" title="5.1 Code: Console input"></a>5.1 Code: Console input</h3><p>​    控制台驱动(console.c)是驱动结构的一个简单说明。控制台驱动通过连接到RISC-V上的UART串行端口硬件，接受输入的字符。控制台驱动程序每次累计一行输入，处理特殊的输入字符，如退格键和control-u。用户进程，如shell，使用<strong>read</strong>系统调用从控制台获取输入行。当你在QEMU中向xv6输入时，你的按键会通过QEMU的模拟UART硬件传递给xv6。</p><p>与驱动交互的UART硬件是由QEMU仿真的16550芯片[11]。在真实的计算机上，16550将管理一个连接到终端或其他计算机的RS232串行链接。当运行QEMU时，它连接到你的键盘和显示器上。</p><p>UART硬件在软件看来是一组<strong>内存映射</strong>的控制寄存器。也就是说，有一些RISC-V硬件的物理内存地址会关联到UART设备，因此加载和存储与设备硬件而不是RAM交互。UART的内存映射地址从0x10000000开始，即<strong>UART0</strong>（kernel/memlayout.h:21）。这里有一些UART控制寄存器，每个寄存器的宽度是一个字节。它们与UART0的偏移量定义在(kernel/uart.c:22)。例如，<strong>LSR</strong>寄存器中一些位表示是否有输入字符在等待软件读取。这些字符（如果有的话）可以从<strong>RHR</strong>寄存器中读取。每次读取一个字符，UART硬件就会将其从内部等待字符的FIFO中删除，并在FIFO为空时清除<strong>LSR</strong>中的就绪位。UART传输硬件在很大程度上是独立于接收硬件的，如果软件向<strong>THR</strong>写入一个字节，UART就会发送该字节。</p><p>Xv6的<strong>main</strong>调用<strong>consoleinit</strong>（kernel/console.c:184）来初始化UART硬件。这段代码配置了UART，当UART接收到一个字节的输入时，就产生一个接收中断，当UART每次完成发送一个字节的输出时，产生一个<strong><em>传输完成(transmit complete)</em></strong>中断(kernel/uart.c:53)。</p><p>xv6 shell通过<strong>init.c</strong>(user/init.c:19)打开的文件描述符从控制台读取。对<strong>read</strong>的系统调用通过内核到达<strong>consoleread</strong>（kernel/console.c:82） 。<strong>consoleread</strong>等待输入的到来(通过中断)，输入会被缓冲在<strong>cons.buf</strong>，然后将输入复制到用户空间，再然后(在一整行到达后)返回到用户进程。如果用户还没有输入完整的行，任何调用了<strong>read</strong>进程将在<strong>sleep</strong>中等待(kernel/console.c:98)(第7章解释了sleep的细节)。</p><p>当用户键入一个字符时，UART硬件向RISC-V抛出一个中断，从而激活xv6的<strong>trap</strong>处理程序。trap处理程序调用devintr(kernel/trap.c:177)，它查看RISC-V的<strong>scause</strong>寄存器，发现中断来自一个外部设备。然后它向一个叫做PLIC[1]的硬件单元询问哪个设备中断了(kernel/trap.c:186)。如果是UART，<strong>devintr</strong>调用<strong>uartintr</strong>。</p><p><strong>uartintr</strong> (kernel/uart.c:180) 从<strong>UART</strong>硬件中读取在等待的输入字符，并将它们交给<strong>consoleintr</strong> (kernel/console.c:138)；它不会等待输入字符，因为以后的输入会引发一个新的中断。<strong>consoleintr</strong>的工作是将中输入字符积累<strong>cons.buf</strong>中，直到有一行字符。 <strong>consoleintr</strong>会特别处理退格键和其他一些字符。当一个新行到达时，<strong>consoleintr</strong>会唤醒一个等待的<strong>consoleread</strong>（如果有的话）。</p><p>一旦被唤醒，<strong>consoleread</strong>将会注意到<strong>cons.buf</strong>中的完整行，并将其将其复制到用户空间，并返回（通过系统调用机制）到用户空间。</p><h3 id="5-2-Code-Console-output"><a href="#5-2-Code-Console-output" class="headerlink" title="5.2 Code: Console output"></a>5.2 Code: Console output</h3><p>​    向控制台写数据的<strong>write</strong>系统调用最终会到达<strong>uartputc</strong>(kernel/uart.c:87)。设备驱动维护了一个输出缓冲区(<strong>uart_tx_buf</strong>)，这样写进程就不需要等待UART完成发送；相反，<strong>uartputc</strong>将每个字符追加到缓冲区，调用<strong>uartstart</strong>来启动设备发送(如果还没有的话)，然后返回。<strong>Uartputc</strong>只有在缓冲区满的时候才会等待。</p><p>​    每次UART发送完成一个字节，它都会产生一个中断。<strong>uartintr</strong>调用<strong>uartstart</strong>，<strong>uartintr</strong>检查设备是否真的发送完毕，并将下一个缓冲输出字符交给设备，每当UART发送完一个字节，就会产生一个中断。因此，如果一个进程向控制台写入多个字节，通常第一个字节将由uartputc s调用uartstart发送，其余的缓冲字节将由uartintr调用uartstart发送，因为发送完成中断到来。</p><p><strong>uartintr</strong>调用<strong>uartstart</strong>，<strong>uartintr</strong>查看设备是否真的发送完成，并将下一个缓冲输出字符交给设备，每当UART发送完一个字节，就会产生一个中断。因此，如果一个进程向控制台写入多个字节，通常第一个字节将由<strong>uartputc</strong>对<strong>uartstart</strong>的调用发送，其余的缓冲字节将随着发送完成中断的到来由<strong>uartintr</strong>的<strong>uartstart</strong>调用发送。</p><p>有一个通用模式需要注意，设备活动和进程活动需要解耦，这将通过缓冲和中断来实现。控制台驱动程序可以处理输入，即使没有进程等待读取它；随后的读取将看到输入。同样，进程可以发送输出字节，而不必等待设备。这种解耦可以通过允许进程与设备I/O并发执行来提高性能，当设备速度很慢（如UART）或需要立即关注（如回显键入的字节）时，这种解耦尤为重要。这个idea有时被称为<strong><em>I/O并发</em></strong>。</p><h3 id="5-3-Concurrency-in-drivers"><a href="#5-3-Concurrency-in-drivers" class="headerlink" title="5.3 Concurrency in drivers"></a>5.3 Concurrency in drivers</h3><p>你可能已经注意到在<strong>consoleread</strong>和<strong>consoleintr</strong>中会调用<strong>acquire</strong>。<strong>acquire</strong>调用会获取一个锁，保护控制台驱动的数据结构不被并发访问。这里有三个并发风险：不同CPU上的两个进程可能会同时调用<strong>consoleread</strong>；硬件可能会在一个CPU正在执行consoleread时，向该CPU抛出一个控制台（实际上是UART）中断；硬件可能会在consoleread执行时向另一个CPU抛出一个控制台中断。第6章探讨锁如何在这些情况下提供帮助。</p><p>需要关注驱动并发安全的另一个原因是，一个进程可能正在等待来自设备的输入，但是当表明输入到来的中断发生时该进程已经没有在运行（被切换）。因此，中断处理程序不允许知道被中断的进程或代码。例如，一个中断处理程序不能安全地用当前进程的页表调用<strong>copyout</strong>。中断处理程序通常只做相对较少的工作（例如，只是将输入数据复制到缓冲区），并唤醒<strong><em>上半部分</em></strong>代码来做剩下的工作。</p><h3 id="5-4-Timer-interrupts"><a href="#5-4-Timer-interrupts" class="headerlink" title="5.4 Timer interrupts"></a>5.4 Timer interrupts</h3><p>Xv6使用定时器中断来维护它的时钟，并使它能够切换计算密集型进程；<strong>usertrap</strong>和<strong>kerneltrap</strong>中的<strong>yield</strong>调用会导致这种切换。每个RISC-V CPU的时钟硬件都会抛出时钟中断。Xv6对这个时钟硬件进行编程，使其定期周期性地中断相应的CPU。</p><p>RISC-V要求在机器模式下处理定时器中断，而不是监督者模式。RISCV机器模式执行时没有分页，并且有一套单独的控制寄存器，因此在机器模式下运行普通的xv6内核代码是不实用的。因此，xv6对定时器中断的处理与上面谈到的trap机制完全分离了。</p><p>在main执行之前的<strong>start.c</strong>，是在机器模式下执行的。它设置了接收定时器中断(kernel/start.c:57)。一部分工作是对<strong>CLINT</strong>硬件（<strong>core-local interruptor</strong>）进行编程，使其每隔一定时间产生一次中断。另一部分是设置一个类似于<strong>trapframe</strong>的暂存区，帮助定时器中断处理程序保存寄存器和<strong>CLINT</strong>寄存器的地址。最后，<strong>start</strong>将<strong>mtvec</strong>设置为<strong>timervec</strong>，启用定时器中断。</p><p>定时器中断可能发生在用户或内核代码执行的任何时候；内核没有办法在关键操作中禁用定时器中断。因此，定时器中断处理程序必须以保证不干扰被中断的内核代码的方式进行工作。基本策略是处理程序要求RISC-V引发一个软件中断并立即返回。RISC-V用普通的trap机制将软件中断传递给内核，并允许内核禁用它们。处理定时器中断产生的软件中断的代码可以在<strong>devintr</strong>（kernel/trap.c:204）中看到。</p><p>机器模式的定时器中断向量是<strong>timervec</strong>(kernel/kernelvec.S:93)。它在<strong>start</strong>准备的暂存区保存一些寄存器，告诉<strong>CLINT</strong>何时产生下一个定时器中断，使RISC-V产生一个软件中断，恢复寄存器，然后返回。在定时器中断处理程序中没有C代码。</p><h3 id="5-5-Real-world"><a href="#5-5-Real-world" class="headerlink" title="5.5 Real world"></a>5.5 Real world</h3><p>Xv6允许在内核和用户程序执行时使用设备和定时器中断。定时器中断可以强制从定时器中断处理程序进行线程切换（调用<strong>yield</strong>），即使是在内核中执行。如果内核线程有时会花费大量的时间进行计算，而不返回用户空间，那么在内核线程之间公平地对CPU进行时间划分的能力是很有用的。然而，内核代码需要注意它可能会被暂停（由于定时器中断），然后在不同的CPU上恢复，这是xv6中一些复杂的根源。如果设备和定时器中断只发生在执行用户代码时，内核可以变得更简单一些。</p><p>在一台典型的计算机上支持所有设备的全貌是一件很辛苦的事情，因为设备很多，设备有很多功能，设备和驱动程序之间的协议可能很复杂，而且文档也不完善。在许多操作系统中，驱动程序所占的代码比核心内核还多。</p><p>UART驱动器通过读取UART控制寄存器，一次读取一个字节的数据；这种模式被称为编程I/O，因为软件在控制数据移动。程序化I/O简单，但速度太慢，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用<strong><em>直接内存访问(direct memory access, DMA)</em></strong>。DMA设备硬件直接将传入数据写入RAM，并从RAM中读取传出数据。现代磁盘和网络设备都使用DMA。DMA设备的驱动程序会在RAM中准备数据，然后使用对控制寄存器的一次写入来告诉设备处理准备好的数据。</p><p>当设备在不可预知的时间需要关注,且不那么频繁时，中断是很有用的。但中断对CPU的开销很大。因此，高速设备，如网络和磁盘控制器，使用了减少对中断需求的技巧。其中一个技巧是对整批传入或传出的请求提出一个单一的中断。另一个技巧是让驱动程序完全禁用中断，并定期检查设备是否需要关注。这种技术称为<strong><em>轮询（polling）</em></strong>。如果设备执行操作的速度非常快，轮询是有意义的，但如果设备大部分时间处于空闲状态，则会浪费CPU时间。一些驱动程序会根据当前设备的负载情况，在轮询和中断之间动态切换。</p><p>UART驱动首先将输入的数据复制到内核的缓冲区，然后再复制到用户空间。这在低数据速率下是有意义的，但对于那些快速生成或消耗数据的设备来说，这样的双重拷贝会大大降低性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用DMA。</p><h3 id="5-6-Exercises"><a href="#5-6-Exercises" class="headerlink" title="5.6 Exercises"></a>5.6 Exercises</h3><ol><li><p>修改uart.c，使其完全不使用中断。你可能还需要修改 console.c。</p></li><li><p>添加一个网卡驱动。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第四章</title>
      <link href="/2022/08/31/xv6-Chapter-4/"/>
      <url>/2022/08/31/xv6-Chapter-4/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章：陷阱和系统调用"><a href="#第四章：陷阱和系统调用" class="headerlink" title="第四章：陷阱和系统调用"></a>第四章：陷阱和系统调用</h2><p>有三种事件会导致CPU搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码。一种情况是<strong><em>系统调用</em></strong>，当用户程序执行<strong>ecall</strong>指令要求内核为其做某事时。另一种情况是<strong><em>异常</em></strong>：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址。第三种情况是设备<strong><em>中断</em></strong>，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。</p><p>本书使用<strong><em>trap</em></strong>作为这些情况的通用术语。通常，代码在执行时发生trap，之后都会被恢复，而且不需要意识到发生了什么特殊的事情。也就是说，我们通常希望trap是透明的；这一点对于中断来说尤其重要，被中断的代码通常不会意识到会发生trap。通常的顺序是：trap迫使控制权转移到内核；内核保存寄存器和其他状态，以便恢复执行；内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复保存的状态，并从trap中返回；代码从原来的地方恢复执行。</p><p>xv6内核会处理所有的trap。这对于系统调用来说是很自然的。这对中断来说也是合理的，因为隔离要求用户进程不能直接使用设备，而且只有内核才有设备处理所需的状态。这对异常处理来说也是合理的，因为xv6响应所有来自用户空间的异常，并杀死该违规程序。</p><p>Xv6 trap 处理分为四个阶段：RISC-V CPU采取的硬件行为，为内核C代码准备的汇编入口，处理trap的C 处理程序，以及系统调用或设备驱动服务。虽然三种trap类型之间的共性表明，内核可以用单一的代码入口处理所有的trap，但事实证明，为三种不同的情况，即来自用户空间的trap、来自内核空间的trap和定时器中断，设置单独的汇编入口和C trap处理程序会更方便的。</p><h3 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h3><p>每个RISC-V CPU都有一组控制寄存器，内核写入这些寄存器来告诉CPU如何处理trap，内核可以通过读取这些寄存器来发现已经发生的trap。RISC-V文档包含了完整的叙述[1]。riscv.h（kernel/riscv.h:1）包含了xv6使用的定义。这里是最重要的寄存器的概述。</p><ul><li><p><code>stvec</code>：内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。</p></li><li><p><code>sepc</code>：当trap发生时，RISC-V会将程序计数器保存在这里（因为<code>PC</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从trap中返回）指令将<code>sepc</code>复制到<code>pc</code>中。内核可以写<code>sepc</code>来控制<code>sret</code>的返回到哪里。</p></li><li><p><code>scause</code>：RISC -V在这里放了一个数字，描述了trap的原因。</p></li><li><p><code>sscratch</code>：内核在这里放置了一个值，在trap处理程序开始时可以方便地使用。</p></li><li><p><code>sstatus</code>：<code>sstatus</code>中的<strong>SIE</strong>位控制设备中断是否被启用，如果内核清除<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核设置<strong>SIE</strong>。<strong>SPP</strong>位表示trap是来自用户模式还是supervisor模式，并控制<code>sret</code>返回到什么模式。</p><p>上述寄存器与在特权态模式下处理的trap有关，在用户模式下不能读或写。对于机器模式下处理的trap，有一组等效的控制寄存器；xv6只在定时器中断的特殊情况下使用它们。</p></li></ul><p>多核芯片上的每个CPU都有自己的一组这些寄存器，而且在任何时候都可能有多个CPU在处理一个trap。</p><p>当需要执行trap时，RISC-V硬件对所有的trap类型（除定时器中断外）进行以下操作：</p><ol><li>如果该trap是设备中断，且<code>sstatus</code> <strong>SIE</strong>位为0，则不执行以下任何操作。</li><li>通过清除SIE来禁用中断。</li><li>复制<code>pc</code>到<code>sepc</code>。</li><li>将当前模式（用户态或特权态）保存在<code>sstatus</code>的<strong>SPP</strong>位。</li><li>在<code>scause</code>设置该次trap的原因。</li><li>将模式转换为特权态。</li><li>将<code>stvec</code>复制到<code>pc</code>。</li><li>从新的<code>pc</code>开始执行。</li></ol><p>注意，CPU不会切换到内核页表，不会切换到内核中的栈，也不会保存pc以外的任何寄存器。内核软件必须执行这些任务。CPU在trap期间做很少的工作的一个原因是为了给软件提供灵活性，例如，一些操作系统在某些情况下不需要页表切换，这可以提高性能。</p><p>你可能会想CPU的trap处理流程是否可以进一步简化。例如，假设CPU没有切换程序计数器（pc）。那么trap可以切换到监督者模式时，还在运行用户指令。这些用户指令可以打破用户空间/内核空间的隔离，例如通过修改<code>satp</code>寄存器指向一个允许访问所有物理内存的页表。因此，CPU必须切换到内核指定的指令地址，即<code>stvec</code>。</p><h3 id="4-2-Traps-from-user-space"><a href="#4-2-Traps-from-user-space" class="headerlink" title="4.2 Traps from user space"></a>4.2 Traps from user space</h3><p>在用户空间执行时，如果用户程序进行了系统调用（<code>ecall</code>指令），或者做了一些非法的事情，或者设备中断，都可能发生trap。来自用户空间的trap的处理路径是<code>uservec</code>（kernel/trampoline.S:16），然后是<code>usertrap</code>（kernel/trap.c:37）；返回时是<code>usertrapret</code>（kernel/trap.c:90），然后是<code>userret</code>（kernel/trampoline.S:16）。</p><p>来自用户代码的trap比来自内核的trap更具挑战性，因为<code>satp</code>指向的用户页表并不映射内核，而且栈指针可能包含一个无效甚至恶意的值。</p><p>因为RISC-V硬件在trap过程中不切换页表，所以用户页表必须包含<code>uservec</code>的映射，即<code>stvec</code>指向的trap处理程序地址。<code>uservec</code>必须切换<code>satp</code>，使其指向内核页表；为了在切换后继续执行指令，<code>uservec</code>必须被映射到内核页表与用户页表相同的地址。</p><p>Xv6用一个包含<code>uservec</code>的trampoline页来满足这些条件。Xv6在内核页表和每个用户页表中的同一个虚拟地址上映射了trampoline页。这个虚拟地址就是<code>TRAMPOLINE</code>（如我们在图2.3和图3.3中看到的）。<code>trampoline.S</code>中包含trampoline的内容，（执行用户代码时）<code>stvec</code>设置为<code>uservec</code>（kernel/trampoline.S:16）。</p><p>当<code>uservec</code>启动时，所有32个寄存器都包含被中断的代码所拥有的值。但是<code>uservec</code>需要能够修改一些寄存器，以便设置<code>satp</code>和生成保存寄存器的地址。RISC-V通过<code>sscratch</code>寄存器提供了帮助。<code>uservec</code>开始时的<code>csrrw</code>指令将<code>a0</code>和<code>sscratch</code>的内容互换。现在用户代码的<code>a0</code>被保存了；<code>uservec</code>有一个寄存器（<code>a0</code>）可以使用；<code>a0</code>包含了内核之前放在<code>sscratch</code>中的值。</p><p><code>uservec</code>的下一个任务是保存用户寄存器。在进入用户空间之前，内核先设置<code>sscratch</code>指向该进程的<code>trapframe</code>，这个<code>trapframe</code>可以保存所有用户寄存器（kernel/proc.h:44）。因为<code>satp</code>仍然是指用户页表，所以<code>uservec</code>需要将<code>trapframe</code>映射到用户地址空间中。当创建每个进程时，xv6为进程的<code>trapframe</code>分配一页内存，并将它映射在用户虚拟地址<code>TRAPFRAME</code>，也就是<code>TRAMPOLINE</code>的下面。进程的<code>p-&gt;trapframe</code>也指向<code>trapframe</code>，不过是指向它的物理地址<a href="#_ftn1">[1]</a>，这样内核可以通过内核页表来使用它。</p><p>因此，在交换<code>a0</code>和<code>sscratch</code>后，<code>a0</code>将指向当前进程的<code>trapframe</code>。<code>uservec</code>将在<code>trapframe</code>保存全部的寄存器，包括从<code>sscratch</code>读取的<code>a0</code>。</p><p><code>trapframe</code>包含指向当前进程的内核栈、当前CPU的hartid、<code>usertrap</code>的地址和内核页表的地址的指针，<code>uservec</code>将这些值设置到相应的寄存器中，并将<code>satp</code>切换到内核页表和刷新TLB，然后调用<code>usertrap</code>。</p><p><code>usertrap</code>的作用是确定trap的原因，处理它，然后返回（kernel/ trap.c:37）。如上所述，它首先改变<code>stvec</code>，这样在内核中发生的trap将由<code>kernelvec</code>处理。它保存了<code>sepc</code>（用户PC），这也是因为<code>usertrap</code>中可能会有一个进程切换，导致<code>sepc</code>被覆盖。如果trap是系统调用，<code>syscall</code>会处理它；如果是设备中断，<code>devintr</code>会处理；否则就是异常，内核会杀死故障进程。<code>usertrap</code>会把用户<code>pc</code>加4，因为RISC-V在执行系统调用时，会留下指向<code>ecall</code>指令的程序指针<a href="#ftn2">[2]</a>。在退出时，<code>usertrap</code>检查进程是否已经被杀死或应该让出CPU（如果这个trap是一个定时器中断）。</p><p>回到用户空间的第一步是调用<code>usertrapret</code>（kernel/trap.c:90）。这个函数设置RISC-V控制寄存器，为以后用户空间trap做准备。这包括改变<code>stvec</code>来引用<code>uservec</code>，准备<code>uservec</code>所依赖的<code>trapframe</code>字段，并将<code>sepc</code>设置为先前保存的用户程序计数器。最后，<code>usertrapret</code>在用户页表和内核页表中映射的trampoline页上调用<code>userret</code>，因为<code>userret</code>中的汇编代码会切换页表。</p><p><code>usertrapret</code>对<code>userret</code>的调用传递了参数<code>a0</code>，<code>a1</code>， <code>a0</code>指向<code>TRAPFRAME</code>，<code>a1</code>指向用户进程页表（kernel/trampoline.S:88），<code>userret</code>将<code>satp</code>切换到进程的用户页表。回想一下，用户页表同时映射了trampoline页和<code>TRAPFRAME</code>，但没有映射内核的其他内容。同样，事实上，在用户页表和内核页表中，trampoline页被映射在相同的虚拟地址上，这也是允许<code>uservec</code>在改变<code>satp</code>后继续执行的原因。<code>userret</code>将<code>trapframe</code>中保存的用户<code>a0</code>复制到<code>sscratch</code>中，为以后与<code>TRAPFRAME</code>交换做准备。从这时开始，<code>userret</code>能使用的数据只有寄存器内容和<code>trapframe</code>的内容。接下来<code>userret</code>从trapframe中恢复保存的用户寄存器，对<code>a0</code>和<code>sscratch</code>做最后的交换，恢复用户<code>a0</code>并保存<code>TRAPFRAME</code>，为下一次trap做准备，并使用<code>sret</code>返回用户空间。</p><h3 id="4-3-Code-Calling-system-calls"><a href="#4-3-Code-Calling-system-calls" class="headerlink" title="4.3 Code: Calling system calls"></a>4.3 Code: Calling system calls</h3><p>第2章以<code>initcode.S</code>调用<code>exec</code>系统调用结束（user/initcode.S:11）。让我们来看看用户调用是如何在内核中实现<code>exec</code>系统调用的。</p><p>用户代码将<code>exec</code>的参数放在寄存器<code>a0</code>和<code>a1</code>中，并将系统调用号放在<code>a7</code>中。系统调用号与函数指针表<code>syscalls</code>数组（kernel/syscall.c:108）中的项匹配。<code>ecall</code>指令进入内核，执行<code>uservec</code>、<code>usertrap</code>，然后执行<code>syscall</code>，就像我们上面看到的那样。</p><p><code>syscall</code>（kernel/syscall.c:133）从trapframe中的<code>a7</code>中得到系统调用号，并其作为索引在<code>syscalls</code>查找相应函数。对于第一个系统调用<code>exec</code>，<code>a7</code>将为<code>SYS_exec</code>（kernel/syscall.h:8），这会让<code>syscall</code>调用<code>exec</code>的实现函数<code>sys_exec</code>。</p><p>当系统调用函数返回时，<code>syscall</code>将其返回值记录在<code>p-&gt;trapframe-&gt;a0</code>中。用户空间的<code>exec()</code>将会返回该值，因为RISC-V上的C调用通常将返回值放在<code>a0</code>中。系统调用返回负数表示错误，0或正数表示成功。如果系统调用号无效，<code>syscall</code>会打印错误并返回-1。</p><h3 id="4-4-Code-System-call-arguments"><a href="#4-4-Code-System-call-arguments" class="headerlink" title="4.4 Code: System call arguments"></a>4.4 Code: System call arguments</h3><p>内核的系统调用实现需要找到用户代码传递的参数。因为用户代码调用系统调用的包装函数，参数首先会存放在寄存器中，这是C语言存放参数的惯例位置。内核trap代码将用户寄存器保存到当前进程的trap frame中，内核代码可以在那里找到它们。函数<code>argint</code>、<code>argaddr</code>和<code>argfd</code>从trap frame中以整数、指针或文件描述符的形式检索第n个系统调用参数。它们都调用<code>argraw</code>来获取保存的用户寄存器（kernel/syscall.c:35）。</p><p>一些系统调用传递指针作为参数，而内核必须使用这些指针来读取或写入用户内存。例如，<code>exec</code>系统调用会向内核传递一个指向用户空间中的字符串的指针数组。这些指针带来了两个挑战。首先，用户程序可能是错误的或恶意的，可能会传递给内核一个无效的指针或一个旨在欺骗内核访问内核内存而不是用户内存的指针。第二，xv6内核页表映射与用户页表映射不一样，所以内核不能使用普通指令从用户提供的地址加载或存储。</p><p>内核实现了安全地将数据复制到用户提供的地址或从用户提供的地址复制数据的函数。例如<code>fetchstr</code>（kernel/syscall.c:25）。文件系统调用，如<code>exec</code>，使用<code>fetchstr</code>从用户空间中检索字符串文件名参数。<code>fetchstr</code>调用<code>copyinstr</code>来做这些困难的工作。</p><p><code>copyinstr</code>（kernel/vm.c:406）将用户页表<code>pagetable</code>中的虚拟地址<code>srcva</code>复制到<code>dst</code>，需指定最大复制字节数。它使用<code>walkaddr</code>（调用<code>walk</code>函数）在软件中模拟分页硬件的操作，以确定<code>srcva</code>的物理地址<code>pa0</code>。<code>walkaddr</code>（kernel/vm.c:95）检查用户提供的虚拟地址是否是进程用户地址空间的一部分，所以程序不能欺骗内核读取其他内存。类似的函数<code>copyout</code>，可以将数据从内核复制到用户提供的地址。</p><h3 id="4-5-Traps-from-kernel-space"><a href="#4-5-Traps-from-kernel-space" class="headerlink" title="4.5 Traps from kernel space"></a>4.5 Traps from kernel space</h3><p>Xv6根据用户还是内核代码正在执行，对CPU陷阱寄存器的配置略有不同行为。当内核在CPU上执行时，内核将<code>stvec</code>指向<code>kernelvec</code>上的汇编代码（kernel/kernelvec.S:10）。由于xv6已经在内核中，<code>kernelvec</code>可以使用<code>satp</code>，将其设置为内核页表，以及引用有效内核的堆栈指针。<code>kernelvec</code>保存所有寄存器，以便中断的代码最后可以在没有中断的情况下恢复。</p><p><code>kernelvec</code>将寄存器保存在中断内核线程的堆栈上，因为寄存器值属于该线程，这是合理的。如果trap导致切换到另一个线程—在这种情况下，trap将实际返回到新线程的栈上，将中断线程保存的寄存器安全地保留在其堆栈上。</p><p><code>kernelvec</code>在保存寄存器后跳转到<code>kerneltrap</code>（kernel/trap.c:134）。<code>kerneltrap</code>是为两种类型的陷阱准备的：设备中断和异常。它调用<code>devintr</code>（kernel/trap.c:177）来检查和处理前者。如果trap不是设备中断，那么它必须是异常，如果它发生在xv6内核中，则一定是一个致命错误；内核调用<code>panic</code>并停止执行。</p><p>如果由于计时器中断而调用了<code>kerneltrap</code>，并且进程的内核线程正在运行（而不是调度程序线程），<code>kerneltrap</code>调用<code>yield</code>让出CPU，允许其他线程运行。在某个时刻，其中一个线程将退出，并让我们的线程及其<code>kerneltrap</code>恢复。第7章解释了线程让出CPU控制权。</p><p>当<code>kerneltrap</code>的工作完成时，它需要返回到被中断的代码。因为<code>yield</code>可能破坏保存的<code>sepc</code>和在<code>sstatus</code>中保存的之前的模式。<code>kerneltrap</code>在启动时保存它们。它现在恢复那些控制寄存器并返回到<code>kernelvec</code>（kernel/kernelvec.S:48）。<code>kernelvec</code>从堆栈恢复保存的寄存器并执行<code>sret</code>，<code>sret</code>将<code>sepc</code>复制到<code>pc</code>并恢复中断的内核代码。</p><p>可以思考一下，如果因为时间中断，<code>kerneltrap</code>调用了<code>yield</code>，trap return是如何发生的。</p><p>当CPU从用户空间进入内核时，Xv6将CPU的<code>stvec</code>设置为<code>kernelvec</code>；可以在<code>usertrap</code>（kernel/trap.c:29）中看到这一点。内核运行但<code>stvec</code>被设置为<code>uservec</code>时，这期间有一个时间窗口，在这个窗口期，禁用设备中断是至关重要的。幸运的是，RISC-V总是在开始使用trap时禁用中断，xv6在设置<code>stvec</code>之前不会再次启用它们。</p><h3 id="4-6-Page-fault-exceptions"><a href="#4-6-Page-fault-exceptions" class="headerlink" title="4.6 Page-fault exceptions"></a>4.6 Page-fault exceptions</h3><p>Xv6对异常的响应是相当固定：如果一个异常发生在用户空间，内核就会杀死故障进程。如果一个异常发生在内核中，内核就会<strong>panic</strong>。真正的操作系统通常会以更有趣的方式进行响应。</p><p>举个例子，许多内核使用页面故障来实现<strong><em>写时复制（copy-on-write，cow）</em>fork</strong>。要解释写时复制fork，可以想一想xv6的<code>fork</code>，在第3章中介绍过。<code>fork</code>通过调用<code>uvmcopy</code>（kernel/vm.c:309）为子进程分配物理内存，并将父进程的内存复制到子程序中，使子进程拥有与父进程相同的内存内容。如果子进程和父进程能够共享父进程的物理内存，效率会更高。然而，直接实现这种方法是行不通的，因为父进程和子进程对共享栈和堆的写入会中断彼此的执行。</p><p>通过使用写时复制fork，可以让父进程和子进程安全地共享物理内存，通过页面故障来实现。当CPU不能将虚拟地址翻译成物理地址时，CPU会产生一个页面故障异常（page-fault exception）。 RISC-V有三种不同的页故障：load页故障（当加载指令不能翻译其虚拟地址时）、stote页故障（当存储指令不能翻译其虚拟地址时）和指令页故障（当指令的地址不能翻译时）。<code>scause</code>寄存器中的值表示页面故障的类型，<code>stval</code>寄存器中包含无法翻译的地址。</p><p><strong><em>COW</em></strong>  fork中的基本设计是父进程和子进程最初共享所有的物理页面，但将它们映射设置为只读。因此，当子进程或父进程执行store指令时，RISC-V CPU会引发一个页面故障异常。作为对这个异常的响应，内核会拷贝一份包含故障地址的页。然后将一个副本的读/写映射在子进程地址空间，另一个副本的读/写映射在父进程地址空间。更新页表后，内核在引起故障的指令处恢复故障处理。因为内核已经更新了相关的PTE，允许写入，所以现在故障指令将正常执行。</p><p>这个COW设计对<code>fork</code>很有效，因为往往子程序在fork后立即调用exec，用新的地址空间替换其地址空间。在这种常见的情况下，子程序只会遇到一些页面故障，而内核可以避免进行完整的复制。此外，COW fork是透明的：不需要对应用程序进行修改，应用程序就能受益。</p><p>页表和页故障的结合，将会有更多种有趣的可能性的应用。另一个被广泛使用的特性叫做<strong><em>懒分配 (lazy allocation)</em></strong>，它有两个部分。首先，当一个应用程序调用<code>sbrk</code>时，内核会增长地址空间，但在页表中把新的地址标记为无效。第二，当这些新地址中的一个出现页面故障时，内核分配物理内存并将其映射到页表中。由于应用程序经常要求获得比他们需要的更多的内存，所以懒分配是一个胜利：内核只在应用程序实际使用时才分配内存。像COW fork一样，内核可以对应用程序透明地实现这个功能。</p><p>另一个被广泛使用的利用页面故障的功能是从<strong><em>磁盘上分页(paging from disk)</em></strong>。如果应用程序需要的内存超过了可用的物理RAM，内核可以交换出一些页：将它们写入一个存储设备，比如磁盘，并将其PTE标记为无效。如果一个应用程序读取或写入一个被换出到磁盘的页，CPU将遇到一个页面故障。内核就可以检查故障地址。如果该地址属于磁盘上的页面，内核就会分配一个物理内存的页面，从磁盘上读取页面到该内存，更新PTE为有效并引用该内存，然后恢复应用程序。为了给该页腾出空间，内核可能要交换另一个页。这个特性不需要对应用程序进行任何修改，如果应用程序具有引用的位置性（即它们在任何时候都只使用其内存的一个子集），这个特性就能很好地发挥作用。</p><p>其他结合分页和分页错误异常的功能包括自动扩展堆栈和内存映射文件。</p><h3 id="4-7-Real-world"><a href="#4-7-Real-world" class="headerlink" title="4.7 Real world"></a>4.7 Real world</h3><p>如果将内核内存映射到每个进程的用户页表中（使用适当的PTE权限标志），就不需要特殊的trampoline页了。这也将消除从用户空间trap进入内核时对页表切换的需求。这也可以让内核中的系统调用实现利用当前进程的用户内存被映射的优势，让内核代码直接去间接引用（对地址取值）用户指针。许多操作系统已经使用这些想法来提高效率。Xv6没有实现这些想法，以减少由于无意使用用户指针而导致内核出现安全漏洞的机会，并减少一些复杂性，以确保用户和内核虚拟地址不重叠。</p><h3 id="4-8-Exercises"><a href="#4-8-Exercises" class="headerlink" title="4.8 Exercises"></a>4.8 Exercises</h3><ol><li>函数<code>copyin</code>和<code>copyinstr</code>在软件中walk用户页表。设置内核页表，使内核拥有用户程序的内存映射，<code>copyin</code>和<code>copyinstr</code>可以使用<code>memcpy</code>将系统调用参数复制到内核空间，依靠硬件来完成页表的walk。</li><li>实现内存的懒分配。</li><li>实现写时复制 fork。</li></ol><hr><ol><li><p><a name="ftn1"></a>内核中物理地址和虚拟地址时直接映射的，所以可以在启用分页时，通过物理地址访问。</p></li><li><p><a name="ftn2"></a>执行系统调用时，进程的pc会指向ecall指令，这里需要加4清除，因为进程栈的地址空间是从高到低。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第三章</title>
      <link href="/2022/08/31/xv6-Chapter-3/"/>
      <url>/2022/08/31/xv6-Chapter-3/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章：页表"><a href="#第三章：页表" class="headerlink" title="第三章：页表"></a>第三章：页表</h2><p>页表是操作系统为每个进程提供自己私有地址空间和内存的机制。页表决定了内存地址的含义，以及物理内存的哪些部分可以被访问。它们允许 xv6 隔离不同进程的地址空间，并将它们映射到物理内存上。页表还提供了一个间接层次，允许 xv6 实现一些技巧：在几个地址空间中映射同一内存（trampoline 页），以及用一个未映射页来保护内核栈和用户栈。本章其余部分将解释 RISC-V 硬件提供的页表以及 xv6 如何使用它们。</p><h3 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1  Paging hardware"></a>3.1  Paging hardware</h3><p>提醒一下，RISC-V 指令（包括用户和内核）操作的是虚拟地址。机器的 RAM，或者说物理内存，是用物理地址来做索引的，RISC-V 的页表通过将每个虚拟地址映射到一个物理地址将这两种地址联系起来，</p><p>xv6运行在Sv39 RISC-V上，这意味着只会使用64位虚拟地址的低39位，高25位没有被使用。在这种Sv39配置中，一个RISC-V页表在逻辑上是一个由2²⁷（134,217,728）个<b>页表项（Page Table Entry, PTE）</b>组成的数组。每个<strong>PTE</strong>包含一个44位的<b>物理页号（Physical Page Number, PPN）</b>和一些标志位。分页硬件通过利用39位中的高27位索引到页表中找到一个<strong>PTE</strong>来转换一个虚拟地址，并计算出一个56位的物理地址，它的前44位来自于<strong>PTE</strong>中的<strong>PPN</strong>，而它的后12位则是从原来的虚拟地址复制过来的。图3.1显示了这个过程，在逻辑上可以把页表看成是一个简单的<strong>PTE</strong>数组（更完整的描述见图3.2）。页表让操作系统控制虚拟地址到物理地址的转换，其粒度为4096（2¹²）字节的对齐块。这样的分块称为页。</p><p>在Sv39 RISC-V中，虚拟地址的前25位不用于地址转换；将来，RISC-V可能会使用这些位来定义更多的转换层。物理地址也有增长的空间：在<strong>PTE</strong>格式中，物理页号还有 10 位的增长空间。</p><p><img src="/img/Figure-3.1.jpg" alt="img"> </p><p>如图 3.2 所示，实际上转换过程分三步进行。一个页表以三层树的形式存储在物理内存中。树的根部是一个 4096 字节的页表页，它包含 512 个 PTE，这些 PTE 包含树的下一级页表页的物理地址。每一页都包含 512 个 PTE，用于指向下一个页表或物理地址。分页硬件用 27 位中的高 9 位选择根页表页中的 PTE，用中间 9 位选择树中下一级页表页中的 PTE，用低 9 位选择最后的 PTE。</p><p>如果转换一个地址所需的三个 PTE 中的任何一个不存在，分页硬件就会引发一个<strong>缺页异常（page-fault exception）</strong>，让内核来处理这个异常（见第 4 章）。这种三层结构允许页表在处理大范围的虚拟地址没有被映射这种常见情况时，能够忽略整个页表。</p><p>每个 PTE 都包含标志位，用于告诉分页硬件相关的虚拟地址被允许怎样使用。<code>PTE_V</code> 表示 PTE 是否存在：如果没有设置，对该页的引用会引起异常（即不允许）。<code>PTE_R</code> 控制是否允许指令读取该页。<code>PTE_W</code> 控制是否允许指令向该页写入。<code>PTE_X</code> 控制 CPU 是否可以将页面的内容解释为指令并执行。<code>PTE_U</code> 控制是否允许用户态下的指令访问页面；如果不设置 <code>PTE_U</code>， 对应 PTE 只能在内核态下使用。图 3.2 显示了这一切的工作原理。标志位和与分页硬件相关的数据结构定义在（<code>kernel/riscv.h</code>）中。</p><p><img src="/img/Figure-3.2.jpg" alt="img"></p><p>要告诉硬件使用一个页表，内核必须将对应根页表页的物理地址写入 <code>satp</code> 寄存器中。每个 CPU 都有自己的 <code>satp</code> 寄存器。一个 CPU 将使用自己的 <code>satp</code> 所指向的页表来翻译后续指令产生的所有地址。每个 CPU 都有自己的 <code>satp</code>，这样不同的 CPU 可以运行不同的进程，每个进程都有自己的页表所描述的私有地址空间。</p><p>关于术语的一些说明：物理内存指的是 <strong>DRAM</strong> 中的存储单元。物理存储器的一个字节有一个地址，称为物理地址。当指令操作虚拟地址时，分页硬件会将其翻译成物理地址，然后发送给 DRAM 硬件，以读取或写入存储。不像物理内存和虚拟地址，虚拟内存不是一个物理对象，而是指内核提供的管理物理内存和虚拟地址的抽象和机制的集合。</p><h3 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2  Kernel address space"></a>3.2  Kernel address space</h3><p>Xv6 为每个进程维护一个用于描述进程的用户地址空间的页表，外加一个单独的描述内核地址空间的页表。内核配置其地址空间的布局，使其能够通过可预测的虚拟地址访问物理内存和各种硬件资源。图 3.3 显示了这个设计是如何将内核虚拟地址映射到物理地址的。文件（<code>kernel/memlayout.h</code>）声明了 xv6 内核内存布局的常量。</p><p> <img src="/img/Figure-3.3.jpg" alt="img"> </p><p>QEMU 模拟的计算机包含 RAM（ 物理内存），从物理地址 <code>0x80000000</code> 开始， 至少到 <code>0x86400000</code>，xv6 称之为 <code>PHYSTOP</code>。QEMU 模拟还包括 I/O 设备，如磁盘接口。QEMU 将设备接口作为<b>内存映射（memory-mapped）</b>的控制寄存器暴露给软件，这些寄存器位于物理地址空间的 <code>0x80000000</code> 以下。内核可以通过读取/写入这些特殊的物理地址与设备进行交互；这种读取和写入与设备硬件而不是与 RAM 进行通信。第 4 章解释了 xv6 如何与设备交互。</p><p>内核对RAM和内存映射的设备寄存器使用“直接映射”，也就是将这些资源映射到和它们物理地址相同的虚拟地址上。例如，内核本身在虚拟地址空间和物理内存中的位置都是<code>KERNBASE=0x80000000</code>。直接映射简化了读/写物理内存的内核代码。例如，当 <code>fork</code> 为子进程分配用户内存时，分配器返回该内存的物理地址；<code>fork</code> 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。</p><p>有几个内核虚拟地址不是直接映射：</p><ul><li><p>trampoline 页。它被映射在虚拟地址空间的顶端；用户页表也有这个映射。第 4 章讨论了 trampoline 页的作用，但我们在这里看到了页表的一个有趣的用例；一个物理页（存放 trampoline 代码）在内核的虚拟地址空间中被映射了两次：一次是在虚拟地址空间的顶部，一次是直接映射。</p></li><li><p>内核栈页。每个进程都有自己的内核栈，内核栈被映射到高地址处，所以 xv6 可以在它后面留下一个未映射的守护页。守护页的 PTE 是无效的（不设置 <code>PTE_V</code> 位），这样如果内核栈溢出，很可能会引起异常，内核会报错。如果没有防护页，栈溢出时会覆盖其他内核内存，导致不正确的操作。报错还是比较好的。</p></li></ul><p>内核通过高地址映射使用它的栈空间，栈空间也可以通过直接映射的地址被内核访问。另一种的设计是只使用直接映射，并在直接映射的地址上使用 stack。但是在这种安排中，提供保护页将涉及到取消映射虚拟地址，否则这些地址将指向物理内存，这将很难使用。</p><p>内核将 trampoline 和 text（可执行程序的代码段）映射为有 <code>PTE_R</code> 和 <code>PTE_X</code> 权限的页。内核从这些页读取和执行指令。内核映射的其他页会有 <code>PTE_R</code> 和 <code>PTE_W</code> 权限，以便内核读写这些页面的内存。守护页的映射是无效的（不设置 <code>PTE_V</code>）。 </p><h3 id="3-3-Code-creating-an-address-space"><a href="#3-3-Code-creating-an-address-space" class="headerlink" title="3.3  Code: creating an address space"></a>3.3  Code: creating an address space</h3><p>大部分用于操作地址空间和页表的 xv6 代码都在<code>vm.c</code>（<code>kernel/vm.c:1</code>）中。核心数据结构是 <code>pagetable_t</code>，它实际上是一个指向 RISC-V 根页表页的指针；<code>pagetable_t</code>可以是内核页表，也可以是进程的页表。核心函数是 <code>walk</code> 和 <code>mappages</code>，前者通过虚拟地址得到 PTE，后者将虚拟地址映射到物理地址。以 <code>kvm</code> 开头的函数操作内核页表；以 <code>uvm</code> 开头的函数操作用户页表；其他函数同时用于这两种页表。<code>copyout</code>和<code>copyin</code>将数据复制到或复制出被作为系统调用参数的用户虚拟地址；它们在 <code>vm.c</code> 中，因为它们需要显式转换用户空间的地址，以便找到相应的物理内存。</p><p>在机器启动时，在启动序列的靠前部分，<code>main</code> 调用 <code>kvminit</code>（<code>kernel/vm.c:22</code>）来创建内核页表。这个调用发生在 xv6 在 RISC-V 启用分页之前，所以地址直接指向物理内存。<code>kvminit</code> 首先分配一页物理内存来存放根页表页。然后调用 <code>kvmmap</code> 将内核所需要的硬件资源映射到物理地址。这些资源包括内核的指令和数据，<code>KERNBASE</code> 到 <code>PHYSTOP</code>的物理内存，以及实际上是设备的内存范围。</p><p><code>kvmmap</code>（<code>kernel/vm.c:118</code>）调用 <code>mappages</code>（<code>kernel/vm.c:149</code>），它将指定范围的虚拟地址映射到一段物理地址。它将范围内地址分割成多页（忽略余数），每次映射一页的起始地址。对于每个要映射的虚拟地址（页的起始地址），<code>mapages</code> 调用 <code>walk</code> 找到该地址的最后一级 PTE 的地址。然后，它配置 PTE，使其持有相关的物理页号、所需的权限（<code>PTE_W</code>、<code>PTE_X</code>和/或<code>PTE_R</code>），以及<code>PTE_V</code>来标记 PTE 为有效（<code>kernel/vm.c:161</code>）。</p><p><code>walk</code>（<code>kernel/vm.c:72</code>）模仿 RISC-V 分页硬件查找虚拟地址的 PTE（见图 3.2）。<code>walk</code> 每次降低 9 位来查找三级页表。它使用每一级的 9 位虚拟地址来查找下一级页表或最后一级（<code>kernel/vm.c:78</code>）的 PTE。如果 PTE 无效，那么所需的物理页还没有被分配；如果 <code>alloc</code> 参数被设置，<code>walk</code> 会分配一个新的页表页，并把它的物理地址放在 PTE 中。它返回 树中最低层PTE的地址（<code>kernel/vm.c:88</code>）。</p><p><code>main</code> 调用 <code>kvminithart</code>（<code>kernel/vm.c:53</code>）来映射内核页表。它将根页表页的物理地址写入寄存器 <code>satp</code> 中。在这之后，CPU 将使用内核页表翻译地址。由于内核使用唯一映射，所以指令的虚拟地址将映射到正确的物理内存地址。</p><p><code>procinit</code>（<code>kernel/proc.c:26</code>），它由 <code>main</code> 调用，为每个进程分配一个内核栈。它将每个栈映射在 <code>KSTACK</code> 生成的虚拟地址上，这就为栈守护页留下了空间。<code>kvmmap</code> 将对应的PTE加入到内核页表中，然后调用 <code>kvminithart</code> 将内核页表重新加载到 <code>satp</code> 中，这样硬件就知道新的 PTE 了。</p><p>每个 RISC-V CPU 都会在 <strong>Translation Look-aside Buffer(TLB)</strong>中缓存页表项，当 xv6 改变页表时，必须告诉 CPU 使相应的缓存 TLB 项无效。如果它不这样做，那么在以后的某个时刻，TLB 可能会使用一个旧的缓存映射，指向一个物理页，而这个物理页在此期间已经分配给了另一个进程，这样的话，一个进程可能会在其他进程的内存上“乱写乱画“。RISC-V 有一条指令 <code>sfence.vma</code>，可以刷新当前 CPU 的 TLB。xv6 在<code>kvminithart</code>中，重新加载 <code>satp</code> 寄存器后， 执行 <code>sfence.vma</code>，也会在从内核空间返回用户空间前，切换到用户页表的trampoline 代码中执行 <code>sfence.vma</code>（<code>kernel/trampoline.S:79</code>）。</p><h3 id="3-4-Physical-memory-allocation"><a href="#3-4-Physical-memory-allocation" class="headerlink" title="3.4  Physical memory allocation"></a>3.4  Physical memory allocation</h3><p> 内核必须在运行时为页表、用户内存、内核堆栈和管道缓冲区分配和释放物理内存。xv6 使用内核地址结束到 <code>PHYSTOP</code> 之间的物理内存来进行运行时分配。它每次分配和释放整个4096 字节的页面。它通过保存空闲页链表，来记录哪些页是空闲的。分配包括从链表中删除一页；释放包括将释放的页面添加到空闲页链表中。</p><h3 id="3-5-Code-Physical-memory-allocator"><a href="#3-5-Code-Physical-memory-allocator" class="headerlink" title="3.5  Code: Physical memory allocator"></a>3.5  Code: Physical memory allocator</h3><p>分配器在 <code>kalloc.c</code>（<code>kernel/kalloc.c:1</code>）中。分配器的数据结构是一个可供分配的物理内存页的<strong>空闲链表</strong>，每个空闲页的链表元素是一个结构体 <code>struct run</code>（<code>kernel/kalloc.c:17</code>）。分配器从哪里获得内存来存放这个结构体呢？它把每个空闲页的 <code>run</code> 结构体存储在空闲页自身里面，因为那里没有其他东西存储。空闲链表由一个<strong>自旋锁</strong>保护（<code>kernel/kalloc.c:21-24</code>）。链表和锁被包裹在一个结构体中，以明确锁保护的是结构体中的字段。现在，请忽略锁以及 <code>acquire</code> 和<code>release</code> 的调用；第 6 章将详细研究锁。</p><p><code>main</code> 调用 <code>kinit</code> 来初始化分配器（<code>kernel/kalloc.c:27</code>）。<code>kinit</code> 初始化空闲页链表，以保存内核地址结束到 <code>PHYSTOP</code> 之间的每一页。xv6 应该通过解析硬件提供的配置信息来确定有多少物理内存可用。但是它没有这么做，而是假设机器有 128M 字节的 RAM。<code>kinit</code> 通过调用<code>freerange</code> 来添加内存到空闲页链表，<code>freerange</code> 则对每一页都调用 <code>kfree</code>。PTE 只能指向按4096 字节对齐的物理地址（4096 的倍数），因此 <code>freerange</code> 使用 <code>PGROUNDUP</code> 来确保它只添加对齐的物理地址到空闲链表中。分配器开始时没有内存；这些对 <code>kfree</code> 的调用给了它一些内存管理。</p><p>分配器有时把地址当作整数来处理，以便对其进行运算（如 <code>freerange</code> 遍历所有页）， 有时把地址当作指针来读写内存（如操作存储在每页中的 <code>run</code> 结构体）；这种对地址的双重使用是分配器代码中充满 C 类型转换的主要原因。另一个原因是，释放和分配本质上改变了内存的类型。</p><p><code>kfree</code>（<code>kernel/kalloc.c:47</code>）将被释放的内存中的每个字节设置为1。这将使得释放内存后使用内存的代码（使用悬空引用）将会读取垃圾而不是旧的有效内容；希望这将导致这类代码更快地崩溃。然后 <code>kfree</code> 将页面预存入释放列表：它将 <code>pa</code>（物理地址）转为指向结构体 <code>run</code> 的指针，在 <code>r-&gt;next</code> 中记录空闲链表之前的节点，并将释放列表设为 <code>r</code>。<code>kalloc</code>移除并返回空闲链表中的第一个元素。</p><h3 id="3-6-Process-address-space"><a href="#3-6-Process-address-space" class="headerlink" title="3.6  Process address space"></a>3.6  Process address space</h3><p>每个进程都有一个单独的页表，当 xv6 在进程间切换时，也会改变页表。如图 2.3 所示，一个进程的用户内存从虚拟地址 0 开始，可以增长到 <code>MAXVA</code>（<code>kernel/riscv.h:348</code>），原则上允许一个进程寻址 256GB 的内存。</p><p>当一个进程要求 xv6 提供更多的用户内存时，xv6 首先使用 <code>kalloc</code> 来分配物理页，然后将指向新物理页的 PTE 添加到进程的页表中。Xv6 设置这些 PTE 的 <code>PTE_W</code>、<code>PTE_X</code>、<code>PTE_R</code>、<code>PTE_U</code> 和 <code>PTE_V</code> 标志。大多数进程不使用整个用户地址空间；xv6 将不使用的 PTE 的 <code>PTE_V</code> 位保持为清除状态。</p><p>我们在这里看到了几个有趣例子，是关于使用页表的。首先，不同的进程页表将用户地址转化为物理内存的不同页，这样每个进程都有私有的用户内存。第二，每个进程都认为自己的内存具有从零开始的连续的虚拟地址，而进程的物理内存可以是不连续的。第三，内核会映射带有 <code>trampoline</code> 代码的页到用户地址空间顶端，因此，有一物理内存页在所有地址空间中都会出。</p><p><img src="/img/Figure-3.4.jpg" alt="img"></p><p>图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。栈只有一页，图中显示的是由<code>exec</code> 创建的初始内容。位于栈顶部的字符串中包含了命令行中输入的参数和指向他们的指针数组。在下方是允许程序在 <code>main</code> 启动的值，就像函数 <code>main(argc, argv)</code> 是刚刚被调用一样<a href="#ftn1">[1]</a>。</p><p>为了检测用户栈溢出分配的栈内存，xv6 会在 stack 的下方放置一个无效的保护页。如果用户栈溢出，而进程试图使用栈下面的地址，硬件会因为该映射无效而产生一个缺页异常。一个现实世界中的操作系统可能会在用户栈溢出时自动为其分配更多的内存。</p><h3 id="3-7-Code-sbrk"><a href="#3-7-Code-sbrk" class="headerlink" title="3.7  Code: sbrk"></a>3.7  Code: sbrk</h3><p> <code>sbrk</code> 是 一 个 进 程 收 缩 或 增 长 内 存 的 系 统 调 用 。 该 系 统 调 用 由 函 数<code>growproc</code>（<code>kernel/proc.c:239</code>）实现，<code>growproc</code> 调用 <code>uvmalloc</code> 或 <code>uvmdealloc</code>，取决于 <code>n</code> 是正数还是负数。<code>uvmalloc</code>（<code>kernel/vm.c:229</code>）通过 <code>kalloc</code> 分配物理内存，并使用 <code>mappages</code> 将 PTE 添加到用户页表中。 <code>uvmdealloc</code> 调用 <code>uvmunmap</code>（<code>kernel/vm.c:174</code>），它使用 <code>walk</code> 来查找 PTE 并使用 <code>kfree</code> 来释放它们所引用的物理内存。</p><p>xv6 使用进程的页表不仅是为了告诉硬件如何映射用户虚拟地址，也是将其作为分配给该进程的物理地址的唯一记录。这就是为什么释放用户内存（<code>uvmunmap</code> 中）需要检查用户页表的原因。</p><h3 id="3-8-Code-exec"><a href="#3-8-Code-exec" class="headerlink" title="3.8  Code: exec"></a>3.8  Code: exec</h3><p><code>exec</code> 是创建一个地址空间的用户部分的系统调用。它读取储存在文件系统上的文件用来初始化一个地址空间的用户部分。<code>exec</code>（<code>kernel/exec.c:13</code>）使用 <code>namei</code>（<code>kernel/exec.c:26</code>）打开二进制文件路径，这在第 8 章中有解释。然后，它读取 ELF 头。xv6 应用程序用 ELF 格式来描述可执行文件，它定义在（<code>kernel/elf.h</code>）。一个 ELF 二进制文件包括一个 ELF 头，<code>struct elfhdr</code>（<code>kernel/elf.h:6</code>）。之后是一串程序段头（program section header），<code>struct proghdr</code>（<code>kernel/elf.h:25</code>）。每一个<code>proghdr</code>描述了应用的一个必须加载到内存中的程序段；xv6 程序只有一个程序段头，但其他系统可能有分开的指令段和数据段需要加载到内存。</p><p>第一步是快速检查文件是否是ELF格式。一个 ELF 二进制文件以四个字节的“魔法数字” <code>0x7F</code>、<code>E</code>、<code>L</code>、<code>F</code>或 <code>ELF_MAGIC</code>（<code>kernel/elf.h:3</code>）开始。如果 ELF 头有正确的”魔法数字“，<code>exec</code>就会认为该二进制文件是正确的类型。</p><p><code>exec</code>使用<code>proc_pagetable</code>（<code>kernel/exec.c:38</code>）分配一个没有使用的页表，使用 <code>uvmalloc</code>（<code>kernel/exec.c:52</code>）为每一个 ELF 段分配内存，使用 <code>loadseg</code>（<code>kernel/exec.c:10</code>）加载每一个段到内存中。<code>loadseg</code>使用<code>walkaddr</code>找到分配内存的物理地址，在该地址写入 ELF 段的每一页，页的内容通过 <code>readi</code> 从文件中读取。</p><p>用 <code>exec</code> 创建的第一个用户程序<code>/init</code> 的程序段头是这样的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># objdump -p _init</span></span><br><span class="line">user/_init: file format elf64-littleriscv</span><br><span class="line">Program Header:</span><br><span class="line">LOAD off 0x00000000000000b0 vaddr 0x0000000000000000</span><br><span class="line">       paddr 0x0000000000000000 align 2**3</span><br><span class="line">     filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx</span><br><span class="line">   STACK off 0x0000000000000000 vaddr 0x0000000000000000</span><br><span class="line">        paddr 0x0000000000000000 align 2**4</span><br><span class="line">     filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-</span><br></pre></td></tr></table></figure><p>程序段头的 <code>filesz</code> 可能小于 <code>memsz</code>，说明它们之间的空隙应该用 0来填充（对于 C 语言中的全局变量），而不是从文件中读取。对于<code>/init</code>来说，<code>filesz</code>是 2112 字节，<code>memsz</code>是 2136字节，因此 <code>uvmalloc</code> 分配了足够的物理内存来容纳 2136 字节，但只从文件<code>/init</code> 中读取 2112字节。</p><p><code>exec</code> 在栈页的下方放置了一个不可访问页，这样程序如果试图使用多个页面，就会出现故障。这个不可访问的页还能允许<code>exec</code> 处理过大的参数；在这种情况下，<code>exec</code>用来复制参数到栈的 <code>copyout</code>（<code>kernel/vm.c:355</code>）函数会注意到目标页不可访问，并返回-1。</p><p>在准备新的内存映像的过程中，如果 <code>exec</code> 检测到一个错误，比如一个无效的程序段， 它就会跳转到标签 <code>bad</code>，释放新的映像，并返回-1。<code>exec</code> 必须延迟释放旧映像，直到它确定<code>exec</code>系统调用会成功：如果旧映像消失了，系统调用就不能返回-1。<code>exec</code>中唯一的错误情况发生在创建映像的过程中。一旦镜像完成，<code>exec</code>就可以提交到新的页表（<code>kernel/exec.c:113</code>）并释放旧的页表（<code>kernel/exec.c:117</code>）。</p><p><code>exec</code> 将 ELF 文件中的字节按 ELF 文件指定的地址加载到内存中。用户或进程可以将任何他们想要的地址放入 ELF 文件中。因此，<code>exec</code>是有风险的，因为 ELF 文件中的地址可能会意外地或故意地指向内核。对于一个不小心的内核来说，后果可能从崩溃到恶意颠覆内核的隔离机制(即安全漏洞)。xv6 执行了一些检查来避免这些风险。例如 <code>if (ph.vaddr + ph.memsz &lt; ph.vaddr)</code>检查总和是否溢出一个 64 位整数。危险的是，用户可以用指向用户选择的地址的 <code>ph.vaddr</code> 和足够大的 <code>ph.memsz</code> 来构造一个 ELF 二进制，使总和溢出到 <strong>0x1000</strong>，这看起来像是一个有效值。在旧版本的 xv6 中，用户地址空间也包含内核（但在用户模式下不可读/写），用户可以选择一个对应内核内存的地址，从而将 ELF 二进制中的数据复制到内核中。在 RISC-V 版本的 xv6 中，这是不可能的，因为内核有自己独立的页表；<code>loadseg</code>加载数据到进程的页表中，而不是内核的页表中。</p><p>内核开发人员很容易忽略一个关键的检查，现实中的内核有很长一段缺少检查的空档期， 用户程序可以利用缺少这些检查来获得内核特权。xv6 在验证需要提供给内核的用户程序数据的时候，并没有完全验证其是否是恶意的，恶意用户程序可能利用这些数据来绕过 xv6 的隔离。</p><h3 id="3-9-Real-world"><a href="#3-9-Real-world" class="headerlink" title="3.9  Real world"></a>3.9  Real world</h3><p>像大多数操作系统一样，xv6 使用分页硬件进行内存保护和映射。大多数操作系统对分页的使用要比 xv6 复杂得多，它将分页和缺页异常结合起来，我们将在第 4 章中讨论。</p><p>Xv6 的内核使用虚拟地址和物理地址之间的直接映射，这样会更简单，并假设在地址0x8000000 处有物理 RAM，即内核期望加载的地方。这在 QEMU 中是可行的，但是在真实的硬件上，它被证明是一个糟糕的想法；真实的硬件将 RAM 和设备放置在不可预测的物理地址上，例如在 0x8000000 处可能没有 RAM，而 xv6 期望能够在那里存储内核。更好的内核设计利用页表将任意的硬件物理内存布局变成可预测的内核虚拟地址布局。</p><p>RISC-V 支持物理地址级别的保护，但 xv6 没有使用该功能。</p><p>在有大量内存的机器上，使用 RISC-V 对超级页(4MB 的页)的支持可能是有意义的。当物理内存很小的时候，小页是有意义的，可以对磁盘进行精细地分配和分页。例如，如果一个程序只使用 8 千字节的内存，那么给它整整 4 兆字节的超级物理内存页是浪费的。更大的页在有大量内存的机器上是有意义的，可以减少页表操作的开销。</p><p>xv6 内核缺乏一个类 malloc 的分配器为小程序提供内存，这使得内核没有使用需要动态分配的复杂数据结构，从而简化了设计。</p><p>内存分配是一个常年的热门话题，基本问题是有效利用有限的内存和为未来未知的请求做准备<a href="#ftn2">[2]</a>。如今人们更关心的是速度而不是空间效率。此外，一个更复杂的内核可能会分配许多不同大小的小块，而不是（在 xv6 中）只分配 4096 字节的块；一个真正的内核分配器需要处理小块分配以及大块分配。</p><h3 id="3-10-Exercises"><a href="#3-10-Exercises" class="headerlink" title="3.10  Exercises"></a>3.10  Exercises</h3><p>1、分析 RISC-V 的设备树（device tree），找出计算机有多少物理内存。</p><p>2、编写一个用户程序，通过调用<code>sbrk(1)</code>使其地址空间增加一个字节。运行该程序，研究调用 <code>sbrk</code> 之前和调用<code>sbrk</code> 之后的程序页表。内核分配了多少空间？新内存的 PTE 包含哪些内容？</p><p>3、修改 xv6 使得内核使用超级页 4M。</p><p>4、修改 xv6，使用户程序间接引用一个空指针时，会收到一个异常，即修改 xv6，使用户程序的虚拟地址 0 不被映射。</p><p>5、Unix 实现的 exec 传统上包括对 shell 脚本的特殊处理。如果要执行的文件以文本<code>#!</code>开头， 那么第一行就被认为是要运行的程序来解释文件。例如，如果调用 <code>exec</code> 运行 <code>myprog arg1</code>， 而 <code>myprog</code> 的第一行是<code>#!/interp</code>，那么<code>exec</code> 执行<code>/interp myprog arg1</code>。在 xv6 中实现对这个约定的支持。</p><p>6、为内核实现地址空间的随机化。</p><hr><ol><li><a name="ftn1"></a>即在栈中保存了从main返回所需要的信息</li><li><a name="ftn2"></a>dereference，就是对地址取值，例如*p。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第二章</title>
      <link href="/2022/08/31/xv6-Chapter-2/"/>
      <url>/2022/08/31/xv6-Chapter-2/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章：操作系统组织"><a href="#第二章：操作系统组织" class="headerlink" title="第二章：操作系统组织"></a>第二章：操作系统组织</h2><p>操作系统的一个关键要求是同时支持几个活动。例如，使用第1章中描述的系统调用接口，一个进程可以用<strong>fork</strong>创建新进程。操作系统必须在这些进程之间分时共享计算机的资源。例如，即使进程的数量多于硬件CPU的数量，操作系统也必须保证所有的进程都有机会执行。操作系统还必须安排进程之间的隔离。也就是说，如果一个进程出现了bug并发生了故障，其不应该影响不依赖该bug进程的进程。然而，完全隔离也不可取，因为进程间可能需要进行交互，例如管道。因此，一个操作系统必须满足三个要求：多路复用、隔离和交互。</p><p>本章概述了如何组织操作系统来实现这三个要求。现实中有很多方法，但本文主要介绍以宏内核<a href="#ftn1">[1]</a>为中心的主流设计，很多Unix操作系统都采用这种设计。本章还介绍了xv6进程的概述，xv6进程是xv6中的隔离单元，还介绍了xv6启动时第一个进程的创建。</p><p>Xv6运行在多核<a href="#ftn2">[2]</a>RISC-V微处理器上，它的许多底层功能（例如，它的进程实现）是RISC-V所特有的。RISC-V是一个64位的CPU，xv6是用 “LP64 “C语言编写的，这意味着C编程语言中的long(L)和指针(P)是64位的，但int是32位的。本书假定读者在某种架构上做过一点机器级的编程，并会介绍一些RISC-V特有的思想。RISC-V有用的参考资料是 “The RISC-V Reader,An Open Architecture Attlas”［12］。用户级ISA[2]和特权架构[1]是官方规范。</p><p>一台完整的计算机中的CPU被支持它的硬件所包围，这些硬件大部分呈I/O接口的形式。编写XV6时，支撑它的硬件是通过带”-machine virt “选项的qemu模拟出来的。其中包括RAM、包含启动代码的ROM、与用户键盘/屏幕的串行连接以及用于存储的磁盘。</p><h3 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h3><p>​    遇到一个操作系统，人们可能会问的第一个问题是为什么需要它呢？答案是，我们可以把图1.2中的系统调用作为一个库来实现，应用程序与之连接。在这个想法中，每个应用程序可以根据自己的需要定制自己的库。应用程序可以直接与硬件资源进行交互，并以最适合应用程序的方式使用这些资源（例如，实现高效、可预测的性能）。一些用于嵌入式设备或实时系统的操作系统就是以这种方式组织的。</p><p>这种系统库方式的缺点是，如果有多个应用程序在运行，这些应用程序必须正确执行。例如，每个应用程序必须定期放弃CPU，以便其他应用程序能够运行。如果所有的应用程序都相互信任并且没有bug，这样的<strong><em>cooperative</em></strong>分时方案可能是OK的。更典型的情况是，应用程序之间互不信任，并且有bug，所以人们通常希望比<strong><em>cooperative</em></strong>方案提供更强的隔离性。</p><p>为了实现强隔离，禁止应用程序直接访问敏感的硬件资源，而将资源抽象为服务是很有帮助的。例如，Unix应用程序只通过文件系统的<code>open</code>、<code>read</code>、<code>write</code>和<code>close</code>系统调用与文件系统进行交互，而不是直接读写磁盘。这为应用程序带来了路径名的便利，而且它允许操作系统（作为接口的实现者）管理磁盘。即使不考虑隔离问题，那些有意交互的程序（或者只是希望互不干扰）很可能会发现文件系统是一个比直接使用磁盘更方便的抽象。</p><p>同样，Unix在进程之间透明地切换硬件CPU，必要时保存和恢复寄存器状态，这样应用程序就不必意识到时间共享。这种透明性允许操作系统共享CPU，即使一些应用程序处于无限循环中。</p><p>另一个例子是，Unix进程使用<code>exec</code>来建立它们的内存映像，而不是直接与物理内存交互。这使得操作系统可以决定将进程放在内存的什么位置；如果内存紧张，操作系统甚至可能将进程的部分数据存储在磁盘上。<code>exec</code>还允许用户将可执行文件储存在文件系统中。</p><p>Unix进程之间的许多形式的交互都是通过文件描述符进行的。文件描述符不仅可以抽象出许多细节（例如，管道或文件中的数据存储在哪里），而且它们的定义方式也可以简化交互。例如，如果管道中的一个应用程序崩溃了，内核就会为管道中的另一个进程产生一个文件结束信号。</p><p>图1.2中的系统调用接口经过精心设计，既为程序员提供了便利，又提供了强隔离的可能。Unix接口并不是抽象资源的唯一方式，但事实证明它是一种非常好的方式。</p><h3 id="2-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="2.2 User mode, supervisor mode, and system calls"></a>2.2 User mode, supervisor mode, and system calls</h3><p>强隔离要求应用程序和操作系统之间有一个分界线。如果应用程序发生错误，我们不希望操作系统崩溃，也不希望其他应用程序崩溃。相反，操作系统应该能够清理崩溃的应用程序并继续运行其他应用程序。为了实现强隔离，操作系统必须安排应用程序不能修改（甚至不能读取）操作系统的数据结构和指令，应用程序不能访问其他进程的内存。</p><p>CPU提供了强隔离的硬件支持。例如，RISC-V有三种模式，CPU可以执行指令：<strong>机器模式</strong>、<strong>监督者（supervisor）模式</strong>和<strong>用户模式</strong>。在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6会在机器模式下执行几条指令，然后转为监督者模式。</p><p>在监督者（supervisor）模式下，CPU被允许执行特权指令：例如，启用和禁用中断，读写保存页表地址的寄存器等。如果用户模式下的应用程序试图执行一条特权指令，CPU不会执行该指令，而是切换到监督者模式，这样监督者模式的代码就可以终止该应用程序，因为它做了不该做的事情。第1章的图1.1说明了这种组织方式。一个应用程序只能执行用户模式的指令（如数字相加等），被称为运行在用户空间，而处于监督者模式的软件也可以执行特权指令，被称为运行在内核空间。运行在内核空间（或监督者模式）的软件称为内核。</p><p>一个应用程序如果要调用内核函数（如xv6中的<code>read</code>系统调用），必须过渡到内核。CPU提供了一个特殊的指令，可以将CPU从用户模式切换到监督者模式，并在内核指定的入口处进入内核。(RISC-V为此提供了<code>ecall</code>指令。)一旦CPU切换到监督者模式，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝或执行该操作。由内核控制监督者模式的入口点是很重要的；如果应用程序可以决定内核的入口点，那么恶意应用程序就能够在跳过参数验证的情况下进入内核。</p><h3 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h3><p>一个关键的设计问题是操作系统的哪一部分应该在监督者模式下运行。一种可能是整个操作系统驻留在内核中，这样所有系统调用的实现都在监督者模式下运行。这种组织方式称为<strong><em>宏内核</em></strong>。</p><p>在这种组织方式中，整个操作系统以全硬件权限运行。这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要全硬件权限。此外，操作系统的不同部分更容易合作。例如，一个操作系统可能有一个缓冲区，其被缓存文件系统和虚拟内存系统共享。</p><p>宏内核组织方式的一个缺点是操作系统的不同部分之间的接口通常是复杂的（我们将在本文的其余部分看到），因此操作系统开发者很容易在这上面出错。在宏内核中，一个错误是致命的，因为监督者模式下的错误往往会导致内核崩溃。如果内核崩溃，计算机就会停止工作，因此所有的应用程序也会崩溃。计算机必须重启。</p><p>为了降低内核出错的风险，操作系统设计者可以尽量减少在监督者模式下运行的操作系统代码量，而在用户模式下执行操作系统的大部分代码。这种内核组织方式称为<strong><em>微内核</em></strong>。</p><p><img src="/img/Figure-2.1.png" alt="Figure-2.1"></p><p>图2.1说明了这种微内核设计。在图中，文件系统作为一个用户级进程运行。作为进程运行的OS服务称为服务器。为了让应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，用于从一个用户模式进程向另一个进程发送消息。例如，如果一个像shell这样的应用程序想要读写文件，它就会向文件服务器发送一个消息，并等待响应。</p><p>在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织方式使得内核相对简单，因为大部分操作系统驻留在用户级服务器中。</p><p>xv6和大多数Unix操作系统一样，是以宏内核的形式实现的。因此，xv6内核接口与操作系统接口相对应，内核实现了完整的操作系统。由于xv6不提供很多服务，所以它的内核比一些微内核要小，但从概念上讲xv6是宏内核。</p><h3 id="2-4-Code-xv6-organization"><a href="#2-4-Code-xv6-organization" class="headerlink" title="2.4 Code: xv6 organization"></a>2.4 Code: xv6 organization</h3><p>xv6内核源码在<code>kernel/</code>子目录下。按照模块化的概念，源码被分成了多个文件，图2.2列出了这些文件。模块间的接口在<code>kernel/defs.h</code>中定义。</p><p><img src="/img/Figure-2.2.png" alt="Figure-2.2"></p><h3 id="2-5-Process-overview"><a href="#2-5-Process-overview" class="headerlink" title="2.5 Process overview"></a>2.5 Process overview</h3><p>xv6中的隔离单位（和其他Unix操作系统一样）是一个进程。进程抽象可以防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核，所以进程不能破坏内核的隔离机制。内核必须小心翼翼地实现进程抽象，因为一个错误或恶意的应用程序可能会欺骗内核或硬件做一些不好的事情（例如，规避隔离）。内核用来实现进程的机制包括：用户/监督模式标志、地址空间和线程的时间片轮转。</p><p>为了帮助实施隔离，进程抽象为程序提供了一种错觉，即它有自己的私有机器。一个进程为程序提供了一个看似私有的内存系统，或者说是地址空间，其他进程不能对其进行读写。进程还为程序提供了“私有”的CPU，用来执行程序的指令。</p><p>Xv6使用页表（由硬件实现）给每个进程提供自己的地址空间。RISC-V页表将<strong>虚拟地址</strong>（RISC-V指令操作的地址）转换（或 “映射”）为<strong>物理地址</strong>（CPU芯片发送到主存储器的地址）。</p><p>Xv6为每个进程维护一个单独的页表，定义该进程的地址空间。如图2.3所示，进程的用户空间内存的地址空间是从虚拟地址0开始的。指令存放在最前面，其次是全局变量，然后是栈，最后是一个堆区（用于<strong>malloc</strong>），进程可以根据需要扩展。有一些因素限制了进程地址空间的最大长度：RISC-V上的指针是64位宽；硬件在页表中查找虚拟地址时只使用低的39位；xv6只使用39位中的38位。因此，最大地址是$2^{38}-1$ = 0x3fffffffff，也就是<code>MAXVA</code>（kernel/riscv.h:348）。在地址空间的顶端，xv6保留了一页，用于<strong>trampoline</strong>和映射进程<strong>trapframe</strong>的页，以便切换到内核，我们将在第4章中解释。</p><p><img src="/img/Figure-2.3.png" alt="Figure-2.3"></p><p>xv6内核为每个进程维护了许多状态，记录在<code>proc</code>结构体(kernel/proc.h:86)。一个进程最重要的内核状态是它的页表、内核栈和运行状态。我们用<code>p-&gt;xxx</code>来表示<code>proc</code>结构的元素，例如，<code>p-&gt;pagetable</code>是指向进程页表的指针。</p><p>每个进程都有一个执行线程（简称线程），执行进程的指令。一个线程可以被暂停，然后再恢复。为了在进程之间透明地切换，内核会暂停当前运行的线程，并恢复另一个进程的线程。线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的栈中。每个进程有两个栈：用户栈和内核栈（<code>p-&gt;kstack</code>）。当进程在执行用户指令时，只有它的用户栈在被使用，而它的内核栈是空的。当进程进入内核时（因为系统调用或中断），内核代码在进程的内核栈上执行；当进程在内核中时，它的用户栈仍然包含保存的数据，但不被主动使用。进程的线程在用户栈和内核栈中交替执行。内核栈是独立的（并且受到保护，不受用户代码的影响），所以即使一个进程用户栈被破坏了，内核也可以执行。</p><p>一个进程可以通过执行RISC-V <code>ecall</code>指令进行系统调用。该指令提高硬件权限级别，并将程序计数器改变为内核定义的入口点。入口点的代码会切换到内核栈，并执行实现系统调用的内核指令。当系统调用完成后，内核切换回用户栈，并通过调用<code>sret</code>指令返回用户空间，降低硬件特权级别，恢复执行系统调用前的用户指令。进程的线程可以在内核中阻塞等待I/O，当I/O完成后，再从离开的地方恢复。</p><p><code>p-&gt;state</code>表示进程是创建、就绪、运行、等待I/O，还是退出。</p><p><code>p-&gt;pagetable</code>以RISC-V硬件需要的格式保存进程的页表，当进程在用户空间执行时，xv6使分页硬件使用进程的<code>p-&gt;pagetable</code>。进程的页表也会记录分配给该进程内存的物理页地址。</p><h3 id="2-6-Code-starting-xv6-and-the-first-process"><a href="#2-6-Code-starting-xv6-and-the-first-process" class="headerlink" title="2.6 Code: starting xv6 and the first process"></a>2.6 Code: starting xv6 and the first process</h3><p>为了使xv6更加具体，我们将概述内核如何启动和运行第一个进程。后面的章节将更详细地描述这个概述中出现的机制。</p><p>当RISC-V计算机开机时，它会初始化自己，并运行一个存储在只读存储器中的<strong>boot loader</strong>。<strong>Boot loader</strong>将xv6内核加载到内存中。然后，在机器模式下，CPU从 <code>_entry</code>（kernel/entry.S:6）开始执行xv6。RISC-V在禁用分页硬件的情况下启动：虚拟地址直接映射到物理地址。</p><p>loader将xv6内核加载到物理地址<code>0x80000000</code>的内存中。之所以将内核放在<code>0x80000000</code>而不是<code>0x0</code>，是因为地址范围<code>0x0:0x80000000</code>包含I/O设备。</p><p><code>_entry</code>处的指令设置了一个栈，这样xv6就可以运行C代码。Xv6在文件<code>start.c</code>(kernel/start.c:11)中声明了初始栈的空间，即<code>stack0</code>。在<code>_entry</code>处的代码加载栈指针寄存器<code>sp</code>，地址为<code>stack0+4096</code>，也就是栈的顶部，因为RISC-V的栈是向下扩张的。现在内核就拥有了栈，<code>_entry</code>调用<code>start</code>(kernel/start.c:21)，并执行其C代码。</p><p>函数<code>start</code>执行一些只有在机器模式下才允许的配置，然后切换到监督者模式。为了进入监督者模式，RISC-V提供了指令<code>mret</code>。这条指令最常用来从上一次的调用中返回，上一次调用从监督者模式到机器模式。<code>start</code>并不是从这样的调用中返回，而是把事情设置得像有过这样的调用一样：它在寄存器<code>mstatus</code>中把上一次的特权模式设置为特权者模式，它把<code>main</code>的地址写入寄存器<code>mepc</code>中，把返回地址设置为<code>main</code>函数的地址，在特权者模式中把<code>0</code>写入页表寄存器<code>satp</code>中，禁用虚拟地址转换，并把所有中断和异常委托给特权者模式。</p><p>在进入特权者模式之前，<code>start</code>还要执行一项任务：对时钟芯片进行编程以初始化定时器中断。在完成了这些基本管理后，<code>start</code>通过调用<code>mret</code>“返回”到监督者模式。这将导致程序计数器变为<code>main</code>（kernel/main.c:11）的地址。</p><p>在<code>main</code>(kernel/main.c:11)初始化几个设备和子系统后，它通过调用<code>userinit</code>(kernel/proc.c:212)来创建第一个进程。第一个进程执行一个用RISC-V汇编编写的小程序<code>initcode.S</code>（user/initcode.S:1），它通过调用<code>exec</code>系统调用重新进入内核。正如我们在第一章中所看到的，<code>exec</code>用一个新的程序（本例中是<code>/init</code>）替换当前进程的内存和寄存器。</p><p>一旦内核完成<code>exec</code>，它就会在<code>/init</code>进程中返回到用户空间。<code>init</code> (user/init.c:15)在需要时会创建一个新的控制台设备文件，然后以文件描述符0、1和2的形式打开它。然后它在控制台上启动一个shell。这样系统就启动了。</p><h3 id="2-7-Real-world"><a href="#2-7-Real-world" class="headerlink" title="2.7 Real world"></a>2.7 Real world</h3><p>在现实世界中，既可以找到宏内核，也可以找到微内核。许多Unix内核都是宏内核。例如，Linux的内核，尽管有些操作系统的功能是作为用户级服务器运行的（如windows系统）。L4、Minix和QNX等内核是以服务器的形式组织的微内核，并在嵌入式环境中得到了广泛的部署。大多数操作系统都采用了进程概念，大多数进程都与xv6的相似。</p><p>然而，现代操作系统支持进程可以拥有多个线程，以允许一个进程利用多个CPU。在一个进程中支持多个线程涉及到不少xv6没有的机制，包括潜在的接口变化(如Linux的<code>clone</code>，<code>fork</code>的变种)，以控制线程所共享进程的那些部分。</p><h3 id="2-8-Exercises"><a href="#2-8-Exercises" class="headerlink" title="2.8 Exercises"></a>2.8 Exercises</h3><p>1、你可以使用gdb来观察kernel mode到user mode的第一次转换。运行<code>make qemu-gdb</code>。在同一目录下的另一个窗口中，运行<code>gdb</code>。输入gdb命令<code>break *0x3ffffff10e</code>，这将在内核中跳转到用户空间的<code>sret</code>指令处设置一个断点。输入<code>continue</code> gdb命令，gdb应该在断点处停止，并即将执行<code>sret</code>。gdb现在应该显示它正在地址0x0处执行，该地址在<code>initcode.S</code>的用户空间开始处。</p><hr><ol><li><p><a name="ftn1"></a>与微内核设计理念相对应的理念，这也是一个源自操作系统级别的概念。对于宏内核来说，整个操作系统就是一个整体，包括了进程管理、内存管理、文件系统等等</p></li><li><p><a name="ftn2"></a>本文所说的 “多核 “是指多个共享内存但并行执行的CPU，每个CPU都有自己的一套寄存器。本文有时使用多处理器一词作为多核的同义词，但多处理器也可以更具体地指具有多个不同处理器芯片的计算机。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 第一章</title>
      <link href="/2022/08/31/xv6-Chapter-1/"/>
      <url>/2022/08/31/xv6-Chapter-1/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：操作系统接口"><a href="#第一章：操作系统接口" class="headerlink" title="第一章：操作系统接口"></a>第一章：操作系统接口</h2><p>   操作系统的工作是将计算机的资源在多个程序间共享，并且给程序提供一系列比硬件本身支持的更有用的服务。操作系统管理并抽象底层硬件，因此，举例来说，一个文字处理程序不需要去关心自己使用的是何种硬盘。操作系统还对硬件进行多路复用，使多个程序可以同时运行的(或者看起来是同时运行)。最后，操作系统为程序提供了一种可控的交互方式，使得多个程序可以共享数据，共同工作。</p><p>​    操作系统通过接口向用户程序提供服务。设计一个好的接口实际上是很困难的。一方面，我们希望接口简单和精准，这样它就容易正确地实现；另一方面，我们可能又想为应用提供许多更加复杂的功能。解决这种矛盾的诀窍是让接口的设计依赖于一些<em>机制</em> (<em>mechanism)</em>，并通过这些机制的组合来提供通用性。</p><p>​    本书以一个操作系统为例，来说明操作系统的概念。这个操作系统就是xv6，它提供了在Ken Thompson和Dennis Ritchie的Unix操作系统[14]中引入的基本接口，同时也模仿了Unix的内部设计。Unix提供了一个机制组合得非常良好的窄接口，具有惊人的通用性。这样的接口设计非常成功，这也使得BSD，Linux，Mac OS X，Solaris这样的现代操作系统，甚至Windows都有类似Unix的接口。理解xv6是理解这些操作系统的一个良好起点。</p><p>​    如图1.1所示，xv6使用了传统形式的<strong>内核</strong>——一个向其他运行中的程序提供服务的特殊程序。每一个正在运行的程序（称为<strong>进程</strong>），都拥有自己的包含指令、数据、栈的内存空间。指令实现程序的运算，数据是用于运算过程的变量，栈则管理程序的过程调用。一台计算机通常有许多进程，但只有一个内核。</p><p><img src="/img/Figure-1.1.png" alt="Figure-1.1"></p><p>​    当一个进程需要调用一个内核服务时，它就会调用<strong>系统调用</strong>，这是操作系统接口中的一个调用。系统调用会进入内核，让内核执行服务然后返回。所以进程会在用户空间和内核空间之间交替运行。</p><p>​    内核使用CPU<a href="#ftn1">[1]</a>提供的硬件保护机制来确保在用户空间中执行的每个进程只能访问自己的内存。内核运行时拥有硬件特权，可以访问这些受到保护的资源，而用户程序运行时则没有这些特权。当用户程序调用系统调用时，硬件提高特权级别并开始执行内核中预定义的函数。</p><p>内核提供的系统调用集合就是用户程序可见的接口。xv6内核提供了传统Unix内核所提供的服务和系统调用的一个子集。图1.2列出了xv6的所有系统调用。</p><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td><strong>int fork()</strong></td><td>创建一个进程，返回子进程的PID。</td></tr><tr><td><strong>int exit(int status)</strong></td><td>终止当前进程，并将status传递给wait()。不会返回。</td></tr><tr><td><strong>int wait(int *status)</strong></td><td>等待子进程结束，并将status接收到参数*status中，返回其PID。</td></tr><tr><td><strong>int kill(int pid)</strong></td><td>终止给定PID的进程，成功返回0，失败返回-1。</td></tr><tr><td><strong>int getpid()</strong></td><td>返回当前进程的PID。</td></tr><tr><td><strong>int sleep(int n)</strong></td><td>睡眠n个时钟周期。</td></tr><tr><td><strong>int exec(char *file, char *argv[])</strong></td><td>通过给定参数加载并执行一个文件；只在错误时返回。</td></tr><tr><td><strong>char *sbrk(int n)</strong></td><td>使进程内存增加n字节，返回新内存的起始地址。</td></tr><tr><td><strong>int open(char *file, int flags)</strong></td><td>打开一个文件，flags表示读或写，返回fd（文件描述符）。</td></tr><tr><td><strong>int write(int fd, char *buf, int n)</strong></td><td>将buf中n字节写入到文件描述符中；返回n。</td></tr><tr><td><strong>int read(int fd, char *buf, int n)</strong></td><td>从文件描述符中读取n字节到buf；返回读取字节数，文件结束返回0。</td></tr><tr><td><strong>int close(int fd)</strong></td><td>释放文件描述符fd。</td></tr><tr><td><strong>int dup(int fd)</strong></td><td>返回一个新文件描述符，其引用与fd相同的文件。</td></tr><tr><td><strong>int pipe(int p[])</strong></td><td>创建管道，将读/写文件描述符放置在p[0]和p[1]。</td></tr><tr><td><strong>int chdir(char *dir)</strong></td><td>改变当前目录。</td></tr><tr><td><strong>int mkdir(char *dir)</strong></td><td>创建新目录。</td></tr><tr><td><strong>int mknod(char *file, int, int)</strong></td><td>创建新设备文件。</td></tr><tr><td><strong>int fstat(int fd, struct stat *st)</strong></td><td>将打开的文件的信息放置在*st中。</td></tr><tr><td><strong>int stat(char *file, struct stat *st)</strong></td><td>将命名文件信息放置在*st中。</td></tr><tr><td><strong>int link(char *file1, char * file2)</strong></td><td>为文件file1创建一个新的名称(file2)。</td></tr><tr><td><strong>int unlink(char *file)</strong></td><td>移除一个文件。</td></tr></tbody></table></div><p>图1.2  xv6系统调用. 如果没有特别说明, 这些调用成功时返回0，失败时返回-1。</p><p>​    </p><p>​    本章剩下的部分概述了xv6的服务的概貌——进程、内存、文件描述符、管道和文件系统，并通过代码片段对其进行了说明，然后讨论了<strong>shell</strong>（Unix的命令行用户接口）中是如何使用它们的。这些系统调用在shell中的应用说明了系统调用的设计如何精巧。</p><p>​    shell是一个普通的程序，它从用户读取命令并执行它们。shell是一个用户程序，而不是内核的一部分，这一事实说明了系统调用接口的强大：shell没有什么特别之处。这也意味着shell是很容易被替换的;因此，事实上现代Unix系统中有各种各样的shell，每个都有自己的用户界面和脚本特性。xv6 shell是Unix Bourne shell的一个简单实现。它的实现可以在（<code>user/sh.c:1</code>）找到。</p><h3 id="1-1-Processes-and-memory-1-1-进程和内存"><a href="#1-1-Processes-and-memory-1-1-进程和内存" class="headerlink" title="1.1 Processes and memory[1.1 进程和内存]"></a>1.1 Processes and memory[1.1 进程和内存]</h3><p>一个xv6进程由用户空间内存（指令、数据和堆栈）和内核私有的进程状态组成。Xv6对进程提供<strong>分时</strong>特性：它透明地切换当前cpu正在执行的进程。当一个进程暂时不使用cpu时，xv6会保存它的CPU寄存器，在下次运行该进程时恢复它们。内核为每个进程关联一个<strong>PID</strong>(进程标识符)。</p><p> 可以使用<strong>fork</strong>系统调用创建一个新的进程。<strong>fork</strong>创建的新进程被称为<strong>子进程</strong>，其内存内容与调用的进程完全相同，原进程被称为<strong>父进程</strong>。在父进程和子进程中，fork都会返回。在父进程中，fork返回子进程的PID；在子进程中，fork返回0。例如，考虑以下用C编程语言编写的程序片段[6]。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">pid = wait((*<span class="type">int</span>* *)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>exit</strong>系统调用会使得调用它的进程退出，并释放资源，例如内存和打开的文件。<strong>exit</strong>需要一个整数状态参数，通常0表示成功，1表示失败。<strong>wait</strong>系统调用返回当前进程的一个已退出（或被杀死）的子进程的PID，并将该子进程的退出状态码复制到一个地址，该地址由wait参数提供；如果调用者的子进程都没有退出，则<strong>wait</strong>等待一个子进程退出。如果调用者没有子进程，wait立即返回-1。如果父进程不关心子进程的退出状态，可以传递一个0地址给wait。</p><p>​    在上面的例子中，输出为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br></pre></td></tr></table></figure><p>可能会以任何一种顺序输出，这取决于是父进程还是子进程先执行它的<strong>printf</strong>调用。在子程序退出后，父进程的<strong>wait</strong>返回，父进程打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child 1234 is done</span><br></pre></td></tr></table></figure><p>虽然子进程最初与父进程拥有相同的内存内容，但父进程和子进程是在不同的内存和不同的寄存器中执行的：改变其中一个进程中的变量不会影响另一个进程。例如，当<strong>wait</strong>的返回值存储到父进程的<strong>pid</strong>变量中时，并不会改变子进程中的变量<strong>pid</strong>。子进程中的<strong>pid</strong>值仍然为零。</p><p><strong>exec</strong>系统调用使用新内存映像来替换进程的内存， 新内存映像从文件系统中的文件中进行读取。这个文件必须有特定的格式，它指定了文件中哪部分存放指令，哪部分是数据，在哪条指令开始，等等。xv6使用ELF格式，第3章将详细讨论。当<strong>exec</strong>成功时，它并不返回到调用程序；相反，从文件中加载的指令在ELF头声明的入口点开始执行。<strong>exec</strong>需要两个参数：包含可执行文件的文件名和一个字符串参数数组。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>  上述代码会执行/bin/echo程序，并将argv数组作为参数。大多数程序都会忽略参数数组的第一个元素，也就是程序名称。</p><p>xv6 shell使用上述调用来在用户空间运行程序。shell的主结构很简单，参见<strong>main</strong>(user/sh.c:145)。主循环用<strong>getcmd</strong>读取用户的一行输入，然后调用<strong>fork</strong>，创建shell副本。父进程调用wait，而子进程则运行命令。例如，如果用户向shell输入了<strong>echo hello</strong>，那么就会调用<strong>runcmd</strong>，参数为<strong>echo hello</strong>。<strong>runcmd</strong> (user/sh.c:58) 运行实际的命令。对于<strong>echo hello</strong>，它会调用<strong>exec</strong> (user/sh.c:78)。如果<strong>exec</strong>成功，那么子进程将执行echo程序的指令，而不是<strong>runcmd</strong>的。在某些时候，<strong>echo</strong>会调用<strong>exit</strong>，这将使父程序从main(user/sh.c:145)中的<strong>wait</strong>返回。</p><p> 你可能会奇怪为什么<strong>fork</strong>和<strong>exec</strong>没有结合在一次调用中，我们后面会看到shell在实现I/O重定向时利用了这种分离的特性。为了避免创建相同进程并立即替换它（使用exec）所带来的浪费，内核通过使用虚拟内存技术（如copy-on-write）来优化这种用例的fork实现（见4.6节）。</p><p>Xv6隐式分配大部分用户空间内存：<strong>fork</strong>复制父进程的内存到子进程，<strong>exec</strong>分配足够的内存来容纳可执行文件。一个进程如果在运行时需要更多的内存（可能是为了<strong>malloc</strong>），可以调用sbrk(n)将其数据内存增长n个字节；sbrk返回新内存的位置。</p><h3 id="1-2-I-O-and-File-descriptors-1-2-I-O-和文件描述符"><a href="#1-2-I-O-and-File-descriptors-1-2-I-O-和文件描述符" class="headerlink" title="1.2 I/O and File descriptors[1.2 I/O 和文件描述符]"></a>1.2 I/O and File descriptors[1.2 I/O 和文件描述符]</h3><p><strong>文件描述符</strong>是一个小整数，代表一个可由进程读取或写入的内核管理对象。一个进程可以通过打开一个文件、目录、设备，或者通过创建一个管道，或者通过复制一个现有的描述符来获得一个文件描述符。为了简单起见，我们通常将文件描述符所指向的对象称为文件；文件描述符接口将文件、管道和设备之间的差异抽象化，使它们看起来都像字节流。我们把输入和输出称为<strong>I/O</strong>。</p><p>在内部，xv6内核为每一个进程单独维护一个以文件描述符为索引的表，因此每个进程都有一个从0开始的文件描述符私有空间。按照约定，一个进程从文件描述符0(标准输入)读取数据，向文件描述符1(标准输出)写入输出，向文件描述符2(标准错误)写入错误信息。正如我们将看到的那样，shell利用这个约定来实现I/O重定向和管道。shell确保自己总是有三个文件描述符打开（user/sh.c:151），这些文件描述符默认是控制台的文件描述符。</p><p><strong>read</strong>/<strong>write</strong>系统调用可以从文件描述符指向的文件读写数据。调用<strong>read(fd, buf, n)</strong>从文件描述符<strong>fd</strong>中读取不超过<strong>n</strong>个字节的数据，将它们复制到<strong>buf</strong>中，并返回读取的字节数。每个引用文件的文件描述符都有一个与之相关关联偏移量。<strong>read</strong>从当前文件偏移量中读取数据，然后按读取的字节数推进偏移量，随后的<strong>read</strong>将返回上次读取之后的数据。当没有更多的字节可读时，读返回零，表示文件结束。</p><p><strong>write(fd, buf, n)</strong>表示将<strong>buf</strong>中的<strong>n</strong>个字节写入文件描述符<strong>fd</strong>中，并返回写入的字节数。若写入字节数小于n则该次写入发生错误。和<strong>read</strong>一样，<strong>write</strong>在当前文件偏移量处写入数据，然后按写入的字节数将偏移量向前推进：每次<strong>write</strong>都从上一次写入的地方开始。</p><p>下面的程序片段(程序<strong>cat</strong>的核心代码)将数据从其标准输入复制到其标准输出。如果出现错误，它会向标准错误写入一条消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">    n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write(<span class="number">1</span>, buf, n) != n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码片段中，需要注意的是，<strong>cat</strong>不知道它是从文件、控制台还是管道中读取的。同样，<strong>cat</strong>也不知道它是在打印到控制台、文件还是其他什么地方。文件描述符的使用和0代表输入，1代表输出的约定，使得<strong>cat</strong>可以很容易实现。</p><p><strong>close</strong>系统调用会释放一个文件描述符，使它可以被以后的<strong>open</strong>、<strong>pipe</strong>或<strong>dup</strong>系统调用所重用（见下文）。新分配的文件描述符总是当前进程中最小的未使用描述符。</p><p>文件描述符和<strong>fork</strong>相互作用，使I/O重定向易于实现。<strong>fork</strong>将父进程的文件描述符表和它的内存一起复制，这样子进程开始时打开的文件和父进程完全一样。系统调用<strong>exec</strong>替换调用进程的内存，但会保留文件描述符表。这种行为允许shell通过<strong>fork</strong>实现I/O重定向，在子进程中重新打开所选的文件描述符，然后调用<strong>exec</strong>运行新程序。下面是shell运行<strong>cat &lt; input.txt</strong>命令的简化版代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>);  <span class="comment">// 释放标准输入的文件描述符</span></span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);  <span class="comment">// 这时input.txt的文件描述符为0</span></span><br><span class="line">    <span class="comment">// 即标准输入为input.txt</span></span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv);  <span class="comment">// cat从0读取，并输出到1，见上个代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子进程关闭文件描述符0后，<strong>open</strong>保证对新打开的<strong>input.txt</strong>使用该文件描述符0。因为此时0将是最小的可用文件描述符。然后<strong>cat</strong>执行时，文件描述符0（标准输入）会指向<strong>input.txt</strong>。这不会改变父进程的文件描述符，它只会修改子进程的描述符。</p><p>xv6 shell中的I/O重定向代码正是以这种方式工作的（user/sh.c:82）。回想一下shell的代码，shell已经<strong>fork</strong>子shell，<strong>runcmd</strong>将调用<strong>exec</strong>来加载新的程序。</p><p><strong>open</strong>的第二个参数由一组用位表示的标志组成，用来控制<strong>open</strong>的工作。可能的值在文件控制(fcntl)头(kernel/fcntl.h:1-5)中定义。<strong>O_RDONLY,</strong> <strong>O_WRONLY,</strong> <strong>O_RDWR</strong>, <strong>O_CREATE</strong>, 和 <strong>O_TRUNC,</strong> 它们分别指定open打开文件时的功能，读、写、读和写、如果文件不存在则创建文件、将文件长度截断为0。</p><p>现在应该清楚为什么<strong>fork</strong>和<strong>exec</strong>是分开调用的：在这两个调用之间，shell有机会重定向子进程的I/O，而不干扰父进程的I/O设置。我们可以假设一个由<strong>fork</strong>和<strong>exec</strong>组成的系统调用<strong>forkexec</strong>，但是用这种调用来做I/O重定向似乎很笨拙。shell在调用<strong>forkexec</strong>之前修改自己的I/O设置（然后取消这些修改），或者<strong>forkexec</strong>可以将I/O重定向的指令作为参数，或者（最糟糕的方案）每个程序（比如cat）都需要自己做I/O重定向。</p><p>虽然<strong>fork</strong>复制了文件描述符表，但每个底层文件的偏移量都是父子共享的。想一想下面的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个片段的最后，文件描述符1所引用的文件将包含数据hello world。父进程中的<strong>write</strong>（由于有了<strong>wait</strong>，只有在子进程结束后才会运行）会从子进程的<strong>write</strong>结束的地方开始。这种行为有助于从shell命令的序列中产生有序的输出，比如<strong>(echo hello; echo world) &gt;output.txt</strong>。</p><p><strong>dup</strong>系统调用复制一个现有的文件描述符，返回一个新的描述符，它指向同一个底层I/O对象。两个文件描述符共享一个偏移量，就像被<strong>fork</strong>复制的文件描述符一样。这是将hello world写进文件的另一种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>如果两个文件描述符是通过一系列的<strong>fork</strong>和<strong>dup</strong>调用从同一个原始文件描述符衍生出来的，那么这两个文件描述符共享一个偏移量。否则，文件描述符不共享偏移量，即使它们是由同一个文件的打开调用产生的。<strong>dup</strong>允许shell实现这样的命令：l<strong>s existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</strong>。2&gt;&amp;1表示2是1的复制（<strong>dup(1)</strong>），即重定向错误信息到标准输出，已存在文件的名称和不存在文件的错误信息都会显示在文件tmp1中。xv6 shell不支持错误文件描述符的I/O重定向，但现在你知道如何实现它了。</p><p>文件描述符是一个强大的抽象，因为它们隐藏了它们连接的细节：一个向文件描述符1写入的进程可能是在向一个文件、控制台等设备或向一个管道写入。</p><h3 id="1-3-Pipes-1-3-管道"><a href="#1-3-Pipes-1-3-管道" class="headerlink" title="1.3 Pipes[1.3 管道]"></a>1.3 Pipes[1.3 管道]</h3><p><strong>管道</strong>是一个小的内核缓冲区，作为一对文件描述符提供给进程，一个用于读，一个用于写。将数据写入管道的一端就可以从管道的另一端读取数据。管道为进程提供了一种通信方式。</p><p>下面的示例代码运行程序wc，标准输入连接到管道的读取端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>);  <span class="comment">// 释放文件描述符0</span></span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// 复制一个p[0](管道读端)，此时文件描述符0（标准输入）也引用管道读端，故改变了标准输入。</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv); <span class="comment">// wc 从标准输入读取数据，并写入到参数中的每// 一个文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序调用<strong>pipe</strong>，创建一个新的管道，并将读写文件描述符记录在数组<strong>p</strong>中，经过<strong>fork</strong>后，父进程和子进程的文件描述符都指向管道。子进程调用<strong>close</strong>和<strong>dup</strong>使文件描述符0引用管道的读端，并关闭p中的文件描述符，并调用<strong>exec</strong>运行<strong>wc</strong>。当<strong>wc</strong>从其标准输入端读取时，它将从管道中读取。父进程关闭管道的读端，向管道写入，然后关闭写端。</p><p>如果没有数据可用，管道上的<strong>read</strong>会等待数据被写入，或者等待所有指向写端的文件描述符被关闭；在后一种情况下，读将返回0，就像数据文件的结束一样。事实上，如果没有数据写入，读会无限阻塞，直到新数据不可能到达为止（写端被关闭），这也是子进程在执行上面的<strong>wc</strong>之前关闭管道的写端很重要的一个原因：如果wc的一个文件描述符仍然引用了管道的写端，那么<strong>wc</strong>将永远看不到文件的关闭（被自己阻塞）。</p><p>xv6的shell实现了管道，如<strong>grep fork sh.c | wc -l</strong>，shell的实现类似于上面的代码（user/sh.c:100）。执行shell的子进程创建一个管道来连接管道的左端和右端（去看源码，不看难懂）。然后，它在管道左端（写入端）调用<strong>fork</strong>和<strong>runcmd</strong>，在右端（读取端）调用<strong>fork</strong>和<strong>runcmd</strong>，并等待两者结束。管道的右端（读取端）可以是一个命令，也可以是包含管道的多个命令（例如，<strong>a | b | c</strong>），它又会分叉为两个新的子进程（一个是<strong>b</strong>，一个是<strong>c</strong>）。因此，shell可以创建一棵进程树。这棵树的叶子是命令，内部（非叶子）节点是等待左右子进程结束的进程。</p><p>原则上，我们可以让内部节点（非叶节点）运行管道的左端，但这样的实现会更加复杂。考虑只做以下修改：修改sh.c，使其不为<strong>runcmd(p-&gt;left)</strong>  fork进程，直接递归运行<strong>runcmd(p-&gt;left)</strong>。像这样，<strong>echo hi | wc</strong>不会产生输出，因为当<strong>echo hi</strong>在<strong>runcmd</strong>中退出时，内部进程会退出，而不会调用<strong>fork</strong>来运行管道的右端。这种不正确的行为可以通过不在<strong>runcmd</strong>中为内部进程调用<strong>exit</strong>来修正，但是这种修正会使代码变得复杂：<strong>runcmd</strong>需要知道该进程是否是内部进程（非叶节点）。当不为<strong>runcmd(p-&gt;right)</strong>  <strong>fork</strong>进程时，也会出现复杂的情况。像这样的修改，<strong>sleep 10 | echo hi</strong>就会立即打印出hi，而不是10秒后，因为<strong>echo</strong>会立即运行并退出，而不是等待<strong>sleep</strong>结束。由于sh.c的目标是尽可能的简单，所以它并没有试图避免创建内部进程。</p><p>管道似乎没有比临时文件拥有更多的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world | wc</span><br></pre></td></tr></table></figure><p>不使用管道：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</span><br></pre></td></tr></table></figure><p>在这种情况下，管道比临时文件至少有四个优势。首先，管道会自动清理自己；如果是文件重定向，shell在完成后必须小心地删除/tmp/xyz。第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。第三，管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。第四，如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。</p><h3 id="1-4-File-system-1-4-文件系统"><a href="#1-4-File-system-1-4-文件系统" class="headerlink" title="1.4 File system[1.4 文件系统]"></a>1.4 File system[1.4 文件系统]</h3><p>xv6文件系统包含了数据文件（拥有字节数组）和目录（拥有对数据文件和其他目录的命名引用）。这些目录形成一棵树，从一个被称为根目录的特殊目录开始。像<strong>/a/b/c</strong>这样的路径指的是根目录<strong>/</strong>中的<strong>a</strong>目录中的<strong>b</strong>目录中的名为<strong>c</strong>的文件或目录。不以<strong>/</strong>开头的路径是相对于调用进程的当前目录进行计算其绝对位置的，可以通过<strong>chdir</strong>系统调用来改变进程的当前目录。下面两个<strong>open</strong>打开了同一个文件（假设所有涉及的目录都存在）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p>前两行将进程的当前目录改为<strong>/a/b</strong>；后面两行既不引用也不改变进程的当前目录。</p><p>有一些系统调用来可以创建新的文件和目录：<strong>mkdir</strong>创建一个新的目录，用<strong>open</strong>加上<strong>O_CREATE</strong>标志创建并打开一个新的数据文件，以及<strong>mknod</strong>创建一个新的设备文件。这个例子说明了这三个系统调用的使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>mknod</strong>创建了一个引用设备的特殊文件。与设备文件相关联的是主要设备号和次要设备号(<strong>mknod</strong>的两个参数)，它们唯一地标识一个内核设备。当一个进程打开设备文件后，内核会将系统的读写调用转移到内核设备实现上，而不是将它们传递给文件系统。</p><p>文件名称与文件是不同的；底层文件（非磁盘上的文件）被称为<strong>inode</strong>，一个inode可以有多个名称，称为<strong>链接</strong>。每个链接由目录中的一个项组成；该项包含一个文件名和对inode的引用。inode保存着一个文件的<strong><em>metadata\</em></strong>（元数据），包括它的类型（文件或目录或设备），它的长度，文件内容在磁盘上的位置，以及文件的链接数量。</p><p><strong>fstat</strong>系统调用从文件描述符引用的inode中检索信息。它定义在<strong>stat.h</strong> (kernel/stat.h)的 <strong>stat</strong> 结构中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1    <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     <span class="comment">// File system’s disk device</span></span><br><span class="line">    uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">    <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">    <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">    uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>link</strong>系统调用创建了一个引用了同一个inode的文件（文件名）。下面的片段创建了引用了同一个inode两个文件a和b。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><p>读写a与读写b是一样的，每个inode都有一个唯一的inode号来标识。经过上面的代码序列后，可以通过检查fstat的结果来确定a和b指的是同一个底层内容：两者将返回相同的inode号（<strong>ino</strong>），并且nlink计数为2。</p><p><strong>unlink</strong>系统调用会从文件系统中删除一个文件名。只有当文件的链接数为零且没有文件描述符引用它时，文件的inode和存放其内容的磁盘空间才会被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面这行代码会删除a，此时只有b会引用inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE | O_RDWR);</span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>);</span><br></pre></td></tr></table></figure><p>这段代码是创建一个临时文件的一种惯用方式，它创建了一个无名称inode，故会在进程关闭<strong>fd</strong>或者退出时删除文件。</p><p>Unix提供了shell可调用的文件操作程序，作为用户级程序，例如<strong>mkdir</strong>、<strong>ln</strong>和<strong>rm</strong>。这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。现在看来，这个设计似乎是显而易见的，但在Unix时期设计的其他系统通常将这类命令内置到shell中（并将shell内置到内核中）。</p><p>有一个例外，那就是cd，它是在shell中实现的 (user/sh.c:160)。cd 必须改变 shell 自身的当前工作目录。如果cd作为一个普通命令执行，那么shell就会fork一个子进程，而子进程会运行cd，cd只会改变子进程的当前工作目录。父进程（即shell）的工作目录则保持不变。</p><h3 id="1-5-Real-world-1-5-现实情况"><a href="#1-5-Real-world-1-5-现实情况" class="headerlink" title="1.5 Real world[1.5 现实情况]"></a>1.5 Real world[1.5 现实情况]</h3><p>Unix将标准文件描述符、管道和方便的shell语法结合起来进行操作，是编写通用可重用程序的一大进步。这个想法引发了一种“软件工具”文化，这也是Unix强大和流行的主要原因，而shell是第一种所谓的脚本语言。Unix系统调用接口今天仍然存在于BSD、Linux和Mac OS X等操作系统中。</p><p>Xv6并不符合 POSIX 标准：它缺少许多系统调用（包括基本的系统调用，如 <strong>lseek</strong>），而且它提供的许多系统调用与标准不同。我们对xv6的主要目标是简单明了，同时提供一个简单的类似UNIX的系统调用接口。一些人已经添加了一些系统调用和一个简单的C库扩展了xv6，以便运行基本的Unix程序。然而，现代内核比xv6提供了更多的系统调用和更多种类的内核服务。例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。现代内核不断快速发展，并提供了许多超越POSIX的功能。</p><p>Unix用一套文件名和文件描述符接口统一了对多种类型资源（文件、目录和设备）的访问。这个思想可以扩展到更多种类的资源，一个很好的例子是Plan 9项目[13]，它把资源就是文件的概念应用到网络、图形等方面。然而，大多数Unix衍生的操作系统都没有遵循这一路线。</p><p>文件系统和文件描述符已经是强大的抽象。即便如此，操作系统接口还有其他模式。Multics是Unix的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，产生了一种截然不同的接口。Multics设计的复杂性直接影响了Unix的设计者，他们试图建立一些更简单的东西。</p><p>Xv6没有用户系统；用Unix的术语来说，所有的xv6进程都以root身份运行。</p><p>本书研究的是xv6如何实现其类似Unix的接口，但其思想和概念不仅仅适用于Unix。任何操作系统都必须将进程复用到底层硬件上，将进程相互隔离，并提供受控进程间通信的机制。在学习了xv6之后，您应该能够研究其他更复杂的操作系统，并在这些系统中看到xv6中蕴含的基本概念。</p><h3 id="1-6-Exercises-1-6-练习"><a href="#1-6-Exercises-1-6-练习" class="headerlink" title="1.6 Exercises[1.6 练习]"></a>1.6 Exercises[1.6 练习]</h3><ol><li>使用UNIX的系统调用编写一个程序，通过一对管道在两个进程之间交换一个字节，每个方向各一个。以交换次数/秒为单位测量程序的性能。</li></ol><hr><ol><li><a name="ftn1"></a>本文一般用CPU中央处理单元的缩写来指代执行计算的硬件单元。其他文本(如RISC-V规范)也使用processor、core和hart等词代替CPU。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6 riscv book 中文版声明</title>
      <link href="/2022/08/31/xv6-Chapter-0/"/>
      <url>/2022/08/31/xv6-Chapter-0/</url>
      
        <content type="html"><![CDATA[<h1 id="xv6-riscv-book-Chinese"><a href="#xv6-riscv-book-Chinese" class="headerlink" title="xv6-riscv-book-Chinese"></a>xv6-riscv-book-Chinese</h1><p>本项目是MIT 6.S081与6.828课程用书xv6-riscv-book的中文翻译。</p><p>此版翻译基于<a href="https://github.com/pleasewhy/xv6-book-2020-Chinese">xv6-book-2020-Chinese</a>修改与校对完成，全部内容转为Markdown格式。</p><p><strong>如果您在阅读过程中发现翻译中有任何错误或可以改进的地方，欢迎提出issue或pull request。</strong></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>操作系统接口（Operating system interfaces）</li><li>操作系统组织（Operating system organization）</li><li>页表（Page tables）</li><li>陷阱和系统调用（Traps and system calls）</li><li>中断和设备驱动（Interrupts and device drivers）</li><li>锁（Locking）</li><li>调度（Scheduling）</li><li>文件系统（FIle system）</li><li>并发（Concurrency revisited）</li></ol><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>以下人员参与了此版中文xv6-book的主要翻译与校对工作。</p><p>王辉宇，臧振宇，丁睿，何思齐，刘雨俊，刘俊豪，陈冬，杭心语，刘又铭，贾子菡，仲殷旻。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://pdos.csail.mit.edu/6.828/2020/index.html">MIT课程地址</a></li><li><a href="https://github.com/mit-pdos/xv6-riscv">xv6-riscv Github repository</a></li><li><a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">英文原版xv6-riscv-book-rev1</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/11/blog-hello-world/"/>
      <url>/2022/05/11/blog-hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul><li>这里引用变量 <script type="math/tex">a_i</script></li><li><script type="math/tex; mode=display">\sigma = x_1 + y_1</script></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>如何置顶blog<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">sticky: 100</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python常用函数</title>
      <link href="/2021/08/19/python-useful-function/"/>
      <url>/2021/08/19/python-useful-function/</url>
      
        <content type="html"><![CDATA[<h2 id="1-生成6位数字随机验证码"><a href="#1-生成6位数字随机验证码" class="headerlink" title="1. 生成6位数字随机验证码"></a>1. 生成6位数字随机验证码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">num_code</span>(<span class="params">length=<span class="number">6</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成长度为length的数字随机验证码</span></span><br><span class="line"><span class="string">    :param length: 验证码长度</span></span><br><span class="line"><span class="string">    :return: 验证码</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.choice(string.digits) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length))</span><br></pre></td></tr></table></figure><h2 id="2-md5加密"><a href="#2-md5加密" class="headerlink" title="2.md5加密"></a>2.md5加密</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># md5加密</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">md5_encrypt</span>(<span class="params">en_str</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用md5二次加密生成32位的字符串</span></span><br><span class="line"><span class="string">    :param en_str: 需要加密的字符串</span></span><br><span class="line"><span class="string">    :return: 加密后的字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">   </span><br><span class="line">    md5 = hashlib.md5()  <span class="comment"># 使用MD5加密模式</span></span><br><span class="line">    md5.update(en_str.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 将参数字符串传入</span></span><br><span class="line">    md5.update(md5.hexdigest().encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># md5二次加密</span></span><br><span class="line">    <span class="keyword">return</span> md5.hexdigest()</span><br></pre></td></tr></table></figure><h2 id="3-生成唯一token"><a href="#3-生成唯一token" class="headerlink" title="3. 生成唯一token"></a>3. 生成唯一token</h2><pre><code>import uuidimport  hashlibdef only_token():    &quot;&quot;&quot;    使用md5加密uuid生成唯一的32位token    :return: 加密后的字符串    &quot;&quot;&quot;md5 = hashlib.md5()  # 使用MD5加密模式md5.update(str(uuid.uuid1()).encode(&#39;utf-8&#39;))  return md5.hexdigest()</code></pre><h2 id="4、发送手机验证码"><a href="#4、发送手机验证码" class="headerlink" title="4、发送手机验证码"></a>4、发送手机验证码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#验证码管理表</span><br><span class="line">class AuthCode(models.Model):</span><br><span class="line">    name = models.CharField(max_length=10,default=None, null=True, blank=True,verbose_name=&#x27;姓名&#x27;)</span><br><span class="line">    phone = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机号&#x27;)</span><br><span class="line">    code = models.CharField(max_length=6,verbose_name=&#x27;验证码&#x27;)</span><br><span class="line">    purpose = models.IntegerField(default=0,verbose_name=&#x27;用途:0-&gt;注册验证 1-&gt;找回密码 2-&gt;其它&#x27;)</span><br><span class="line">    sendNum = models.IntegerField(default=0,verbose_name=&#x27;发送次数&#x27;)</span><br><span class="line">    isCanGet = models.BooleanField(default=0,verbose_name=&#x27;0-&gt;可以获取,1-&gt;不可以获取&#x27;)</span><br><span class="line">    recentlySendTime = models.DateTimeField(auto_now_add=True,verbose_name=&#x27;最近一次发送时间&#x27;)</span><br><span class="line">    creation_time = models.DateTimeField(auto_now=True, verbose_name=&#x27;创建时间&#x27;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name = &#x27;手机验证码&#x27;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import http.client</span><br><span class="line">import urllib</span><br><span class="line"># 使用互亿无线</span><br><span class="line">host = &quot;106.ihuyi.com&quot;</span><br><span class="line">sms_send_uri = &quot;/webservice/sms.php?method=Submit&quot;</span><br><span class="line"></span><br><span class="line"># 查看用户名 登录用户中心-&gt;验证码通知短信&gt;产品总览-&gt;API接口信息-&gt;APIID</span><br><span class="line">account = &quot;你的用户名&quot;</span><br><span class="line"># 查看密码 登录用户中心-&gt;验证码通知短信&gt;产品总览-&gt;API接口信息-&gt;APIKEY</span><br><span class="line">password = &quot;你的密码&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_sms(text, mobile):</span><br><span class="line">    text = f&quot;您的验证码是：&#123;text&#125;。请不要把验证码泄露给其他人。&quot;</span><br><span class="line">    params = urllib.parse.urlencode(</span><br><span class="line">        &#123;&#x27;account&#x27;: account, &#x27;password&#x27;: password, &#x27;content&#x27;: text, &#x27;mobile&#x27;: mobile, &#x27;format&#x27;: &#x27;json&#x27;&#125;)</span><br><span class="line">    headers = &#123;&quot;Content-type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Accept&quot;: &quot;text/plain&quot;&#125;</span><br><span class="line">    conn = http.client.HTTPConnection(host, port=80, timeout=30)</span><br><span class="line">    conn.request(&quot;POST&quot;, sms_send_uri, params, headers)</span><br><span class="line">    response = conn.getresponse()</span><br><span class="line">    response_str = response.read()</span><br><span class="line">    conn.close()</span><br><span class="line">    return response_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    mobile = &quot;手机号&quot;</span><br><span class="line">    text = &#x27;123122&#x27;</span><br><span class="line"></span><br><span class="line">    print(json.loads(send_sms(text, mobile).decode(&#x27;utf-8&#x27;)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5、生成二维码"><a href="#5、生成二维码" class="headerlink" title="5、生成二维码"></a>5、生成二维码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import qrcode</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">def maker_qrcode(url):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    生成二维码</span><br><span class="line">    :param url: 需要生成二维码的url</span><br><span class="line">    :return: 返回图片字节流</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    image = qrcode.make(url)  # 创建二维码片</span><br><span class="line"></span><br><span class="line">    buffer = io.BytesIO()</span><br><span class="line">    # 将图片内容丢入容器</span><br><span class="line">    image.save(buffer, &#x27;png&#x27;)</span><br><span class="line">    # 返回容器内的字节</span><br><span class="line">    return buffer.getvalue()</span><br><span class="line">    </span><br><span class="line">或者</span><br><span class="line">from .settings import BASE_DIR</span><br><span class="line"></span><br><span class="line">def create_qrcode(name, url):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    生成机器扫码支付二维码</span><br><span class="line">    :param name: 图片名称</span><br><span class="line">    :param url: 支付路由</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    img = qrcode.make(url, border=0)  # 创建二维码片</span><br><span class="line">    save_path = BASE_DIR + &#x27;/&#x27; + name + &#x27;.png&#x27;</span><br><span class="line">    print(save_path)</span><br><span class="line">    img.save(save_path)</span><br><span class="line">    return img</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-微信群发"><a href="#6-微信群发" class="headerlink" title="6.微信群发"></a>6.微信群发</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf8</span><br><span class="line">import itchat, time</span><br><span class="line"></span><br><span class="line">itchat.auto_login(True)</span><br><span class="line"></span><br><span class="line">SINCERE_WISH = u&#x27;祝%s新年快乐！&#x27;</span><br><span class="line"></span><br><span class="line">friendList = itchat.get_friends(update=True)[35:]</span><br><span class="line">count = 0</span><br><span class="line"></span><br><span class="line">for  index,friend in enumerate(friendList):</span><br><span class="line">    print(index,friend[&#x27;DisplayName&#x27;],friend[&#x27;NickName&#x27;])</span><br><span class="line">    itchat.send(SINCERE_WISH % (friend[&#x27;DisplayName&#x27;]</span><br><span class="line">                                or friend[&#x27;NickName&#x27;]), friend[&#x27;UserName&#x27;])</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&#x27;备注名称&#x27;,friend[&#x27;DisplayName&#x27;],&#x27;昵称&#x27;,friend[&#x27;NickName&#x27;],&#x27;用户名&#x27;,friend[&#x27;UserName&#x27;])</span><br><span class="line"></span><br><span class="line">print(&quot;----end----&quot;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 发送文本</span><br><span class="line">itchat.send(&#x27;Hello, WeChat!&#x27;)</span><br><span class="line"># 发送图片</span><br><span class="line">itchat.send_image(&#x27;my_picture.png&#x27;)</span><br><span class="line"># 发送视频</span><br><span class="line">itchat.send_video(&#x27;my_video.mov&#x27;)</span><br><span class="line"># 发送文件</span><br><span class="line">itchat.send_file(&#x27;my_file.zip&#x27;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="7、微信自动回复"><a href="#7、微信自动回复" class="headerlink" title="7、微信自动回复"></a>7、微信自动回复</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding=utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">import itchat</span><br><span class="line">import random</span><br><span class="line">#图灵机器人</span><br><span class="line">#http://www.tuling123.com/member/robot/1380138/center/frame.jhtml?page=0&amp;child=0获取apikey</span><br><span class="line">KEY = &#x27;你的KEY&#x27;</span><br><span class="line"></span><br><span class="line">def get_response(msg):</span><br><span class="line">    apiUrl = &#x27;http://www.tuling123.com/openapi/api&#x27;</span><br><span class="line">    data = &#123;</span><br><span class="line">        &#x27;key&#x27;    : KEY,</span><br><span class="line">        &#x27;info&#x27;   : msg,</span><br><span class="line">        &#x27;userid&#x27; : &#x27;wechat-robot&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">    try:</span><br><span class="line">        r = requests.post(apiUrl, data=data).json()</span><br><span class="line">        return r.get(&#x27;text&#x27;)</span><br><span class="line">    except:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">@itchat.msg_register(itchat.content.TEXT)</span><br><span class="line">def tuling_reply(msg):</span><br><span class="line">    defaultReply = &#x27;I received: &#x27; + msg[&#x27;Text&#x27;]</span><br><span class="line">    robots=[&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;]</span><br><span class="line">    reply = get_response(msg[&#x27;Text&#x27;])+random.choice(robots)</span><br><span class="line">    return reply or defaultReply</span><br><span class="line"></span><br><span class="line">itchat.auto_login(enableCmdQR=False)</span><br><span class="line">itchat.run()</span><br></pre></td></tr></table></figure><h2 id="8、提取Django中model中的字段名变成字典、列表"><a href="#8、提取Django中model中的字段名变成字典、列表" class="headerlink" title="8、提取Django中model中的字段名变成字典、列表"></a>8、提取Django中model中的字段名变成字典、列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">t = &quot;&quot;&quot;</span><br><span class="line">    goods_id = models.IntegerField(verbose_name=&#x27;商品编号&#x27;)</span><br><span class="line">    label_code = models.CharField(max_length=20, verbose_name=&#x27;商品标签&#x27;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 字典</span><br><span class="line">print(&#123;k:None for k in re.findall(&#x27;([a-z_A-Z]+)\s=\s&#x27;,t)&#125;)</span><br><span class="line"># 列表</span><br><span class="line"># print([k for k in re.findall(&#x27;([a-z_A-Z]+)\s=\s&#x27;,t)])</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">&#123;&#x27;goods_id&#x27;: None, &#x27;lable_code&#x27;: None&#125;</span><br></pre></td></tr></table></figure><h2 id="9、数据库中给表创建数据"><a href="#9、数据库中给表创建数据" class="headerlink" title="9、数据库中给表创建数据"></a>9、数据库中给表创建数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">def createData(dataDict,tableName):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    给数据表创建数据</span><br><span class="line">    :param dataDict: 字典</span><br><span class="line">    :param tableName: 表名</span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    #连接数据库</span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=&#x27;192.168.0.188&#x27;, #数据库所在地址URL</span><br><span class="line">        user=&#x27;root&#x27;, #用户名</span><br><span class="line">        password=&#x27;123456&#x27;, #密码</span><br><span class="line">        database=&#x27;名称&#x27;, #数据库名称</span><br><span class="line">        port=3306,  #端口号</span><br><span class="line">        charset=&#x27;utf8&#x27;</span><br><span class="line">    )</span><br><span class="line">    #拿到查询游标</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    clos,value = zip(*dataDict.items())</span><br><span class="line">    sql = &quot;INSERT INTO `%s`(%s) VALUES (%s)&quot; % (tableName,</span><br><span class="line">                                                &#x27;,&#x27;.join(clos),</span><br><span class="line">                                                &#x27;,&#x27;.join([&#x27;%s&#x27;] * len(value))</span><br><span class="line">                                                )</span><br><span class="line">    print(sql)</span><br><span class="line">    cursor.execute(sql, value)</span><br><span class="line">    conn.commit()</span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    print(&#x27;Done&#x27;)</span><br></pre></td></tr></table></figure><h2 id="10-捕捉异常"><a href="#10-捕捉异常" class="headerlink" title="10.捕捉异常"></a>10.捕捉异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    pass</span><br><span class="line">except 异常类型 as e:</span><br><span class="line">    pass</span><br><span class="line">finally:</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">异常类型</span><br><span class="line">Exception  全部异常</span><br><span class="line">AttributeError 试图访问一个对象没有的属性，比如foo.x，但是foo没有属性x</span><br><span class="line">IOError 输入/输出异常；基本上是无法打开文件</span><br><span class="line">ImportError 无法引入模块或包；基本上是路径问题或名称错误</span><br><span class="line">IndentationError 语法错误（的子类） ；代码没有正确对齐</span><br><span class="line">IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]</span><br><span class="line">KeyError 试图访问字典里不存在的键</span><br><span class="line">KeyboardInterrupt Ctrl+C被按下</span><br><span class="line">NameError 使用一个还未被赋予对象的变量</span><br><span class="line">SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）</span><br><span class="line">TypeError 传入对象类型与要求的不符合</span><br><span class="line">UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它</span><br><span class="line">ValueError 传入一个调用者不期望的值，即使值的类型是正确的</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11、获取当前时间"><a href="#11、获取当前时间" class="headerlink" title="11、获取当前时间"></a>11、获取当前时间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">current_time = str(datetime.datetime.now())[:19]</span><br><span class="line">print(current_time)</span><br><span class="line"></span><br><span class="line">输出格式如：2018-10-20 10:01:43</span><br><span class="line">local_time = time.strftime(&#x27;%Y%m%d%H%M%S&#x27;, time.localtime(time.time()))</span><br><span class="line">print(local_time)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12、订单编号"><a href="#12、订单编号" class="headerlink" title="12、订单编号"></a>12、订单编号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from random import Random</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def random_str(randomlength=8):</span><br><span class="line">    str = &#x27;&#x27;</span><br><span class="line">    chars = &#x27;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789&#x27;</span><br><span class="line">    length = len(chars) - 1</span><br><span class="line">    random = Random()</span><br><span class="line">    for i in range(randomlength):</span><br><span class="line">        str+=chars[random.randint(0, length)]</span><br><span class="line">    return str</span><br><span class="line"></span><br><span class="line">def order_num():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    生成付款订单号</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    local_time = time.strftime(&#x27;%Y%m%d%H%M%S&#x27;, time.localtime(time.time()))</span><br><span class="line">    result = local_time + random_str(5)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(order_num())</span><br></pre></td></tr></table></figure><h2 id="13、mysql自动填写当前时间"><a href="#13、mysql自动填写当前时间" class="headerlink" title="13、mysql自动填写当前时间"></a>13、mysql自动填写当前时间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURRENT_TIMESTAMP</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190312172747658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为表添加索引</span><br><span class="line"></span><br><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="14、drf动态过滤查询"><a href="#14、drf动态过滤查询" class="headerlink" title="14、drf动态过滤查询"></a>14、drf动态过滤查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># page.py</span><br><span class="line"></span><br><span class="line">from rest_framework.pagination import PageNumberPagination</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserPagination(PageNumberPagination):</span><br><span class="line">    &quot;&quot;&quot;用户分页器&quot;&quot;&quot;</span><br><span class="line">    page_size = 10  # 默认的页面数据数量</span><br><span class="line">    page_query_param = &#x27;page&#x27;  # 定制取数据页码key </span><br><span class="line">    page_size_query_param = &#x27;page_size&#x27;  # 默认取数据页码key </span><br><span class="line">    max_page_size = 15   # 数据每页取值的最大上限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># serializers.py</span><br><span class="line"></span><br><span class="line">from rest_framework import serializers</span><br><span class="line"></span><br><span class="line">from user.models import UserInfo</span><br><span class="line"></span><br><span class="line">class UserSerializers(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;用户收货地址&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model = UserInfo</span><br><span class="line">    # 所有字段</span><br><span class="line">        #fields = &#x27;__all__&#x27;</span><br><span class="line">        fields = [&#x27;name&#x27;, &#x27;code&#x27;, &#x27;title&#x27;,  &#x27;province&#x27;, &#x27;city&#x27;,</span><br><span class="line">                    &#x27;quxian&#x27;, &#x27;address&#x27;, &#x27;code__gte&#x27;, &#x27;code__lte&#x27;]</span><br><span class="line">        # 显示外键</span><br><span class="line">        depth = 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># views.py</span><br><span class="line">class MachineViews(APIView):</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # 从前端获取出来的过滤参数，解析成字典传进filter()函数中</span><br><span class="line">        # 动态过滤，</span><br><span class="line">        kwargs = &#123;&#125;</span><br><span class="line">        # 表中的字段名</span><br><span class="line">        columns = [&#x27;name&#x27;, &#x27;code&#x27;, &#x27;title&#x27;,  &#x27;province&#x27;, &#x27;city&#x27;,</span><br><span class="line">                    &#x27;quxian&#x27;, &#x27;address&#x27;, &#x27;code__gte&#x27;, &#x27;code__lte&#x27;]</span><br><span class="line">        for k, v in request.query_params.items():</span><br><span class="line">            if k not in columns:</span><br><span class="line">                return Response(&#x27;参数不对&#x27;, status=status.HTTP_400_BAD_REQUEST)</span><br><span class="line">if v:</span><br><span class="line">            kwargs[k] = v</span><br><span class="line"></span><br><span class="line">        users = UserInfo.objects.filter(**kwargs)</span><br><span class="line">        page = UserPagination()</span><br><span class="line">        page_goods_list = page.paginate_queryset(users, self.request, self)</span><br><span class="line">        ser = UserSerializers(page_goods_list, many=True)</span><br><span class="line">        return page.get_paginated_response(ser.data)</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="15、linux后台运行python程序"><a href="#15、linux后台运行python程序" class="headerlink" title="15、linux后台运行python程序"></a>15、linux后台运行python程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup /home/project_venv/user/bin/python3 -u /home/user/user_server.py &gt;&gt; /home/user/user.log 2&gt;&amp;1 &amp;   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="16、追加外键"><a href="#16、追加外键" class="headerlink" title="16、追加外键"></a>16、追加外键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb_commentPhoto ADD CONSTRAINT FK_comment_phone</span><br><span class="line">FOREIGN KEY tb_goodsComment(id) REFERENCES tb_commentPhoto(comment_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="17、写-读CSV文件，查看是否存在，若存在就从csv中删除"><a href="#17、写-读CSV文件，查看是否存在，若存在就从csv中删除" class="headerlink" title="17、写/读CSV文件，查看是否存在，若存在就从csv中删除"></a>17、写/读CSV文件，查看是否存在，若存在就从csv中删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_invite_code(random_code_pool=None, length=6, num=10, is_append=False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建随机邀请码,并写入txt文件</span><br><span class="line">    :param: random_code_pool 随机邀请码</span><br><span class="line">    :param: length 邀请码长度</span><br><span class="line">    :param: num 邀请码个数</span><br><span class="line">    :param: is_append True追加,False 覆盖</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if not random_code_pool:</span><br><span class="line">        code_pool = string.ascii_uppercase + string.digits</span><br><span class="line">        random_code_pool = []</span><br><span class="line">        for i in range(num):</span><br><span class="line">            s = &#x27;&#x27;</span><br><span class="line">            for _ in range(length):</span><br><span class="line">                s += random.choice(code_pool)</span><br><span class="line">            if s and s not in random_code_pool:</span><br><span class="line">                random_code_pool.append(s)</span><br><span class="line"></span><br><span class="line">    # 写入方法。是追加还是覆盖</span><br><span class="line">    write_method = &#x27;a+&#x27; if is_append else &#x27;w&#x27;</span><br><span class="line">    # 写入文件</span><br><span class="line">    with open(&#x27;./invite_code.csv&#x27;, write_method, newline=&#x27;&#x27;) as f:</span><br><span class="line">        writer = csv.writer(f)</span><br><span class="line">        for rowData in random_code_pool:</span><br><span class="line">            # 按行写入</span><br><span class="line">            writer.writerow((rowData,))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_invite_code(code):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    查看邀请码是否存在txt文件中，</span><br><span class="line">    若存在就返回True，并在txt文件中删除</span><br><span class="line">    若不存在就返回False</span><br><span class="line">    :param code:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    code_pool = []</span><br><span class="line">    with open(&#x27;./invite_code.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;,errors=&#x27;ignore&#x27;) as f:</span><br><span class="line">        allFileInfo = csv.reader(f)</span><br><span class="line">        for row in allFileInfo:</span><br><span class="line">            code_pool.append(row[0])</span><br><span class="line"></span><br><span class="line">    if code in code_pool:</span><br><span class="line">        # 删除查询的code</span><br><span class="line">        code_pool.pop(code_pool.index(code))</span><br><span class="line"></span><br><span class="line">        # 重新写入文件</span><br><span class="line">        create_invite_code(code_pool,is_append=False)</span><br><span class="line">        return True</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # create_invite_code(length=9,num=100)</span><br><span class="line">    print(check_invite_code(&#x27;WJ4PSTJG2&#x27;))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="18、django中从request获取访问路径"><a href="#18、django中从request获取访问路径" class="headerlink" title="18、django中从request获取访问路径"></a>18、django中从request获取访问路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;获取相对路径&#x27;, request.get_full_path())</span><br><span class="line">print(&#x27;获取绝对路径&#x27;, request.build_absolute_uri())</span><br><span class="line">print(request.build_absolute_uri(&#x27;?&#x27;))</span><br><span class="line">print(request.build_absolute_uri(&#x27;/&#x27;)[:-1].strip(&quot;/&quot;))</span><br><span class="line">print(request.build_absolute_uri(&#x27;/&#x27;).strip(&quot;/&quot;))</span><br><span class="line">print(request.build_absolute_uri(&#x27;/&#x27;))</span><br><span class="line">print(&#x27;----------&#x27;)</span><br><span class="line">print(request.META[&#x27;HTTP_HOST&#x27;])</span><br><span class="line">print(request.META[&#x27;PATH_INFO&#x27;])</span><br><span class="line">print(request.META[&#x27;QUERY_STRING&#x27;])</span><br><span class="line">iphost = request.META.get(&#x27;REMOTE_ADDR&#x27;, &#x27;&#x27;)  # 获取访问来源IP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出如：</span><br><span class="line">获取相对路径 /QRcode/?d=1</span><br><span class="line">获取绝对路径 http://127.0.0.1:8000/QRcode/?d=1</span><br><span class="line">http://127.0.0.1:8000/QRcode/</span><br><span class="line">http://127.0.0.1:8000</span><br><span class="line">http://127.0.0.1:8000</span><br><span class="line">http://127.0.0.1:8000/</span><br><span class="line">----------</span><br><span class="line">127.0.0.1:8000</span><br><span class="line">/QRcode/</span><br><span class="line">d=1</span><br></pre></td></tr></table></figure><h2 id="19、Django收集静态文件"><a href="#19、Django收集静态文件" class="headerlink" title="19、Django收集静态文件"></a>19、Django收集静态文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先在项目根目录下创建一个static文件夹</span><br><span class="line">然后在settings.py中设置</span><br><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;)</span><br><span class="line">最后执行下面的命令：</span><br><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure><h2 id="20、xadmin插件"><a href="#20、xadmin插件" class="headerlink" title="20、xadmin插件"></a>20、xadmin插件</h2><p><a href="https://www.cnblogs.com/lanqie/p/8340215.html">https://www.cnblogs.com/lanqie/p/8340215.html</a></p><h2 id="21、uwsgi自动重启"><a href="#21、uwsgi自动重启" class="headerlink" title="21、uwsgi自动重启"></a>21、uwsgi自动重启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"># 使用nginx连接时 使用</span><br><span class="line">socket=0.0.0.0:2019</span><br><span class="line"># 直接作为web服务器使用</span><br><span class="line">#http=0.0.0.1:8000</span><br><span class="line"># 配置工程目录</span><br><span class="line">chdir=/home/user</span><br><span class="line"># 配置项目的wsgi目录。相对于工程目录</span><br><span class="line">wsgi-file=user/wsgi.py</span><br><span class="line">virtualenv=/home/project_venv/user</span><br><span class="line">#配置进程，线程信息</span><br><span class="line">processes=1</span><br><span class="line">threads=1</span><br><span class="line">enable-threads=True</span><br><span class="line">master=True</span><br><span class="line">pidfile=uwsgi.pid</span><br><span class="line">daemonize=uwsgi.log</span><br><span class="line">#启动uwsgi的用户名和用户组</span><br><span class="line">uid=root</span><br><span class="line">gid=root</span><br><span class="line">#uwsgi自动重启</span><br><span class="line">py-autoreload=1</span><br></pre></td></tr></table></figure><h2 id="22、谷歌浏览器快捷键"><a href="#22、谷歌浏览器快捷键" class="headerlink" title="22、谷歌浏览器快捷键"></a>22、谷歌浏览器快捷键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">浏览器缓存</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+Del  清除Google浏览器缓存的快捷键</span><br><span class="line"></span><br><span class="line">Ctrl+Shift+R  重新加载当前网页而不使用缓存内容</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="23、git克隆分支"><a href="#23、git克隆分支" class="headerlink" title="23、git克隆分支"></a>23、git克隆分支</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b dev 地址 </span><br></pre></td></tr></table></figure><h2 id="24、mysql更新语句、新增列、删除列"><a href="#24、mysql更新语句、新增列、删除列" class="headerlink" title="24、mysql更新语句、新增列、删除列"></a>24、mysql更新语句、新增列、删除列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update user set name=&#x27;张三&#x27; where id=111</span><br><span class="line"># 删除</span><br><span class="line">DELETE FROM table_name [WHERE Clause]</span><br><span class="line"></span><br><span class="line"># 增加字段</span><br><span class="line">alter table 表名 add column 列名 类型;</span><br><span class="line"># 删除字段</span><br><span class="line">alter table 表名 dropcolumn 列名 ;</span><br></pre></td></tr></table></figure><h2 id="25、删除指定格式的文件"><a href="#25、删除指定格式的文件" class="headerlink" title="25、删除指定格式的文件"></a>25、删除指定格式的文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def remove_specified_format_file(file_dir, format_name):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    删除指定格式的文件</span><br><span class="line">    :param file_dir: 文件根目录</span><br><span class="line">    :param format_name: 格式</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    for root, dirs, files in os.walk(file_dir):</span><br><span class="line">        # print(root) #当前目录路径</span><br><span class="line">        # print(dirs) #当前路径下所有子目录</span><br><span class="line">        # print(files) #当前路径下所有非目录子文件</span><br><span class="line">        for file in files:</span><br><span class="line">            if re.match(format_name, file):</span><br><span class="line">                print(os.path.join(root, file))</span><br><span class="line">                os.remove(os.path.join(root, file))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">remove_specified_format_file(r&#x27;D:\学习\LDC\java&#x27;, r&#x27;\._*&#x27;)</span><br></pre></td></tr></table></figure><h2 id="26、计算文件总数"><a href="#26、计算文件总数" class="headerlink" title="26、计算文件总数"></a>26、计算文件总数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def file_count(file_dir):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    :param file_dir: 文件根目录</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    count = 0</span><br><span class="line">    for root, dirs, files in os.walk(file_dir):</span><br><span class="line">        # print(root) #当前目录路径</span><br><span class="line">        # print(dirs) #当前路径下所有子目录</span><br><span class="line">        # print(files) #当前路径下所有非目录子文件</span><br><span class="line">        count += len(files)</span><br><span class="line">    return count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(file_count(r&#x27;D:\学习\LDC\java\Java学习\newEstore\estore\js&#x27;))</span><br></pre></td></tr></table></figure><h2 id="27、计算文件夹大小"><a href="#27、计算文件夹大小" class="headerlink" title="27、计算文件夹大小"></a>27、计算文件夹大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def file_size(file_dir):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    删除指定格式的文件</span><br><span class="line">    :param file_dir: 文件根目录</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    size = 0</span><br><span class="line">    for root, dirs, files in os.walk(file_dir):</span><br><span class="line">        # print(root) #当前目录路径</span><br><span class="line">        # print(dirs) #当前路径下所有子目录</span><br><span class="line">        # print(files) #当前路径下所有非目录子文件</span><br><span class="line">        for file in files:</span><br><span class="line">            size += os.path.getsize(os.path.join(root, file))</span><br><span class="line"># M为单位</span><br><span class="line">    return size / 1024 / 1024</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_name = r&#x27;D:\学习&#x27;</span><br><span class="line">print(file_size(file_name))</span><br></pre></td></tr></table></figure><h2 id="28、Django实现jsonp跨域"><a href="#28、Django实现jsonp跨域" class="headerlink" title="28、Django实现jsonp跨域"></a>28、Django实现jsonp跨域</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># html</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">                    url: &#x27;请求路由&#x27;,</span><br><span class="line">                    type: &#x27;GET&#x27;,</span><br><span class="line">                    dataType: &#x27;JSONP&#x27;,</span><br><span class="line">                    data:&#123;</span><br><span class="line">                      code: &#x27;yes&#x27;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    jsonp: &#x27;callback&#x27;,</span><br><span class="line">                    success: function(res) &#123;</span><br><span class="line">                       var selectData = $.parseJSON(res);</span><br><span class="line">                       alert(selectData);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    error: function(err) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line"># views.py</span><br><span class="line">def get(self, request, *args, **kwargs):</span><br><span class="line">        code = request.GET.get(&#x27;code&#x27;, &#x27;&#x27;)</span><br><span class="line">        # 跨域请求</span><br><span class="line">        callback = request.GET.get(&#x27;callback&#x27;, &#x27;&#x27;)</span><br><span class="line">        return HttpResponse(&quot;%s(&#x27;%s&#x27;)&quot; % (callback, json.dumps(&#123;&#x27;code&#x27;: code&#125;)), status=status.HTTP_200_OK)</span><br><span class="line">                    </span><br><span class="line">cors解决跨域</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/wxiaoyu/p/9578848.html</span><br></pre></td></tr></table></figure><h2 id="29、微信获取用户信息"><a href="#29、微信获取用户信息" class="headerlink" title="29、微信获取用户信息"></a>29、微信获取用户信息</h2><p>参考：<a href="https://blog.csdn.net/weixin_39735923/article/details/79202563">https://blog.csdn.net/weixin_39735923/article/details/79202563</a></p><h2 id="30、uwsgi初始配置问题"><a href="#30、uwsgi初始配置问题" class="headerlink" title="30、uwsgi初始配置问题"></a>30、uwsgi初始配置问题</h2><p><a href="https://blog.csdn.net/weixin_39735923/article/details/79202563">https://blog.csdn.net/weixin_39735923/article/details/79202563</a></p><h2 id="31、django中drf序列化"><a href="#31、django中drf序列化" class="headerlink" title="31、django中drf序列化"></a>31、django中drf序列化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 序列化器</span><br><span class="line">class MsgSerializers(serializers.ModelSerializer):</span><br><span class="line">    addtime = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">    hasread = serializers.CharField(source=&#x27;get_hasread_display&#x27;)</span><br><span class="line">    msgtype = serializers.CharField(source=&#x27;get_msgtype_display&#x27;)</span><br><span class="line">    class Meta:</span><br><span class="line">        model = MallMsg</span><br><span class="line">        # 可以混合使用</span><br><span class="line">        fields = &#x27;__all__&#x27;  # &#x27;__all__&#x27; 所有字段</span><br><span class="line">        # 数据库层级控制（序列化链表操作）</span><br><span class="line">        # depth = 1  # 外键层级</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#分页器</span><br><span class="line">from rest_framework.pagination import PageNumberPagination</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyLimitOffsetPagination(PageNumberPagination):</span><br><span class="line"></span><br><span class="line">    page_size = 3  # 默认的页面数据数量</span><br><span class="line">    page_query_param = &#x27;page&#x27;  # 定制取数据页码key ？</span><br><span class="line">    page_size_query_param = &#x27;page_size&#x27;  # 默认取数据页码key &amp;</span><br><span class="line">    max_page_size = 15  # 数据每页取值的最大上限</span><br></pre></td></tr></table></figure><h2 id="32、第三方库"><a href="#32、第三方库" class="headerlink" title="32、第三方库"></a>32、第三方库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装openssl</span><br><span class="line"> pip3 install pyOpenSSL</span><br></pre></td></tr></table></figure><h2 id="33、requests请求https携带CA证书"><a href="#33、requests请求https携带CA证书" class="headerlink" title="33、requests请求https携带CA证书"></a>33、requests请求https携带CA证书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import OpenSSL</span><br><span class="line">import requests</span><br><span class="line">import urllib3.contrib.pyopenssl</span><br><span class="line"></span><br><span class="line">urllib3.contrib.pyopenssl.inject_into_urllib3()</span><br><span class="line"></span><br><span class="line">def p12_to_pem(certname, pwd):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    从.p12文件中提取pem</span><br><span class="line">    :param certname:</span><br><span class="line">    :param pwd:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pem_name = certname + &quot;.pem&quot;</span><br><span class="line">    f_pem = open(pem_name, &#x27;wb&#x27;)</span><br><span class="line">    p12file = certname + &quot;.p12&quot;</span><br><span class="line">    p12 = OpenSSL.crypto.load_pkcs12(open(p12file, &#x27;rb&#x27;).read(), pwd)</span><br><span class="line">    f_pem.write(OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, p12.get_privatekey()))</span><br><span class="line">    f_pem.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, p12.get_certificate()))</span><br><span class="line">    ca = p12.get_ca_certificates()</span><br><span class="line">    if ca is not None:</span><br><span class="line">        for cert in ca:</span><br><span class="line">            f_pem.write(OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, cert))</span><br><span class="line">    f_pem.close()</span><br><span class="line">    return pem_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post_cert_request(url, data,header, certname, pwd):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    使用证书发起https请求</span><br><span class="line">    :param url:</span><br><span class="line">    :param data:</span><br><span class="line">    :param certname:</span><br><span class="line">    :param pwd:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if (certname != &quot;&quot;):</span><br><span class="line">        cert = p12_to_pem(certname, pwd)</span><br><span class="line">    else:</span><br><span class="line">        cert = None</span><br><span class="line">    r = requests.post(url, header=header, data=data, cert=cert)</span><br><span class="line">    return r</span><br></pre></td></tr></table></figure><h2 id="34、django创建缓存命令"><a href="#34、django创建缓存命令" class="headerlink" title="34、django创建缓存命令"></a>34、django创建缓存命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createcachetable 缓存表名</span><br></pre></td></tr></table></figure><h2 id="35、Django-更改超级用户密码"><a href="#35、Django-更改超级用户密码" class="headerlink" title="35、Django 更改超级用户密码"></a>35、Django 更改超级用户密码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在工程文件目录下敲入：</span><br><span class="line">python manage.py shell</span><br><span class="line"></span><br><span class="line">再在python交互界面输入：</span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">user = User.objects.get(username = &#x27;用户名&#x27;)</span><br><span class="line">user.set_password(&#x27;密码&#x27;)</span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure><h2 id="36、restframe使用缓存"><a href="#36、restframe使用缓存" class="headerlink" title="36、restframe使用缓存"></a>36、restframe使用缓存</h2><p><a href="https://blog.csdn.net/Odyssues_lee/article/details/80872586">https://blog.csdn.net/Odyssues_lee/article/details/80872586</a></p><h2 id="37、数据库"><a href="#37、数据库" class="headerlink" title="37、数据库"></a>37、数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user  where ISNULL(code)</span><br><span class="line">update user set code=&#x27;111&#x27;,info=&#x27;微信&#x27; where ISNULL(code)</span><br></pre></td></tr></table></figure><h2 id="38、linux常用命令"><a href="#38、linux常用命令" class="headerlink" title="38、linux常用命令"></a>38、linux常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tail -f 日志名  实时监控日志</span><br><span class="line">tail -f 80_v10.log</span><br><span class="line"></span><br><span class="line">netstat -na|grep 80  查看端口tcp连接数</span><br><span class="line">netstat -na|grep 80 | wc -l 计算端口tcp连接数</span><br><span class="line"></span><br><span class="line">ps -ef|grep python  查看有多少python程序在运行</span><br><span class="line"></span><br><span class="line">gunzip 2015.csv.gz   # 解压</span><br><span class="line">unzip 19.zip # 解压zip</span><br><span class="line">wc -l 2015.csv   # 查看行数</span><br><span class="line">apt install lrzsz  # 安装</span><br><span class="line">sz 文件名  # 下载文件</span><br><span class="line"></span><br><span class="line">查找文件</span><br><span class="line">find / -name 文件名</span><br><span class="line"></span><br><span class="line">匹配执行过的以find为开头的命令</span><br><span class="line">history | grep find</span><br></pre></td></tr></table></figure><h2 id="39、xadmin禁止增加、删除"><a href="#39、xadmin禁止增加、删除" class="headerlink" title="39、xadmin禁止增加、删除"></a>39、xadmin禁止增加、删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># models.py</span><br><span class="line"># 用户管理</span><br><span class="line">class UserManage(models.Model):</span><br><span class="line">    name = models.CharField(max_length=20, verbose_name=&#x27;用户名&#x27;)</span><br><span class="line">    phone = models.CharField(max_length=11, unique=True, verbose_name=&#x27;手机号&#x27;)</span><br><span class="line">    code = models.CharField(max_length=11, unique=True, verbose_name=&#x27;编号&#x27;)</span><br><span class="line">    </span><br><span class="line">    user = models.ForeignKey(User, on_delete=models.CASCADE, editable=False, null=True, verbose_name=&#x27;管理员&#x27;)</span><br><span class="line"></span><br><span class="line"># adminx.py</span><br><span class="line"># 用户列表</span><br><span class="line">class UserAdmin(object):</span><br><span class="line">    list_display = [ &#x27;code&#x27;, &#x27;phone&#x27;, &#x27;name&#x27;,]</span><br><span class="line">    search_fields = [&#x27;code&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    list_filter = [&#x27;code&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    list_editable = [&#x27;name&#x27;]  # 数据即时编辑</span><br><span class="line">    readonly_fields = [&#x27;code&#x27;, &#x27;phone&#x27;, &#x27;name&#x27;]  # 只读字段，不能编辑</span><br><span class="line">    model_icon = &#x27;fa fa-square&#x27;</span><br><span class="line">    model = UserInfo</span><br><span class="line">    </span><br><span class="line">    def has_delete_permission(self, *args, **kwargs):</span><br><span class="line">    # 禁止删除</span><br><span class="line">        if args:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">def has_add_permission(self,*args,**kwargs):</span><br><span class="line"># 禁止增加</span><br><span class="line">        return False</span><br><span class="line">        </span><br><span class="line">    def save_models(self):</span><br><span class="line">    # 用户级别设置</span><br><span class="line">        self.new_obj.user = self.request.user</span><br><span class="line">        flag = self.org_obj is None and &#x27;create&#x27; or &#x27;change&#x27;</span><br><span class="line">        if flag == &#x27;create&#x27;:</span><br><span class="line">        # 对密码字段进行加密</span><br><span class="line">            self.new_obj.password = encrypt_oracle(self.new_obj.password)</span><br><span class="line">        elif flag == &#x27;change&#x27;:</span><br><span class="line">            if &#x27;password&#x27; in self.change_message():</span><br><span class="line">                self.new_obj.password = encrypt_oracle(self.new_obj.password)</span><br><span class="line">        else:</span><br><span class="line">        pass</span><br><span class="line">        super().save_models()</span><br><span class="line"></span><br><span class="line">xadmin.site.register(UserInfo, UserAdmin)</span><br></pre></td></tr></table></figure><h2 id="40、时间格式字符串相减"><a href="#40、时间格式字符串相减" class="headerlink" title="40、时间格式字符串相减"></a>40、时间格式字符串相减</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">start = str(datetime.datetime.now())[:19]</span><br><span class="line">time.sleep(60)</span><br><span class="line">end = str(datetime.datetime.now())[:19]</span><br><span class="line">print(start,end)</span><br><span class="line">link_start = datetime.datetime.strptime(start, &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">link_end = datetime.datetime.strptime(end, &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">link_min = round((link_end - link_start).seconds / 60, 2)</span><br><span class="line">print(link_min,&#x27;分钟&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="41、显示循环进度条"><a href="#41、显示循环进度条" class="headerlink" title="41、显示循环进度条"></a>41、显示循环进度条</h2><p>参考：<a href="https://blog.csdn.net/zejianli/article/details/77915751">https://blog.csdn.net/zejianli/article/details/77915751</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from tqdm import tqdm,trange</span><br><span class="line">from time import sleep</span><br><span class="line">text = &quot;&quot;</span><br><span class="line">for char in tqdm([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]):</span><br><span class="line">    text = text + char</span><br><span class="line">    sleep(1)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"># 方式二</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def process_bar(percent, index, total,start_time, start_str=&#x27;&#x27;, end_str=&#x27;&#x27;, total_length=100):</span><br><span class="line">    # 进度条</span><br><span class="line">    percent_length = int(percent)</span><br><span class="line">    bar = &#x27;\r&#x27; + start_str + (&#x27;\033[1;31;41m \033[0m&#x27; * percent_length + &#x27;\033[1;37;47m \033[0m&#x27; * (</span><br><span class="line">                total_length - percent_length)) + f&#x27;  &#123;round(index / total * 100, 2)&#125;%  &#x27; + f&#x27; &#123;index&#125;|&#123;end_str&#125;&#x27;+ f&#x27;   |已进行时间: &#123;round(time.time() - start_time, 2)&#125;秒&#x27;</span><br><span class="line"></span><br><span class="line">    print(bar, end=&#x27;&#x27;, flush=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    data_set = [i for i in range(23)]</span><br><span class="line">    i = 0</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    total = len(data_set)</span><br><span class="line">    end_str = &#x27;&#123;&#125;&#x27;.format(total)</span><br><span class="line">    for data in data_set:</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        i += 1</span><br><span class="line">        process_bar(i * 100 / total, i, total, start_time, start_str=&#x27;&#x27;, end_str=end_str, total_length=100)</span><br><span class="line"></span><br><span class="line"># 方式三</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">d = [i for i in range(100)]</span><br><span class="line">for i in range(len(d)):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    sys.stdout.write(&#x27;\r&gt;&gt; Downloading  %.2f%%&#x27; % (float(i) / float(len(d)) * 100.0))</span><br><span class="line">sys.stdout.flush()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="42、把列表中的字典转成csv文件"><a href="#42、把列表中的字典转成csv文件" class="headerlink" title="42、把列表中的字典转成csv文件"></a>42、把列表中的字典转成csv文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">lists = [&#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125;,&#123;&#x27;a&#x27;:2,&#x27;b&#x27;:3&#125;]</span><br><span class="line">df = pd.DataFrame(lists)</span><br><span class="line">print(df)</span><br><span class="line">df.to_csv(&#x27;result2.csv&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="43、windows添加右键新建MarkDown文件"><a href="#43、windows添加右键新建MarkDown文件" class="headerlink" title="43、windows添加右键新建MarkDown文件"></a>43、windows添加右键新建MarkDown文件</h2><p>在网上下载Typora软件安装后<br>1、在桌面上新建一个txt文件，输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br><span class="line">&quot;FileName&quot;=&quot;template.md&quot;</span><br></pre></td></tr></table></figure><p>2、另存为，改后缀为.reg，保存类型为.txt，编码为Unicode</p><p><img src="https://img-blog.csdnimg.cn/20200526232015169.png" alt="在这里插入图片描述"></p><p>3、双击运行，确定，重启电脑，此时在桌面右键就有了新建md文件</p><h2 id="44、redis设置值定时过期"><a href="#44、redis设置值定时过期" class="headerlink" title="44、redis设置值定时过期"></a>44、redis设置值定时过期</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">import redis</span><br><span class="line"></span><br><span class="line">redis_client = redis.Redis(</span><br><span class="line">    host=&#x27;127.0.0.1&#x27;,</span><br><span class="line">    port=6379,</span><br><span class="line">    db=0,</span><br><span class="line">    password=&#x27;123456&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">def redis_set():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    redis设置值定时过期</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    global redis_client</span><br><span class="line"></span><br><span class="line">    redis_client.set(&#x27;name&#x27;,&#x27;ldc&#x27;)</span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    # 设置‘name’50秒过期</span><br><span class="line">    expire_time = now + datetime.timedelta(hours=0, minutes=0, seconds=50)</span><br><span class="line">    redis_client.expireat(&#x27;name&#x27;, expire_time)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    redis_set()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="45、linux根据端口杀进程"><a href="#45、linux根据端口杀进程" class="headerlink" title="45、linux根据端口杀进程"></a>45、linux根据端口杀进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def killport(port):</span><br><span class="line">    command = &#x27;&#x27;&#x27;kill -9 $(netstat -nlp | grep :&#x27;&#x27;&#x27; + str(port) + &#x27;&#x27;&#x27; | awk &#x27;&#123;print $7&#125;&#x27; | awk -F&quot;/&quot; &#x27;&#123; print $1 &#125;&#x27;)&#x27;&#x27;&#x27;</span><br><span class="line">    os.system(command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 开始执行</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    port = 4237</span><br><span class="line">    killport(port)</span><br></pre></td></tr></table></figure><h2 id="46、监控linux网络流量"><a href="#46、监控linux网络流量" class="headerlink" title="46、监控linux网络流量"></a>46、监控linux网络流量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iftop -n -N -i eth0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nethogs eth0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim +/字符串 文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="47、win10添加右键打开cmd"><a href="#47、win10添加右键打开cmd" class="headerlink" title="47、win10添加右键打开cmd"></a>47、win10添加右键打开cmd</h2><p>通过添加注册表项实现</p><p>win + r 输入 regedit</p><p>找到注册表位置：HKEY_CLASSES_ROOT\Directory\Background\shell\</p><p>右键“shel”l,新建“项”，命名为“以管理员身份打开cmd”，</p><p>右键“以管理员身份打开cmd”，新建“DWORD(32位)值”，命名为”ShowBasedOnVelocityId”,值为“639bc8”</p><p>右键“以管理员身份打开cmd”，新建“项”，命名为“command”</p><p>右键“command”，点击“默认”，点击“修改”，填写数值为 cmd.exe /s /k pushd “%V”</p><h2 id="48、xadmin后台无法显示下拉框完整内容"><a href="#48、xadmin后台无法显示下拉框完整内容" class="headerlink" title="48、xadmin后台无法显示下拉框完整内容"></a>48、xadmin后台无法显示下拉框完整内容</h2><p>解决方案 在根目录中找到/static/xadmin/vendor/selectize/selectize.bootstrap3.css<br>在331行后加入 position: static;</p><p><img src="https://img-blog.csdnimg.cn/20190704184201572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="49、xadmin单点登录"><a href="#49、xadmin单点登录" class="headerlink" title="49、xadmin单点登录"></a>49、xadmin单点登录</h2><p>使用中间件实现。</p><p>新建一个utils.py文件，存放以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.sessions.models import Session</span><br><span class="line">from django.db.models import Q</span><br><span class="line">from django.utils import timezone</span><br><span class="line">from django.utils.deprecation import MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class XadminMiddleware(MiddlewareMixin):</span><br><span class="line">    def process_request(self, request):</span><br><span class="line">        &quot;&quot;&quot;xadmin后台单点登录&quot;&quot;&quot;</span><br><span class="line">        PATH_INFO = request.META.get(&#x27;PATH_INFO&#x27;, &#x27;&#x27;)</span><br><span class="line">        if PATH_INFO and &#x27;xadmin&#x27; in PATH_INFO:</span><br><span class="line">            request.session.clear_expired()   # 清除过期的key</span><br><span class="line">            session_key = request.session.session_key</span><br><span class="line">            for session in Session.objects.filter(~Q(session_key=session_key), expire_date__gte=timezone.now()):</span><br><span class="line">                data = session.get_decoded()</span><br><span class="line">                if data.get(&#x27;_auth_user_id&#x27;, None) == str(request.user.id):</span><br><span class="line">                    session.delete()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在urls.py中设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">...</span><br><span class="line">re_path(&#x27;^xadmin/&#x27;, xadmin.site.urls),</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后在settings.py中注册中间件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   MIDDLEWARE = [</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   &#x27;utils.xadminauth.XadminMiddleware&#x27;,</span><br><span class="line">   ...</span><br><span class="line">   ]</span><br><span class="line">SESSION_COOKIE_AGE = 1209600  # 设置过期时间</span><br><span class="line">   SESSION_SAVE_EVERY_REQUEST = Ture  # 每次请求都更新</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【参考】 <a href="https://blog.csdn.net/Python_anning">https://blog.csdn.net/Python_anning</a></p><h2 id="50、Django-restful-多个models数据表序列化合并返回（一次请求返回多个序列化器数据）"><a href="#50、Django-restful-多个models数据表序列化合并返回（一次请求返回多个序列化器数据）" class="headerlink" title="50、Django restful 多个models数据表序列化合并返回（一次请求返回多个序列化器数据）"></a>50、Django restful 多个models数据表序列化合并返回（一次请求返回多个序列化器数据）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># 导入第三方包</span><br><span class="line">pip install django-crispy-forms==1.7.2</span><br><span class="line"></span><br><span class="line"># 在settings.py中添加应用</span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">...</span><br><span class="line">&#x27;drf_multiple_model&#x27;,</span><br><span class="line">&#x27;rest_framework&#x27;,</span><br><span class="line">...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 在views.py中使用</span><br><span class="line">    from drf_multiple_model.pagination import MultipleModelLimitOffsetPagination</span><br><span class="line">    from drf_multiple_model.views import ObjectMultipleModelAPIView</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    class LimitPagination(MultipleModelLimitOffsetPagination):</span><br><span class="line">        # 多个models数据表联合查询，分页，每页限制数据10条</span><br><span class="line">        default_limit = 10</span><br><span class="line">        </span><br><span class="line">    class StudentSerializers(serializers.ModelSerializer):</span><br><span class="line">        &quot;&quot;&quot;学生表序列化器&quot;&quot;&quot;</span><br><span class="line">        # merchant = MerchantSerializers()</span><br><span class="line">        </span><br><span class="line">        register_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">       </span><br><span class="line">        class Meta:</span><br><span class="line">            model = Student</span><br><span class="line">            fields = &#x27;__all__&#x27;</span><br><span class="line">    class ClassesSerializers(serializers.ModelSerializer):</span><br><span class="line">        &quot;&quot;&quot;班级表序列化器&quot;&quot;&quot;</span><br><span class="line">        # merchant = MerchantSerializers()</span><br><span class="line">        </span><br><span class="line">        add_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">       </span><br><span class="line">        class Meta:</span><br><span class="line">            model = Classes</span><br><span class="line">            fields = &#x27;__all__&#x27;</span><br><span class="line">    </span><br><span class="line">    class SchoolSerializers(serializers.ModelSerializer):</span><br><span class="line">        &quot;&quot;&quot;学校表序列化器&quot;&quot;&quot;</span><br><span class="line">        # merchant = MerchantSerializers()</span><br><span class="line">        </span><br><span class="line">        add_time = serializers.DateTimeField(read_only=True, format=&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">       </span><br><span class="line">        class Meta:</span><br><span class="line">            model = School</span><br><span class="line">            fields = &#x27;__all__&#x27;      </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    class StudentInfo(ObjectMultipleModelAPIView):</span><br><span class="line">        # 获取学生信息，班级信息，学校信息</span><br><span class="line">    </span><br><span class="line">        def get(self, request, *args, **kwargs):</span><br><span class="line">            uid = request.GET.get(&#x27;uid&#x27;, &#x27;&#x27;)  # 学生id</span><br><span class="line">            cid = request.GET.get(&#x27;cid&#x27;, &#x27;&#x27;)  # 班级id</span><br><span class="line">            sid = request.GET.get(&#x27;sid&#x27;, &#x27;&#x27;)  # 学校id</span><br><span class="line">            </span><br><span class="line">            self.querylist = [</span><br><span class="line">                &#123;&#x27;queryset&#x27;: Student.objects.filter(id=uid).order_by(&#x27;-id&#x27;),</span><br><span class="line">                    &#x27;serializer_class&#x27;:  StudentSerializers, &#x27;label&#x27;: &#x27;student&#x27;, &#125;,</span><br><span class="line">                &#123;&#x27;queryset&#x27;: Classes.objects.filter(id=cid).order_by(&#x27;-id&#x27;),</span><br><span class="line">                    &#x27;serializer_class&#x27;:  ClassesSerializers, &#x27;label&#x27;: &#x27;classes&#x27;, &#125;,</span><br><span class="line">                &#123;&#x27;queryset&#x27;: School.objects.filter(id=sid).order_by(&#x27;-id&#x27;),</span><br><span class="line">                    &#x27;serializer_class&#x27;:  SchoolSerializers, &#x27;label&#x27;: &#x27;school&#x27;, &#125;,</span><br><span class="line">            ]</span><br><span class="line">    </span><br><span class="line">            return self.list(request, *args, **kwargs)</span><br><span class="line">    </span><br><span class="line">        pagination_class = LimitPagination</span><br></pre></td></tr></table></figure><h2 id="51、-Django序列化器返回外键关联数据"><a href="#51、-Django序列化器返回外键关联数据" class="headerlink" title="51、 Django序列化器返回外键关联数据"></a>51、 Django序列化器返回外键关联数据</h2><p>通过 related_name=’goods_price’把两个表关联起来，当返回Goods的信息时也会返回相应的GoodsPrice信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class GoodsPriceSerializers(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;商品价格表序列化器&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    class Meta:</span><br><span class="line">        model = GoodsPrice</span><br><span class="line">        fields = [&#x27;price&#x27;]</span><br><span class="line"></span><br><span class="line">class GoodsSerializers(serializers.ModelSerializer):</span><br><span class="line">    &quot;&quot;&quot;商品表序列化器&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    goods_price = GoodsPriceSerializers(many=True, read_only=True)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model = Goods</span><br><span class="line">        fields = [&#x27;title&#x27;,&#x27;goods_price&#x27;]</span><br><span class="line">        depth = 2</span><br><span class="line"></span><br><span class="line">class Goods(models.Model):</span><br><span class="line">    &quot;&quot;&quot;商品表&quot;&quot;&quot;</span><br><span class="line">    title = models.CharField(max_length=50, verbose_name=&#x27;商品名称&#x27;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &#x27;goods&#x27;</span><br><span class="line">        verbose_name = &#x27;商品信息表&#x27;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br><span class="line"></span><br><span class="line">class GoodsPrice(models.Model):</span><br><span class="line">    &quot;&quot;&quot;商品价格表,通过外键关联商品信息表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    price = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=&#x27;售价&#x27;)</span><br><span class="line">    goods = models.ForeignKey(to=&#x27;Goods&#x27;, related_name=&#x27;goods_price&#x27;, on_delete=models.SET_NULL, blank=True, null=True,verbose_name=&#x27;商品&#x27;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return str(self.price)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        managed = True</span><br><span class="line">        db_table = &#x27;goodsPrice&#x27;</span><br><span class="line">        verbose_name = &#x27;商品售价&#x27;</span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure><h2 id="52、python-Django通过User-Agent判断请求来源是微信扫一扫或者是支付宝扫一扫"><a href="#52、python-Django通过User-Agent判断请求来源是微信扫一扫或者是支付宝扫一扫" class="headerlink" title="52、python Django通过User Agent判断请求来源是微信扫一扫或者是支付宝扫一扫"></a>52、python Django通过User Agent判断请求来源是微信扫一扫或者是支付宝扫一扫</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Footest(APIView):</span><br><span class="line"> def get(self, request, *args, **kwargs):</span><br><span class="line">     # print(request.META)</span><br><span class="line">     if &#x27;MicroMessenger&#x27; in request.META[&#x27;HTTP_USER_AGENT&#x27;]:</span><br><span class="line">         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是微信&#x27;&#125;)</span><br><span class="line">     elif &#x27;AlipayClient&#x27; in request.META[&#x27;HTTP_USER_AGENT&#x27;]:</span><br><span class="line">         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是支付宝&#x27;&#125;)</span><br><span class="line">     else:</span><br><span class="line">         return Response(data=&#123;&#x27;msg&#x27;: &#x27;访问来源是其他&#x27;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</p><p>浏览器的 UA 字串</p><p>标准格式为： 浏览器标识 (操作系统标识; 加密等级标识; 浏览器语言) 渲染引擎标识 版本信息</p><p>获取user-Agent 之后，<br>通过识别MicroMessenger或者AlipayClient这样的关键字应该就可以判断是微信还是支付宝<br>【参考文章】 <a href="https://blog.csdn.net/fly910905/article/details/82498813?utm_source=blogxgwz4">https://blog.csdn.net/fly910905/article/details/82498813?utm_source=blogxgwz4</a></p><h2 id="53、xadmin后台集成’导入‘插件，导入excel文件"><a href="#53、xadmin后台集成’导入‘插件，导入excel文件" class="headerlink" title="53、xadmin后台集成’导入‘插件，导入excel文件"></a>53、xadmin后台集成’导入‘插件，导入excel文件</h2><p>效果图：</p><p><img src="https://img-blog.csdnimg.cn/20190426190357134.png" alt="在这里插入图片描述"></p><p>1、添加</p><p>在虚拟环境根目录\Lib\site-packages\xadmin\plugins中添加excel.py文件</p><p><img src="https://img-blog.csdnimg.cn/20190426190440451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>from xadmin.views import BaseAdminPlugin, ListAdminViewfrom django.template import loaderimport xadminclass ListExcelImportPlugin(BaseAdminPlugin):    # 重写init_request    import_excel = False    def init_request(self, *args, **kwargs):        return self.import_excel    def block_top_toolbar(self, context, nodes):        # 这里 xadmin/excel/model_list.top_toolbar.import.html 是自己写的html文件      nodes.append(loader.render_to_string(&quot;xadmin/excel/model_list.top_toolbar.import.html&quot;))xadmin.site.register_plugin(ListExcelImportPlugin, ListAdminView)</code></pre><p>在虚拟环境根目录\Lib\site-packages\xadmin\plugins<strong>init</strong>.py中</p><pre><code>PLUGINS = (...    &#39;excel&#39;,...)</code></pre><p>2、添加html文件</p><p><img src="https://img-blog.csdnimg.cn/20190426190455263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在虚拟环境根目录\Lib\site-packages\xadmin\templates\xadmin\中增加文件夹excel,在文件夹中添加model_list.top_toolbar.import.html文件</p><pre><code>    &#123;% load i18n %&#125;&lt;div class=&quot;btn-group export&quot;&gt;    &lt;a class=&quot;dropdown-toggle btn btn-default btn-sm&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt;        &lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入数据 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;    &lt;/a&gt;    &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dLabel&quot;&gt;        &lt;li&gt;&lt;a data-toggle=&quot;modal&quot; data-target=&quot;#export-modal-import-excel&quot;&gt;&lt;i class=&quot;icon-circle-arrow-down&quot;&gt;&lt;/i&gt; 导入            Excel&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div id=&quot;export-modal-import-excel&quot; class=&quot;modal fade&quot;&gt;        &lt;div class=&quot;modal-dialog&quot;&gt;            &lt;div class=&quot;modal-content&quot;&gt;                &lt;form method=&quot;post&quot; action=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt;                    &lt;!--&#123;% csrf_token %&#125;--&gt;                    &lt;div class=&quot;modal-header&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;×&lt;/button&gt;                        &lt;h4 class=&quot;modal-title&quot;&gt;导入 Excel&lt;/h4&gt;                    &lt;/div&gt;                    &lt;div class=&quot;modal-body&quot;&gt;                        &lt;input type=&quot;file&quot; onchange=&quot;fileChange(this)&quot; name=&quot;excel&quot; id=&quot;submit_upload&quot;&gt;                    &lt;/div&gt;                    &lt;div class=&quot;modal-footer&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;&#123;% trans "Close" %&#125;&lt;/button&gt;                        &lt;button class=&quot;btn btn-success&quot; type=&quot;button&quot; id=&quot;submit_upload_b&quot;&gt;&lt;i class=&quot;icon-share&quot;&gt;&lt;/i&gt; 导入                        &lt;/button&gt;                    &lt;/div&gt;                &lt;/form&gt;            &lt;/div&gt;&lt;!-- /.modal-content --&gt;        &lt;/div&gt;&lt;!-- /.modal-dalog --&gt;    &lt;/div&gt;&lt;!-- /.modal --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function fileChange(target) &#123;        //检测上传文件的类型        var imgName = document.all.submit_upload.value;        var ext, idx;        if (imgName == &#39;&#39;) &#123;            document.all.submit_upload_b.disabled = true;            alert(&quot;请选择需要上传的 xls 文件!&quot;);            return;        &#125; else &#123;            idx = imgName.lastIndexOf(&quot;.&quot;);            if (idx != -1) &#123;                ext = imgName.substr(idx + 1).toUpperCase();                ext = ext.toLowerCase();                if (ext != &#39;xls&#39; &amp;&amp; ext != &#39;xlsx&#39;) &#123;                    document.all.submit_upload_b.disabled = true;                    alert(&quot;只能上传 .xls 类型的文件!&quot;);                    return;                &#125;            &#125; else &#123;                document.all.submit_upload_b.disabled = true;                alert(&quot;只能上传 .xls 类型的文件!&quot;);                return;            &#125;        &#125;    &#125;    $(document).ready(function () &#123;        $(&#39;#submit_upload_b&#39;).click(function () &#123;            var form_data = new FormData();            var file_info = $(&#39;#submit_upload&#39;)[0].files[0];            form_data.append(&#39;file&#39;, file_info);            form_data.append(&#39;file_source&#39;, $(&#39;.breadcrumb li&#39;).eq(1).text().trim());            var url = window.location.protocol + &#39;//&#39; + window.location.host + &#39;/importkdorderno/&#39;            $.ajax(&#123;                url: url,                type: &#39;POST&#39;,                data: form_data,                dataType: &quot;json&quot;,                beforeSend: function (xhr) &#123;                    xhr.setRequestHeader(&quot;X-CSRFToken&quot;, $.getCookie(&quot;csrftoken&quot;))                &#125;,                processData: false,  // tell jquery not to process the data                contentType: false, // tell jquery not to set contentType                success: function (res) &#123;                    alert(res.msg);                    window.location.reload();                &#125;,                error: function (err) &#123;                &#125;            &#125;);        &#125;);    &#125;)&lt;/script&gt;</code></pre><p>3、在views.py处理上传的excel文件</p><pre><code>import pandas as pdfrom rest_framework.views import APIViewclass ImportKDOrderNo(APIView):    def post(self, request, *args, **kwargs):        file = request.FILES.get(&#39;file&#39;)        # read = InMemoryUploadedFile().open()        data = pd.read_excel(file)  # 使用pandas处理excel文件        file_source = request.POST.get(&#39;file_source&#39;, &#39;&#39;)  # 文件来源        if &#39;订单号&#39; and &#39;物流单号&#39; not in data:            return Response(data=&#123;&#39;msg&#39;: &#39;文件格式有误，第一行第一列应该为【订单号】，第一行第二列应该为【物流单号】&#39;&#125;)        ordernos = data[&#39;订单号&#39;]        logistics = data[&#39;物流单号&#39;]        for i in range(len(ordernos)):            print(&#39;订单号&#39;, ordernos[i], &#39;物流单号&#39;, logistics[i])        return Response(data=&#123;&#39;msg&#39;: &#39;上传成功&#39;&#125;)</code></pre><p>4、在urls.py中添加访问路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from 你的应用名称 import views</span><br><span class="line"></span><br><span class="line">app_name = &#x27;你的应用名称&#x27;</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    # 其他路由</span><br><span class="line">    ...</span><br><span class="line">    # 导入物流单号</span><br><span class="line">    path(&#x27;importkdorderno/&#x27;, views.ImportKDOrderNo.as_view(), name=&#x27;importkdorderno&#x27;),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="54、Django中查找今天进账金额"><a href="#54、Django中查找今天进账金额" class="headerlink" title="54、Django中查找今天进账金额"></a>54、Django中查找今天进账金额</h2><p>views.py</p><pre><code>from datetime import datetimeclass CountFee(APIView):    def get(self, request, *args, **kwargs):        # 获取当前时间的年月日，然后使用聚合函数添加fee字段的值        year = datetime.now().year        month = datetime.now().month        day = datetime.now().day        count_fees = FeeDetail.objects.filter(addtime__year=year, addtime__month=month, addtime__day=day).aggregate(Sum(&#39;fee&#39;))        all_fee = count_fees[&#39;fee__sum&#39;] if count_fees[&#39;fee__sum&#39;] else 0        print(all_fee)        return Response(&#123;&#39;code&#39;: 1, &#39;msg&#39;: &#39;success&#39;, &#39;data&#39;: &#123;&#39;all_fee&#39;: all_fee&#125;&#125;)</code></pre><h2 id="55、判断是什么系统"><a href="#55、判断是什么系统" class="headerlink" title="55、判断是什么系统"></a>55、判断是什么系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import platform</span><br><span class="line">PlATFORM = platform.system()</span><br><span class="line">if PlATFORM == &quot;Linux&quot;:</span><br><span class="line">    print(&#x27;linux&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;其他&#x27;) </span><br></pre></td></tr></table></figure><h2 id="56、sql查询"><a href="#56、sql查询" class="headerlink" title="56、sql查询"></a>56、sql查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 联合更新</span><br><span class="line">update malluser set master_master_id=3 where master_id in (select a.id from (select id from  malluser where id like &#x27;15%&#x27;)a) </span><br><span class="line"># 统计某字段重复数据</span><br><span class="line">SELECT phone, COUNT(*) AS sumCount FROM malluser GROUP BY phone HAVING sumCount &gt; 1;</span><br></pre></td></tr></table></figure><h2 id="57、-xadmin后台删除数据出现错误"><a href="#57、-xadmin后台删除数据出现错误" class="headerlink" title="57、 xadmin后台删除数据出现错误"></a>57、 xadmin后台删除数据出现错误</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`get_deleted_objects() takes 3 positional arguments but 5 were given`</span><br></pre></td></tr></table></figure><p>这是由于Django2.1版本和xadmin不兼容导致的</p><p>知道虚拟环境\Lib\site-packages\xadmin\plugins\actions.py</p><p>修改93行，</p><p>把</p><pre><code>deletable_objects, model_count, perms_needed, protected = get_deleted_objects(            queryset, self.opts, self.user, self.admin_site, using)</code></pre><p>改为</p><pre><code>deletable_objects, model_count, perms_needed, protected = get_deleted_objects(            queryset, self.user, self.admin_site)</code></pre><p>然后在adminx.py文件中对应的模型类中允许删除</p><pre><code>class MaterialAdmin(object):    &quot;&quot;&quot;素材库分类&quot;&quot;&quot;    list_display = [&#39;id&#39;, &#39;name&#39;, &#39;class_id&#39;, &#39;is_delete&#39;, &#39;addtime&#39;]    def has_delete_permission(self, *args, **kwargs):        return True</code></pre><h2 id="58、xdamin限制用户点击"><a href="#58、xdamin限制用户点击" class="headerlink" title="58、xdamin限制用户点击"></a>58、xdamin限制用户点击</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//如果登录z=xadmin后台的账号不是【root】的就不能点击更新操作</span><br><span class="line">    var master_name = $(&#x27;#top-nav&#x27;).find(&#x27;strong&#x27;).text();</span><br><span class="line">        master_name =  master_name.substring(4);</span><br><span class="line">    if(master_name != &#x27;root&#x27;)&#123;</span><br><span class="line">            $(&quot;.grid-item a&quot;).each(function(index, element) &#123;</span><br><span class="line">                $(this).attr(&#x27;href&#x27;,&#x27;#&#x27;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="59、获取公众号关注url"><a href="#59、获取公众号关注url" class="headerlink" title="59、获取公众号关注url"></a>59、获取公众号关注url</h2><p>在微信网页版，打开公众号，点击右上角“…”，在弹框中选择右下角中间的“查看历史记录”，然后在弹框中选择左上角倒数第一个，“用默认浏览器打开”，就可以在打开的浏览器中获取该公众号的关注url，当把这个url发给好友时，好友点开的就是去关注公众号的页面。</p><h2 id="60、xadmin后台用户操作表权限"><a href="#60、xadmin后台用户操作表权限" class="headerlink" title="60、xadmin后台用户操作表权限"></a>60、xadmin后台用户操作表权限</h2><p>虚拟环境根目录\Lib\site-packages\xadmin\views\base.py</p><p>可以找到：</p><p><img src="https://img-blog.csdnimg.cn/20190627140512311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在项目子应用下的adminx.py中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line"></span><br><span class="line">from machine.models import Machine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MachineAdmin(object):</span><br><span class="line">    list_display = [&#x27;code&#x27;,]  # 显示的字段</span><br><span class="line"></span><br><span class="line">    search_fields = [&#x27;code&#x27;]  # 搜索的字段</span><br><span class="line">    list_filter = [&#x27;code&#x27;, &#x27;is_delete&#x27;] # 过滤的字段</span><br><span class="line">    ordering = (&#x27;-id&#x27;,) # 按id降序排序</span><br><span class="line">    list_editable = [&#x27;is_delete&#x27;, ]  # 数据即时编辑</span><br><span class="line">    list_per_page = 30  # 每页显示数据数量</span><br><span class="line">    model_icon = &#x27;fa fa-cog fa-spin&#x27;  # 左侧显示的小图标</span><br><span class="line"></span><br><span class="line">    def has_delete_permission(self, *args, **kwargs): </span><br><span class="line">        # 删除权限</span><br><span class="line">        if self.request.user.is_superuser:  # 管理员才能增加</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def has_add_permission(self, *args, **kwargs):</span><br><span class="line">        if self.request.user.is_superuser:  # 管理员才能增加</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def has_change_permission(self, *args, **kwargs):</span><br><span class="line">        if self.request.user.is_superuser: # 管理员才能修改</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def queryset(self):</span><br><span class="line">        qs = super(MachineAdmin, self).queryset()</span><br><span class="line">        if self.request.user.is_superuser:  # 管理员可以查看所有</span><br><span class="line">            return qs</span><br><span class="line">        else:</span><br><span class="line">            # 登录用户只能看到自己修改的数据</span><br><span class="line">            return qs.filter(master_id=self.request.user.last_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xadmin.site.register(MallMachine, MallMachineAdmin)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="61、使用nginx部署项目"><a href="#61、使用nginx部署项目" class="headerlink" title="61、使用nginx部署项目"></a>61、使用nginx部署项目</h2><p>先在/etc/nginx/sites-available中创建一个配置文件，文件名为test(注意没有后缀):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#设定虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen 80;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        #定义使用 www.nginx.cn访问</span><br><span class="line">#ssl on;</span><br><span class="line">        server_name  xxx.xxx.com;</span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root /root/项目名称;</span><br><span class="line">ssl_session_timeout 5m; </span><br><span class="line">        ssl_certificate   /etc/nginx/cert/xxx.pem;</span><br><span class="line">        ssl_certificate_key  /etc/nginx/cert/xxx.key;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        #access_log  logs/nginx.access.log  main;</span><br><span class="line"> </span><br><span class="line">        #默认请求</span><br><span class="line">        location / &#123;</span><br><span class="line">            #倒入了uwsgi的配置</span><br><span class="line">            include uwsgi_params; </span><br><span class="line">    client_max_body_size50m;</span><br><span class="line">            #连接uwsgi的超时时间</span><br><span class="line">           # uwsgi_connect_timeout 30; </span><br><span class="line">     #设定了uwsig服务器位置</span><br><span class="line">     uwsgi_pass 127.0.0.1:8002;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /static&#123;</span><br><span class="line">      alias /root/项目名称/static;</span><br><span class="line">        &#125;</span><br><span class="line">location /media &#123;</span><br><span class="line">alias /root/项目名称/media;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中xxx.xxx.com表示域名.如果没有https，就使用#把ssl注释掉就可以了。</p><p>然后把test映射到/etc/nginx/sites-enabled</p><p>命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/nginx/sites-available/test /etc/nginx/sites-enabled/test</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即可<br>注意：<br>uwsgi中配置listen=1024时，启动uwsgi时可能会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django + uwsgi + nginx 日志Listen queue size is greater than the system max net.core.somaxconn (128).</span><br></pre></td></tr></table></figure><p>解决方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改系统参数</span><br><span class="line"></span><br><span class="line">/proc/sys/net/ipv4/tcp_max_syn_backlog  原来2048    改为8192</span><br><span class="line">/proc/sys/net/core/somaxconn原来128     改为262144</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="62、xadmin后台发送邮件找回密码"><a href="#62、xadmin后台发送邮件找回密码" class="headerlink" title="62、xadmin后台发送邮件找回密码"></a>62、xadmin后台发送邮件找回密码</h2><p><img src="https://img-blog.csdnimg.cn/20190710230444358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>输入你用户绑定的邮箱</p><p><img src="https://img-blog.csdnimg.cn/20190710230454725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>想要发送邮件，需要在settings.py中设置邮件发送器</p><p>settings.py最下面增加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ------------------------邮箱配置-----------------------------------------</span><br><span class="line">EMAIL_BACKEND = &#x27;django.core.mail.backends.smtp.EmailBackend&#x27; #把要发送的邮件显示再控制台上，方便调试</span><br><span class="line">EMAIL_USE_SSL = True</span><br><span class="line">EMAIL_HOST = &#x27;smtp.qq.com&#x27;  # 如果是 163 改成 smtp.163.com</span><br><span class="line">EMAIL_PORT = 465</span><br><span class="line">EMAIL_HOST_USER = &#x27;邮箱账号&#x27; # 帐号</span><br><span class="line">EMAIL_HOST_PASSWORD = &#x27;授权码&#x27;  # 到邮箱里开通</span><br><span class="line">DEFAULT_FROM_EMAIL = EMAIL_HOST_USER</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于django2与xadmin有些地方不兼容，需要修改源码：</p><p>找到虚拟环境根目录\Lib\site-packages\xadmin\plugins\passwords.py</p><p>在passwords.py文件中大概79行，修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">return password_reset_confirm(request=request, uidb36=uidb36, token=token,</span><br><span class="line">                                      template_name=self.password_reset_confirm_template,</span><br><span class="line">                                      token_generator=self.password_reset_token_generator,</span><br><span class="line">                                      set_password_form=self.password_reset_set_form,</span><br><span class="line">                                      post_reset_redirect=self.get_admin_url(&#x27;xadmin_password_reset_complete&#x27;),</span><br><span class="line">                                      current_app=self.admin_site.name, extra_context=context).dispatch(request=request,</span><br><span class="line">                                                                                                        uidb64=uidb36,token=token)</span><br><span class="line">             </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到虚拟环境根目录Lib\site-packages\django\contrib\auth\views.py</p><p>在views.py文件中大概258行，增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 成功后跳转路由,根据自己实际来定</span><br><span class="line">self.success_url = self.request.build_absolute_uri(&#x27;/&#x27;) + &#x27;xadmin/&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020052620533440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="63、xadmin外键下拉框添加过滤"><a href="#63、xadmin外键下拉框添加过滤" class="headerlink" title="63、xadmin外键下拉框添加过滤"></a>63、xadmin外键下拉框添加过滤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MallGoodsAdmin(object):</span><br><span class="line">    &quot;&quot;&quot;商品管理&quot;&quot;&quot;</span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;show_photo&#x27;, &#x27;nickname&#x27;, &#x27;merchant&#x27;, &#x27;goods_class&#x27;, &#x27;label&#x27;,]</span><br><span class="line">    search_fields = [&#x27;nickname&#x27;]</span><br><span class="line">    list_filter = [&#x27;goods_class&#x27;, &#x27;label&#x27;,]</span><br><span class="line">    model_icon = &#x27;fa fa-bars&#x27;</span><br><span class="line">    list_editable = [&#x27;goods_class&#x27;, ]</span><br><span class="line">    #,重写虚拟环境根目录下\Lib\site-packages\xadmin\views\edit.py中的formfield_for_dbfield</span><br><span class="line">    def formfield_for_dbfield(self, db_field, **kwargs):</span><br><span class="line">        # 对MallGoodsClass这个表项的下拉框选择进行过滤</span><br><span class="line">        # MallGoods中有一个goods_class商品分类外键MallGoodsClass，过滤掉外键MallGoodsClass中 </span><br><span class="line">        # master_class为空的值</span><br><span class="line">        if db_field.name == &quot;goods_class&quot;:</span><br><span class="line">            kwargs[&quot;queryset&quot;] = MallGoodsClass.objects.filter(master_class__isnull=False)</span><br><span class="line">            # 对assigned_recipient这个表项的下拉选择进行过滤</span><br><span class="line">        return db_field.formfield(**dict(**kwargs))</span><br><span class="line">        return super().formfield_for_dbfield(db_field, **kwargs)</span><br><span class="line"></span><br><span class="line">xadmin.site.register(models.MallGoods, MallGoodsAdmin)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="64、xadmin即时编辑器去掉空标签"><a href="#64、xadmin即时编辑器去掉空标签" class="headerlink" title="64、xadmin即时编辑器去掉空标签"></a>64、xadmin即时编辑器去掉空标签</h2><p><img src="https://img-blog.csdnimg.cn/20190716151440115.png" alt="在这里插入图片描述"></p><p>虚拟环境根目录下\Lib\site-packages\xadmin\plugins\editable.py，在大概</p><p>129行增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">form.fields[fields[0]].empty_label = None</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190716151459680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="65、用户增加的小组件，让其他用户可见"><a href="#65、用户增加的小组件，让其他用户可见" class="headerlink" title="65、用户增加的小组件，让其他用户可见"></a>65、用户增加的小组件，让其他用户可见</h2><p>找到虚拟环境根目录\Lib\site-packages\xadmin\views\dashboard.py</p><p>在548行、554行</p><p><img src="https://img-blog.csdnimg.cn/20190723175537371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@filter_hook</span><br><span class="line">    def get_widgets(self):</span><br><span class="line"></span><br><span class="line">        if self.widget_customiz:</span><br><span class="line">            portal_pos = UserSettings.objects.filter(</span><br><span class="line">               key=self.get_portal_key())</span><br><span class="line">            if len(portal_pos):</span><br><span class="line">                portal_pos = portal_pos[0].value</span><br><span class="line">                widgets = []</span><br><span class="line"></span><br><span class="line">                if portal_pos:</span><br><span class="line">                    user_widgets = dict([(uw.id, uw) for uw in UserWidget.objects.filter(page_id=self.get_page_id())])</span><br><span class="line">                    for col in portal_pos.split(&#x27;|&#x27;):</span><br><span class="line">                        ws = []</span><br><span class="line">                        for wid in col.split(&#x27;,&#x27;):</span><br><span class="line">                            try:</span><br><span class="line">                                widget = user_widgets.get(int(wid))</span><br><span class="line">                                if widget:</span><br><span class="line">                                    ws.append(self.get_widget(widget))</span><br><span class="line">                            except Exception as e:</span><br><span class="line">                                import logging</span><br><span class="line">                                logging.error(e, exc_info=True)</span><br><span class="line">                        widgets.append(ws)</span><br><span class="line"></span><br><span class="line">                return widgets</span><br><span class="line"></span><br><span class="line">        return self.get_init_widget()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="66、pip-install-uwsgi出错"><a href="#66、pip-install-uwsgi出错" class="headerlink" title="66、pip install uwsgi出错"></a>66、pip install uwsgi出错</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins/python/uwsgi_python.h:2:20: fatal error: Python.h: No such file or directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先安装python3环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install python3-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再虚拟环境中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uwsgi</span><br></pre></td></tr></table></figure><h2 id="66、xadmin后台加载数据慢，解决方案"><a href="#66、xadmin后台加载数据慢，解决方案" class="headerlink" title="66、xadmin后台加载数据慢，解决方案"></a>66、xadmin后台加载数据慢，解决方案</h2><p>list_filter: 过滤器要慎用，不要使用类似id这些数据量大的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MallUserAdmin(object):</span><br><span class="line">    &quot;&quot;&quot;用户管理&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;tp_icon&#x27;, &#x27;nickname&#x27;, &#x27;phone&#x27;, &#x27;level&#x27;, &#x27;balance&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 显示字段</span><br><span class="line">    search_fields = [&#x27;id&#x27;, &#x27;nickname&#x27;, &#x27;phone&#x27;]  # 搜索</span><br><span class="line">    list_filter = [&#x27;level&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 过滤器</span><br><span class="line">    # list_filter = [&#x27;id&#x27;, &#x27;level&#x27;, &#x27;province&#x27;, &#x27;city&#x27;, &#x27;quxian&#x27;]  # 如果加id，xadmin加载回来的数据就会很慢，所以不要在过滤器上使用id</span><br><span class="line">    list_per_page = 30  # 默认每页数量</span><br><span class="line">    model_icon = &#x27;fa fa-users&#x27;  # 左侧图标</span><br><span class="line">    ordering = [&#x27;-id&#x27;]  # 排序</span><br><span class="line">    readonly_fields = [&#x27;subscribe&#x27;, &#x27;wx_openid&#x27;, &#x27;phone&#x27;]  # 只读字段</span><br><span class="line">    is_addbalance = True   # 加载自定义的插件</span><br><span class="line">    relfield_style = &#x27;fk-ajax&#x27;  # 其他表如果外键到用户表就做ajax搜索查询，不一次性加载数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="67-、xadmin导出插件处理，增加导出勾选数据项"><a href="#67-、xadmin导出插件处理，增加导出勾选数据项" class="headerlink" title="67 、xadmin导出插件处理，增加导出勾选数据项"></a>67 、xadmin导出插件处理，增加导出勾选数据项</h2><p>常规的导出只有两个选择【导出表头】、【导出全部数据】</p><p><img src="https://img-blog.csdnimg.cn/20190917141511283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在想要做的是增加一个选择，即【导出表头】、【导出全部数据】、【导出勾选数据】，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20190917141839822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>需要修改xadmin源代码，具体如下</p><h4 id="1、加载js文件"><a href="#1、加载js文件" class="headerlink" title="1、加载js文件"></a>1、加载js文件</h4><p>找到虚拟环境\Lib\site-packages\xadmin\views\list.py，在607行增加’xadmin.plugin.importexport.js’，如下图所示</p><p><img src="https://img-blog.csdnimg.cn/20190917141853832.png" alt="在这里插入图片描述"></p><h4 id="2、修改export-py，后端处理下载文件"><a href="#2、修改export-py，后端处理下载文件" class="headerlink" title="2、修改export.py，后端处理下载文件"></a>2、修改export.py，后端处理下载文件</h4><p>找到虚拟环境\Lib\site-packages\xadmin\plugins\export.py</p><p>在84行把rows = context[‘results’]修改成如下函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 新增导出所选数据</span><br><span class="line"># rows = context[&#x27;results&#x27;]  </span><br><span class="line">rows = []</span><br><span class="line">select_across = self.request.GET.get(&#x27;_select_across&#x27;, False) == &#x27;1&#x27;</span><br><span class="line">selected = self.request.GET.get(&#x27;_selected_actions&#x27;, &#x27;&#x27;)</span><br><span class="line">if self.request.GET.get(&#x27;selected&#x27;, &#x27;off&#x27;) == &#x27;on&#x27;:</span><br><span class="line">    if not select_across:</span><br><span class="line">        selected_pk = selected.split(&#x27;,&#x27;)</span><br><span class="line">        for i in context[&#x27;results&#x27;]:</span><br><span class="line">            if str(i[&#x27;object&#x27;].id) in selected_pk:</span><br><span class="line">                rows.append(i)</span><br><span class="line">    else:</span><br><span class="line">        rows = context[&#x27;results&#x27;]</span><br><span class="line">else:</span><br><span class="line">    rows = context[&#x27;results&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019091714200418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3、 修改model_list.top_toolbar.exports.html<br>找到虚拟环境\Lib\site-packages\xadmin\templates\xadmin\blocks\model_list.top_toolbar.exports.html</p><p>使用以下代码覆盖原文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load i18n %&#125;</span><br><span class="line">&lt;div class=&quot;btn-group export&quot;&gt;</span><br><span class="line">    &lt;a id=&quot;export-menu&quot; class=&quot;dropdown-toggle btn btn-default btn-sm&quot; data-toggle=&quot;dropdown&quot; href=&quot;#&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;fa fa-share&quot;&gt;&lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">    &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dLabel&quot;&gt;</span><br><span class="line">        &#123;% for et in export_types %&#125;</span><br><span class="line">        &lt;li&gt;&lt;a data-toggle=&quot;modal&quot; data-target=&quot;#export-modal-&#123;&#123;et.type&#125;&#125;&quot;&gt;&lt;i class=&quot;fa fa-arrow-circle-down&quot;&gt;</span><br><span class="line">        &lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125; &#123;&#123;et.name&#125;&#125;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">    &#123;% for et in export_types %&#125;</span><br><span class="line">    &lt;div id=&quot;export-modal-&#123;&#123;et.type&#125;&#125;&quot; class=&quot;modal fade&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;modal-dialog&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;modal-content&quot;&gt;</span><br><span class="line">                &lt;form method=&quot;get&quot; action=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;div class=&quot;modal-header&quot;&gt;</span><br><span class="line">                        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt;</span><br><span class="line">                        &lt;h4 class=&quot;modal-title&quot;&gt;&#123;% trans &quot;Export&quot; %&#125; &#123;&#123;et.name&#125;&#125;&lt;/h4&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;modal-body&quot;&gt;</span><br><span class="line">                        &#123;&#123; form_params|safe &#125;&#125;</span><br><span class="line">                        &lt;input type=&quot;hidden&quot; name=&quot;export_type&quot; value=&quot;&#123;&#123;et.type&#125;&#125;&quot;&gt;</span><br><span class="line">                        &lt;!-- 增加 导出所选数据 一栏 --&gt;</span><br><span class="line">                        &lt;input type=&quot;hidden&quot; name=&quot;_selected_actions&quot; value=&quot;&quot;/&gt;</span><br><span class="line">                        &lt;input type=&quot;hidden&quot; name=&quot;_select_across&quot; value=&quot;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;label class=&quot;checkbox&quot;&gt;</span><br><span class="line">                            &#123;% if et.type == &quot;xlsx&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xlsx_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with table header.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                            &#123;% if et.type == &quot;xls&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xls_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with table header.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                            &#123;% if et.type == &quot;csv&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_csv_header&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with table header.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                            &#123;% if et.type == &quot;xml&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_xml_format&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with format.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                            &#123;% if et.type == &quot;json&quot; %&#125;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;export_json_format&quot; checked=&quot;checked&quot; value=&quot;on&quot;&gt;</span><br><span class="line">                            &#123;% trans &quot;Export with format.&quot; %&#125;</span><br><span class="line">                            &#123;% endif %&#125;</span><br><span class="line">                        &lt;/label&gt;</span><br><span class="line">                        &lt;label class=&quot;checkbox&quot;&gt;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;all&quot; value=&quot;on&quot;&gt; &#123;% trans &quot;Export all data.&quot; %&#125;</span><br><span class="line">                        &lt;/label&gt;</span><br><span class="line">                        &lt;!-- 增加 导出所选数据 一栏 --&gt;</span><br><span class="line">                        &lt;label class=&quot;checkbox&quot;&gt;</span><br><span class="line">                            &lt;input type=&quot;checkbox&quot; name=&quot;selected&quot; value=&quot;on&quot;&gt; 导出勾选数据</span><br><span class="line">                        &lt;/label&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;modal-footer&quot;&gt;</span><br><span class="line">                        &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;&#123;% trans &quot;Close&quot; %&#125;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;button class=&quot;btn btn-success myexport  glyphicon glyphicon-export &quot; type=&quot;submit&quot;&gt;&lt;i</span><br><span class="line">                                class=&quot;fa fa-share&quot;&gt;&lt;/i&gt; &#123;% trans &quot;Export&quot; %&#125;</span><br><span class="line">                        &lt;/button&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;&lt;!-- /.modal-content --&gt;</span><br><span class="line">        &lt;/div&gt;&lt;!-- /.modal-dalog --&gt;</span><br><span class="line">    &lt;/div&gt;&lt;!-- /.modal --&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 如果是订单导出，把待出货订单设置成待收货订单</span><br><span class="line">    $(document).ready(function () &#123;</span><br><span class="line">        $(&#x27;.myexport&#x27;).click(function () &#123;</span><br><span class="line">            // 当把订单导出时，需要修改订单状态为待收货状态</span><br><span class="line">            var url = window.location.protocol + &#x27;//&#x27; + window.location.host + &quot;/exportorder/&quot;;</span><br><span class="line">            $(&quot;input[name=&#x27;_select_across&#x27;]&quot;).val($(&quot;input[name=&#x27;select_across&#x27;]&quot;).val());</span><br><span class="line">            if ($(&quot;input[name=&#x27;selected&#x27;]&quot;).is(&#x27;:checked&#x27;)) &#123;</span><br><span class="line">                var arr = [];</span><br><span class="line">                $.each($(&#x27;.action-select&#x27;), function () &#123;</span><br><span class="line">                    if (true == $(this).prop(&#x27;checked&#x27;)) &#123;</span><br><span class="line">                        arr.push($(this).val());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                if(arr.length == 0)&#123;</span><br><span class="line">                    alert(&#x27;请先勾选导出数据&#x27;)</span><br><span class="line">                    return false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                var arr = []</span><br><span class="line">                var order_type = $(&#x27;.breadcrumb li&#x27;).eq(1).text().trim()</span><br><span class="line">                $(&#x27;.grid-item&#x27;).each(function (index, el) &#123;</span><br><span class="line"></span><br><span class="line">                    arr.push($(el).find(&#x27;td&#x27;).eq(1).text().trim())</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            if (($(&#x27;.breadcrumb &gt; li&#x27;).eq(1).text()).indexOf(&#x27;订单&#x27;) != -1) &#123;</span><br><span class="line">                // 5秒后执行</span><br><span class="line">                setTimeout(function () &#123;</span><br><span class="line">                    $.ajax(&#123;</span><br><span class="line">                        type: &quot;POST&quot;,</span><br><span class="line">                        url: url,</span><br><span class="line">                        data: &#123;&#x27;orderlist&#x27;: JSON.stringify(arr), &#x27;order_type&#x27;: order_type,&#125;,</span><br><span class="line">                        beforeSend: function (xhr) &#123;</span><br><span class="line">                            xhr.setRequestHeader(&quot;X-CSRFToken&quot;, $.getCookie(&quot;csrftoken&quot;))</span><br><span class="line">                        &#125;,</span><br><span class="line">                        success: function (data) &#123;</span><br><span class="line">                            window.location.reload();</span><br><span class="line">                        &#125;,</span><br><span class="line">                        error: function (xhr) &#123;</span><br><span class="line">                            alert(&quot;出现未知错误&quot;);</span><br><span class="line">                            window.location.reload();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;, 5000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="68、使用F查询更新用户重要数据"><a href="#68、使用F查询更新用户重要数据" class="headerlink" title="68、使用F查询更新用户重要数据"></a>68、使用F查询更新用户重要数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import F</span><br><span class="line"># 使用F查询更新用户余额</span><br><span class="line">balance = 5  </span><br><span class="line">MallUser.objects.filter(id=1).update(balance=F(&#x27;balance&#x27;) + balance)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相当于sql的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update Malluser set balance=balance + 5 where id=1;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="69、日志输出模块"><a href="#69、日志输出模块" class="headerlink" title="69、日志输出模块"></a>69、日志输出模块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import platform</span><br><span class="line"># 全局函数</span><br><span class="line">PlATFORM = platform.system()</span><br><span class="line">if (PlATFORM == &quot;Linux&quot;):</span><br><span class="line">    # linux系统,文件保存在var下</span><br><span class="line">    SERVER_LOG_PATH = &#x27;/var/mylog.log&#x27;</span><br><span class="line">else:</span><br><span class="line">    # windows系统,文件保存在D盘下</span><br><span class="line">    SERVER_LOG_PATH = &#x27;D:\mylog.log&#x27;</span><br><span class="line"># 定义一个logging的对象，命名为mylog</span><br><span class="line">LOGGER = logging.getLogger(&#x27;mylog&#x27;)</span><br><span class="line"># 设置级别为WARNING</span><br><span class="line">LOGGER.setLevel(logging.WARNING)</span><br><span class="line"># 创建一个handler，用于写入日志文件</span><br><span class="line">fh = logging.FileHandler(SERVER_LOG_PATH, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">fh.setLevel(logging.WARNING)</span><br><span class="line"># 定义handler的输出格式</span><br><span class="line">formatter = logging.Formatter(&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;, datefmt=&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line"># 给Logger添加handler</span><br><span class="line">LOGGER.addHandler(fh)</span><br><span class="line"># 不在控制台显示</span><br><span class="line">LOGGER.propagate = False</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="70、字典排序"><a href="#70、字典排序" class="headerlink" title="70、字典排序"></a>70、字典排序</h2><p>字典在内存中发布是无序的，当想对键值或者键名进行排序时可以先把字典转成元组，这可以达到排序的目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">score = &#123;&#x27;小明&#x27;: &#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90, &#125;,</span><br><span class="line">     &#x27;小红&#x27;: &#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59, &#125;,</span><br><span class="line">     &#x27;小黑&#x27;: &#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70, &#125;,</span><br><span class="line">     &#x27;小白&#x27;: &#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80, &#125;,</span><br><span class="line">     &#125;</span><br><span class="line"># 对姓名进行排序，即对键名进行排序</span><br><span class="line">b = sorted(score.items(), key=lambda x: x[0], reverse=True)</span><br><span class="line">show_str = &#x27;&#x27;</span><br><span class="line">for info in b:</span><br><span class="line">    # print(info)</span><br><span class="line">    key, value = info[0], info[1]</span><br><span class="line">    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\r\n&#x27;</span><br><span class="line">print(&#x27;对姓名进行排序&#x27;)</span><br><span class="line">print(show_str)</span><br><span class="line"># 对平均分进行排序</span><br><span class="line">b = sorted(score.items(), key=lambda x: x[1][&#x27;avg_score&#x27;], reverse=True)</span><br><span class="line">show_str = &#x27;&#x27;</span><br><span class="line">for info in b:</span><br><span class="line">    # print(info)</span><br><span class="line">    key, value = info[0], info[1]</span><br><span class="line">    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\r\n&#x27;</span><br><span class="line">print(&#x27;对平均分进行排序&#x27;)</span><br><span class="line">print(show_str)</span><br><span class="line"></span><br><span class="line"># 对英语成绩进行排序</span><br><span class="line">b = sorted(score.items(), key=lambda x: x[1][&#x27;English&#x27;], reverse=True)</span><br><span class="line">show_str = &#x27;&#x27;</span><br><span class="line">for info in b:</span><br><span class="line">    # print(info)</span><br><span class="line">    key, value = info[0], info[1]</span><br><span class="line">    show_str += &#x27;姓名：&#123;&#125;,平均分：&#123;&#125;，成绩：&#123;&#125;&#x27;.format(key,value[&#x27;avg_score&#x27;], value) + &#x27;\r\n&#x27;</span><br><span class="line">print(&#x27;对英语成绩进行排序&#x27;)</span><br><span class="line">print(show_str)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">对姓名进行排序</span><br><span class="line">姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;</span><br><span class="line">姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;</span><br><span class="line">姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;</span><br><span class="line">姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;</span><br><span class="line"></span><br><span class="line">对平均分进行排序</span><br><span class="line">姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;</span><br><span class="line">姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;</span><br><span class="line">姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;</span><br><span class="line">姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;</span><br><span class="line"></span><br><span class="line">对英语成绩进行排序</span><br><span class="line">姓名：小白,平均分：80，成绩：&#123;&#x27;avg_score&#x27;: 80, &#x27;English&#x27;: 95, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 80&#125;</span><br><span class="line">姓名：小明,平均分：90，成绩：&#123;&#x27;avg_score&#x27;: 90, &#x27;English&#x27;: 90, &#x27;Math&#x27;: 90, &#x27;Chniese&#x27;: 90&#125;</span><br><span class="line">姓名：小黑,平均分：70，成绩：&#123;&#x27;avg_score&#x27;: 70, &#x27;English&#x27;: 75, &#x27;Math&#x27;: 65, &#x27;Chniese&#x27;: 70&#125;</span><br><span class="line">姓名：小红,平均分：60，成绩：&#123;&#x27;avg_score&#x27;: 60, &#x27;English&#x27;: 60, &#x27;Math&#x27;: 61, &#x27;Chniese&#x27;: 59&#125;</span><br></pre></td></tr></table></figure><h3 id="对列表中字典按多个键值排序"><a href="#对列表中字典按多个键值排序" class="headerlink" title="对列表中字典按多个键值排序"></a>对列表中字典按多个键值排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from operator import itemgetter</span><br><span class="line">data = [</span><br><span class="line">    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 300, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 2, &#x27;position&#x27;: 255, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 3, &#x27;position&#x27;: 256, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 500, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 5, &#x27;position&#x27;: 455, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 322, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;code&#x27;: 6, &#x27;position&#x27;: 676, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;,</span><br><span class="line">]</span><br><span class="line">data = sorted(data, key=itemgetter(&#x27;code&#x27;, &#x27;position&#x27;))</span><br><span class="line"></span><br><span class="line">print(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 300, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 322, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 1, &#x27;position&#x27;: 500, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 2, &#x27;position&#x27;: 255, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 3, &#x27;position&#x27;: 256, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 5, &#x27;position&#x27;: 455, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;, </span><br><span class="line">&#123;&#x27;code&#x27;: 6, &#x27;position&#x27;: 676, &#x27;time&#x27;: &#x27;1620442242&#x27;&#125;]</span><br></pre></td></tr></table></figure><h2 id="71、时间格式与字符串互转、比较大小"><a href="#71、时间格式与字符串互转、比较大小" class="headerlink" title="71、时间格式与字符串互转、比较大小"></a>71、时间格式与字符串互转、比较大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># 当前时间转字符串</span><br><span class="line">now = datetime.datetime.strftime(datetime.datetime.now(), &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line"># 字符串转时间格式</span><br><span class="line">now = datetime.datetime.strptime(now, &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">a = now + datetime.timedelta(minutes=-15)</span><br><span class="line"># 时间比较大小</span><br><span class="line">if a &lt; now:</span><br><span class="line">    print(&#x27;yes&#x27;)</span><br></pre></td></tr></table></figure><h2 id="72、python把’-u’开头的字符串转中文"><a href="#72、python把’-u’开头的字符串转中文" class="headerlink" title="72、python把’\u’开头的字符串转中文"></a>72、python把’\u’开头的字符串转中文</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str_data = &#x27;\\u7528\\u6237 ID \\u6216\\u5bc6\\u7801\\u9519\\u8bef&#x27;</span><br><span class="line"># 字符串.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode_escape&#x27;)</span><br><span class="line">str_data_to_zh = str_data.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode_escape&#x27;)</span><br><span class="line">print(str_data_to_zh)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">用户 ID 或密码错误</span><br></pre></td></tr></table></figure><h2 id="73、django进行数据迁移时出现No-changes-detected解决方案"><a href="#73、django进行数据迁移时出现No-changes-detected解决方案" class="headerlink" title="73、django进行数据迁移时出现No changes detected解决方案"></a>73、django进行数据迁移时出现No changes detected解决方案</h2><p>原因：可能是由于app下面没有migrations文件夹<br>所以需要创建这个文件夹，命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations --empty 你的app名称</span><br></pre></td></tr></table></figure><h2 id="74、ubuntu下载文件到windows桌面"><a href="#74、ubuntu下载文件到windows桌面" class="headerlink" title="74、ubuntu下载文件到windows桌面"></a>74、ubuntu下载文件到windows桌面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install lrzsz</span><br><span class="line">sz 123.txt</span><br></pre></td></tr></table></figure><h2 id="75、git查看提交日志"><a href="#75、git查看提交日志" class="headerlink" title="75、git查看提交日志"></a>75、git查看提交日志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;ldc&quot;</span><br></pre></td></tr></table></figure><h2 id="76、python翻译模块"><a href="#76、python翻译模块" class="headerlink" title="76、python翻译模块"></a>76、python翻译模块</h2><p>可以把英文翻译成中文，也可以把中文翻译成英文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pip install  translate</span><br><span class="line"></span><br><span class="line">from translate import Translator</span><br><span class="line"></span><br><span class="line">name = &#x27;giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca&#x27;</span><br><span class="line">translator = Translator(to_lang=&quot;chinese&quot;)</span><br><span class="line">translation = translator.translate(name)</span><br><span class="line">print(translation)</span><br><span class="line"></span><br><span class="line">translator= Translator(from_lang=&quot;chinese&quot;,to_lang=&quot;english&quot;)</span><br><span class="line">translation = translator.translate(&quot;我想你&quot;)</span><br><span class="line">print(translation)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">大熊猫，熊猫，熊猫熊，浣熊，大熊猫</span><br><span class="line">I missed you.</span><br></pre></td></tr></table></figure><h2 id="77、python实现字符串转字典"><a href="#77、python实现字符串转字典" class="headerlink" title="77、python实现字符串转字典"></a>77、python实现字符串转字典</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import ast</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">target_str = &#x27;&#123;&quot;h&quot;: 1, &quot;e&quot;: 2, &quot;l&quot;: 3, &quot;l&quot;: 4, &quot;o&quot;: 5&#125;&#x27;</span><br><span class="line">target_str2 = &quot;&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 3, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 方式1：使用json，缺点，字符串中不能出现单引号</span><br><span class="line"># 由于 json 语法规定 数组或对象之中的字符串必须使用双引号，不能使用单引号</span><br><span class="line"># 官网https://www.json.org/json-en.html上有一段描述是</span><br><span class="line"># A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes</span><br><span class="line">print(json.loads(target_str))</span><br><span class="line"># print(json.loads(target_str2))   # 使用json转这个字符串会报错 Expecting property name enclosed in double quotes</span><br><span class="line"></span><br><span class="line"># 方式2：使用eval函数，缺点，不安全</span><br><span class="line">print(eval(target_str))</span><br><span class="line">print(eval(target_str2))</span><br><span class="line"># print(eval(&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;))  # 会列出当前的目录文件，如果字符串是一些删除命令，则可以把整个目录清空！</span><br><span class="line"></span><br><span class="line"># 方式3，使用ast.literal_eval，没有json与eval的缺点，推荐使用这个</span><br><span class="line">print(ast.literal_eval(target_str))</span><br><span class="line">print(ast.literal_eval(target_str2))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br><span class="line">&#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 2, &#x27;l&#x27;: 4, &#x27;o&#x27;: 5&#125;</span><br></pre></td></tr></table></figure><h2 id="78、django-app-如何在后台显示中文名"><a href="#78、django-app-如何在后台显示中文名" class="headerlink" title="78、django app 如何在后台显示中文名"></a>78、django app 如何在后台显示中文名</h2><p>1.在app (这里以user为例)下面的<strong>init</strong>.py文件中</p><p>添加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_app_config = &#x27;user.apps.UserConfig&#x27;</span><br></pre></td></tr></table></figure><p>2.在apps.py中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.apps import AppConfig</span><br><span class="line"></span><br><span class="line">class UserConfig(AppConfig):</span><br><span class="line">    name = &#x27;user&#x27;</span><br><span class="line">    verbose_name = &#x27;用户&#x27;</span><br></pre></td></tr></table></figure><h2 id="79、使用python给Excel指定行添加数据"><a href="#79、使用python给Excel指定行添加数据" class="headerlink" title="79、使用python给Excel指定行添加数据"></a>79、使用python给Excel指定行添加数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import openpyxl, sys</span><br><span class="line"></span><br><span class="line">wb = openpyxl.load_workbook(&#x27;b.xlsx&#x27;)</span><br><span class="line">sheet = wb[&#x27;Sheet1&#x27;]</span><br><span class="line"></span><br><span class="line"># 在excel表格第二行添加新数据</span><br><span class="line">addrow = 1   # 增加一行</span><br><span class="line">row = 2  # 在第二行新增一行</span><br><span class="line">name = &#x27;b-back.xlsx&#x27; # 新的表名</span><br><span class="line"></span><br><span class="line">wb1 = openpyxl.Workbook()</span><br><span class="line">sheet1 = wb1[&#x27;Sheet&#x27;]</span><br><span class="line"></span><br><span class="line"># 复制前row行</span><br><span class="line">for i in range(1, row):</span><br><span class="line">    for j in range(1, sheet.max_column + 1):</span><br><span class="line">        sheet1.cell(row=i, column=j).value = sheet.cell(row=i, column=j).value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 复制后row行</span><br><span class="line">for i in range(row, sheet.max_row + 1):</span><br><span class="line">    for j in range(1, sheet.max_column + 1):</span><br><span class="line">        if i == row:</span><br><span class="line">            # 给第row行添加新的数据</span><br><span class="line">            sheet1.cell(row=row, column=j).value = &#x27;新增&#x27;</span><br><span class="line">        sheet1.cell(row=i + addrow, column=j).value = sheet.cell(row=i, column=j).value</span><br><span class="line"></span><br><span class="line">wb1.save(name)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200526120005871.png" alt="在这里插入图片描述"></p><h2 id="80、python中的format格式拼接字符串"><a href="#80、python中的format格式拼接字符串" class="headerlink" title="80、python中的format格式拼接字符串"></a>80、python中的format格式拼接字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 5&#125;</span><br><span class="line"></span><br><span class="line">print(&#x27;&#123;a&#125;,&#123;b&#125;&#x27;.format(**d))</span><br><span class="line">print(&#x27;&#123;0&#125;,&#123;1&#125;,&#123;0&#125;&#x27;.format(&#x27;a&#x27;, &#x27;b&#x27;))</span><br><span class="line">print(f&quot;&#123;d[&#x27;a&#x27;]&#125;&quot;)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2</span><br><span class="line">a,b,a</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="81、数据库inner-join、full-join、left-join、union、union-all区别"><a href="#81、数据库inner-join、full-join、left-join、union、union-all区别" class="headerlink" title="81、数据库inner join、full join、left join、union、union all区别"></a>81、数据库inner join、full join、left join、union、union all区别</h2><p>表a_test</p><p><img src="https://img-blog.csdnimg.cn/20200529102527295.png#pic_center" alt="在这里插入图片描述"></p><p>表b_test</p><p><img src="https://img-blog.csdnimg.cn/20200529102549669.png#pic_center" alt="在这里插入图片描述"></p><p>INNER JOIN</p><p>是A和B的交集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test INNER JOIN b_test ON a_test.name = b_test.namesa</span><br><span class="line"></span><br><span class="line">Inner join 产生的结果集中，是A和B的交集。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102631494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>FULL OUTER JOIN</p><p>产生A和B的并集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test FULL OUTER JOIN b_test ON a_test.name = b_test.name </span><br><span class="line"></span><br><span class="line">Full outer join 产生A和B的并集。</span><br><span class="line">但是需要注意的是，对于没有匹配的记录，则会以null做为值。</span><br><span class="line">可以使用IF NULL判断。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102702865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test FULL OUTER JOIN b_test ON a_test.name = b_test.name</span><br><span class="line">WHERE a_test.id IS null OR b_test.id IS null</span><br><span class="line"></span><br><span class="line">产生A表和B表没有交集的数据集。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102724731.png#pic_center" alt="在这里插入图片描述"></p><p>LEFT [OUTER] JOIN</p><p>产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test LEFT OUTER JOIN b_test ON a_test.name = b_test.name</span><br><span class="line">有些数据库可以不要OUTER</span><br><span class="line">SELECT * FROM a_test LEFT  JOIN b_test ON a_test.name = b_test.name</span><br><span class="line">Left outer join 产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102808618.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM a_test LEFT OUTER JOIN b_test ON a_test.name = b_test.name </span><br><span class="line">WHERE b_test.id IS null</span><br><span class="line"></span><br><span class="line">产生在A表中有而在B表中没有的集合。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102828846.png#pic_center" alt="在这里插入图片描述"></p><p>RIGHT [OUTER] JOIN</p><p>RIGHT OUTER JOIN 是后面的表为基础，与LEFT OUTER JOIN用法类似。</p><p>UNION 与 UNION ALL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</span><br><span class="line">请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。</span><br><span class="line">列也必须拥有相似的数据类型。</span><br><span class="line">同时，每条 SELECT 语句中的列的顺序必须相同。</span><br><span class="line">UNION 只选取记录，而UNION ALL会列出所有记录。</span><br><span class="line"></span><br><span class="line">SELECT name FROM a_test UNION SELECT name FROM b_test</span><br><span class="line"></span><br><span class="line">选取不同值</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102855430.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT a_test.id,a_test.name  FROM a_test </span><br><span class="line">UNION </span><br><span class="line">SELECT b_test.id,b_test.name FROM b_test</span><br><span class="line"></span><br><span class="line">由于 id 51 xh   与 id 4 xh 并不相同，不合并</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102917488.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM a_test UNION ALL SELECT name FROM b_test</span><br><span class="line"></span><br><span class="line">全部列出来</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200529102937801.png#pic_center" alt="在这里插入图片描述"></p><p>还需要注意的是我们还有一个是“交差集” cross join, 这种Join没有办法用文式图表示，因为其就是把表A和表B的数据进行一个N*M的组合，即笛卡尔积。</p><p>表达式如下：SELECT * FROM a_test CROSS JOIN b_test</p><p>这个笛卡尔乘积会产生 4 x 4 = 16 条记录，一般来说，我们很少用到这个语法。但是我们得小心，如果不是使用嵌套的select语句，一般系统都会产生笛卡尔乘积然再做过滤。这是对于性能来说是非常危险的，尤其是表很大的时候。</p><h2 id="82、windows电脑查看端口使用情况"><a href="#82、windows电脑查看端口使用情况" class="headerlink" title="82、windows电脑查看端口使用情况"></a>82、windows电脑查看端口使用情况</h2><p>找出8000端口对应的PID进程，命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano|findstr 8000</span><br></pre></td></tr></table></figure><p>进程信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP    0.0.0.0:8000           0.0.0.0:0              LISTENING       1620</span><br><span class="line">UDP    0.0.0.0:8000           *:*                                    1620</span><br></pre></td></tr></table></figure><p>找出进程对应的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasklist |findstr 1620</span><br><span class="line"></span><br><span class="line">KGService.exe                 1620 Console                    1     18,696 K</span><br></pre></td></tr></table></figure><p>关进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /pid 1620 /F</span><br></pre></td></tr></table></figure><p>查看程序占用内存<br>比如查看python占用运行内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist  /fi &quot;imagename eq python.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a61afd069e964e6f9d755c5c1884ca6f.png" alt="在这里插入图片描述"></p><h2 id="83、Django生成表和反向生成Model"><a href="#83、Django生成表和反向生成Model" class="headerlink" title="83、Django生成表和反向生成Model"></a>83、Django生成表和反向生成Model</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正向生成：</span><br><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line"></span><br><span class="line">反向：</span><br><span class="line">会根据设置的数据库中的表在自动生成对应的Model代码，并打印出来</span><br><span class="line">python manage.py inspectdb</span><br><span class="line"></span><br><span class="line">以直接将打印的代码直接导入到指定的Model文件中</span><br><span class="line">python manage.py inspectdb &gt; models.py</span><br></pre></td></tr></table></figure><h2 id="84、windows的hosts文件位置"><a href="#84、windows的hosts文件位置" class="headerlink" title="84、windows的hosts文件位置"></a>84、windows的hosts文件位置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><h2 id="85、postgresql数据库"><a href="#85、postgresql数据库" class="headerlink" title="85、postgresql数据库"></a>85、postgresql数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"># 如果表存在就先删除</span><br><span class="line">drop table if exists student;</span><br><span class="line"># 创建学生表</span><br><span class="line"># id      serial not null  表示id自增</span><br><span class="line"># id      integer not null  表示id不自增</span><br><span class="line">create table student</span><br><span class="line">(</span><br><span class="line">    id                    serial not null</span><br><span class="line">        constraint student_pk</span><br><span class="line">            primary key,</span><br><span class="line">    name                  varchar,</span><br><span class="line">    class_id              integer,</span><br><span class="line">    height                numeric,</span><br><span class="line">    weight                numeric,</span><br><span class="line">    write_date            timestamp</span><br><span class="line">    </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">comment on table student is &#x27;学生表&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.name is &#x27;名称&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.class_id is &#x27;班级ID&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.height is &#x27;身高&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.weight is &#x27;体重&#x27;;</span><br><span class="line"></span><br><span class="line">comment on column student.write_date is &#x27;修改时间&#x27;;</span><br><span class="line"></span><br><span class="line">alter table student</span><br><span class="line">    owner to odoo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 更新</span><br><span class="line">update user set name=&#x27;张三&#x27; where id=111</span><br><span class="line"></span><br><span class="line"># 更新表a的字段为表b的值</span><br><span class="line">update account_invoice </span><br><span class="line">set sale_order_id=so.id </span><br><span class="line">from sale_order so </span><br><span class="line">where account_invoice.origin=so.name</span><br><span class="line"></span><br><span class="line"># 新增</span><br><span class="line">insert into &quot;user&quot; (name,sex) values (&#x27;小明&#x27;,1),(&#x27;小红&#x27;, 0)</span><br><span class="line"># 新增或更新</span><br><span class="line">如果id冲突就更新</span><br><span class="line">INSERT INTO  student(id, name)</span><br><span class="line">   VALUES(12, &#x27;小明&#x27;),(13, &#x27;小红&#x27;)</span><br><span class="line">   ON conflict(id) DO UPDATE</span><br><span class="line">   SET name =&#x27;未知&#x27;;</span><br><span class="line">如果id冲突就什么也不做</span><br><span class="line">INSERT INTO  student(id, name)</span><br><span class="line">   VALUES(12, &#x27;小明&#x27;),(13, &#x27;小红&#x27;)</span><br><span class="line">   ON conflict(id) DO NOTHING;</span><br><span class="line"></span><br><span class="line"># 把一个表中的数据插入到另一个表中</span><br><span class="line">insert into 目标表名 (column1,column2,columnn) select value1,value2,valuen from  源表名</span><br><span class="line">比如：</span><br><span class="line">insert into student (name, classs_name,create_date) select  student_name as name, class_name, now() from class_table;</span><br><span class="line"></span><br><span class="line"># 获取当前时间</span><br><span class="line">now()</span><br><span class="line">select now()</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">DELETE FROM table_name [WHERE Clause]</span><br><span class="line"></span><br><span class="line"># 增加字段</span><br><span class="line">alter table 表名 add column 列名 类型;</span><br><span class="line"># 删除字段</span><br><span class="line">alter table 表名 dropcolumn 列名 ;</span><br><span class="line"></span><br><span class="line"># postgresql数据库查看表所有字段</span><br><span class="line">select * from information_schema.columns where table_schema=&#x27;public&#x27; and table_name=&#x27;表名&#x27;;</span><br><span class="line"></span><br><span class="line"># postgresql获取所有表名</span><br><span class="line">select tablename from pg_tables where schemaname=&#x27;public&#x27;</span><br><span class="line"></span><br><span class="line"># 对查询结果按id降序显示</span><br><span class="line">select * from table_name order by id desc</span><br><span class="line"></span><br><span class="line"># 对查询结果按id升序显示</span><br><span class="line">select * from table_name order by id asc</span><br><span class="line"></span><br><span class="line"># 转义字符, 查找name中包含单引号的记录</span><br><span class="line">select * from student where name like  E&#x27;%\&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line"># 查看表记录总数</span><br><span class="line">select relname as TABLE_NAME, reltuples as rowCounts from pg_class where relkind = &#x27;r&#x27; and relnamespace = (select oid from pg_namespace where nspname=&#x27;public&#x27;) order by rowCounts desc;</span><br><span class="line"></span><br><span class="line"># 将结果转换为数组</span><br><span class="line">SELECT array(SELECT &quot;name&quot; FROM sale_order);</span><br><span class="line"></span><br><span class="line"># 将数组合并为字符串</span><br><span class="line">select array_to_string(array[1,2,3], &#x27;,&#x27;)</span><br><span class="line"></span><br><span class="line"># 联合子集更新，把sale_order_line的name连接换行符，然后按id更新到表a_test中对应的name</span><br><span class="line">update a_test set name=array_to_string(array(select name from sale_order_line where order_id=a_test.id),&#x27;&lt;br/&gt;&#x27;);</span><br><span class="line"></span><br><span class="line"># PostgreSQL合并查询同一列的多条记录，针对一对多，多对多字段</span><br><span class="line">比如表：</span><br><span class="line"></span><br><span class="line">id   name                  </span><br><span class="line">1    小明                   </span><br><span class="line">1    小红                     id   name</span><br><span class="line">1    小亮        --&gt;          1    小明，小亮，小红</span><br><span class="line">2    小强                     2    小强，小王</span><br><span class="line">2    小王</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">    id, array_to_string(ARRAY(SELECT unnest(array_agg(name order by name desc))),&#x27;,&#x27;) AS all_name</span><br><span class="line">FROM  </span><br><span class="line">    student</span><br><span class="line">GROUP BY id;</span><br><span class="line"></span><br><span class="line"># case语句</span><br><span class="line">case var</span><br><span class="line">when condition1 then statement1</span><br><span class="line">when condition2 then statement2</span><br><span class="line">else statementn</span><br><span class="line">end as new_name</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">select case name</span><br><span class="line">when &#x27;小明&#x27; then &#x27;xm&#x27;</span><br><span class="line">when &#x27;小红&#x27; then &#x27;xh&#x27;</span><br><span class="line">when &#x27;小刚&#x27; then &#x27;xg&#x27;</span><br><span class="line">else &#x27;xw&#x27;</span><br><span class="line">end as short_name</span><br><span class="line">from student</span><br><span class="line"></span><br><span class="line"># 临时表、字符串合并、类型转换、时间格式转换、当前时间</span><br><span class="line">WITH TEMP AS ( </span><br><span class="line">SELECT CAST ( concat ( bam.account_period_code, &#x27;-01&#x27; ) AS TIMESTAMP ) </span><br><span class="line">   AS account_period_time </span><br><span class="line"> FROM bi_account_move AS bam ) </span><br><span class="line">SELECT</span><br><span class="line">account_period_time,</span><br><span class="line">to_char(CURRENT_DATE,&#x27;yyyy-MM-dd hh24:MI:ss&#x27;) as current_date,</span><br><span class="line">to_char( account_period_time, &#x27;yyyy&#x27; ) as year,</span><br><span class="line">to_char( account_period_time, &#x27;MM&#x27; ) as month,</span><br><span class="line">to_char( account_period_time, &#x27;dd&#x27; ) as day </span><br><span class="line">FROM TEMP</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">account_period_timecurrent_date    yearmonthday</span><br><span class="line">2019-06-01 0:00:002020-06-24 00:00:002019 06     01</span><br><span class="line">2019-06-01 0:00:002020-06-24 00:00:002019 06     01</span><br><span class="line"></span><br><span class="line"># 多个字符串拼接</span><br><span class="line">select </span><br><span class="line">concat(&#x27;payment_&#x27;, CAST(ap.id as varchar)) as line_key</span><br><span class="line">from ap</span><br><span class="line"></span><br><span class="line"># 将查询所得结果集的某一字段拼接成字符串，默认的是逗号</span><br><span class="line">select GROUP_CONCAT(id) from test where id&gt;5;</span><br><span class="line">结果为：</span><br><span class="line">1,2,3,4,5,6,7</span><br><span class="line"># 使用其他分隔符拼接</span><br><span class="line">select GROUP_CONCAT(id separator &#x27;-&#x27;) from test where id&gt;5;</span><br><span class="line">结果为：</span><br><span class="line">1-2-3-4-5-6-7</span><br><span class="line"># 多个临时表</span><br><span class="line">WITH temp_student AS ( SELECT ID, NAME, sex FROM student WHERE sex = TRUE ),</span><br><span class="line">temp_class AS (</span><br><span class="line">SELECT</span><br><span class="line">ID,</span><br><span class="line">NAME,</span><br><span class="line">student_id,</span><br><span class="line">teacher_id</span><br><span class="line">FROM</span><br><span class="line">the_class </span><br><span class="line">),</span><br><span class="line">temp_teacher AS (</span><br><span class="line">SELECT </span><br><span class="line">  ID,</span><br><span class="line">NAME,</span><br><span class="line">age </span><br><span class="line">FROM</span><br><span class="line">teacher </span><br><span class="line">) </span><br><span class="line">SELECT</span><br><span class="line">ts.NAME AS student_name,</span><br><span class="line">tc.NAME AS class_name,</span><br><span class="line">te.NAME AS teacher_name</span><br><span class="line">from temp_student as ts</span><br><span class="line">LEFT JOIN temp_class AS tc ON tc.student_id = ts.ID  </span><br><span class="line">LEFT JOIN teacher AS te ON te.id = tc.teacher_id  </span><br><span class="line"></span><br><span class="line"># null转成有意义的值</span><br><span class="line">select COALESCE(name, &#x27;&#x27;) as name from a_test</span><br><span class="line">意思就是如果name为null，就转为空字符串</span><br><span class="line"></span><br><span class="line"># 字符串截取</span><br><span class="line">select SUBSTRING(&#x27;abcd&#x27;,1,2); -- result:ab 表示从下标从1开始,截取2个字符</span><br><span class="line"></span><br><span class="line"># 使用 interval 时间相加减(+/-)</span><br><span class="line">当前时间 + 10秒，</span><br><span class="line">select to_char(now() + interval &#x27;10 second&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line">当前时间 - 10秒</span><br><span class="line">select to_char(now() + interval &#x27;-10 second&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line"> </span><br><span class="line">当前时间 + 10分，</span><br><span class="line">select to_char(now() + interval &#x27;10 minute&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate  from account_period;</span><br><span class="line"> </span><br><span class="line">当前时间 + 10时，</span><br><span class="line">select to_char(now() + interval &#x27;10 hour&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line"> </span><br><span class="line">当前时间 + 10天，</span><br><span class="line">select to_char(now() + interval &#x27;10 day&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line"></span><br><span class="line">当前时间 + 10年，</span><br><span class="line">select to_char(now() + interval &#x27;10 year&#x27;, &#x27;yyyy-mm-dd hh24:mi:ss&#x27;)  as reqDate from account_period;</span><br><span class="line"></span><br><span class="line"># UNION types numeric and text cannot be matched</span><br><span class="line">NULL::NUMERIC</span><br><span class="line"> 这个问题，是因为几个sql组合在一起时，同一个字段的值，遇到null时，需要进行类型转换。</span><br><span class="line"></span><br><span class="line"># 对行记录定义行编号，使用函数ROW_NUMBER()</span><br><span class="line"># 按分数进行降序，然后给行记录标记行编号，可以作为排名来使用</span><br><span class="line">select           </span><br><span class="line">ROW_NUMBER() OVER (ORDER BY score desc) AS sequence_number,</span><br><span class="line">name,score</span><br><span class="line">from</span><br><span class="line">b_test</span><br><span class="line"></span><br><span class="line"># 数字转字符串  </span><br><span class="line">select cast(123 as VARCHAR); </span><br><span class="line"></span><br><span class="line"># 字符串转数字  </span><br><span class="line">select cast(&#x27;123&#x27; as INTEGER);</span><br></pre></td></tr></table></figure><h2 id="86、python控制台输出带颜色的文字方法"><a href="#86、python控制台输出带颜色的文字方法" class="headerlink" title="86、python控制台输出带颜色的文字方法"></a>86、python控制台输出带颜色的文字方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#格式：　　设置颜色开始 ：\033[显示方式;前景色;背景色m</span><br><span class="line">#说明：</span><br><span class="line">前景色            背景色           颜色</span><br><span class="line">---------------------------------------</span><br><span class="line">30                40              黑色</span><br><span class="line">31                41              红色</span><br><span class="line">32                42              绿色</span><br><span class="line">33                43              黃色</span><br><span class="line">34                44              蓝色</span><br><span class="line">35                45              紫红色</span><br><span class="line">36                46              青蓝色</span><br><span class="line">37                47              白色</span><br><span class="line">显示方式           意义</span><br><span class="line">-------------------------</span><br><span class="line">0                终端默认设置</span><br><span class="line">1                高亮显示</span><br><span class="line">4                使用下划线</span><br><span class="line">5                闪烁</span><br><span class="line">7                反白显示</span><br><span class="line">8                不可见</span><br><span class="line"> </span><br><span class="line">#例子：</span><br><span class="line">\033[1;31;40m    &lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&gt;</span><br><span class="line">\033[0m          &lt;!--采用终端默认设置，即取消颜色设置--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line">print(&#x27;紫红字体 \033[1;35m hello world \033[0m!&#x27;)</span><br><span class="line">print(&#x27;褐色背景绿色字体 \033[1;32;43m hello world \033[0m!&#x27;)</span><br><span class="line">print(&#x27;\033[1;33;44mhello world\033[0m&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200615143709116.png" alt="在这里插入图片描述"></p><h2 id="87、控制台输出白色方框"><a href="#87、控制台输出白色方框" class="headerlink" title="87、控制台输出白色方框"></a>87、控制台输出白色方框</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;█&#x27;)</span><br></pre></td></tr></table></figure><h2 id="88、xadmin后台编辑多对多字段"><a href="#88、xadmin后台编辑多对多字段" class="headerlink" title="88、xadmin后台编辑多对多字段"></a>88、xadmin后台编辑多对多字段</h2><p>在models.py定义了多对多字段，想要在编辑时可以灵活使用这个字段的话，可以按以下方法设置：<br>modes.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    title = models.CharField(verbose_name=&quot;书名&quot;, max_length=32)</span><br><span class="line">    second_title = models.CharField(verbose_name=&quot;副标题&quot;, max_length=32, blank=True, null=True)</span><br><span class="line">    author = models.CharField(verbose_name=&quot;作者&quot;, max_length=32)</span><br><span class="line">    translator = models.CharField(verbose_name=&quot;译者&quot;, max_length=32, blank=True, null=True)</span><br><span class="line">    intro = models.TextField(verbose_name=&quot;描述&quot;)</span><br><span class="line">    pic = models.FileField(verbose_name=&quot;封面图片&quot;, max_length=64, upload_to=&#x27;book_cover&#x27;, null=True, blank=True)</span><br><span class="line">    tags = models.ManyToManyField(Tags, verbose_name=&#x27;书籍标签&#x27;, blank=True)</span><br><span class="line">    prizes = models.ManyToManyField(Prizes, verbose_name=&#x27;获奖详情&#x27;, blank=True)</span><br><span class="line">    sump = models.IntegerField(verbose_name=&quot;收藏人数&quot;, default=0)</span><br><span class="line">    rate_num = models.IntegerField(verbose_name=&quot;评分人数&quot;, default=0)</span><br><span class="line">    num = models.IntegerField(verbose_name=&quot;浏览量&quot;, default=0)</span><br><span class="line">    published_time = models.DateField(blank=True, null=True, verbose_name=&#x27;出版时间&#x27;)</span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=True, verbose_name=&#x27;创建时间&#x27;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &#x27;book&#x27;</span><br><span class="line">        verbose_name = &quot;图书&quot;</span><br><span class="line">        verbose_name_plural = &quot;图书&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br></pre></td></tr></table></figure><p>adminx.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 书籍管理</span><br><span class="line">class BookAdmin(object):</span><br><span class="line">    search_fields = [&#x27;title&#x27;, &#x27;author&#x27;, &#x27;intro&#x27;]  # 检索字段</span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;show_pic&#x27;, &#x27;title&#x27;, &#x27;second_title&#x27;, &#x27;author&#x27;, &#x27;translator&#x27;, &#x27;published_time&#x27;, &#x27;intro&#x27;,</span><br><span class="line">                    &#x27;tags&#x27;, &#x27;prizes&#x27;, &#x27;num&#x27;, &#x27;sump&#x27;, &#x27;rate_num&#x27;]  # 要显示的字段</span><br><span class="line">    list_filter = [&#x27;published_time&#x27;, &#x27;tags&#x27;, &#x27;prizes&#x27;]  # 分组过滤的字段</span><br><span class="line">    ordering = (&#x27;id&#x27;,)  # 设置默认排序字段，负号表示降序排序</span><br><span class="line">    list_per_page = 30  # 默认每页显示多少条记录，默认是100条</span><br><span class="line">    model_icon = &#x27;fa fa-book&#x27;  # 左侧小图标</span><br><span class="line">    list_editable = [&#x27;title&#x27;, &#x27;author&#x27;, &#x27;intro&#x27;, &#x27;published_time&#x27;]  # 可编辑字段</span><br><span class="line">    style_fields = &#123;&#x27;tags&#x27;: &#x27;m2m_transfer&#x27;, &#x27;prizes&#x27;: &#x27;m2m_transfer&#x27;&#125;  # 控制字段的显示样式</span><br><span class="line">    filter_horizontal = (&#x27;tags&#x27;, &#x27;prizes&#x27;)  # 水平选择编辑多对多字段</span><br></pre></td></tr></table></figure><p>重点是设置style_fields 和filter_horizontal ，效果：</p><p><img src="https://img-blog.csdnimg.cn/20200621214122315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="89、Django后台通过按钮显示TextField字段内容"><a href="#89、Django后台通过按钮显示TextField字段内容" class="headerlink" title="89、Django后台通过按钮显示TextField字段内容"></a>89、Django后台通过按钮显示TextField字段内容</h2><p>由于TextField字段类型内容可能很长，在后台显示时很占屏幕位置，可以通过按钮来控制显示，代码如下：<br>models.py中定义了一个TextField字段类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Prizes(models.Model):</span><br><span class="line">    name = models.CharField(max_length=32, verbose_name=&quot;奖项&quot;)</span><br><span class="line">    intro = models.TextField(blank=True, null=True, verbose_name=&#x27;简介&#x27;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table = &#x27;prizes&#x27;</span><br><span class="line">        verbose_name = &quot;奖项&quot;</span><br><span class="line">        verbose_name_plural = &quot;奖项&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br></pre></td></tr></table></figure><p>这里使用xadmin作为后台管理框架，在adminx.py中代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from django.utils.safestring import mark_safe</span><br><span class="line">from xadmin import views</span><br><span class="line"></span><br><span class="line">from .models import *</span><br><span class="line"></span><br><span class="line"># 奖项管理</span><br><span class="line">class PrizesAdmin(object):</span><br><span class="line">    search_fields = [&#x27;name&#x27;]  # 检索字段</span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;show_intro&#x27;]</span><br><span class="line">    list_filter = [&#x27;name&#x27;]</span><br><span class="line">    ordering = (&#x27;id&#x27;,)</span><br><span class="line"></span><br><span class="line">    def show_intro(self, obj):</span><br><span class="line">        # 显示简介</span><br><span class="line">        if not obj.intro:</span><br><span class="line">            return mark_safe(&#x27;&#x27;)</span><br><span class="line">        if len(obj.intro) &lt; 20:</span><br><span class="line">            return mark_safe(obj.intro)</span><br><span class="line"></span><br><span class="line">        short_id = f&#x27;&#123;obj._meta.db_table&#125;_short_text_&#123;obj.id&#125;&#x27;</span><br><span class="line">        short_text_len = len(obj.intro) // 4</span><br><span class="line">        short_text = obj.intro[:short_text_len] + &#x27;......&#x27;</span><br><span class="line">        detail_id = f&#x27;&#123;obj._meta.db_table&#125;_detail_text_&#123;obj.id&#125;&#x27;</span><br><span class="line">        detail_text = obj.intro</span><br><span class="line"></span><br><span class="line">        text = &quot;&quot;&quot;&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">                        #%s,%s &#123;padding:10px;border:1px solid green;&#125; </span><br><span class="line">                  &lt;/style&gt;</span><br><span class="line">                    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    function openShutManager(oSourceObj,oTargetObj,shutAble,oOpenTip,oShutTip,oShortObj)&#123;</span><br><span class="line">                        var sourceObj = typeof oSourceObj == &quot;string&quot; ? document.getElementById(oSourceObj) : oSourceObj;</span><br><span class="line">                        var targetObj = typeof oTargetObj == &quot;string&quot; ? document.getElementById(oTargetObj) : oTargetObj;</span><br><span class="line">                        var shortObj = typeof oShortObj == &quot;string&quot; ? document.getElementById(oShortObj) : oShortObj;</span><br><span class="line">                        var openTip = oOpenTip || &quot;&quot;;</span><br><span class="line">                        var shutTip = oShutTip || &quot;&quot;;</span><br><span class="line">                        if(targetObj.style.display!=&quot;none&quot;)&#123;</span><br><span class="line">                           if(shutAble) return;</span><br><span class="line">                           targetObj.style.display=&quot;none&quot;;</span><br><span class="line">                           shortObj.style.display=&quot;block&quot;;</span><br><span class="line">                           if(openTip  &amp;&amp;  shutTip)&#123;</span><br><span class="line">                            sourceObj.innerHTML = shutTip; </span><br><span class="line">                           &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                           targetObj.style.display=&quot;block&quot;;</span><br><span class="line">                           shortObj.style.display=&quot;none&quot;;</span><br><span class="line">                           if(openTip  &amp;&amp;  shutTip)&#123;</span><br><span class="line">                            sourceObj.innerHTML = openTip; </span><br><span class="line">                           &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;/script&gt;</span><br><span class="line">                    &lt;p id=&quot;%s&quot;&gt;%s&lt;/p&gt;</span><br><span class="line">                    &lt;p&gt;&lt;a href=&quot;###&quot; οnclick=&quot;openShutManager(this,&#x27;%s&#x27;,false,&#x27;点击关闭&#x27;,&#x27;点击展开&#x27;,&#x27;%s&#x27;)&quot;&gt;点击展开&lt;/a&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;p id=&quot;%s&quot; style=&quot;display:none&quot;&gt;</span><br><span class="line">                       %s</span><br><span class="line">                    &lt;/p&gt;</span><br><span class="line">                    &quot;&quot;&quot; % (short_id, detail_id, short_id, short_text, detail_id, short_id, detail_id, detail_text)</span><br><span class="line">        return mark_safe(text)</span><br><span class="line"></span><br><span class="line">    show_intro.short_description = &#x27;描述&#x27;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：复制代码后需要做如下修改：</p><p><img src="https://img-blog.csdnimg.cn/20200815204246956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>一开始效果</p><p><img src="https://img-blog.csdnimg.cn/20200621230038819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击展开效果：<img src="https://img-blog.csdnimg.cn/20200621230120177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="90、前端判断上传的文件是否为图片且限制大小为300kB"><a href="#90、前端判断上传的文件是否为图片且限制大小为300kB" class="headerlink" title="90、前端判断上传的文件是否为图片且限制大小为300kB"></a>90、前端判断上传的文件是否为图片且限制大小为300kB</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en-us&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;body class=&quot;login&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;input class=&quot;form-control input-lg&quot; id=&quot;id_icon&quot; name=&quot;icon&quot; type=&quot;file&quot; onchange=&quot;imgTypeSize(&#x27;id_icon&#x27;,300)&quot;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    //判断是否为图片，若为图片，判断其大小是否大于0.3M</span><br><span class="line">    function imgTypeSize(FileId, maxsize) &#123;</span><br><span class="line">        /*获取图片内容对象*/</span><br><span class="line">        var imgFile = document.getElementById(FileId).files[0];</span><br><span class="line">        if (imgFile.name == &quot;&quot;) &#123;</span><br><span class="line">            alert(&quot;请上传头像哦&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*图片类型正则验证*/</span><br><span class="line">            var imgStr = /\.(jpg|jpeg|png|bmp|BMP|JPG|PNG|JPEG)$/;</span><br><span class="line">            if (!imgStr.test(imgFile.name)) &#123;</span><br><span class="line">                alert(&quot;文件不是图片类型&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /*图片大小*/</span><br><span class="line">                var imagSize = imgFile.size;</span><br><span class="line">                if (imagSize &lt; (1024 * maxsize)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    alert(imgFile.name + &quot;大小不能超过&quot; + maxsize + &quot;kB&quot;);</span><br><span class="line">                    document.getElementById(FileId).value = &quot;&quot;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="91、form表单提交前验证"><a href="#91、form表单提交前验证" class="headerlink" title="91、form表单提交前验证"></a>91、form表单提交前验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot; id=&quot;login-form&quot; onsubmit=&quot;return toVaild()&quot;&gt;</span><br><span class="line">&lt;input class=&quot;form-control&quot; id=&quot;id_account&quot; name=&quot;account&quot; type=&quot;text&quot; placeholder=&quot;账号&quot;/&gt;</span><br><span class="line">&lt;input class=&quot;form-control&quot; id=&quot;id_password&quot; name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot;&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&#x27;id_username&#x27;).focus()</span><br><span class="line"></span><br><span class="line">    function toVaild() &#123;</span><br><span class="line">        var account = document.getElementById(&quot;id_account&quot;).value;</span><br><span class="line">        var password = document.getElementById(&quot;id_password&quot;).value;</span><br><span class="line">        if (account == &quot;&quot; || password == &quot;&quot;) &#123;</span><br><span class="line">            alert(&quot;请输入账号和密码&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="92、有序字典"><a href="#92、有序字典" class="headerlink" title="92、有序字典"></a>92、有序字典</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import collections</span><br><span class="line"></span><br><span class="line">d1 = collections.OrderedDict()  # 创建一个有序字典</span><br><span class="line">d1[&#x27;a&#x27;] = &#x27;A&#x27;</span><br><span class="line">d1[&#x27;b&#x27;] = &#x27;B&#x27;</span><br><span class="line">d1[&#x27;c&#x27;] = &#x27;C&#x27;</span><br><span class="line">d1[&#x27;d&#x27;] = &#x27;D&#x27;</span><br><span class="line">for k, v in d1.items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure><h2 id="93、Python在Windows系统下实现TTS（文字转语音）"><a href="#93、Python在Windows系统下实现TTS（文字转语音）" class="headerlink" title="93、Python在Windows系统下实现TTS（文字转语音）"></a>93、Python在Windows系统下实现TTS（文字转语音）</h2><p>导入包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip install pypiwin32</span><br><span class="line"></span><br><span class="line">import win32com.client</span><br><span class="line">spk = win32com.client.Dispatch(&quot;SAPI.SpVoice&quot;)</span><br><span class="line">spk.Speak(u&quot;my name is ldc,what is your name&quot;)</span><br><span class="line">spk.Speak(u&quot;大家好&quot;)</span><br></pre></td></tr></table></figure><h2 id="94、定义一个简单闹钟"><a href="#94、定义一个简单闹钟" class="headerlink" title="94、定义一个简单闹钟"></a>94、定义一个简单闹钟</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># pip install pypiwin32 -i https://pypi.python.org/simple</span><br><span class="line">import win32com.client</span><br><span class="line">import time </span><br><span class="line">import winsound</span><br><span class="line"></span><br><span class="line">spk = win32com.client.Dispatch(&quot;SAPI.SpVoice&quot;)</span><br><span class="line"># 定义闹钟时间</span><br><span class="line">clocktime = [[19, 19], [11, 10], [12, 10], [18, 47]]  </span><br><span class="line">runinghour = 1  # 定义运行时间</span><br><span class="line">times = runinghour * 3600  # 次数</span><br><span class="line">print(times)</span><br><span class="line">for i in range(1, times):</span><br><span class="line">    time_now = [time.localtime(time.time()).tm_hour, time.localtime(time.time()).tm_min]</span><br><span class="line">    if time_now in clocktime:</span><br><span class="line">        print(time_now)</span><br><span class="line">        winsound.Beep(1000, 1000)</span><br><span class="line">        spk.Speak(u&quot;快去看下饭好了没有？&quot;)</span><br><span class="line">    time.sleep(60)  # 每分钟对比一次时间</span><br></pre></td></tr></table></figure><h2 id="95、根据年月获取当月天数"><a href="#95、根据年月获取当月天数" class="headerlink" title="95、根据年月获取当月天数"></a>95、根据年月获取当月天数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def get_month_days(year, month):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据年份，月份信息显示此月份天数</span><br><span class="line">    :param year: 年份：</span><br><span class="line">    :param month: 月份（1～12）：</span><br><span class="line">    :return: 当月天数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if month &gt;12 or month &lt;= 0:</span><br><span class="line">        return -1</span><br><span class="line">    if month == 2:</span><br><span class="line">        return 29 if year % 4 == 0 and year % 100 != 0 or year % 400 == 0 else 28</span><br><span class="line"></span><br><span class="line">    if month in (4, 6, 9, 11):</span><br><span class="line">        return 30</span><br><span class="line">    else:</span><br><span class="line">        return 31</span><br><span class="line"></span><br><span class="line">a = &#x27;2020-04&#x27;.split(&#x27;-&#x27;)</span><br><span class="line">year = int(a[0])</span><br><span class="line">month = int(a[1])</span><br><span class="line">print(get_month_days(year,month))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="96、Django获取favicon-ico图标"><a href="#96、Django获取favicon-ico图标" class="headerlink" title="96、Django获取favicon.ico图标"></a>96、Django获取favicon.ico图标</h2><p>制作一个ico文件，使用PS或者某些在线生成ico的网站</p><p>将此文件命名为“favicon.ico”后放在static/下</p><p><img src="https://img-blog.csdnimg.cn/20200805104730363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在urls.py中定义路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from django.views.generic import RedirectView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"># 访问favicon.ico 网站图标</span><br><span class="line">    path(&quot;favicon.ico&quot;,RedirectView.as_view(url=&#x27;static/favicon.ico&#x27;)),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="97、django-静态文件配置"><a href="#97、django-静态文件配置" class="headerlink" title="97、django 静态文件配置"></a>97、django 静态文件配置</h2><p>settings.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = &#x27;/static/&#x27;</span><br><span class="line"># 添加静态资源路由地址</span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, &#x27;static&#x27;),</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"># 使用python manage.py collectstatic收集静态文件时时使用STATIC_ROOT</span><br><span class="line"># STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>urls.py</p><pre><code>from django.urls import path, re_pathfrom django.views.generic import RedirectViewfrom django.views.static import servefrom &#39;你的项目名称&#39; import settingsurlpatterns = [    path(&quot;favicon.ico&quot;,RedirectView.as_view(url=&#39;static/favicon.ico&#39;)),    re_path(&#39;static/(?P&lt;path&gt;.*)$&#39;, serve, &#123;&#39;document_root&#39;: settings.STATICFILES_DIRS[0]&#125;),]</code></pre><h2 id="98、django-JsonResponse返回中文时显示unicode编码（-u67e5-u8be2）"><a href="#98、django-JsonResponse返回中文时显示unicode编码（-u67e5-u8be2）" class="headerlink" title="98、django JsonResponse返回中文时显示unicode编码（\u67e5\u8be2）"></a>98、django JsonResponse返回中文时显示unicode编码（\u67e5\u8be2）</h2><p>原因<br>这个unicode编码，是python3默认返回的编码。</p><p>解决方案<br>JsonResponse里面有个参数json_dumps_params，设置为json_dumps_params={‘ensure_ascii’:False}即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&#x27;msg&#x27;: &#x27;创建成功&#x27;,&#125;</span><br><span class="line">return JsonResponse(data=data, json_dumps_params=&#123;&#x27;ensure_ascii&#x27;: False&#125;)</span><br></pre></td></tr></table></figure><h2 id="99、获取当前时间月份的首日与最后一天"><a href="#99、获取当前时间月份的首日与最后一天" class="headerlink" title="99、获取当前时间月份的首日与最后一天"></a>99、获取当前时间月份的首日与最后一天</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import calendar</span><br><span class="line"></span><br><span class="line">def get_month_start_and_end(date=datetime.datetime.now()):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取当前时间的月份首日与最后一天</span><br><span class="line">    :param date:</span><br><span class="line">    :return: (首日，最后一天)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    year, month = str(date).split(&#x27;-&#x27;)[0], str(date).split(&#x27;-&#x27;)[1]</span><br><span class="line">    end = calendar.monthrange(int(year), int(month))[1]</span><br><span class="line">    return f&#x27;&#123;year&#125;-&#123;month&#125;-01&#x27;, f&#x27;&#123;year&#125;-&#123;month&#125;-&#123;end&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="100、xadmin后台批量操作"><a href="#100、xadmin后台批量操作" class="headerlink" title="100、xadmin后台批量操作"></a>100、xadmin后台批量操作</h2><p>adminx.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from django.db.models import  Sum</span><br><span class="line">from xadmin.plugins.actions import BaseActionView</span><br><span class="line"></span><br><span class="line">class MyCountFeeAction(BaseActionView):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">        用户余额统计</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">    action_name = &quot;countuserfee&quot;  #: 相当于这个 Action 的唯一标示, 尽量用比较针对性的名字</span><br><span class="line">    description = u&#x27;统计用户总余额&#x27;  #: 描述, 出现在 Action 菜单中, 可以使用 ``%(verbose_name_plural)s`` 代替 Model 的名字.</span><br><span class="line">    model_perm = &#x27;view&#x27;  # 权限</span><br><span class="line"></span><br><span class="line">    def do_action(self, queryset):</span><br><span class="line">        all_balance = MallUser.objects.all().aggregate(Sum(&#x27;balance&#x27;))</span><br><span class="line">        return HttpResponse(f&#x27;用户总余额&#123;all_balance&#125;&#x27;)</span><br><span class="line">class UserAdmin(object):</span><br><span class="line">    &quot;&quot;&quot;用户信息管理&quot;&quot;&quot;</span><br><span class="line">    list_display = [&#x27;username&#x27;, &#x27;balance&#x27;, &#x27;status&#x27;, &#x27;addtime&#x27;]</span><br><span class="line">    search_fields = [&#x27;username&#x27;, ]</span><br><span class="line">    list_filter = [&#x27;status&#x27;, &#x27;addtime&#x27;]</span><br><span class="line">    list_per_page = 30  # 默认每页数量</span><br><span class="line">    model_icon = &#x27;fa fa-user&#x27;</span><br><span class="line">    list_editable = [&#x27;status&#x27;]</span><br><span class="line">    ordering = [&#x27;-addtime&#x27;]</span><br><span class="line">    actions = [ MyCountFeeAction]  # 添加批量选择操作</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200812233442373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）"><a href="#101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）" class="headerlink" title="101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）"></a>101、xadmin过滤器外键显示特定值（比如只能过滤自己与超级管理员定义的数据）</h2><p>首先，修改xadmin源码，修改xadmin/filters.py,在401行，做如下修改，</p><pre><code>把self.lookup_choices = field.get_choices(include_blank=False)改为：# 调用自定义的方法if hasattr(model_admin, &#39;&#123;field&#125;_choices&#39;.format(field=field.name)):        self.lookup_choices = getattr(model_admin, &#39;&#123;field&#125;_choices&#39;.format(field=field.name))(field, request,params, model,model_admin,field_path)    else:        self.lookup_choices = field.get_choices(include_blank=False)</code></pre><p>如图:</p><p><img src="https://img-blog.csdnimg.cn/20200812234011656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>然后，在adminx.py中定义过滤的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import xadmin</span><br><span class="line">from django.db.models import  Q, Sum</span><br><span class="line">from xadmin.plugins.actions import BaseActionView</span><br><span class="line"></span><br><span class="line">class MeasurePointAdmin(object):</span><br><span class="line">    # search_fields = [&#x27;user__name&#x27;, &#x27;user__account&#x27;]  # 检索字段</span><br><span class="line">    list_display = [&#x27;num&#x27;, &#x27;elevation&#x27;, &#x27;correct_num&#x27;, &#x27;cumulative_amount&#x27;]</span><br><span class="line">    list_filter = [&#x27;user&#x27;, &#x27;is_default&#x27;, &#x27;create_time&#x27;]  # 分组过滤的字段</span><br><span class="line">    list_editable = [&#x27;num&#x27;, &#x27;elevation&#x27;, &#x27;correct_num&#x27;, &#x27;cumulative_amount&#x27;]</span><br><span class="line">    ordering = (&#x27;id&#x27;,)  # 设置默认排序字段，负号表示降序排序</span><br><span class="line">    list_per_page = 30  # 默认每页显示多少条记录，默认是100条</span><br><span class="line">    model_icon = &#x27;fa fa-users&#x27;  # 左侧小图标</span><br><span class="line">    readonly_fields = [&#x27;user&#x27;, &#x27;is_default&#x27;]</span><br><span class="line">    import_excel = True</span><br><span class="line">    actions = [MyCountFeeAction]</span><br><span class="line"></span><br><span class="line"># 定义的函数名必须是  字段名_choices</span><br><span class="line">    def user_choices(self, field, request, params, model, model_admin, field_path):</span><br><span class="line">        # 超级用户不做控制</span><br><span class="line">        if self.request.user.is_superuser:</span><br><span class="line">            return field.get_choices(include_blank=False)</span><br><span class="line"></span><br><span class="line">        # 过滤器只显示自己与超级管理员</span><br><span class="line">        user_lst = field.related_model._default_manager.filter(Q(id=self.request.user.id) | Q(is_superuser=True))</span><br><span class="line">        # 返回格式 [(&#x27;pk&#x27;,&#x27;标题&#x27;),]</span><br><span class="line">        return [(user.id, user.username) for user in user_lst]</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="https://img-blog.csdnimg.cn/2020081223440761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtX2lzX2Rj,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="102、Django中的CSRF局部禁用"><a href="#102、Django中的CSRF局部禁用" class="headerlink" title="102、Django中的CSRF局部禁用"></a>102、Django中的CSRF局部禁用</h2><p>为了避免没有csrf token而产生的403的forbidden错误，可以使用csrf_exempt装饰器来处理POST、GET请求的View, 这种方式是CSRF局部禁用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.utils.decorators import method_decorator</span><br><span class="line">from django.views.decorators.csrf import csrf_exempt</span><br><span class="line"></span><br><span class="line">@method_decorator(csrf_exempt)</span><br><span class="line">def update_data(request):</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">    pass</span><br><span class="line">elif request.method == &#x27;GET&#x27;:</span><br><span class="line">    pass</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="103、使用python命令创建django项目"><a href="#103、使用python命令创建django项目" class="headerlink" title="103、使用python命令创建django项目"></a>103、使用python命令创建django项目</h2><p>创建django项目<br>方式一：直接打开pycharm创建，选择file-&gt;new project-&gt;django<br>方式二：通过命令创建<br>先创建虚拟环境：python -m venv django_venv<br>然后导入django库：pip install django -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>最后使用命令创建：django-admin startproject my_django_project</p><h2 id="104、-二维列表、二维数组行求和与列求和"><a href="#104、-二维列表、二维数组行求和与列求和" class="headerlink" title="104、 二维列表、二维数组行求和与列求和"></a>104、 二维列表、二维数组行求和与列求和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line"># 二维数组，对列和行求和</span><br><span class="line">a = [</span><br><span class="line">    [&#x27;&#x27;, 0, &#x27;&#x27;, 1, 4.1],</span><br><span class="line">    [&#x27;&#x27;, 0, &#x27;&#x27;, &#x27;&#x27;, 4],</span><br><span class="line">    [&#x27;123&#x27;, 0, &#x27;&#x27;, 3, 4, 6,7],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def aa(x, y):</span><br><span class="line">    x = 0 if isinstance(x, str) else x</span><br><span class="line">    y = 0 if isinstance(y, str) else y</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line"># 对行求和</span><br><span class="line">row_sum = [reduce(aa, i) for i in a]</span><br><span class="line"># 对列求和，只能处理相同长度的子元素</span><br><span class="line">column_sum_1 = [reduce(aa, i) for i in zip(*a)]</span><br><span class="line"># 对列求和，可以处理不同长度的子元素</span><br><span class="line">column_sum_2 = list(dict(pd.DataFrame(a).fillna(0).apply(lambda x: &#x27;&#x27; if any(isinstance(d, str) for d in x) else round(x.sum(), 2))).values())</span><br><span class="line">print(&#x27;行求和：&#123;&#125;\r\n列求和(相同长度)：&#123;&#125;\r\n列求和：&#123;&#125;&#x27;.format(row_sum, column_sum_1, column_sum_2))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行求和：[5.1, 4, 20]</span><br><span class="line">列求和(相同长度)：[0, 0, 0, 4, 12.1]</span><br><span class="line">列求和：[&#x27;&#x27;, 0, &#x27;&#x27;, &#x27;&#x27;, 12.1, 6.0, 7.0]</span><br></pre></td></tr></table></figure><h2 id="105、获取时间字符串的月份数"><a href="#105、获取时间字符串的月份数" class="headerlink" title="105、获取时间字符串的月份数"></a>105、获取时间字符串的月份数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">    </span><br><span class="line">def get_months(start_month_str, end_month_str):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # 获取时间字符串中的月份数</span><br><span class="line">    :param start_month_str: 开始字符串</span><br><span class="line">    :param end_month_str: 结束字符串</span><br><span class="line">    :return: 月份数</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    end_month_date = datetime.strptime(end_month_str, &#x27;%Y-%m&#x27;)</span><br><span class="line">    start_month_date = datetime.strptime(start_month_str, &#x27;%Y-%m&#x27;)</span><br><span class="line">    end_year, end_month = end_month_date.year, end_month_date.month</span><br><span class="line">    start_year, start_month = start_month_date.year, start_month_date.month</span><br><span class="line"></span><br><span class="line">    return (end_year - start_year) *12 + (end_month - start_month) + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end_month_str = &#x27;2021-02&#x27;</span><br><span class="line">start_month_str = &#x27;2020-07&#x27;</span><br><span class="line">print(get_months(start_month_str, end_month_str))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="106、字符串不足补零"><a href="#106、字符串不足补零" class="headerlink" title="106、字符串不足补零"></a>106、字符串不足补零</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;hello world&#x27;.zfill(15)) # 补0</span><br><span class="line">print(&#x27;hello world&#x27;.rjust(15)) # 右对齐，补空格</span><br><span class="line">print(&#x27;hello world&#x27;.ljust(15)) # 左对齐，补空格</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">0000hello world</span><br><span class="line">    hello world</span><br><span class="line">hello world  </span><br></pre></td></tr></table></figure><h2 id="107、时间戳转字符串日期"><a href="#107、时间戳转字符串日期" class="headerlink" title="107、时间戳转字符串日期"></a>107、时间戳转字符串日期</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">t1 = time.time()</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime(t1)))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1621741567.082192</span></span><br><span class="line"><span class="number">2021</span>-05-<span class="number">23</span> <span class="number">11</span>:<span class="number">46</span>:07</span><br></pre></td></tr></table></figure><p>使用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># !/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@contact: 微信 1257309054</span><br><span class="line">@file: 时间戳转日期.py</span><br><span class="line">@time: 2022/6/27 17:16</span><br><span class="line">@author: LDC</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import time</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 正确10位长度的时间戳可精确到秒，11-14位长度则是包含了毫秒</span><br><span class="line">def int_to_datetime(intValue):</span><br><span class="line">    if len(str(intValue)) == 10:</span><br><span class="line">        # 精确到秒</span><br><span class="line">        timeValue = time.localtime(intValue)</span><br><span class="line">        tempDate = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeValue)</span><br><span class="line">        datetimeValue = datetime.datetime.strptime(tempDate, &quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">    elif 10 &lt; len(str(intValue)) and len(str(intValue)) &lt; 15:</span><br><span class="line">        # 精确到毫秒</span><br><span class="line">        k = len(str(intValue)) - 10</span><br><span class="line">        timetamp = datetime.datetime.fromtimestamp(intValue / (1 * 10 ** k))</span><br><span class="line">        datetimeValue = timetamp.strftime(&quot;%Y-%m-%d %H:%M:%S.%f&quot;)</span><br><span class="line">    else:</span><br><span class="line">        return -1</span><br><span class="line">    return datetimeValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time1 = 1656321420</span><br><span class="line">time2 = 1656321086560</span><br><span class="line">print(int_to_datetime(time1))</span><br><span class="line">print(int_to_datetime(time2))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">输出：</span><br><span class="line">2022-06-27 17:17:00</span><br><span class="line">2022-06-27 17:11:26.560000</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h2 id="108、列表转字符串"><a href="#108、列表转字符串" class="headerlink" title="108、列表转字符串"></a>108、列表转字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,a)))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">`<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>`</span><br></pre></td></tr></table></figure><h2 id="109、pip国内镜像源"><a href="#109、pip国内镜像源" class="headerlink" title="109、pip国内镜像源"></a>109、pip国内镜像源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pip install 库名 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">清华：-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">阿里云：-i http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">中国科技大学 -i https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"></span><br><span class="line">华中理工大学：-i http://pypi.hustunique.com/</span><br><span class="line"></span><br><span class="line">山东理工大学：-i http://pypi.sdutlinux.org/ </span><br><span class="line"></span><br><span class="line">豆瓣：-i http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure><h2 id="110、python把时间字符串转换成刚刚、1天前、3个月前、1年前"><a href="#110、python把时间字符串转换成刚刚、1天前、3个月前、1年前" class="headerlink" title="110、python把时间字符串转换成刚刚、1天前、3个月前、1年前"></a>110、python把时间字符串转换成刚刚、1天前、3个月前、1年前</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def date_interval(date_str):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    获取时间间隔</span><br><span class="line">    1分钟前，2分钟前，10分钟前，1小时前，2小时前，1天前，2天前，3天前，1个月前，3个月前，1年前，3年前</span><br><span class="line">    :param date_str: 时间字符串</span><br><span class="line">    :return: 字符串</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    date_str = time.strptime(date_str, &#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    # 将时间元组转换为时间戳</span><br><span class="line">    t = time.mktime(date_str)</span><br><span class="line"></span><br><span class="line">    # 当前时间</span><br><span class="line">    seconds = time.time() - t</span><br><span class="line"></span><br><span class="line">    years = int(seconds // (60 * 60 * 24 * 365))</span><br><span class="line">    if years:</span><br><span class="line">        return &#x27;&#123;&#125;年前&#x27;.format(years)</span><br><span class="line">    months = int(seconds // (60 * 60 * 24 * 30))</span><br><span class="line">    if months:</span><br><span class="line">        return &#x27;&#123;&#125;月前&#x27;.format(months)</span><br><span class="line">    days = int(seconds // (60 * 60 * 24))</span><br><span class="line">    if days:</span><br><span class="line">        return &#x27;&#123;&#125;天前&#x27;.format(days)</span><br><span class="line">    hours = int(seconds // (60 * 60))</span><br><span class="line">    if hours:</span><br><span class="line">        return &#x27;&#123;&#125;小时前&#x27;.format(hours)</span><br><span class="line">    minutes = int(seconds // (60))</span><br><span class="line">    if minutes:</span><br><span class="line">        return &#x27;&#123;&#125;分钟前&#x27;.format(minutes)</span><br><span class="line">    return &#x27;刚刚&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    date1 = &#x27;2019-07-10 15:27:51&#x27;</span><br><span class="line">    date2 = &#x27;2021-07-10 15:27:51&#x27;</span><br><span class="line">    date3 = &#x27;2021-08-10 15:27:51&#x27;</span><br><span class="line">    date4 = &#x27;2021-08-12 11:01:51&#x27;</span><br><span class="line">    date5 = datetime.datetime.now() + datetime.timedelta(seconds=-3)</span><br><span class="line">    date5 = date5.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    print(date_interval(date1))</span><br><span class="line">    print(date_interval(date2))</span><br><span class="line">    print(date_interval(date3))</span><br><span class="line">    print(date_interval(date4))</span><br><span class="line">    print(date_interval(date5))</span><br></pre></td></tr></table></figure><h2 id="111、Django使用ORM执行sql语句"><a href="#111、Django使用ORM执行sql语句" class="headerlink" title="111、Django使用ORM执行sql语句"></a>111、Django使用ORM执行sql语句</h2><p>通过raw函数执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alarm_datas = gsm.AlertMessage.objects.raw(&#x27;&#x27;&#x27;</span><br><span class="line">                select am_all.id, am_all.sensor_number</span><br><span class="line">                    FROM alert_message as am_all</span><br><span class="line">                    where </span><br><span class="line">                        am_all.real=&#x27;1&#x27;</span><br><span class="line">                        and am_all.is_show=1</span><br><span class="line">                    order by am_all.alarm_level desc</span><br><span class="line">                &#x27;&#x27;&#x27;)</span><br><span class="line">for ad in alarm_datas:</span><br><span class="line">print(ad.sensor_number)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="112、Django通过变量字段获取数据"><a href="#112、Django通过变量字段获取数据" class="headerlink" title="112、Django通过变量字段获取数据"></a>112、Django通过变量字段获取数据</h2><p>通过方法<code>__getattribute__</code>来获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert_messages = AlertMessage.objects.filter(real=0)</span><br><span class="line">am_fields = [&#x27;id&#x27;, &#x27;real&#x27;, &#x27;name&#x27;]</span><br><span class="line">for am in alert_messages:</span><br><span class="line">for i in range(len(am_fields)):</span><br><span class="line">print(am_fields[i], am.__getattribute__(am_fields[i]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="113、Django查询变量字段、更新变量字段"><a href="#113、Django查询变量字段、更新变量字段" class="headerlink" title="113、Django查询变量字段、更新变量字段"></a>113、Django查询变量字段、更新变量字段</h2><p>通过<code>**&#123;变量名:值&#125;</code>来操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">field = &#x27;device_code&#x27;</span><br><span class="line"># 查询</span><br><span class="line">device_infos = gsm.DeviceInfo.objects.filter(**&#123;field: &#x27;012&#x27;&#125;)</span><br><span class="line"># 更新</span><br><span class="line">gsm.DeviceInfo.objects.filter(device_code=&#x27;012&#x27;).update(**&#123;field : &#x27;0&#x27;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="114、vue生成dist文件"><a href="#114、vue生成dist文件" class="headerlink" title="114、vue生成dist文件"></a>114、vue生成dist文件</h2><p>安装npm，到<a href="https://nodejs.org/en/download/">官网下载</a><br>在vue项目下打开cmd，输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>如果报错，npm ERR! missing script: build，<br>则使用以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><p>具体看package.json</p><p><img src="https://img-blog.csdnimg.cn/eff15dcd4c1d499f9641d0ac25c09bc0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Lic5pyo5pyI,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="115、python获取电脑磁盘、CPU、内存使用情况"><a href="#115、python获取电脑磁盘、CPU、内存使用情况" class="headerlink" title="115、python获取电脑磁盘、CPU、内存使用情况"></a>115、python获取电脑磁盘、CPU、内存使用情况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import psutil</span><br><span class="line">#  pip install psutil</span><br><span class="line"></span><br><span class="line"># 获取本机磁盘使用率和剩余空间G信息</span><br><span class="line">def get_disk_info():</span><br><span class="line">    # 循环磁盘分区</span><br><span class="line">    content = &quot;&quot;</span><br><span class="line">    for disk in psutil.disk_partitions():</span><br><span class="line">        # 读写方式 光盘 or 有效磁盘类型</span><br><span class="line">        if &#x27;cdrom&#x27; in disk.opts or disk.fstype == &#x27;&#x27;:</span><br><span class="line">            continue</span><br><span class="line">        disk_name_arr = disk.device.split(&#x27;:&#x27;)</span><br><span class="line">        disk_name = disk_name_arr[0]</span><br><span class="line">        disk_info = psutil.disk_usage(disk.device)</span><br><span class="line">        # 磁盘剩余空间，单位G</span><br><span class="line">        free_disk_size = disk_info.free//1024//1024//1024</span><br><span class="line">        # 当前磁盘使用率和剩余空间G信息</span><br><span class="line">        info = &quot;&#123;&#125;盘使用率：&#123;&#125;%%， 剩余空间：&#123;&#125;G &quot;.format(disk_name, str(disk_info.percent), free_disk_size)</span><br><span class="line">        # 拼接多个磁盘的信息</span><br><span class="line">        content = content + info</span><br><span class="line">    print(content)</span><br><span class="line"></span><br><span class="line"># cpu信息</span><br><span class="line">def get_cpu_info():</span><br><span class="line">    cpu_percent = psutil.cpu_percent(interval=1)</span><br><span class="line">    cpu_info = &quot;CPU使用率：%i%%&quot; % cpu_percent</span><br><span class="line">    print(cpu_info)</span><br><span class="line"></span><br><span class="line"># 内存信息</span><br><span class="line">def get_memory_info():</span><br><span class="line">    virtual_memory = psutil.virtual_memory()</span><br><span class="line">    used_memory = virtual_memory.used/1024/1024/1024</span><br><span class="line">    free_memory = virtual_memory.free/1024/1024/1024</span><br><span class="line">    memory_percent = virtual_memory.percent</span><br><span class="line">    memory_info = &quot;内存使用：%0.2fG，使用率%0.1f%%，剩余内存：%0.2fG&quot; % (used_memory, memory_percent, free_memory)</span><br><span class="line">    print(memory_info)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    get_disk_info()</span><br><span class="line">    get_cpu_info()</span><br><span class="line">    get_memory_info()</span><br></pre></td></tr></table></figure><h2 id="116、max比较字典列表"><a href="#116、max比较字典列表" class="headerlink" title="116、max比较字典列表"></a>116、max比较字典列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">使用max函数比较字典列表对象</span><br><span class="line">需求：找出用户组最大id的字典</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">def com_id(f):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    比较用用户ids列表</span><br><span class="line">    :param f: 字典</span><br><span class="line">    :return: 返回最大的用户id</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    return max(f[&#x27;user_ids&#x27;])</span><br><span class="line"></span><br><span class="line">friends_added = [</span><br><span class="line">        &#123;&#x27;user_ids&#x27;: [1, 2], &#x27;create_at&#x27;: &#x27;2020-01-01&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;user_ids&#x27;: [2, 1], &#x27;create_at&#x27;: &#x27;2020-02-02&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;user_ids&#x27;: [4, 1], &#x27;create_at&#x27;: &#x27;2020-02-02&#x27;&#125;,</span><br><span class="line">    ]</span><br><span class="line"># max函数中使用key参数，指定自定义函数来比较</span><br><span class="line">item = max(friends_added, key=com_id)</span><br><span class="line">item_1 = max(friends_added, key=lambda f: max(f[&#x27;user_ids&#x27;])) # com_id可以转成lambda函数</span><br><span class="line">print(item)</span><br><span class="line">print(item_1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;</span><br><span class="line">&#123;&#x27;user_ids&#x27;: [3, 6], &#x27;create_at&#x27;: &#x27;2020-01-02&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="117、django查询表的具体字段"><a href="#117、django查询表的具体字段" class="headerlink" title="117、django查询表的具体字段"></a>117、django查询表的具体字段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExampleModel.objects.values(&#x27;id&#x27;, &#x27;username&#x27;)</span><br><span class="line"># 返回的结果是QuerySet， 里面的元素是dict格式</span><br><span class="line"># [&#123;&#x27;id&#x27;:1, &#x27;username&#x27;: &#x27;Austin&#x27;&#125;, &#123;&#x27;id&#x27;:2, &#x27;username&#x27;:&#x27;Sam&#x27;&#125;, ...]</span><br><span class="line"># 相当于SQL中的SELECT id, username FROM ......, </span><br><span class="line"># 只返回对应属性（字段）的值</span><br></pre></td></tr></table></figure><h2 id="118、MySQL查询数据添加自增序号"><a href="#118、MySQL查询数据添加自增序号" class="headerlink" title="118、MySQL查询数据添加自增序号"></a>118、MySQL查询数据添加自增序号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set @i = 0;</span><br><span class="line">select waveform, &#x27;沿桥风吹&#x27; as label ,(@i:=@i+1) xh from alert_message where is_real=1 and node_id=138</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="119、MySQL-时间截取年月日"><a href="#119、MySQL-时间截取年月日" class="headerlink" title="119、MySQL 时间截取年月日"></a>119、MySQL 时间截取年月日</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id,</span><br><span class="line">addtime, </span><br><span class="line">date_format(addtime,&#x27;%Y-%m-%d&#x27;) as short_time </span><br><span class="line">from alert_message </span><br><span class="line">where date_format(addtime,&#x27;%Y-%m-%d&#x27;) = &#x27;2022-03-13&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/37cec67fa1e1458f9aba1b745600a493.png" alt="在这里插入图片描述"></p><h2 id="120、-列表取奇数下标值"><a href="#120、-列表取奇数下标值" class="headerlink" title="120、 列表取奇数下标值"></a>120、 列表取奇数下标值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;奇数下标值&#x27;</span>,list1[<span class="number">1</span>::<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">奇数下标值 [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="121、列表取偶数下标值"><a href="#121、列表取偶数下标值" class="headerlink" title="121、列表取偶数下标值"></a>121、列表取偶数下标值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;偶数下标值&#x27;</span>,list1[::<span class="number">2</span>])</span><br><span class="line">偶数下标值 [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="122、列表相同元素分类、分组"><a href="#122、列表相同元素分类、分组" class="headerlink" title="122、列表相同元素分类、分组"></a>122、列表相同元素分类、分组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">a =[<span class="built_in">list</span>(group) <span class="keyword">for</span> key, group <span class="keyword">in</span> itertools.groupby(data)]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]]</span><br></pre></td></tr></table></figure><h2 id="123、ubuntu切换用户"><a href="#123、ubuntu切换用户" class="headerlink" title="123、ubuntu切换用户"></a>123、ubuntu切换用户</h2><p>1）从user用户切换到root用户<br>sudo su<br>2）从root用户切回user用户<br>su user (user是你自己安装时候的用户名)，或是直接输入exit，也可Ctrl+D组合键推出</p><h2 id="124、numpy二维数组获取某一列"><a href="#124、numpy二维数组获取某一列" class="headerlink" title="124、numpy二维数组获取某一列"></a>124、numpy二维数组获取某一列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = [</span><br><span class="line">    [1, 2, 3, 4, 5, 6],</span><br><span class="line">    [7, 8, 9, 10, 11, 12],</span><br><span class="line">    [13.2, 14.8, 15.9, 16.10, 16.11, 17.12],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">a_np = np.array(a)  # 把二维列表转成numpy数组</span><br><span class="line">print(&#x27;第一行&#x27;, a_np[0].tolist())  # 获取第一行</span><br><span class="line">print(&#x27;第一列&#x27;, a_np[:, 0].tolist())  # 获取第一列</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">第一行 [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]</span><br><span class="line">第一列 [1.0, 7.0, 13.2]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自制电子时钟</title>
      <link href="/2020/08/19/EI-clock-conclusion/"/>
      <url>/2020/08/19/EI-clock-conclusion/</url>
      
        <content type="html"><![CDATA[<h1 id="自制电子时钟—总结"><a href="#自制电子时钟—总结" class="headerlink" title="自制电子时钟—总结"></a>自制电子时钟—总结</h1><h2 id="使用到的模块及其功能："><a href="#使用到的模块及其功能：" class="headerlink" title="使用到的模块及其功能："></a>使用到的模块及其功能：</h2><ul><li>DS1302：低功耗实时时钟芯片，它可以对年、月、日、周、时、分、秒进行计时，且具有闰年补偿等多种功能。</li><li>LCD1602：用来显示字母、数字、符号等的点阵型液晶模块，能够同时显示16x02即32个字符。</li><li>按键k1,k2,k3,k4：<br>k1：切换模式，比如工作模式、计时模式、设置模式。<br>k2：设置模式: plus；计时模式: 打开计时，暂停计时<br>k3：设置模式: shift；计时模式：归零<br>k4：闹钟响时，关闭闹钟</li><li>蜂鸣器：闹钟铃声，天空之城</li></ul><h2 id="主要原理："><a href="#主要原理：" class="headerlink" title="主要原理："></a>主要原理：</h2><p>&emsp; &emsp; 工作模式下，51单片机从DS1302中获取数据，再把数据传递到LCD来显示时间和日期；设置模式下，通过k2和k3来改变数据；计时模式下，通过k2来打开或关闭定时器1，来实现开始/暂停计时，通过k3来计时初始化；闹钟响时，打开定时器1，通过天空之城乐谱来控制蜂鸣器的音调。  </p><h2 id="DS1302"><a href="#DS1302" class="headerlink" title="DS1302"></a>DS1302</h2><p>编码是BCD8421编码，用4位二进制数来表示1位十进制数中的0~9这10个数字  </p><div class="table-container"><table><thead><tr><th style="text-align:center">十进制数</th><th style="text-align:center">8421码</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0001</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0010</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0011</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0100</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0101</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">0110</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">0111</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1001</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*BCD8421编码，十进制数据转换成BCD码 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">encode_BCD</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>   </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat1,dat2;</span><br><span class="line">dat1 = dat/<span class="number">10</span>;</span><br><span class="line">dat2 = dat%<span class="number">10</span>;</span><br><span class="line">dat = dat2 + dat1*<span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> dat; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BCD8421解码，BCD码转换成十进制数据   */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">decode_BCD</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dat1,dat2;</span><br><span class="line">dat1 = dat/<span class="number">16</span>;</span><br><span class="line">dat2 = dat%<span class="number">16</span>;</span><br><span class="line">dat = dat2 + dat1*<span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>读写数据到DS1302<br>  DS1302的数据读写是通过I/O串行进行的。当进行一次读写操作时最少得发送两个字节，第一个字节是控制字节，就是一个命令，告诉DS1302是读还是写操作，是对RAM还是对CLOK寄存器操作，以及操作的地址。第二个字节就是要读或写的数据了。 </p><ol><li>控制字节<br><img src="http://www.elecfans.com/uploads/allimg/171020/2362487-1G02009234UB.jpg" alt="控制指令">  <ul><li>位0就是读写位，当位0为1时，就是告诉DS1302，下面是进行读出操作，而当位0为0时就是写入操作。  </li><li>位0－位5是要进行操作的DS1302寄存器地址。<br>位6就是告诉DS1302，是要对RAM进行操作还是对时间寄存器进行操作，0就是对时间寄存器操作，一般我们都是对时间寄存器进行操作。  </li><li>位7就是固定的1。  </li><li>现在就知道为什么控制字80H是写秒寄存器，而81H是读秒寄存器了吧。80H换成二进制就是10000000。而81H的二进制就是10000001，一个是写操作，另一个是读操作嘛！  </li></ul></li><li>读写操作<br><img src="http://www.elecfans.com/uploads/allimg/171020/2362487-1G02009241L44.jpg" alt="读写">  <ul><li>写：<br>在进行操作之前先得将CE（也可说是RST）置高电平，然后单片机将控制字的位0放到I/O上，当I/O的数据稳定后，将SCLK置高电平，DS1302检测到SCLK的上升沿后就将I/O上的数据读取，然后单片机将SCLK置为低电平，再将控制字的位1放到I/O上，如此反复，将一个字节控制字的8个位传给DS1302。<br>接下来就是传一个字节的数据给DS1302，在SCLK低电平时单片机将数据放到IO上，当SCLK上升沿时，DS1302读取。当传完数据后，单片机将CE置为低电平，操作结束。</li><li>读：<br>在进行操作之前先得将CE（也可说是RST）置高电平，然后单片机将控制字的位0放到I/O上，当I/O的数据稳定后，将SCLK置高电平，DS1302检测到SCLK的上升沿后就将I/O上的数据读取，然后单片机将SCLK置为低电平，再将控制字的位1放到I/O上，如此反复，将一个字节控制字的8个位传给DS1302。<br>接下来就是从DS1302读数据，在SCLK高电平时DS1302放数据到IO上，将SCLK置为低电平后，产生下降沿电压，单片机就可从IO上读取数据。当传完数据后，单片机将CE置为低电平，操作结束。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写入数据到DS1302*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_DS1302_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr,<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">TRST = <span class="number">0</span>;</span><br><span class="line">_nop_(); </span><br><span class="line">TSCLK = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line"></span><br><span class="line">TRST = <span class="number">1</span>; <span class="comment">//拉高CE，开始读写数据</span></span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//写入地址</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">TIO = addr &amp; <span class="number">0x01</span>;<span class="comment">//发送地址的最低位 </span></span><br><span class="line">addr &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">TSCLK = <span class="number">1</span>;<span class="comment">//产生上升沿电压，写入命令</span></span><br><span class="line">_nop_();</span><br><span class="line">TSCLK = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//写入数据</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">TIO = dat &amp; <span class="number">0x01</span>;<span class="comment">//发送数据的最低位</span></span><br><span class="line">dat &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">TSCLK = <span class="number">1</span>;<span class="comment">//产生上升沿电压，写入数据</span></span><br><span class="line">_nop_();</span><br><span class="line">TSCLK = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line">TRST = <span class="number">0</span>; <span class="comment">//数据传输结束</span></span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从DS1302读取数据*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">read_DS1302_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i,dat=<span class="number">0</span>,dat1=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">TRST = <span class="number">0</span>;</span><br><span class="line">_nop_(); </span><br><span class="line">TSCLK = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line"></span><br><span class="line">TRST = <span class="number">1</span>; <span class="comment">//拉高CE，开始读写数据</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//开始传送八位地址命令</span></span><br><span class="line">&#123;    </span><br><span class="line">TIO = addr &amp; <span class="number">0x01</span>;<span class="comment">//发送地址的最低位 </span></span><br><span class="line">addr &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">TSCLK = <span class="number">1</span>;<span class="comment">//产生上升沿电压，写入命令</span></span><br><span class="line">_nop_();</span><br><span class="line">TSCLK = <span class="number">0</span>;<span class="comment">//DS1302下降沿时，放置数据</span></span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//读取8位数据</span></span><br><span class="line">&#123;</span><br><span class="line">dat1 = TIO;<span class="comment">//从最低位开始接收</span></span><br><span class="line">dat = (dat&gt;&gt;<span class="number">1</span>) | (dat1&lt;&lt;<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">TSCLK = <span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">TSCLK = <span class="number">0</span>;<span class="comment">//产生下降沿电压，读取数据</span></span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TRST = <span class="number">0</span>;</span><br><span class="line">_nop_();<span class="comment">//以下为DS1302复位的稳定时间,必须的。</span></span><br><span class="line">TSCLK = <span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">TIO = <span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">TIO = <span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="LCD1602"><a href="#LCD1602" class="headerlink" title="LCD1602"></a>LCD1602</h2><ul><li>LCD操作模式  </li></ul><div class="table-container"><table><thead><tr><th>输入</th><th>输出</th><th>输出</th></tr></thead><tbody><tr><td>读状态</td><td>RS=0,RW=H,EN为高变低脉冲</td><td>D0~D7个状态值</td></tr><tr><td>读数据</td><td>RS=1,RW=1,EN为高变低脉冲</td><td>无</td></tr><tr><td>写指令</td><td>RS=0,RW=0,D0—D7=数据,EN由高脉冲变为低脉冲</td><td>D0—D7状态值</td></tr><tr><td>写数据</td><td>RS=1, RW=0, D0—D7=数据，EN由高脉冲变为低脉冲</td><td>D0—D7状态值</td></tr></tbody></table></div><ul><li><p>详细说明：<br>(1) RS和RW都为0时表示对LCD写指令操作，包括写入LCD的显示模式和设定LCD地址的指令。.显示模式包括清屏、地址归为、显示状态、进入点设定、功能设定、游标显示模式操作;关于地址的操作包括设定CGRAM地址、设定DDRAM地址。<br>(2) 当RS=0,RW=1时，表示读LCD状态，此时可以读取LCD忙信号，同时可以读取地址计数器的值。忙信号的状态用来确定LCD内部动作是否完成，若在LCD内部出于忙状态时对LCD进行读写操作将会失败。<br>(3) 当RS=1时，若RW=0表示写数据操作，若RW=1表示读数据操作  </p></li><li><p>地址：<br>LCD供两行，第一行可立即显示字符的地址为00H—0FH，第二行可立即显示字符的地址为40H—67H。  </p></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断液晶是否忙，如果忙就等待</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_busy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> busy;</span><br><span class="line">P0 = <span class="number">0xff</span>;</span><br><span class="line">RS = <span class="number">0</span>;</span><br><span class="line">RW = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">EN = <span class="number">1</span>;</span><br><span class="line">busy = P0;   <span class="comment">//读状态，RS = 0;RW = 1;EN = 1;</span></span><br><span class="line">EN = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(busy &amp; <span class="number">0x80</span>); <span class="comment">//判断状态码最高位，STA7读写使能，1：禁止，0：允许</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写1字节指令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span>   <span class="comment">//RS=L,RW=L,E=下降沿脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">read_busy();</span><br><span class="line">RS = <span class="number">0</span>;</span><br><span class="line">RW = <span class="number">0</span>;</span><br><span class="line">P0 = cmd;</span><br><span class="line">EN = <span class="number">1</span>;</span><br><span class="line">EN = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写1字节数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>   <span class="comment">//RS=H,RW=L,E=下降沿脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">read_busy();</span><br><span class="line">RS = <span class="number">1</span>;</span><br><span class="line">RW = <span class="number">0</span>;</span><br><span class="line">P0 = dat;</span><br><span class="line">EN = <span class="number">1</span>;</span><br><span class="line">EN = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><p>核心代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> <span class="comment">//us延时 12MHz下</span></span><br><span class="line">&#123;</span><br><span class="line">t/=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(t;t;t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">play_tone</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> tone)</span> <span class="comment">//播音调函数，就是方波发生器</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Buzzer=!Buzzer; </span><br><span class="line">delay_us(tone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>定时器获取延时时间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span> <span class="comment">//毫秒延时12MHz下</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">75</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_init</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD|=<span class="number">0x10</span>; <span class="comment">//使用定时器1</span></span><br><span class="line">TH1=(<span class="number">65536</span><span class="number">-65000</span>)/<span class="number">256</span>; <span class="comment">//装初值</span></span><br><span class="line">TL1=(<span class="number">65536</span><span class="number">-65000</span>)%<span class="number">256</span>;</span><br><span class="line">EA =  <span class="number">1</span>; <span class="comment">//开中断，打开定时器开关</span></span><br><span class="line">ET1 = <span class="number">1</span>;</span><br><span class="line">TR1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer1_interrupt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *song)</span>  <span class="comment">//定时器1 中断</span></span><br><span class="line">&#123;</span><br><span class="line">TH1=(<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>; <span class="comment">//装初值</span></span><br><span class="line">TL1=(<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">music_s++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(music_s&gt;=<span class="number">4</span>*t_tone) <span class="comment">//一个音节播放的时间，这里可以通过调t_tone前的系数可以改变时长</span></span><br><span class="line">&#123;</span><br><span class="line">music_s=<span class="number">0</span>; <span class="comment">//讲计时器清零</span></span><br><span class="line"><span class="keyword">if</span>((*tone_p)!=<span class="number">0</span>) <span class="comment">//如果音不是0</span></span><br><span class="line">tone = tones[*tone_p+<span class="number">7</span>*(*(tone_p+<span class="number">1</span>))<span class="number">-1</span>];  <span class="comment">//赋值音调</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">tone = <span class="number">0</span>;     <span class="comment">//关了蜂鸣器</span></span><br><span class="line">t_tone = *(tone_p+<span class="number">2</span>); <span class="comment">//取时间啊</span></span><br><span class="line"></span><br><span class="line">tone_p+=<span class="number">3</span>; <span class="comment">//移动指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*tone_p == <span class="number">8</span>) tone_p = song;   <span class="comment">//结束标志</span></span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">30</span>); <span class="comment">//延时一下，不延时特别难听</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>歌曲谱子数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tones[]=    <span class="comment">//C调音调</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">3816</span>,<span class="number">3401</span>,<span class="number">3030</span>,<span class="number">2865</span>,<span class="number">2551</span>,<span class="number">2272</span>,<span class="number">2024</span>, <span class="comment">//低音</span></span><br><span class="line"><span class="number">1912</span>,<span class="number">1703</span>,<span class="number">1517</span>,<span class="number">1432</span>,<span class="number">1275</span>,<span class="number">1136</span>,<span class="number">1012</span>, <span class="comment">//中音</span></span><br><span class="line"><span class="number">965</span>, <span class="number">851</span>, <span class="number">758</span>, <span class="number">715</span>, <span class="number">605</span>, <span class="number">538</span>, <span class="number">466</span> <span class="comment">//高音</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code sky[]=&#123; <span class="comment">//谱子，天空之城</span></span><br><span class="line"><span class="comment">//格式： 音调， 音度， 拍数</span></span><br><span class="line"><span class="comment">//例： 4，1，1 //音调fa，中音，时长半拍</span></span><br><span class="line"><span class="comment">//0代表空音</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line"><span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">8</span><span class="comment">//结束标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sbit Buzzer=P1^<span class="number">5</span>; <span class="comment">//定义buzzer引脚</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> music_s=<span class="number">0</span>, t_tone=<span class="number">0</span>;     <span class="comment">//music_s用作定时器计时， t_tone保存音调时长</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  tone=<span class="number">0</span>;     <span class="comment">//tone保存音调，</span></span><br><span class="line"><span class="type">char</span> *tone_p=sky; <span class="comment">//指针指向要播放的曲目</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo：搭建自己的blog</title>
      <link href="/2020/08/18/blog-building/"/>
      <url>/2020/08/18/blog-building/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用gitee-hexo在gitee上部署blog"><a href="#如何使用gitee-hexo在gitee上部署blog" class="headerlink" title="如何使用gitee+hexo在gitee上部署blog"></a>如何使用gitee+hexo在gitee上部署blog</h1><h2 id="我搭建的blog网站：kiloGrand"><a href="#我搭建的blog网站：kiloGrand" class="headerlink" title="我搭建的blog网站：kiloGrand"></a>我搭建的blog网站：<a href="https://kilogrand.github.io/">kiloGrand</a></h2><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>下载git，推荐下载地址：<a href="https://pc.qq.com/detail/13/detail_22693.html">链接</a> ，在腾讯软件中心下载比较快</li><li>下载nodejs <a href="http://nodejs.cn/download/">官方下载</a>，我使用的版本是12.16.2，版本太高可能会出问题，推荐使用12.x.x系列的版本</li></ul><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ul><li>git 除了安装路径可以改之外，其他的不用改，一直next就行</li><li>nodejs 同上  </li></ul><h2 id="注册Gitee和GitHub账号"><a href="#注册Gitee和GitHub账号" class="headerlink" title="注册Gitee和GitHub账号"></a>注册Gitee和GitHub账号</h2><p><a href="https://github.com/">github官网</a><br><a href="https://gitee.com/">gitee官网</a><br>注意：在gitee和github中的设置-多邮件管理中,  “ [  ] 不公关我的邮箱地址”，这里不打勾，同时也要把你的邮箱设为提交邮箱<br><img src="https://img-blog.csdnimg.cn/20200821220646123.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>下载hexo主题sakura <a href="https://github.com/honjun/hexo-theme-sakura">github的Sakura链接</a>  ，推荐下载链接：<a href="https://gitee.com/wczzsmmn/hexo-theme-sakura">gitee的Sakura下载链接</a></li><li><p>下载cdn文件 <a href="https://github.com/honjun/cdn">cdn文件github下载链接</a> ，推荐下载链接：<a href="https://gitee.com/kiloGrand/cdn">cdn文件下载gitee链接</a>  </p><p>gitee上下载文件的方法：点击右上角克隆/下载—-下载zip<br><img src="https://img-blog.csdnimg.cn/202008212219345.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ul><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">*</span> <span class="string">配置git</span>  </span><br><span class="line">  <span class="string">打开git</span>    </span><br><span class="line">    <span class="string">$</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&#x27;gitee用户名&#x27;</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&#x27;gitee登陆邮箱&#x27;</span></span><br><span class="line"><span class="string">*</span> <span class="string">安装hexo</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span>  </span><br><span class="line"><span class="string">*</span> <span class="string">安装hexo-deployer-git</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line"><span class="string">*</span> <span class="string">初始化项目</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">cd</span> <span class="string">E://blog_project</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">hexo</span> <span class="string">init</span> <span class="string">blog</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">cd</span> <span class="string">E://blog_project/blog</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">//依据网页文件和新的css样式生成新的网站文件</span>  </span><br><span class="line">    <span class="string">$</span> <span class="string">hexo</span> <span class="string">s</span> <span class="string">//启动本地服务器，可以在&lt;http://localhost:4000&gt;查看网站效果</span>  </span><br></pre></td></tr></table></figure><h2 id="使用jsDeliver-github搭建免费的cdn"><a href="#使用jsDeliver-github搭建免费的cdn" class="headerlink" title="使用jsDeliver+github搭建免费的cdn"></a>使用jsDeliver+github搭建免费的cdn</h2><p>参考教程见 <a href="https://www.jianshu.com/p/467290ea7e9f">简书链接</a>  </p><ol><li>在github上新建一个名为cdn的仓库 </li><li><p>把下载好的cdn文件解压到E://cdn中，里面的图片可以替换，文件名最后不要改变，建议在cdn目录下加一个大小在20m以内的短视频，后面会用到，下面是修改后并且上传到github后的样子：<br><img src="https://img-blog.csdnimg.cn/2020082122362875.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>打开git<br> cd E://blog_project/cdn   </p></li><li><p>提交到github仓库上</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">init</span><span class="string">//初始化</span></span><br><span class="line"><span class="string">git</span> <span class="string">status</span> <span class="string">//查看状态</span>  </span><br><span class="line"><span class="string">git</span> <span class="string">add</span> <span class="string">.</span>  <span class="string">//添加文件到暂存区</span>  </span><br><span class="line"><span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&#x27;第一次提交&#x27;</span> <span class="string">//</span> <span class="string">提交到本地库</span> </span><br><span class="line"><span class="string">​git</span> <span class="string">remote</span> <span class="string">add</span> <span class="string">github</span> <span class="string">cdn仓库链接</span> <span class="string">//关联远程仓库</span>  </span><br><span class="line"><span class="string">​git</span> <span class="string">pull</span> <span class="string">--rebase</span> <span class="string">github</span> <span class="string">master</span> <span class="string">//合并远程仓库和本地仓库的冲突</span>  </span><br><span class="line"><span class="string">git</span> <span class="string">push</span> <span class="string">github</span> <span class="string">master</span> <span class="string">//推送到远程仓库上</span>  </span><br><span class="line"><span class="string">(jsDeliver不支持加载超过20M的资源，所以一些视频最好压缩到20M以下)</span></span><br></pre></td></tr></table></figure></li><li><p>发布仓库：浏览器打开github中新建的cdn，点击release发布, 发布版本号1.0（自定义）<br>使用方法：<br><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file">https://cdn.jsdelivr.net/gh/user/repo@version/file</a><br><a href="https://cdn.jsdelivr.net/gh/user/repo/file">https://cdn.jsdelivr.net/gh/user/repo/file</a><br>eg：  <a href="https://cdn.jsdelivr.net/gh/kiloGrand/cdn@1.2/img/custom/avatar.jpg">https://cdn.jsdelivr.net/gh/kiloGrand/cdn@1.2/img/custom/avatar.jpg</a>    <a href="https://cdn.jsdelivr.net/gh/kiloGrand/cdn/img/custom/avatar.jpg">https://cdn.jsdelivr.net/gh/kiloGrand/cdn/img/custom/avatar.jpg</a><br>版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源</p></li></ol><h2 id="blog配置"><a href="#blog配置" class="headerlink" title="blog配置"></a>blog配置</h2><ol><li>首先，在gitee上新建一个仓库，仓库名为你的账户名</li><li><p>用编辑器打开blog文件夹，我用的是vscode：<img src="https://img-blog.csdnimg.cn/20200821231313130.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>把blog/source中的所有md文件、blog/themes/Sakura/languages/zh-cn.yml和blog/themes/Sakura/_config.yml中的 ‘<a href="https://cdn.jsdelivr.net/gh/">https://cdn.jsdelivr.net/gh/</a>…’ 改成自己的cdn的文件链接。</p></li><li>按照<a href="https://docs.hojun.cn/sakura/docs/#/home">官方文档</a>进行配置，每当配置完一部份，可以使用下面的命令来生成网页，访问<a href="http://localhost:4000">http://localhost:4000</a>查看网站效果<br> $ hexo clean<br> $ hexo g<br> $ hexo s  </li><li>配置scaffolds文件夹下的md文件，这个文件夹是关于博客文章的。</li></ol><p>注意：在配置首页媒体时，aplayer的ID是网易云音乐的歌单号，比如<a href="https://music.163.com/#/playlist?id=4958788236">https://music.163.com/#/playlist?id=4958788236</a> ，它的ID是 4958788236，只需把原来的ID替换成你想要的歌单的ID就行了，其实这个项目的所有的音乐部分的ID都是网易云歌单号的ID，你可以用自己的网易云账户创建一个歌单，供blog使用。</p><h2 id="blog部署"><a href="#blog部署" class="headerlink" title="blog部署"></a>blog部署</h2><ol><li>生成部署文件<br> $ hexo clean<br> $ hexo g<br> $ hexo d    //上传到远程在码云上的仓库  </li><li>登录码云账户，打开和自己用户名相同的仓库, 点击服务，打开giteePages，点击开启。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200821225438232.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwMjU4ODAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="深入开发"><a href="#深入开发" class="headerlink" title="深入开发"></a>深入开发</h4><ul><li><a href="https://blog.csdn.net/u011759205/article/details/104839472">xx博客</a></li><li><a href="https://hexo.io/zh-cn/docs/index.html">hexo文档</a>  </li><li><a href="https://guole.fun/posts/butterfly-custom/">xxblog</a></li></ul><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ul><li>无法push到gitee/GitHub，可能是邮箱没有设置好，或者是_config.yml中的repo配置错了</li><li>hexo -g生成的public中的index是空的，可能是nodejs的版本太高，建议安装nvm来切换nodejs的版本  </li></ul><h2 id="博客使用"><a href="#博客使用" class="headerlink" title="博客使用"></a>博客使用</h2><p>编写文章的两种方法：  </p><ul><li>在git下执行<br>$ hexo new 博客文章名<br>同时会在 根目录下 /source/_posts 目录下生成md文件  </li><li>手动到根目录下 /source/_posts 目录下，创建一个makedown 文件进行编写就可以了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
